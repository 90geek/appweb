#if UNUSED
/*
    Map options by removing all internal control specific options.
    WARNING: this returns a non-cloned reference and relies on no GC yield until the returned value is used or cloned.
 */
static cchar *map(cchar *options)
{
    Esp     *esp;
    MprBuf  *buf;
    char    key[MPR_MAX_STRING];
    cchar   *cp, *ep;
    int     quote;

    if (options == 0) {
        return MPR->emptyString;
    }
    while (isspace((int) *options)) options++;
    if (*options) {
        esp = MPR->espService;
        buf = mprCreateBuf(-1, -1);
        for (cp = options; *cp; cp++) {
            while (isspace((int) *cp)) cp++;
            if ((ep = strchr(cp, '=')) != 0 && strlen(ep) >= 2) {
                sncopy(key, sizeof(key), cp, ep - cp);
                if (!mprLookupKey(esp->options, key)) {
                    /* Copy key */
                    mprPutCharToBuf(buf, ' ');
                    mprPutBlockToBuf(buf, cp, ep - cp);
                    mprPutStringToBuf(buf, "='");
                    cp = ep + 1;
                    quote = (*cp == '"' || *cp == '\'') ? *cp : ' ';
                    if ((ep = strchr(++cp, quote)) != 0) {
                        mprPutBlockToBuf(buf, cp, ep - cp);
                    }
                    mprPutCharToBuf(buf, '\'');
                    cp = ep;
                } else {
                    cp = ep + 1;
                    quote = (*cp == '"' || *cp == '\'') ? *cp : ' ';
                    if ((ep = strchr(++cp, quote)) != 0) {
                        cp = ep;
                    }
                    break;
                }
            } 
        }
        mprAddNullToBuf(buf);
        if (mprGetBufLength(buf) > 1) {
            return mprGetBufStart(buf);
        }
    }
    return MPR->emptyString;
}


static MprHashTable *getOptionsHash(cchar *options)
{
    MprHashTable    *table;
    char            key[MPR_MAX_STRING];
    cchar           *cp, *ep;
    int             quote;

    table = mprCreateHash(-1, 0);
    if (options == 0) {
        return table;
    }
    while (isspace((int) *options)) options++;
    if (*options) {
        for (cp = options; *cp; cp++) {
            while (isspace((int) *cp)) cp++;
            if ((ep = strchr(cp, '=')) != 0 && strlen(ep) >= 2) {
                sncopy(key, sizeof(key), cp, ep - cp);
                cp = ep + 1;
                quote = (*cp == '"' || *cp == '\'') ? *cp : ' ';
                if ((ep = strchr(++cp, quote)) != 0) {
                    mprAddKey(table, key, snclone(cp, ep - cp));
                }
                cp = ep;
            } 
        }
    }
    return table;
}


/*
    Add a field value to the option string. This will aggregate values into a single key='value value' setting
    WARNING: this returns a non-cloned reference and relies on no GC yield until the returned value is used or cloned.
 */
static cchar *add(cchar *options, cchar *field, cchar *value)
{
    MprBuf  *buf;
    cchar   *cp, *ep;
    ssize   len;
    int     quote;

    mprAssert(field && *field);
    mprAssert(value && *value);

    if (options == 0) {
        options = "";
    }
    while (isspace((int) *options)) options++;
    len = strlen(field);

    for (cp = options; *cp; cp++) {
        if (*cp == *field && sncasecmp(cp, field, len) == 0 && cp[len] == '=' && strlen(&cp[len]) >= 2) {
            cp = &cp[len + 1];
            buf = mprCreateBuf(-1, -1);
            mprPutCharToBuf(buf, ' ');
            mprPutBlockToBuf(buf, options, cp - options);
            quote = (*cp == '"' || *cp == '\'') ? *cp : ' ';
            if ((ep = strchr(++cp, quote)) != 0) {
                mprPutCharToBuf(buf, '\'');
                mprPutBlockToBuf(buf, cp, ep - cp);
                mprPutCharToBuf(buf, ' ');
                mprPutStringToBuf(buf, value);
                mprPutCharToBuf(buf, '\'');
                mprPutStringToBuf(buf, ++ep);
            } else {
                mprPutStringToBuf(buf, cp);
            }
            mprAddNullToBuf(buf);
            return mprGetBufStart(buf);
        }
    }
    return sjoin(options, " ", field, "='", value, "'", NULL);
}


/*
    Get the value of a field in options. If not present, return the defaultValue
 */
static cchar *get(cchar *options, cchar *field, cchar *defaultValue)
{
    cchar   *cp, *ep;
    ssize   len;
    int     quote;

    if (options == 0) {
        return defaultValue;
    }
    while (isspace((int) *options)) options++;

    if (*options && field) {
        len = strlen(field);
        while (isspace((int) *options)) options++;
        for (cp = options; *cp; cp++) {
            if (*cp == *field && sncasecmp(cp, field, len) == 0 && cp[len] == '=' && strlen(&cp[len]) >= 2) {
                cp = &cp[len + 1];
                quote = (*cp == '"' || *cp == '\'') ? *cp : ' ';
                if ((ep = strchr(++cp, quote)) != 0) {
                    return snclone(cp, ep - cp);
                }
            }
        }
    }
    return defaultValue;
    return httpGetOption(options, field, defaultValue);
}
#endif
