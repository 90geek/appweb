#define EJS_DEFINE_OPTABLE 1
#include "ejs.h"

/******************************************************************************/
/* 
    This file is an amalgamation of all the individual source code files for the
    LD_NAME Library Source.
  
    Catenating all the source into a single file makes embedding simpler and
    the resulting application faster, as many compilers can do whole file
    optimization.
  
    If you want to modify the product, you can still get the whole source as 
    individual files if you need.
 */


/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsApp.c"
 */
/************************************************************************/

/*
    ejsApp.c -- App class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*  
    Get the application command line arguments
    static function get args(): Array
 */
static EjsArray *app_args(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsArray    *args;
    int         i;

    args = ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, args, i, ejsCreateStringFromAsc(ejs, ejs->argv[i]));
    }
    return args;
}


/*  
    Get the current working directory
    function get dir(): Path
 */
static EjsPath *app_dir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetCurrentPath(ejs));
}


/*  
    Set the current working directory
    function chdir(value: String|Path): void
 */
static EjsObj *app_chdir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1);

    if (ejsIs(ejs, argv[0], Path)) {
        path = ((EjsPath*) argv[0])->value;

    } else if (ejsIs(ejs, argv[0], String)) {
        path = ejsToMulti(ejs, argv[0]);

    } else {
        ejsThrowIOError(ejs, "Bad path");
        return NULL;
    }
    if (chdir((char*) path) < 0) {
        ejsThrowIOError(ejs, "Can't change the current directory");
    }
    return 0;
}

/*  
    Get the directory containing the application's executable file.
    static function get exeDir(): Path
 */
static EjsPath *app_exeDir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAppDir(ejs));
}


/*  
    Get the application's executable filename.
    static function get exePath(): Path
 */
static EjsPath *app_exePath(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAppPath(ejs));
}


/*  
    Exit the application
    static function exit(status: Number, how: String = "default"): void
 */
static EjsObj *app_exit(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *how;
    int     status, mode;

    if (ejs->dontExit) {
        ejsThrowStateError(ejs, "App.exit has been disabled");
        return 0;
    }
    status = argc >= 1 ? ejsGetInt(ejs, argv[0]) : 0;
    how = ejsToMulti(ejs, argc >= 2 ? ejsToString(ejs, argv[1]): S(empty));

    if (scmp(how, "default") == 0) {
        mode = MPR_EXIT_DEFAULT;
    } else if (scmp(how, "immediate") == 0) {
        mode = MPR_EXIT_IMMEDIATE;
    } else if (scmp(how, "graceful") == 0) {
        mode = MPR_EXIT_GRACEFUL;
    } else {
        mode = MPR_EXIT_NORMAL;
    }
    mprTerminate(mode);
    ejsAttention(ejs);
    return 0;
}


#if ES_App_env
/*  
    Get all environment vars
    function get env(): Object
 */
static EjsAny *app_env(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
#if VXWORKS
    return S(null);
#else
    EjsPot  *result;
    char        **ep, *pair, *key, *value;

    result = ejsCreatePot(ejs, S(Object), 0);
    for (ep = environ; ep && *ep; ep++) {
        pair = sclone(*ep);
        key = stok(pair, "=", &value);
        ejsSetPropertyByName(ejs, result, EN(key), ejsCreateStringFromAsc(ejs, value));
    }
    return result;
#endif
}
#endif


/*  
    Get an environment var
    function getenv(key: String): String
 */
static EjsAny *app_getenv(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *value;

    value = getenv(ejsToMulti(ejs, argv[0]));
    if (value == 0) {
        return S(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


/*  
    Put an environment var
    function putenv(key: String, value: String): void
 */
static EjsObj *app_putenv(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
#if !WINCE
#if BLD_UNIX_LIKE
    char    *key, *value;

    key = sclone(ejsToMulti(ejs, argv[0]));
    value = sclone(ejsToMulti(ejs, argv[1]));
    setenv(key, value, 1);
#else
    //  TODO OPT
    char *cmd = sjoin(ejsToMulti(ejs, argv[0]), "=", ejsToMulti(ejs, argv[1]), NULL);
    putenv(cmd);
#endif
#endif
    return 0;
}


/*  
    Get the ejs module search path. Does not actually read the environment.
    function get search(): Array
 */
static EjsArray *app_search(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    return ejs->search;
}


/*  
    Set the ejs module search path. Does not actually update the environment.
    function set search(path: Array): Void
 */
static EjsObj *app_set_search(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    ejsSetSearchPath(ejs, (EjsArray*) argv[0]);
    return 0;
}


/*  
    Get a default search path. NOTE: this does not modify ejs->search.
    function get createSearch(searchPaths: String): Array
 */
static EjsArray *app_createSearch(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *searchPath;

    searchPath = (argc == 0) ? NULL : ejsToMulti(ejs, argv[0]);
    return ejsCreateSearchPath(ejs, searchPath);
}


/*  
    static function get pid (): void
 */
static EjsNumber *app_pid(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, getpid());
}


/*  
    static function run(timeout: Number = -1, oneEvent: Boolean = false): Boolean
 */
static EjsObj *app_run(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprTime     mark, remaining;
    int         rc, oneEvent, timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]) : MAXINT;
    oneEvent = (argc > 1) ? ejsGetInt(ejs, argv[1]) : 0;

    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime();
    remaining = timeout;
    do {
        rc = mprWaitForEvent(ejs->dispatcher, remaining); 
        remaining = mprGetRemainingTime(mark, timeout);
    } while (!oneEvent && !ejs->exiting && remaining > 0 && !mprIsStopping());
    return (rc == 0) ? S(true) : S(false);
}


/*  
    Pause the application. This services events while asleep.
    static function sleep(delay: Number = -1): void
 */
static EjsObj *app_sleep(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprTime     mark, remaining;
    int         timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]) : MAXINT;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime();
    remaining = timeout;
    do {
        mprWaitForEvent(ejs->dispatcher, (int) remaining); 
        remaining = mprGetRemainingTime(mark, timeout);
    } while (!ejs->exiting && remaining > 0 && !mprIsStopping());
    return 0;
}



void ejsConfigureAppType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, N("ejs", "App"));
    mprAssert(type);
#if UNUSED
    ejsSetSpecial(ejs, S_App, type);
#endif

    ejsSetProperty(ejs, type, ES_App__inputStream, ejsCreateFileFromFd(ejs, 0, "stdin", O_RDONLY));
    ejsSetProperty(ejs, type, ES_App__outputStream, ejsCreateFileFromFd(ejs, 1, "stdout", O_WRONLY));
    ejsSetProperty(ejs, type, ES_App__errorStream, ejsCreateFileFromFd(ejs, 2, "stderr", O_WRONLY));

    ejsBindMethod(ejs, type, ES_App_args, app_args);
    ejsBindMethod(ejs, type, ES_App_createSearch, app_createSearch);
    ejsBindMethod(ejs, type, ES_App_dir, app_dir);
    ejsBindMethod(ejs, type, ES_App_chdir, app_chdir);
    ejsBindMethod(ejs, type, ES_App_exeDir, app_exeDir);
    ejsBindMethod(ejs, type, ES_App_exePath, app_exePath);
    ejsBindMethod(ejs, type, ES_App_env, app_env);
    ejsBindMethod(ejs, type, ES_App_exit, app_exit);
    ejsBindMethod(ejs, type, ES_App_getenv, app_getenv);
    ejsBindMethod(ejs, type, ES_App_putenv, app_putenv);
    ejsBindMethod(ejs, type, ES_App_pid, app_pid);
    ejsBindMethod(ejs, type, ES_App_run, app_run);
    ejsBindAccess(ejs, type, ES_App_search, app_search, app_set_search);
    ejsBindMethod(ejs, type, ES_App_sleep, app_sleep);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsApp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsArray.c"
 */
/************************************************************************/

/**
    ejsArray.c - Ejscript Array class

    This module implents the standard Array type. It provides the type methods and manages the special "length" property.
    The array elements with numeric indicies are stored in EjsArray.data[]. Non-numeric properties are stored in EjsArray.obj

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int  checkSlot(Ejs *ejs, EjsArray *ap, int slotNum);
static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2);
static int growArray(Ejs *ejs, EjsArray *ap, int len);
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName qname);
static EjsNumber *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsAny **argv);
static EjsArray *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);
static EjsString *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);

static EjsArray *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsArray *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsArray *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsObj *setArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);

/*
    Create a new array
 */
static EjsArray *createArray(Ejs *ejs, EjsType *type, int numProp)
{
    EjsArray     *ap;

    if ((ap = ejsCreatePot(ejs, S(Array), 0)) == 0) {
        return 0;
    }
    ap->length = 0;
#if FUTURE
    /*
        Clear isObject because we must NOT use direct slot access in the VM
     */ 
    ap->obj.isObject = 0;
#endif
    return ap;
}


/*
    Cast the object operand to a primitive type
 */
static EjsAny *castArray(Ejs *ejs, EjsArray *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return S(true);

    case S_Number:
        return S(zero);

    case S_String:
        return arrayToString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


EjsArray *ejsCloneArray(Ejs *ejs, EjsArray *ap, bool deep)
{
    EjsArray    *newArray;
    EjsObj      **dest, **src;
    int         i;

    if ((newArray = ejsClonePot(ejs, ap, deep)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (ap->length > 0) {
        if (growArray(ejs, newArray, ap->length) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        src = ap->data;
        dest = newArray->data;
        if (deep) {
            for (i = 0; i < ap->length; i++) {
                dest[i] = ejsClone(ejs, src[i], deep);
            }
        } else {
            memcpy(dest, src, ap->length * sizeof(EjsObj*));
        }
    }
    return newArray;
}


/*
    Delete a property and update the length
 */
static int deleteArrayProperty(Ejs *ejs, EjsArray *ap, int slot)
{
    if (slot >= ap->length) {
        mprAssert(0);
        return EJS_ERR;
    }
    if (ejsSetProperty(ejs, ap, slot, S(undefined)) < 0) {
        return EJS_ERR;
    }
    if ((slot + 1) == ap->length) {
        ap->length--;
    }
    return 0;
}


/*
    Delete an element by name.
 */
static int deleteArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    if (isdigit((int) qname.name->value[0])) {
        return deleteArrayProperty(ejs, ap, (int) wtoi(qname.name->value, 10, NULL));
    }
    return (ejs->potHelpers.deletePropertyByName)(ejs, ap, qname);
}


/*
    Return the number of elements in the array
 */
static int getArrayPropertyCount(Ejs *ejs, EjsArray *ap)
{
    return ap->length;
}


/*
    Get an array element. Slot numbers correspond to indicies.
 */
static EjsObj *getArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->length) {
        return S(undefined);
    }
    return ap->data[slotNum];
}


static EjsObj *getArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    int     slotNum;

    if (isdigit((int) qname.name->value[0])) { 
        slotNum = ejsAtoi(ejs, qname.name, 10);
        if (slotNum < 0 || slotNum >= ap->length) {
            return 0;
        }
        return getArrayProperty(ejs, ap, slotNum);
    }

    /* The "length" property is a method getter */
    if (qname.name == S(length)) {
        return 0;
    }
    slotNum = (ejs->potHelpers.lookupProperty)(ejs, ap, qname);
    if (slotNum < 0) {
        return 0;
    }
    return (ejs->potHelpers.getProperty)(ejs, ap, slotNum);
}


/*
    Lookup an array index.
 */
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    int     index;

    if (qname.name == 0 || !isdigit((int) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < ap->length) {
        return index;
    }
    return EJS_ERR;
}


/*
    Cast operands as required for invokeArrayOperator
 */
static EjsObj *coerceArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, arrayToString(ejs, (EjsArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeArrayOperator(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    EjsAny  *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return S(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return S(one);

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return S(zero);

    /*
        Operator overload
     */
    case EJS_OP_ADD:
        result = ejsCreateArray(ejs, 0);
        pushArray(ejs, result, 1, &lhs);
        pushArray(ejs, result, 1, &rhs);
        return result;

    case EJS_OP_AND:
        return makeIntersection(ejs, lhs, rhs);

    case EJS_OP_OR:
        return makeUnion(ejs, lhs, rhs);

    case EJS_OP_SHL:
        return pushArray(ejs, lhs, 1, &rhs);

    case EJS_OP_SUB:
        return removeArrayElements(ejs, lhs, rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum, EjsAny *value)
{
    if ((slotNum = checkSlot(ejs, ap, slotNum)) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;
    return slotNum;
}


static int setArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname, EjsObj *value)
{
    int     slotNum;

    if (!isdigit((int) qname.name->value[0])) { 
        /* The "length" property is a method getter */
        if (qname.name == S(length)) {
            setArrayLength(ejs, ap, 1, &value);
            return ES_Array_length;
        }
        slotNum = (ejs->potHelpers.lookupProperty)(ejs, ap, qname);
        if (slotNum < 0) {
            slotNum = (ejs->potHelpers.setProperty)(ejs, ap, slotNum, value);
            if (slotNum < 0) {
                return EJS_ERR;
            }
            if ((ejs->potHelpers.setPropertyName)(ejs, ap, slotNum, qname) < 0) {
                return EJS_ERR;
            }
            return slotNum;

        } else {
            return (ejs->potHelpers.setProperty)(ejs, ap, slotNum, value);
        }
    }
    if ((slotNum = checkSlot(ejs, ap, ejsAtoi(ejs, qname.name, 10))) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;
    return slotNum;
}


static EjsArray *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r, **resultSlots;
    int         i, j, k;

    result = ejsCreateArray(ejs, 0);
    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        for (j = 0; j < rhs->length; j++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                resultSlots = result->data;
                for (k = 0; k < result->length; k++) {
                    if (compareArrayElement(ejs, l[i], resultSlots[k])) {
                        break;
                    }
                }
                if (result->length == 0 || k == result->length) {
                    setArrayProperty(ejs, result, -1, l[i]);
                }
            }
        }
    }
    return result;
}


static int addUnique(Ejs *ejs, EjsArray *ap, EjsObj *element)
{
    int     i;

    for (i = 0; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            break;
        }
    }
    if (i == ap->length) {
        if (setArrayProperty(ejs, ap, -1, element) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


static EjsArray *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r;
    int         i;

    result = ejsCreateArray(ejs, 0);
    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        addUnique(ejs, result, l[i]);
    }
    for (i = 0; i < rhs->length; i++) {
        addUnique(ejs, result, r[i]);
    }
    return result;
}


static EjsArray *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsObj  **l, **r;
    int     i, j, k;

    l = lhs->data;
    r = rhs->data;

    for (j = 0; j < rhs->length; j++) {
        for (i = 0; i < lhs->length; i++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                for (k = i + 1; k < lhs->length; k++) {
                    l[k - 1] = l[k];
                }
                lhs->length--;
            }
        }
    }
    return lhs;
}


static int checkSlot(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0) {
        if (!DYNAMIC(ap)) {
            ejsThrowTypeError(ejs, "Object is not dynamic");
            return EJS_ERR;
        }
        slotNum = ap->length;
        if (growArray(ejs, ap, ap->length + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }

    } else if (slotNum >= ap->length) {
        if (growArray(ejs, ap, slotNum + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
    return slotNum;
}


/*
    Array constructor.

    function Array(...args): Array

    Support the forms:

        var arr = Array();
        var arr = Array(size);
        var arr = Array(elt, elt, elt, ...);
 */
static EjsArray *arrayConstructor(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *arg0, **src, **dest;
    int         size, i;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    if (args->length == 0) {
        return ap;
    }
    size = 0;
    arg0 = getArrayProperty(ejs, args, 0);

    if (args->length == 1 && ejsIs(ejs, arg0, Number)) {
        /*
            x = new Array(size);
         */
        size = ejsGetInt(ejs, arg0);
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }

    } else {
        /*
            x = new Array(element0, element1, ..., elementN):
         */
        size = args->length;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        src = args->data;
        dest = ap->data;
        for (i = 0; i < size; i++) {
            dest[i] = src[i];
        }
    }
    ap->length = size;
    return ap;
}


/*
    Append an item to an array

    function append(obj: Object) : Array
 */
static EjsArray *appendArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (setArrayProperty(ejs, ap, ap->length, argv[0]) < 0) {
        return 0;
    }
    return ap;
}


/*
    Clear an array. Remove all elements of the array.

    function clear() : void
 */
static EjsObj *clearArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    ap->length = 0;
    return 0;
}


/*
    Clone an array.

    function clone(deep: Boolean = false) : Array
 */
static EjsArray *cloneArrayMethod(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    bool    deep;

    mprAssert(argc == 0 || ejsIs(ejs, argv[0], Boolean));

    deep = (argc == 1) ? ((EjsBoolean*) argv[0])->value : 0;
    return ejsCloneArray(ejs, ap, deep);
}


/*
    Compact an array. Remove all null elements.

    function compact() : Array
 */
static EjsArray *compactArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **src, **dest;
    int         i, oldLen;

    data = ap->data;
    src = dest = &data[0];
    for (i = 0; i < ap->length; i++, src++) {
        if (*src == 0 || !ejsIsDefined(ejs, *src)) {
            continue;
        }
        *dest++ = *src;
    }
    oldLen = ap->length;
    ap->length = (int) (dest - &data[0]);
    for (i = ap->length; i < oldLen; i++) {
        *dest++ = S(undefined);
    }
    return ap;
}


/*
    Concatenate the supplied elements with the array to create a new array. If any arguments specify an array,
    their elements are catenated. This is a one level deep copy.

    function concat(...args): Array
 */
static EjsArray *concatArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args, *newArray, *vpa;
    EjsObj          *vp, **src, **dest;
    int         i, k, next;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = ((EjsArray*) argv[0]);

    newArray = ejsCreateArray(ejs, ap->length);
    src = ap->data;
    dest = newArray->data;

    /*
        Copy the original array
     */
    for (next = 0; next < ap->length; next++) {
        dest[next] = src[next];
    }

    /*
        Copy the args. If any element is itself an array, then flatten it and copy its elements.
     */
    for (i = 0; i < args->length; i++) {
        vp = args->data[i];
        if (ejsIs(ejs, vp, Array)) {
            vpa = (EjsArray*) vp;
            if (growArray(ejs, newArray, next + vpa->length) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
            dest = newArray->data;
            for (k = 0; k < vpa->length; k++) {
                dest[next++] = vpa->data[k];
            }
        } else {
            if (growArray(ejs, newArray, next + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
            dest[next++] = vp;
        }
    }
    return newArray;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    EjsObj      *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIs(ejs, ap, Array)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    data = ap->data;

    for (; ip->index < ap->length; ip->index++) {
        vp = data[ip->index];
        mprAssert(vp);
        if (ejsIs(ejs, vp, Void)) {
            continue;
        }
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsIterator *getArrayIterator(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, nextArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    EjsObj          *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIs(ejs, ap, Array)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    data = ap->data;
    for (; ip->index < ap->length; ip->index++) {
        vp = data[ip->index];
        mprAssert(vp);
        if (ejsIs(ejs, vp, Void)) {
            continue;
        }
        ip->index++;
        return vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsAny *getArrayValues(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, nextArrayValue, 0, NULL);
}


#if KEEP
static EjsObj *find(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return 0;
}


/**
    Iterate over all elements in the object and find all elements for which the matching function is true.
    The match is called with the following signature:

        function match(arrayElement: Object, elementIndex: Number, arr: Array): Boolean

    @param match Matching function
    @return Returns a new array containing all matching elements.
 */
static EjsObj *findAll(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *funArgs[3];
    EjsBoolean  *result;
    EjsArray    *elements;
    int         i;

    mprAssert(argc == 1 && ejsIsFunction(ejs, argv[0]));

    elements = ejsCreateArray(ejs, 0);
    if (elements == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    for (i = 0; i < ap->length; i++) {
        funArgs[0] = ap->obj.properties.slots[i];         /* Array element */
        funArgs[1] = ejsCreateNumber(ejs, i);             /* element index */
        funArgs[2] = ap;                                  /* Array */
        result = (EjsBoolean*) ejsRunFunction(ejs, (EjsFunction*) argv[0], 0, 3, funArgs);
        if (result == 0 || !ejsIs(ejs, result, Boolean) || !result->value) {
            setArrayProperty(ejs, elements, elements->length, ap->obj.properties.slots[i]);
        }
    }
    return elements;
}
#endif


static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2)
{
    if (v1 == v2) {
        return 1;
    }
    if (TYPE(v1) != TYPE(v2)) {
        return 0;
    }
    if (ejsIs(ejs, v1, Number)) {
        return ((EjsNumber*) v1)->value == ((EjsNumber*) v2)->value;
    }
    if (ejsIs(ejs, v1, String)) {
        return (EjsString*) v1 == (EjsString*) v2;
    }
    return 0;
}


/*
    Search for an item using strict equality "===". This call searches from
    the start of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function indexOf(element: Object, startIndex: Number = 0): Number
 */
static EjsNumber *indexOfArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *element;
    int     i, start;

    mprAssert(argc == 1 || argc == 2);

    element = argv[0];
    start = (argc == 2) ? (int) ((EjsNumber*) argv[1])->value : 0;

    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        return S(minusOne);
    }
    if (start < 0) {
        start = 0;
    }
    for (i = start; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return ejsCreateNumber(ejs, i);
        }
    }
    return S(minusOne);
}


/*
    Insert elements. Insert elements at the specified position. Negative indicies are measured from the end of the array.
    @return Returns a the original array.

    function insert(pos: Number, ...args): Array
 */
static EjsArray *insertArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj          **src, **dest;
    int         i, pos, delta, oldLen, endInsert;

    mprAssert(argc == 2 && ejsIs(ejs, argv[1], Array));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0) {
        pos += ap->length;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (pos >= ap->length) {
        pos = ap->length;
    }
    args = (EjsArray*) argv[1];

    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    delta = args->length;
    dest = ap->data;
    src = args->data;

    endInsert = pos + delta;
    for (i = ap->length - 1; i >= endInsert; i--) {
        dest[i] = dest[i - delta];
    }
    for (i = 0; i < delta; i++) {
        dest[pos++] = src[i];
    }
    return ap;
}


/*
    Joins the elements in the array into a single string.
    @param sep Element separator.
    @return Returns a string.

    function join(sep: String = undefined): String
 */
static EjsString *joinArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result, *sep;
    EjsObj              *vp;
    int             i;

    sep = (argc == 1) ? (EjsString*) argv[0] : NULL;
    result = S(empty);
    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        if (!ejsIsDefined(ejs, vp)) {
            continue;
        }
        if (i > 0 && sep) {
            result = ejsCatString(ejs, result, sep);
        }
        result = ejsCatString(ejs, result, ejsToString(ejs, vp));
    }
    return result;
}


/*
    Search for an item using strict equality "===". This call searches from
    the end of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function lastIndexOf(element: Object, fromIndex: Number = 0): Number
 */
static EjsNumber *lastArrayIndexOf(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *element;
    int     i, start;

    mprAssert(argc == 1 || argc == 2);

    element = argv[0];
    start = ((argc == 2) ? (int) ((EjsNumber*) argv[1])->value : ap->length - 1);
    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }
    if (start < 0) {
        return S(minusOne);
    }
    for (i = start; i >= 0; i--) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return ejsCreateNumber(ejs, i);
        }
    }
    return S(minusOne);
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    override function get length(): Number
 */
static EjsNumber *getArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ap->length);
}


/*
    Set the length of an array.

    override function set length(value: Number): void
 */
static EjsObj *setArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **dest;
    int     length;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
    mprAssert(ejsIs(ejs, ap, Array));

    length = (int) ((EjsNumber*) argv[0])->value;
    if (length < 0) {
        length = 0;
    }
    if (length > ap->length) {
        if (growArray(ejs, ap, length) < 0) {
            return 0;
        }
        data = ap->data;
        for (dest = &data[ap->length]; dest < &data[length]; dest++) {
            *dest = 0;
        }
    }
    ap->length = length;
    return 0;
}


/*
    Remove and return the last value in the array.
    @return Returns the last element in the array.

    function pop(): Object
 */
static EjsObj *popArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (ap->length == 0) {
        return S(undefined);
    }
    return ap->data[--ap->length];
}


/*
    Append items to the end of the array.
    @return Returns the new length of the array.

    function push(...items): Number
 */
static EjsNumber *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsAny **argv)
{
    EjsArray    *args;
    EjsObj      **src, **dest;
    int         i, oldLen;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    dest = ap->data;
    src = args->data;
    for (i = 0; i < args->length; i++) {
        dest[i + oldLen] = src[i];
    }
    return ejsCreateNumber(ejs, ap->length);
}


/*
    Remove array elements
    MOB - rename to "remove"

    function removeElements(...elts): Array
 */
static EjsArray *removeElements(Ejs *ejs, EjsArray *ap, int argc, EjsArray **argv)
{
    return removeArrayElements(ejs, ap, argv[0]);
}


/*
    Reverse the order of the objects in the array. The elements are reversed in the original array.
    @return Returns a reference to the array.

    function reverse(): Array
 */
static EjsArray *reverseArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *tmp, **data;
    int         i, j;

    if (ap->length <= 1) {
        return ap;
    }
    data = ap->data;
    i = (ap->length - 2) / 2;
    j = (ap->length + 1) / 2;

    for (; i >= 0; i--, j++) {
        tmp = data[i];
        data[i] = data[j];
        data[j] = tmp;
    }
    return ap;
}


/*
    Remove and return the first value in the array.
    @return Returns the first element in the array.

    function shift(): Object
 */
static EjsObj *shiftArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj         *result, **data;
    int         i;

    if (ap->length == 0) {
        return S(undefined);
    }
    data = ap->data;
    result = data[0];
    for (i = 1; i < ap->length; i++) {
        data[i - 1] = data[i];
    }
    ap->length--;
    return result;
}


/*
    Create a new array by taking a slice from an array.

    function slice(start: Number, end: Number, step: Number = 1): Array
 */
static EjsArray *sliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result;
    EjsObj          **src, **dest;
    int         start, end, step, i, j, len, size;

    mprAssert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = ap->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }
    if (step == 0) {
        step = 1;
    }
    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    } else if (start >= ap->length) {
        start = ap->length;
    }
    if (end < 0) {
        end += ap->length;
    }
    if (end < 0) {
        end = 0;
    } else if (end >= ap->length) {
        end = ap->length;
    }
    size = (start < end) ? end - start : start - end;

    /*
        This may allocate too many elements if abs(step) is > 1, but length will still be correct.
     */
    result = ejsCreateArray(ejs, size);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    src = ap->data;
    dest = result->data;

    len = 0;
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }

    } else {
        for (i = start, j = 0; i > end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }
    }
    result->length = len;
    return result;
}


/*
    Quick sort partition
 */
static int partition(Ejs *ejs, EjsArray *array, EjsFunction *compare, int direction, int p, int r)
{
    EjsString   *sx, *so;
    EjsNumber   *result;
    EjsAny      *argv[3], *tmp;
    EjsObj      *x;
    int         i, j, order;

    x = array->data[r];
    sx = 0;

    if (compare) {
        if ((argv[1] = ejsCreateNumber(ejs, r)) == 0) {
            return 0;
        }
    } else {
        if ((sx = ejsToString(ejs, x)) == 0) {
            return 0;
        }
    }
    j = p - 1;

    for (i = p; i < r; i++) {
        if (compare) {
            argv[0] = array;
            argv[2] = ejsCreateNumber(ejs, i);
            result = ejsRunFunction(ejs, compare, NULL, 3, argv);
            if (!ejsIs(ejs, result, Number)) {
                return 0;
            }
            order = ejsGetInt(ejs, result);

        } else {
            if ((so = ejsToString(ejs, array->data[i])) == 0) {
                return 0;
            }
            order = ejsCompareString(ejs, sx, so);
        }
        order *= direction;
        if (order > 0) {
            j = j + 1;
            tmp = array->data[j];
            array->data[j] = array->data[i];
            array->data[i] = tmp;
        }
    }
    array->data[r] = array->data[j + 1];
    array->data[j + 1] = x;
    return j + 1;
}


void quickSort(Ejs *ejs, EjsArray *ap, EjsFunction *compare, int direction, int p, int r)
{
    int     q;

    if (p < r && !ejs->exception) {
        q = partition(ejs, ap, compare, direction, p, r);
        quickSort(ejs, ap, compare, direction, p, q - 1);
        quickSort(ejs, ap, compare, direction, q + 1, r);
    }
}


/**
    Sort the array using the supplied compare function

    function sort(compare: Function = null, direction: Number = 1): Array

    Where compare is defined as:
        function compare(a,b): Number
 */
static EjsArray *sortArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsFunction     *compare;
    int             direction;

    if (ap->length <= 1) {
        return ap;
    }
    compare = (EjsFunction*) ((argc >= 1) ? argv[0]: NULL);
    if (compare == S(null)) {
        compare = 0;
    }
    if (compare && !ejsIsFunction(ejs, compare)) {
        ejsThrowArgError(ejs, "Compare argument is not a function");
        return 0;
    }
    direction = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 1;
    quickSort(ejs, ap, compare, direction, 0, ap->length - 1);
    return ap;
}


/*
    Insert, remove or replace array elements. Return the removed elements.

    function splice(start: Number, deleteCount: Number, ...values): Array

 */
static EjsArray *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result, *values;
    EjsObj          **data, **dest, **items;
    int         start, deleteCount, i, delta, endInsert, oldLen;

    mprAssert(1 <= argc && argc <= 3);
    
    start = ejsGetInt(ejs, argv[0]);
    deleteCount = ejsGetInt(ejs, argv[1]);
    values = (EjsArray*) argv[2];

    if (ap->length == 0) {
        if (deleteCount <= 0) {
            return ap;
        }
        ejsThrowArgError(ejs, "Array is empty");
        return 0;
    }
    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }

    if (deleteCount < 0) {
        deleteCount = ap->length - start + 1;
    }
    if (deleteCount > ap->length) {
        deleteCount = ap->length;
    }
    result = ejsCreateArray(ejs, deleteCount);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    data = ap->data;
    dest = result->data;
    items = values->data;

    /*
        Copy removed items to the result
     */
    for (i = 0; i < deleteCount; i++) {
        dest[i] = data[i + start];
    }
    oldLen = ap->length;
    delta = values->length - deleteCount;
    
    if (delta > 0) {
        /*
            Make room for items to insert
         */
        if (growArray(ejs, ap, ap->length + delta) < 0) {
            return 0;
        }
        data = ap->data;
        endInsert = start + delta;
        for (i = ap->length - 1; i >= endInsert; i--) {
            data[i] = data[i - delta];
        }
        
    } else {
        ap->length += delta;
    }

    /*
        Copy in new values
     */
    for (i = 0; i < values->length; i++) {
        data[start + i] = items[i];
    }

    /*
        Remove holes
     */
    if (delta < 0) {
        for (i = start + values->length; i < oldLen; i++) {
            data[i] = data[i - delta];
        }
    }
    return result;
}


#if ES_Object_toLocaleString && FUTURE
/*
    Convert the array to a single localized string each member of the array
    has toString called on it and the resulting strings are concatenated.
    Currently just calls toString.

    function toLocaleString(): String
 */
static EjsString *toLocaleString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return arrayToString(ejs, ap, argc, argv);
}
#endif


/*
    Convert the array to a single string each member of the array has toString called on it and the resulting strings 
    are concatenated.

    override function toString(): String
 */
static EjsString *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result, *comma;
    EjsObj              *vp;
    int             i, rc;

    result = S(empty);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    comma = ejsCreateStringFromAsc(ejs, ",");
    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        rc = 0;
        if (i > 0) {
            result = ejsCatString(ejs, result, comma);
        }
        if (ejsIsDefined(ejs, vp)) {
            result = ejsCatString(ejs, result, ejsToString(ejs, vp));
        }
        if (rc < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return result;
}


/*
    Return an array with duplicate elements removed where duplicates are detected by using "==" (ie. content equality, 
    not strict equality).

    function unique(): Array
 */
static EjsArray *uniqueArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data;
    int     i, j, k;

    data = ap->data;

    for (i = 0; i < ap->length; i++) {
        for (j = i + 1; j < ap->length; j++) {
            if (compareArrayElement(ejs, data[i], data[j])) {
                for (k = j + 1; k < ap->length; k++) {
                    data[k - 1] = data[k];
                }
                ap->length--;
                j--;
            }
        }
    }
    return ap;
}


/*
    function unshift(...args): Array
 */
static EjsArray *unshiftArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj          **src, **dest;
    int         i, delta, oldLen, endInsert;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    if (args->length <= 0) {
        return ap;
    }
    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    delta = args->length;
    dest = ap->data;
    src = args->data;

    endInsert = delta;
    for (i = ap->length - 1; i >= endInsert; i--) {
        dest[i] = dest[i - delta];
    }
    for (i = 0; i < delta; i++) {
        dest[i] = src[i];
    }
    return ap;
}


static int growArray(Ejs *ejs, EjsArray *ap, int len)
{
    EjsObj      **dp;
    ssize       size, factor, count;
    int         i;

    mprAssert(ap);

    if (len <= 0) {
        return 0;
    }
    if (len <= ap->length) {
        return 0;
    }
    size = mprGetBlockSize(ap->data);
    size = (int) (mprGetBlockSize(ap->data) / sizeof(EjsObj*));

    /*
        Allocate or grow the data structures.
     */
    if (len > size) {
        if (size > EJS_LOTSA_PROP) {
            /*
                Looks like a big object so grow by a bigger chunk
             */
            factor = max(size / 4, EJS_ROUND_PROP);
            count = (len + factor) / factor * factor;
        } else {
            count = len;
        }
        //  OPT - this is currently 16
        count = EJS_PROP_ROUNDUP(count);
        if (ap->data == 0) {
            mprAssert(ap->length == 0);
            mprAssert(count > 0);
            if ((ap->data = mprAllocZeroed(sizeof(EjsObj*) * count)) == 0) {
                return EJS_ERR;
            }
        } else {
            mprAssert(size > 0);
            if ((ap->data = mprRealloc(ap->data, sizeof(EjsObj*) * count)) == 0) {
                return EJS_ERR;
            }
        }
        dp = &ap->data[ap->length];
        for (i = ap->length; i < count; i++) {
            *dp++ = S(undefined);
        }
    } else {
        mprNop(ITOP(size));
    }
    ap->length = len;
    return 0;
}



int ejsAddItem(Ejs *ejs, EjsArray *ap, EjsAny *item)
{
    int     index;

    index = ap->length;
    if (setArrayProperty(ejs, ap, index, &item) < 0) {
        return MPR_ERR_MEMORY;
    }
    return index;
}


int ejsAppendArray(Ejs *ejs, EjsArray *dest, EjsArray *src)
{
    int     next;

    for (next = 0; next < src->length; next++) {
        if (ejsSetProperty(ejs, dest, dest->length, src->data[next]) < 0) {
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


void ejsClearArray(Ejs *ejs, EjsArray *ap)
{
    ap->length = 0;
}


/*
    Insert an item to the list at a specified position. We insert before the item at "index".
    ie. The inserted item will go into the "index" location and the other elements will be moved up.
 */
int ejsInsertItem(Ejs *ejs, EjsArray *ap, int index, EjsAny *item)
{
    return insertArray(ejs, ap, index, item) != 0;
}


void *ejsGetItem(Ejs *ejs, EjsArray *ap, int index)
{
    return ejsGetProperty(ejs, ap, index);
}


void *ejsGetFirstItem(Ejs *ejs, EjsArray *ap)
{
    mprAssert(ap);

    if (ap == 0 || ap->length == 0) {
        return 0;
    }
    return ap->data[0];
}


void *ejsGetLastItem(Ejs *ejs, EjsArray *ap)
{
    mprAssert(ap);

    if (ap == 0 || ap->length == 0) {
        return 0;
    }
    return ap->data[ap->length - 1];
}


void *ejsGetNextItem(Ejs *ejs, EjsArray *ap, int *next)
{
    void    *item;
    int     index;

    mprAssert(next);
    mprAssert(*next >= 0);

    if (ap == 0) {
        return 0;
    }
    index = *next;
    if (index < ap->length) {
        item = ap->data[index];
        *next = ++index;
        return item;
    }
    return 0;
}


void *ejsGetPrevItem(Ejs *ejs, EjsArray *ap, int *next)
{
    int     index;

    mprAssert(next);

    if (ap == 0) {
        return 0;
    }
    if (*next < 0) {
        *next = ap->length;
    }
    index = *next;

    if (--index < ap->length && index >= 0) {
        *next = index;
        return ap->data[index];
    }
    return 0;
}


int ejsLookupItem(Ejs *ejs, EjsArray *ap, EjsAny *item)
{
    int     i;

    mprAssert(ap);
    
    for (i = 0; i < ap->length; i++) {
        if (ap->data[i] == item) {
            return i;
        }
    }
    return MPR_ERR_CANT_FIND;
}


/*
    Remove an item. The array is not compacted
 */
int ejsRemoveItem(Ejs *ejs, EjsArray *ap, EjsAny *item)
{
    int     i;

    for (i = 0; i < ap->length; i++) {
        if (ap->data[i] == item) {
            return deleteArrayProperty(ejs, ap, i);
        }
    }
    return MPR_ERR_CANT_FIND;
}


int ejsRemoveLastItem(Ejs *ejs, EjsArray *ap)
{
    mprAssert(ap);

    if (ap->length <= 0) {
        return MPR_ERR_CANT_FIND;
    }
    return deleteArrayProperty(ejs, ap, ap->length - 1);
}


int ejsRemoveItemAtPos(Ejs *ejs, EjsArray *ap, int index)
{
    mprAssert(ap);

    if (ap->length <= 0) {
        return MPR_ERR_CANT_FIND;
    }
    return deleteArrayProperty(ejs, ap, index);
}



EjsArray *ejsCreateArray(Ejs *ejs, int size)
{
    EjsArray    *ap;

    /*
        No need to invoke constructor
     */
    if ((ap = ejsCreatePot(ejs, S(Array), 0)) != 0) {
        ap->length = 0;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return ap;
}


static void manageArray(EjsArray *ap, int flags)
{
    EjsObj      *vp, **data;
    int         i, length;

    if (flags & MPR_MANAGE_MARK) {
        length = ap->length;
        data = ap->data;
        for (i = length - 1; i >= 0; i--) {
            if ((vp = data[i]) != 0) {
                mprMark(vp);
            }
        }
        mprMark(data);
    }
}


void ejsCreateArrayType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;

    type = ejsCreateNativeType(ejs, N("ejs", "Array"), sizeof(EjsArray), S_Array, ES_Array_NUM_CLASS_PROP, 
        manageArray, EJS_POT_HELPERS);
    type->numericIndicies = 1;
    type->virtualSlots = 1;
    type->mutableInstances = 1;
    type->dynamicInstances = 1;

    helpers = &type->helpers;
    helpers->cast = (EjsCastHelper) castArray;
    helpers->clone = (EjsCloneHelper) ejsCloneArray;
    helpers->create = (EjsCreateHelper) createArray;
    helpers->getProperty = (EjsGetPropertyHelper) getArrayProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getArrayPropertyCount;
    helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getArrayPropertyByName;
    helpers->deleteProperty = (EjsDeletePropertyHelper) deleteArrayProperty;
    helpers->deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteArrayPropertyByName;
    helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeArrayOperator;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupArrayProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setArrayProperty;
    helpers->setPropertyByName = (EjsSetPropertyByNameHelper) setArrayPropertyByName;

    ejsSetSpecial(ejs, S_length, ejsCreateStringFromAsc(ejs, "length"));
}


void ejsConfigureArrayType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Array);
    prototype = type->prototype;

    /*
        We override some Object methods
     */
    ejsBindConstructor(ejs, type, arrayConstructor);
    ejsBindMethod(ejs, prototype, ES_Array_iterator_get, getArrayIterator);
    ejsBindMethod(ejs, prototype, ES_Array_iterator_getValues, getArrayValues);
    ejsBindMethod(ejs, prototype, ES_Array_clone, cloneArrayMethod);
    ejsBindMethod(ejs, prototype, ES_Array_toString, arrayToString);
    ejsBindMethod(ejs, prototype, ES_Array_append, appendArray);
    ejsBindMethod(ejs, prototype, ES_Array_clear, clearArray);
    ejsBindMethod(ejs, prototype, ES_Array_compact, compactArray);
    ejsBindMethod(ejs, prototype, ES_Array_concat, concatArray);
    ejsBindMethod(ejs, prototype, ES_Array_indexOf, indexOfArray);
    ejsBindMethod(ejs, prototype, ES_Array_insert, insertArray);
    ejsBindMethod(ejs, prototype, ES_Array_join, joinArray);
    ejsBindMethod(ejs, prototype, ES_Array_lastIndexOf, lastArrayIndexOf);
    ejsBindAccess(ejs, prototype, ES_Array_length, getArrayLength, setArrayLength);
    ejsBindMethod(ejs, prototype, ES_Array_pop, popArray);
    ejsBindMethod(ejs, prototype, ES_Array_push, pushArray);
#if ES_Array_removeElements
    ejsBindMethod(ejs, prototype, ES_Array_removeElements, removeElements);
#endif
    ejsBindMethod(ejs, prototype, ES_Array_reverse, reverseArray);
    ejsBindMethod(ejs, prototype, ES_Array_shift, shiftArray);
    ejsBindMethod(ejs, prototype, ES_Array_slice, sliceArray);
    ejsBindMethod(ejs, prototype, ES_Array_sort, sortArray);
    ejsBindMethod(ejs, prototype, ES_Array_splice, spliceArray);
    ejsBindMethod(ejs, prototype, ES_Array_unique, uniqueArray);
    ejsBindMethod(ejs, prototype, ES_Array_unshift, unshiftArray);

#if FUTURE
    ejsBindMethod(ejs, prototype, ES_Array_toLocaleString, toLocaleString);
    ejsBindMethod(ejs, prototype, ES_Array_toJSONString, toJSONString);
    ejsBindMethod(ejs, prototype, ES_Array_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, prototype, ES_Array_AND, operAND);
    ejsBindMethod(ejs, prototype, ES_Array_EQ, operEQ);
    ejsBindMethod(ejs, prototype, ES_Array_GT, operGT);
    ejsBindMethod(ejs, prototype, ES_Array_LT, operLT);
    ejsBindMethod(ejs, prototype, ES_Array_LSH, operLSH);
    ejsBindMethod(ejs, prototype, ES_Array_MINUS, operMINUS);
    ejsBindMethod(ejs, prototype, ES_Array_OR, operOR);
    ejsBindMethod(ejs, prototype, ES_Array_AND, operAND);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsArray.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsBlock.c"
 */
/************************************************************************/

/**
    ejsBlock.c - Lexical block

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




EjsBlock *ejsCloneBlock(Ejs *ejs, EjsBlock *src, bool deep)
{
    EjsBlock    *dest;

    dest = (EjsBlock*) ejsClonePot(ejs, src, deep);

    dest->nobind = src->nobind;
    dest->scope = src->scope;
    mprInitList(&dest->namespaces);
    mprCopyList(&dest->namespaces, &src->namespaces);
    return dest;
}



void ejsResetBlockNamespaces(Ejs *ejs, EjsBlock *block)
{
    mprClearList(&block->namespaces);
}


int ejsGetNamespaceCount(EjsBlock *block)
{
    mprAssert(block);
    return block->namespaces.length;
}


void ejsPopBlockNamespaces(EjsBlock *block, int count)
{
    mprAssert(block);
    mprAssert(block->namespaces.length >= count);

    block->namespaces.length = count;
}


int ejsAddNamespaceToBlock(Ejs *ejs, EjsBlock *block, EjsNamespace *nsp)
{
    mprAssert(block);

    if (nsp == 0) {
        ejsThrowTypeError(ejs, "Not a namespace");
        return EJS_ERR;
    }
#if UNUSED && KEEP
    /* Namespaces must be ordered and so can't do this */ 
    for (next = 0; ((existing = (EjsNamespace*) mprGetNextItem(&block->namespaces, &next)) != 0); ) {
        if (existing->value == nsp->value) {
            break;
        }
    }
    if (existing == NULL) {
        mprAddItem(&block->namespaces, nsp);
    }
#else
        mprAddItem(&block->namespaces, nsp);
#endif
    return 0;
}


/*
    Inherit namespaces from base types. Only inherit protected.
 */
void ejsInheritBaseClassNamespaces(Ejs *ejs, EjsType *type, EjsType *baseType)
{
    EjsNamespace    *nsp, *existing;
    EjsBlock        *block;
    MprList         *baseNamespaces;
    int             next, i;

    block = &type->constructor.block;
    baseNamespaces = &baseType->constructor.block.namespaces;

    if (baseNamespaces) {
        for (next = 0; ((nsp = (EjsNamespace*) mprGetNextItem(baseNamespaces, &next)) != 0); ) {
            //  OPT -- must be a better way to do this?
            if (ejsContainsString(ejs, nsp->value, S(commaProt))) {
                for (i = 0; ((existing = (EjsNamespace*) mprGetNextItem(&block->namespaces, &i)) != 0); ) {
                    if (existing->value == nsp->value) {
                        break;
                    }
                }
                //  OPT -- debug to see if duplicates found 
                mprAssert(existing == NULL);
                if (existing == NULL) {
                    mprInsertItemAtPos(&block->namespaces, next - 1, nsp);
                }
            }
        }
    }
}



EjsBlock *ejsCreateBlock(Ejs *ejs, int size)
{
    EjsBlock        *block;

    if ((block = ejsCreatePot(ejs, S(Block), size)) == 0) {
        return 0;
    }
    block->pot.shortScope = 1;
    block->pot.isBlock = 1;
    mprInitList(&block->namespaces);
    return block;
}


void ejsManageBlock(EjsBlock *block, int flags)
{
    EjsObj          *item;
    EjsBlock        *b;
    int             next;

    if (block) {
        if (flags & MPR_MANAGE_MARK) {
            ejsManagePot(block, flags);
            mprMark(block->prevException);

            /*
                Must mark each item of the list as the list itself is not allocated
             */
            mprMark(block->namespaces.items);
            for (next = 0; ((item = (EjsObj*) mprGetNextItem(&block->namespaces, &next)) != 0); ) {
                mprMark(item);
            }
            /* This is the lexical block scope */
            for (b = block->scope; b; b = b->scope) {
#if FUTURE
                if (b->pot.shortScope) {
                    break;
                }
#endif
                mprMark(b);
            }
            /* This is the activation (call) chain */
            for (b = block->prev; b; b = b->prev) {
                mprMark(b);
            }
            /*
                Don't mark stack as the VM will mark that
                Don't mark locations as they are always inherited from a frame which will mark them for us
             */
        }
    }
}


void ejsCreateBlockType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Block"), sizeof(EjsBlock), S_Block, ES_Block_NUM_CLASS_PROP, 
        ejsManageBlock, EJS_POT_HELPERS);
    type->constructor.block.pot.shortScope = 1;

    type->helpers.clone = (EjsCloneHelper) ejsCloneBlock;
    ejsSetSpecial(ejs, S_commaProt, ejsCreateStringFromAsc(ejs, ",protected"));
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsBlock.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsBoolean.c"
 */
/************************************************************************/

/**
    ejsBoolean.c - Boolean native class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to a primitive type

    function cast(type: Type) : Object
 */
static EjsAny *castBooleanVar(Ejs *ejs, EjsBoolean *vp, EjsType *type)
{
    mprAssert(ejsIs(ejs, vp, Boolean));

    switch (type->sid) {
    case S_Number:
        return ((vp->value) ? S(one): S(zero));

    case S_String:
        return ejsCreateStringFromAsc(ejs, (vp->value) ? "true" : "false");

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


/*
    Coerce operands for invokeOperator
 */
static EjsAny *coerceBooleanOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return S(nan);
        } else if (ejsIs(ejs, rhs, Null) || ejsIs(ejs, rhs, Number) || ejsIs(ejs, rhs, Date)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        } else {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsBoolean*) lhs)->value ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsBoolean*) lhs)->value ? S(false) : S(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
}


/*
    Run an operator on the operands
 */
static EjsAny *invokeBooleanOperator(Ejs *ejs, EjsBoolean *lhs, int opcode, EjsBoolean *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Boolean) || !ejsIs(ejs, rhs, Boolean)) {
            if ((result = coerceBooleanOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ((lhs->value == rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ((lhs->value != rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_LT:
        return ((lhs->value < rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_LE:
        return ((lhs->value <= rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_GT:
        return ((lhs->value > rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_GE:
        return ((lhs->value >= rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? S(true): S(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    case EJS_OP_COMPARE_FALSE:
        return ((lhs->value) ? S(false): S(true));

    case EJS_OP_COMPARE_TRUE:
        return ((lhs->value) ? S(true): S(false));

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, - lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, !lhs->value);

    case EJS_OP_NOT:
        return ejsCreateBoolean(ejs, ~lhs->value);

    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return ejsCreateBoolean(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateBoolean(ejs, lhs->value & rhs->value);

    case EJS_OP_DIV:
        return ejsCreateBoolean(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateBoolean(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateBoolean(ejs, lhs->value | rhs->value);

    case EJS_OP_REM:
        return ejsCreateBoolean(ejs, lhs->value % rhs->value);

    case EJS_OP_SUB:
        return ejsCreateBoolean(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return ejsCreateBoolean(ejs, lhs->value >> rhs->value);

    case EJS_OP_XOR:
        return ejsCreateBoolean(ejs, lhs->value ^ rhs->value);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*
    Boolean constructor.

        function Boolean(value: Boolean = null)

    If the value is omitted or 0, -1, NaN, false, null, undefined or the empty string, then set the boolean value to
    to false.
 */

static EjsBoolean *booleanConstructor(Ejs *ejs, EjsBoolean *bp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0 || argc == 1);

    if (argc >= 1) {
        /* Change the bp value */
        bp->value = ejsToBoolean(ejs, argv[0])->value;
    }
    return bp;
}


#if UNUSED
EjsBoolean *ejsCreateBoolean(Ejs *ejs, int value)
{
    return ((value) ? S(true) : S(false));
}
#endif


void ejsCreateBooleanType(Ejs *ejs)
{
    EjsType     *type;
    EjsBoolean  *vp;

    type = ejsCreateNativeType(ejs, N("ejs", "Boolean"), sizeof(EjsBoolean), S_Boolean, ES_Boolean_NUM_CLASS_PROP,
        NULL, EJS_OBJ_HELPERS);
    type->helpers.cast = (EjsCastHelper) castBooleanVar;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeBooleanOperator;

    /*
        Pre-create the only two valid instances for boolean
     */
    vp = ejsCreateObj(ejs, type, 0);
    vp->value = 1;
    ejsSetSpecial(ejs, S_true, vp);

    vp = ejsCreateObj(ejs, type, 0);
    vp->value = 0;
    ejsSetSpecial(ejs, S_false, vp);
}


void ejsConfigureBooleanType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Boolean);
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, booleanConstructor);
    ejsSetProperty(ejs, ejs->global, ES_boolean, type);
    ejsSetProperty(ejs, ejs->global, ES_true, S(true));
    ejsSetProperty(ejs, ejs->global, ES_false, S(false));
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsBoolean.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsByteArray.c"
 */
/************************************************************************/

/*
    ejsByteArray.c - Ejscript ByteArray class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);
static EjsString *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);

static int  flushByteArray(Ejs *ejs, EjsByteArray *ap);
static ssize  getInput(Ejs *ejs, EjsByteArray *ap, ssize required);
static int  lookupByteArrayProperty(Ejs *ejs, EjsByteArray *ap, EjsName qname);

static MPR_INLINE int swap16(EjsByteArray *ap, int a);
static MPR_INLINE int swap32(EjsByteArray *ap, int a);
static MPR_INLINE int64 swap64(EjsByteArray *ap, int64 a);
static MPR_INLINE double swapDouble(EjsByteArray *ap, double a);
static int putByte(EjsByteArray *ap, int value);
static int putInteger(EjsByteArray *ap, int value);
static int putLong(EjsByteArray *ap, int64 value);
static int putShort(EjsByteArray *ap, int value);
static int putString(EjsByteArray *ap, EjsString *value, ssize len);
static int putNumber(EjsByteArray *ap, MprNumber value);
static int putDouble(EjsByteArray *ap, double value);

#define availableBytes(ap)  (((EjsByteArray*) ap)->writePosition - ((EjsByteArray*) ap)->readPosition)
#define room(ap) (ap->length - ap->writePosition)
#define adjustReadPosition(ap, amt) \
    if (1) { \
        ap->readPosition += amt; \
        if (ap->readPosition == ap->writePosition) {    \
            ap->readPosition = ap->writePosition = 0; \
        } \
    } else

/*
    Cast the object operand to a primitive type
 */
static EjsAny *castByteArrayVar(Ejs *ejs, EjsByteArray *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return S(true);

    case S_Number:
        return S(zero);

    case S_String:
        return ba_toString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsByteArray *cloneByteArrayVar(Ejs *ejs, EjsByteArray *ap, bool deep)
{
    EjsByteArray    *newArray;
    int             i;

    if ((newArray = ejsCreateByteArray(ejs, ap->length)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    for (i = 0; i < ap->length; i++) {
        newArray->value[i] = ap->value[i];
    }
    newArray->readPosition = ap->readPosition;
    newArray->writePosition = ap->writePosition;
    return newArray;
}


static int deleteByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slot)
{
    if (slot >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad subscript");
        return EJS_ERR;
    }
    if ((slot + 1) == ap->length) {
        ap->length--;
        if (ap->readPosition >= ap->length) {
            ap->readPosition = ap->length - 1;
        }
        if (ap->writePosition >= ap->length) {
            ap->writePosition = ap->length - 1;
        }
    }
    if (ejsSetProperty(ejs, ap, slot, S(undefined)) < 0) {
        return EJS_ERR;
    }
    return 0;
}


static ssize getByteArrayPropertyCount(Ejs *ejs, EjsByteArray *ap)
{
    return ap->length;
}


static EjsNumber *getByteArrayProperty(Ejs *ejs, EjsByteArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad array subscript");
        return 0;
    }
    return ejsCreateNumber(ejs, ap->value[slotNum]);
}


static int lookupByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, EjsName qname)
{
    int     index;

    if (qname.name == 0 || ! isdigit((int) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < ap->length) {
        return index;
    }
    return EJS_ERR;
}


/*
    Cast operands as required for invokeOperator
 */
static EjsAny *coerceByteArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ba_toString(ejs, (EjsByteArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeByteArrayOperator(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceByteArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return S(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return S(one);

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return S(zero);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slotNum,  EjsObj *value)
{
    if (slotNum >= ap->length && ejsGrowByteArray(ejs, ap, slotNum + 1) < 0) {
        return EJS_ERR;
    }
    if (ejsIs(ejs, value, Number)) {
        ap->value[slotNum] = ejsGetInt(ejs, value);
    } else {
        ap->value[slotNum] = ejsGetInt(ejs, ejsToNumber(ejs, value));
    }
    if (slotNum >= ap->length) {
        ap->length = slotNum + 1;
    }
    return slotNum;
}


/*
    function ByteArray(size: Number = -1, resizable: Boolean = true): ByteArray
 */
static EjsByteArray *ba_ByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    bool    resizable;
    int     size;

    mprAssert(0 <= argc && argc <= 2);

    size = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : MPR_BUFSIZE;
    if (size <= 0) {
        size = 1;
    }
    resizable = (argc == 2) ? ejsGetBoolean(ejs, argv[1]): 1;
    ap->growInc = (resizable) ? MPR_BUFSIZE : 0;
    ap->endian = mprGetEndian(ejs);
    ap->resizable = 1;
    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    ap->resizable = resizable;
    mprAssert(ap->value);
    return ap;
}


/**
    Determine if the byte array is in async mode
    function get async(): Boolean
 */
static EjsBoolean *ba_async(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ap->async ? S(true) : S(false);
}


/**
    Set the async mode 
    function set async(enable: Boolean): Void
 */
static EjsObj *ba_setAsync(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ap->async = (argv[0] == S(true));
    return 0;
}


/**
    Get the number of bytes that are currently available on this stream for reading.
    function get available(): Number
 */
static EjsNumber *ba_available(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) (ap->writePosition - ap->readPosition));
}


/*
    function close(): Void
 */
static EjsObj *ba_close(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "close", NULL, ap);
    }
    ap->writePosition = ap->readPosition = 0;
    return 0;
}


/*
    Copy data down and adjust the read/write offset pointers.
    function compact(): Void
 */
static EjsObj *ba_compact(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);

    if (ap->writePosition == ap->readPosition) {
        ap->writePosition = ap->readPosition = 0;

    } else if (ap->readPosition > 0) {
        memmove(ap->value, &ap->value[ap->readPosition], ap->writePosition - ap->readPosition);
        ap->writePosition -= ap->readPosition;
        ap->readPosition = 0;
    }
    return 0;
}


/*
    Copy data into the array. Data is written at the $destOffset.
    function copyIn(destOffset: Number, src: ByteArray, srcOffset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_copyIn(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *src;
    ssize           i, destOffset, srcOffset, count;

    destOffset = ejsGetInt(ejs, argv[0]);
    src = (EjsByteArray*) argv[1];
    srcOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= src->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad source offset");
        return 0;
    }
    if (count < 0) {
        count = MAXINT;
    }
    count = min(src->length - srcOffset, count);

    ejsMakeRoomInByteArray(ejs, ap, destOffset + count);
    if ((destOffset + count) > src->length) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        ap->value[destOffset++] = src->value[srcOffset++];
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Copy data from the array. Data is copied from the $srcOffset.
    function copyOut(srcOffset: Number, dest: ByteArray, destOffset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_copyOut(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *dest;
    ssize           count;
    int             i, srcOffset, destOffset;

    srcOffset = ejsGetInt(ejs, argv[0]);
    dest = (EjsByteArray*) argv[1];
    destOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad source data offset");
        return 0;
    }
    count = min(ap->length - srcOffset, count);
    ejsMakeRoomInByteArray(ejs, dest, destOffset + count);
    if ((destOffset + count) > dest->length) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        dest->value[destOffset++] = ap->value[srcOffset++];
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Determine if the system is using little endian byte ordering
    function get endian(): Number
 */
static EjsNumber *endian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ap->endian);
}


/*
    Set the system encoding to little or big endian.
    function set endian(value: Number): Void
 */
static EjsObj *setEndian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     endian;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    endian = ejsGetInt(ejs, argv[0]);
    if (endian != 0 && endian != 1) {
        ejsThrowArgError(ejs, "Bad endian value");
        return 0;
    }
    ap->endian = endian;
    ap->swap = (ap->endian != mprGetEndian(ejs));
    return 0;
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextByteArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIs(ejs, ap, ByteArray)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < ap->readPosition) {
        ip->index = (int) ap->readPosition;
    }
    if (ip->index < (int) ap->writePosition) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.
    iterator native function get(): Iterator
 */
static EjsIterator *ba_get(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, nextByteArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextByteArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIs(ejs, ap, ByteArray)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < (int) ap->readPosition) {
        ip->index = (int) ap->readPosition;
    }
    if (ip->index < ap->writePosition) {
        return ejsCreateNumber(ejs, ap->value[ip->index++]);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to return the next array element value.
    iterator native function getValues(): Iterator
 */
static EjsIterator *ba_getValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, nextByteArrayValue, 0, NULL);
}


/*  
    Flush the data in the byte array and reset the read and write position pointers
    function flush(ignored: Number): Void
 */
static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    flushByteArray(ejs, ap);
    ap->writePosition = ap->readPosition = 0;
    return 0;
}


/*
    Get the length of an array.
    @return Returns the number of items in the array
    override function get length(): Number
 */
static EjsNumber *ba_getLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (int) ap->length);
}


#if KEEP
/*
    Set the length of an array.
    override function set length(value: Number): void
 */
static EjsObj *ba_setLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
    mprAssert(ejsIs(ejs, ap, ByteArray));

    ap->length = ejsGetInt(ejs, argv[0]);
    if (ap->readPosition >= ap->length) {
        ap->readPosition = ap->length - 1;
    }
    if (ap->writePosition >= ap->length) {
        ap->writePosition = ap->length - 1;
    }

    return 0;
}
#endif


/*
    Get the length of an array.
    @return Returns the number of items in the array
    function resizable(): Boolean
 */
static EjsBoolean *ba_resizable(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ap->resizable ? S(true) : S(false);
}


/*
    Read data from the array into another byte array. Data is read from the current read $position pointer.
    Data is written to the write position if offset is -1. Othwise at the given offset. If offset is < 0, the 
    write position is updated.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_read(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    ssize           offset, count;
    int             i;

    mprAssert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc == 3) ? ejsGetInt(ejs, argv[2]) : (int) buffer->length;

    if (count < 0) {
        count = buffer->length;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        buffer->readPosition = 0;
        buffer->writePosition = 0;
    }
    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return S(null);
    }
    count = min(availableBytes(ap), count);
    for (i = 0; i < count; i++) {
        buffer->value[offset++] = ap->value[ap->readPosition++];
    }
    buffer->writePosition += count;
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Read a boolean from the array.
    function readBoolean(): Boolean
 */
static EjsBoolean *ba_readBoolean(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return S(null);
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return ejsCreateBoolean(ejs, result);
}


/*
    Read a byte from the array.
    function readByte(): Number
 */
static EjsNumber *ba_readByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return S(null);
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return ejsCreateNumber(ejs, result);
}


/**
    Read a date from the array.
    function readDate(): Date
 */
static EjsDate *ba_readDate(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return S(null);
    }
    value = * (double*) &ap->value[ap->readPosition];
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));
    return ejsCreateDate(ejs, (MprTime) value);
}


/**
    Read a double from the array. The data will be decoded according to the encoding property.
    function readDouble(): Number
 */
static EjsNumber *ba_readDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return S(null);
    }
    memcpy(&value, (char*) &ap->value[ap->readPosition], sizeof(double));
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));
    return ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Read a 32-bit integer from the array. The data will be decoded according to the encoding property.
    function readInteger(): Number
 */
static EjsNumber *ba_readInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_INT) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return S(null);
    }
    value = * (int*) &ap->value[ap->readPosition];
    value = swap32(ap, value);
    adjustReadPosition(ap, sizeof(int));
    return ejsCreateNumber(ejs, value);
}


/*
    Read a 64-bit long from the array.The data will be decoded according to the encoding property.
    function readLong(): Number
 */
static EjsNumber *ba_readLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int64   value;

    if (getInput(ejs, ap, EJS_SIZE_LONG) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return S(null);
    }
    value = * (int64*) &ap->value[ap->readPosition];
    value = swap64(ap, value);
    adjustReadPosition(ap, sizeof(int64));
    return ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Get the current read position offset
    function get readPosition(): Number
 */
static EjsNumber *ba_readPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->readPosition);
}


/*
    Set the current read position offset
    function set readPosition(position: Number): Void
 */
static EjsObj *ba_setReadPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad position value");
        return 0;
    }
    if (pos > ap->writePosition) {
        ejsThrowStateError(ejs, "Read position is greater than write position");
    } else {
        ap->readPosition = pos;
    }
    return 0;
}


/*
    Read a 16-bit short integer from the array. The data will be decoded according to the encoding property.
    function readShort(): Number
 */
static EjsNumber *ba_readShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_SHORT) <= 0) {
        return S(null);
    }
    value = * (short*) &ap->value[ap->readPosition];
    value = swap16(ap, value);
    adjustReadPosition(ap, sizeof(short));
    return ejsCreateNumber(ejs, value);
}


/*
    Read a UTF-8 string from the array. Read data from the read position up to the write position but not more 
    than count characters.

    function readString(count: Number = -1): String
 */
static EjsString *ba_readString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsString   *result;
    ssize       count;

    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;

    if (count < 0) {
        if (getInput(ejs, ap, 1) < 0) {
            return S(null);
        }
        count = availableBytes(ap);

    } else if (getInput(ejs, ap, count) < 0) {
        return S(null);
    }
    count = min(count, availableBytes(ap));
    //  TODO - UNICODE ENCODING
    result = ejsCreateStringFromMulti(ejs, (cchar*) &ap->value[ap->readPosition], count);
    adjustReadPosition(ap, count);
    return result;
}


void ejsResetByteArrayIfEmpty(Ejs *ejs, EjsByteArray *ap)
{
    if (ap->writePosition == ap->readPosition) {
        ap->writePosition = ap->readPosition = 0;
    }
}


/*
    Reset the read and write position pointers if there is no available data.
    function reset(): Void
 */
static EjsObj *ba_reset(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ejsResetByteArrayIfEmpty(ejs, ap);
    return 0;
}


/**
    function off(name, observer: Function): Number
 */
static EjsObj *ba_off(Ejs *ejs, EjsByteArray *ap, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, ap->emitter, argv[0], argv[1]);
    return 0;
}


/**
    function get on(name, observer: Function): Void
 */
static EjsObj *ba_on(Ejs *ejs, EjsByteArray *ap, int argc, EjsAny **argv)
{
    ejsAddObserver(ejs, &ap->emitter, argv[0], argv[1]);
    return 0;
}


/**
    Get the number of data bytes that the array can store from the write position till the end of the array.
    function get room(): Number
 */
static EjsNumber *ba_room(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) room(ap));
}


/*
    Convert the byte array data between the read and write positions into a string.
    override function toString(): String
 */
static EjsString *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    //  TODO - UNICODE ENCODING
    return ejsCreateStringFromMulti(ejs, (cchar*) &ap->value[ap->readPosition], availableBytes(ap));
}


/*
    Write data to the array. Data is written to the current write $position pointer.
    function write(...data): Number
 */
EjsNumber *ejsWriteToByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *bp;
    EjsString       *sp;
    EjsObj          *vp;
    ssize           len, wrote;
    int             i;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    /*
        Unwrap nested arrays
     */
    args = (EjsArray*) argv[0];
    while (ejsIs(ejs, args, Array) && args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (!ejsIs(ejs, vp, Array)) {
            break;
        }
        args = (EjsArray*) vp;
    }
    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    wrote = 0;

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, args, i);
        if (vp == 0) {
            continue;
        }
        switch (TYPE(vp)->sid) {
        case S_Boolean:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_BOOLEAN)) {
                return 0;
            }
            wrote += putByte(ap, ejsGetBoolean(ejs, vp));
            break;

        case S_Date:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, (MprNumber) ((EjsDate*) vp)->value);
            break;

        case S_Number:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, ejsGetNumber(ejs, vp));
            break;

        case S_String:
            if (!ejsMakeRoomInByteArray(ejs, ap, ((EjsString*) vp)->length)) {
                return 0;
            }
            sp = (EjsString*) vp;
            wrote += putString(ap, sp, sp->length);
            break;

        default:
            sp = ejsToString(ejs, vp);
            wrote += putString(ap, sp, sp->length);
            break;

        case S_ByteArray:
            bp = (EjsByteArray*) vp;
            len = availableBytes(bp);
            if (!ejsMakeRoomInByteArray(ejs, ap, len)) {
                return 0;
            }
            /*
                Note: this only copies between the read/write positions of the source byte array
             */
            ejsCopyToByteArray(ejs, ap, ap->writePosition, (char*) &bp->value[bp->readPosition], len);
            ap->writePosition += len;
            wrote += len;
            break;
        }
    }
    if (ap->emitter && wrote > 0 && availableBytes(ap) > 0) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return ejsCreateNumber(ejs, (MprNumber) wrote);
}


/*
    Write a byte to the array
    function writeByte(value: Number): Void
 */
static EjsObj *ba_writeByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, 1)) {
        return 0;
    }
    putByte(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a short to the array
    function writeShort(value: Number): Void
 */
static EjsObj *ba_writeShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(short))) {
        return 0;
    }
    putShort(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a double to the array
    function writeDouble(value: Number): Void
 */
static EjsObj *ba_writeDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(double))) {
        return 0;
    }
    putDouble(ap, ejsGetDouble(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write an integer (32 bits) to the array
    function writeInteger(value: Number): Void
 */

static EjsObj *ba_writeInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(int))) {
        return 0;
    }
    putInteger(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a long (64 bit) to the array
    function writeLong(value: Number): Void
 */
static EjsObj *ba_writeLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(int))) {
        return 0;
    }
    putLong(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Get the current write position offset
    function get writePosition(): Number
 */
static EjsNumber *ba_writePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->writePosition);
}


/*
    Set the current write position offset
    function set writePosition(position: Number): Void
 */
static EjsObj *ba_setWritePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->length) {
        ejsThrowStateError(ejs, "Write position is outside bounds of array");
        return 0;
    }
    if (pos < ap->readPosition) {
        ejsThrowStateError(ejs, "Write position is less than read position");
    } else {
        ap->writePosition = pos;
    }
    return 0;
}


/*
    Flush the array. Issue a "flush" event. Flushing attempts to write pending data before resetting the array.
 */
static int flushByteArray(Ejs *ejs, EjsByteArray *ap)
{
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "flush", NULL, ap);
    }
    ap->writePosition = ap->readPosition = 0;
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
    }
    return 0;
}


/*
    Grow the byte array up to the given length, but not over the maximum. Return the length or an error code.
    This routine always throws an exception.
 */
int ejsGrowByteArray(Ejs *ejs, EjsByteArray *ap, ssize len)
{
    if (len > ap->length) {
        if (!ap->resizable) {
            ejsThrowResourceError(ejs, "Byte array is too small. Need room for %d bytes.", len);
            return EJS_ERR;
        }
        if ((ap->value = mprRealloc(ap->value, len)) == 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
        memset(&ap->value[ap->length], 0, len - ap->length);
        ap->growInc = min(ap->growInc * 2, 32 * 1024);
        ap->length = len;
    }
    return 0;
}


/*
    Get more input sufficient to satisfy the rquired number of bytes. The required parameter specifies how many bytes 
    must be read. Short fills are not permitted. Return the count of bytes available or 0 if the required number of 
    bytes can't be read. Return -ve on errors.
 */
static ssize getInput(Ejs *ejs, EjsByteArray *ap, ssize required)
{
    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    if (availableBytes(ap) < required && !ejs->exception) {
        if (ap->emitter) {
            ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
        }
    }
    if (availableBytes(ap) < required) {
        return 0;
    }
    return availableBytes(ap);
}


bool ejsMakeRoomInByteArray(Ejs *ejs, EjsByteArray *ap, ssize require)
{
    ssize   newLen;

    if (room(ap) < require) {
        if (ap->emitter && availableBytes(ap)) {
            ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
        }
        if (room(ap) < require) {
            newLen = max(ap->length + require, ap->length + ap->growInc);
            if (ejsGrowByteArray(ejs, ap, newLen) < 0) {
                return 0;
            }
        }
    }
    return 1;
}


static MPR_INLINE int swap16(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 8 | (a & 0xFF00 >> 8);
}


static MPR_INLINE int swap32(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 24 | (a & 0xFF00 << 8) | (a & 0xFF0000 >> 8) | (a & 0xFF000000 >> 16);
}


static MPR_INLINE int64 swap64(EjsByteArray *ap, int64 a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = a & 0xFFFFFFFF;
    high = (a >> 32) & 0xFFFFFFFF;
    return  (low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32;
}


static MPR_INLINE double swapDouble(EjsByteArray *ap, double a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = ((int64) a) & 0xFFFFFFFF;
    high = (((int64) a) >> 32) & 0xFFFFFFFF;
    return  (double) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}


static int putByte(EjsByteArray *ap, int value)
{
    ap->value[ap->writePosition++] = (char) value;
    return sizeof(char);
}


static int putShort(EjsByteArray *ap, int value)
{
    value = swap16(ap, value);

    *((short*) &ap->value[ap->writePosition]) = (short) value;
    ap->writePosition += sizeof(short);
    return sizeof(short);
}


static int putInteger(EjsByteArray *ap, int value)
{
    value = swap32(ap, value);

    *((int*) &ap->value[ap->writePosition]) = (int) value;
    ap->writePosition += sizeof(int);
    return sizeof(int);
}


static int putLong(EjsByteArray *ap, int64 value)
{
    value = swap64(ap, value);

    *((int64*) &ap->value[ap->writePosition]) = value;
    ap->writePosition += sizeof(int64);
    return sizeof(int64);
}


static int putDouble(EjsByteArray *ap, double value)
{
    value = swapDouble(ap, value);

#if OLD
    *((double*) &ap->value[ap->writePosition]) = value;
#else
    memcpy((char*) &ap->value[ap->writePosition], &value, sizeof(double));
#endif
    ap->writePosition += sizeof(double);
    return sizeof(double);
}


/*
    Write a number in the default number encoding
 */
static int putNumber(EjsByteArray *ap, MprNumber value)
{
    return putDouble(ap, value);
}


static int putString(EjsByteArray *ap, EjsString *str, ssize len)
{
    //  TODO -- this must do encoding
    mprMemcpy(&ap->value[ap->writePosition], room(ap), str->value, len);
    ap->writePosition += len;
    return (int) len;
}


void ejsResetByteArray(EjsByteArray *ba)
{
    if (ba->writePosition == ba->readPosition) {
        ba->writePosition = ba->readPosition = 0;
    }
}


void ejsSetByteArrayPositions(Ejs *ejs, EjsByteArray *ba, ssize readPosition, ssize writePosition)
{
    if (readPosition >= 0) {
        ba->readPosition = readPosition;
    }
    if (writePosition >= 0) {
        ba->writePosition = writePosition;
    }
}


int ejsCopyToByteArray(Ejs *ejs, EjsByteArray *ba, ssize offset, char *data, ssize length)
{
    int     i;

    mprAssert(ba);
    mprAssert(data);

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (!ejsMakeRoomInByteArray(ejs, ba, offset + length)) {
        return EJS_ERR;
    }
    if (ba->length < (offset + length)) {
        return EJS_ERR;
    }
    for (i = 0; i < length; i++) {
        ba->value[offset++] = data[i];
    }
    return 0;
}


ssize ejsGetByteArrayAvailable(EjsByteArray *ba)
{
    return availableBytes(ba);
}


ssize ejsGetByteArrayRoom(EjsByteArray *ba)
{
    return room(ba);
}


EjsByteArray *ejsCreateByteArray(Ejs *ejs, ssize size)
{
    EjsByteArray    *ap;

    /*
        No need to invoke constructor
     */
    ap = ejsCreateObj(ejs, ST(ByteArray), 0);
    if (ap == 0) {
        return 0;
    }
    if (size <= 0) {
        size = MPR_BUFSIZE;
    }
    ap->async = -1;
    ap->resizable = 1;
    ap->growInc = MPR_BUFSIZE;
    ap->endian = mprGetEndian(ejs);
    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    return ap;
}


static void manageByteArray(EjsByteArray *ap, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ap->emitter);
        mprMark(ap->value);
        mprMark(TYPE(ap));
    }
}


void ejsConfigureByteArrayType(Ejs *ejs)
{
    EjsType     *type;
    EjsHelpers  *helpers;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "ByteArray"), sizeof(EjsByteArray), manageByteArray, EJS_OBJ_HELPERS);
    ejsSetSpecialType(ejs, S_ByteArray, type);
    type->numericIndicies = 1;
    type->virtualSlots = 1;
    type->mutableInstances = 1;
    prototype = type->prototype;

    helpers = &type->helpers;
    helpers->cast = (EjsCastHelper) castByteArrayVar;
    helpers->clone = (EjsCloneHelper) cloneByteArrayVar;
    helpers->deleteProperty = (EjsDeletePropertyHelper) deleteByteArrayProperty;
    helpers->getProperty = (EjsGetPropertyHelper) getByteArrayProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getByteArrayPropertyCount;
    helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeByteArrayOperator;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupByteArrayProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setByteArrayProperty;
    
    ejsBindConstructor(ejs, type, ba_ByteArray);
    ejsBindMethod(ejs, prototype, ES_ByteArray_on, ba_on);
    ejsBindMethod(ejs, prototype, ES_ByteArray_available, ba_available);
    ejsBindAccess(ejs, prototype, ES_ByteArray_async, ba_async, ba_setAsync);
    ejsBindMethod(ejs, prototype, ES_ByteArray_close, ba_close);
    ejsBindMethod(ejs, prototype, ES_ByteArray_compact, ba_compact);
    ejsBindMethod(ejs, prototype, ES_ByteArray_copyIn, ba_copyIn);
    ejsBindMethod(ejs, prototype, ES_ByteArray_copyOut, ba_copyOut);
    ejsBindAccess(ejs, prototype, ES_ByteArray_endian, endian, setEndian);
    ejsBindMethod(ejs, prototype, ES_ByteArray_flush, ba_flush);
    ejsBindMethod(ejs, prototype, ES_ByteArray_resizable, ba_resizable);
    ejsBindMethod(ejs, prototype, ES_ByteArray_length, ba_getLength);
    ejsBindMethod(ejs, prototype, ES_ByteArray_iterator_get, ba_get);
    ejsBindMethod(ejs, prototype, ES_ByteArray_iterator_getValues, ba_getValues);
    ejsBindMethod(ejs, prototype, ES_ByteArray_off, ba_off);
    ejsBindMethod(ejs, prototype, ES_ByteArray_read, ba_read);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readBoolean, ba_readBoolean);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readByte, ba_readByte);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readDate, ba_readDate);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readDouble, ba_readDouble);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readInteger, ba_readInteger);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readLong, ba_readLong);
    ejsBindAccess(ejs, prototype, ES_ByteArray_readPosition, ba_readPosition,ba_setReadPosition);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readShort, ba_readShort);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readString, ba_readString);
    ejsBindMethod(ejs, prototype, ES_ByteArray_reset, ba_reset);
    ejsBindMethod(ejs, prototype, ES_ByteArray_room, ba_room);
    ejsBindMethod(ejs, prototype, ES_ByteArray_toString, ba_toString);
    ejsBindMethod(ejs, prototype, ES_ByteArray_write, ejsWriteToByteArray);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeByte, ba_writeByte);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeShort, ba_writeShort);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeInteger, ba_writeInteger);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeLong, ba_writeLong);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeDouble, ba_writeDouble);
    ejsBindAccess(ejs, prototype, ES_ByteArray_writePosition, ba_writePosition, ba_setWritePosition);
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsByteArray.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsCmd.c"
 */
/************************************************************************/

/*
    ejsCmd.c -- Cmd class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj *cmd_start(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv);

/*
    function Cmd(cmdline: Object, options: Object)
 */
static EjsCmd *cmd_constructor(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->ejs = ejs;
    cmd->timeout = -1;
    if (argc >= 1) {
        cmd_start(ejs, cmd, argc, argv);
    }
    return cmd;
}


/**
    function close(): Void
 */
static EjsObj *cmd_close(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc) {
        mprDestroyCmd(cmd->mc);
        cmd->mc = 0;
    }
    return 0;
}


/**
    function get errorStream(): Stream
 */
static EjsByteArray *cmd_errorStream(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->error == 0) {
        cmd->error = ejsCreateByteArray(ejs, -1);
    }
    return cmd->error;
}


/**
    function get env(): Object
 */
static EjsObj *cmd_env(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    return cmd->env;
}


/**
    function set env(values: Object): Void
 */
static EjsObj *cmd_set_env(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->env = argv[0];
    return 0;
}


/**
    function finalize(): Void
 */
static EjsObj *cmd_finalize(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    mprFinalizeCmd(cmd->mc);
    return 0;
}


/**
    function flush(dir: Number = Stream.BOTH): Void
 */
static EjsObj *cmd_flush(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    /* Nothing to do */
    return 0;
}


/**
    static function kill(pid: Number, signal: Number = 2): Boolean
 */
static EjsObj *cmd_kill(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    int     rc, pid, signal;

    signal = SIGINT;

    pid = 0;
    if (argc == 0) {
        if (cmd->mc && cmd->mc->pid) {
            pid = cmd->mc->pid;
        }
    } else if (argc >= 1) {
        pid = ejsGetInt(ejs, argv[0]);
    } 
    if (argc >= 2) {
        signal = ejsGetInt(ejs, argv[1]);
    }
    if (pid == 0) {
        ejsThrowStateError(ejs, "No process to kill");
        return 0;
    }
#if BLD_WIN_LIKE
{
    HANDLE	handle;
	handle = OpenProcess(PROCESS_TERMINATE, 0, pid);
    if (handle == 0) {
        ejsThrowIOError(ejs, "Can't find process ID %d", pid);
        return 0;
    }
    rc = TerminateProcess(handle, signal) == 0;
}
#elif VXWORKS
    // CRASH    rc = taskDelete(cmd->pid);
    rc = taskDelete(pid);
#else
    rc = kill(pid, signal);
#endif
    if (rc < 0) {
        if (cmd->throw) {
            ejsThrowIOError(ejs, "Can't kill %d with signal %d, errno %d", pid, signal, errno);
        }
        return S(false);
    }
    return S(true);
}


/**
    function get on(name, observer: Function): Void
 */
static EjsObj *cmd_on(Ejs *ejs, EjsCmd *cmd, int argc, EjsAny **argv)
{
    EjsFunction     *observer;

    observer = (EjsFunction*) argv[1];
    if (observer->boundThis == 0 || observer->boundThis == ejs->global) {
        observer->boundThis = cmd;
    }
    ejsAddObserver(ejs, &cmd->emitter, argv[0], observer);
    if (!cmd->async) {
        cmd->async = 1;
    }
    return 0;
}


/**
    function get off(name, observer: Function): Void
 */
static EjsObj *cmd_off(Ejs *ejs, EjsCmd *cmd, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, cmd->emitter, argv[0], argv[1]);
    return 0;
}


/**
    function pid(): Number
 */
static EjsNumber *cmd_pid(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0 || cmd->mc->pid == 0) {
        return S(zero);
    }
    return ejsCreateNumber(ejs, cmd->mc->pid);
}


/**
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *cmd_read(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    ssize           offset, count, nbytes;

    mprAssert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc == 3) ? ejsGetInt(ejs, argv[2]) : (int) buffer->length;

    if (count < 0) {
        count = buffer->length;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        buffer->readPosition = 0;
        buffer->writePosition = 0;
    }
    count = buffer->length - buffer->writePosition;
    if (count <= 0) {
        if (ejsGrowByteArray(ejs, buffer, MPR_BUFSIZE) < 0) {
            return 0;
        }
        count = buffer->length - buffer->writePosition;
    }
    nbytes = mprGetBufLength(cmd->stdoutBuf);
    if (nbytes == 0 && !cmd->async) {
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Command timed out");
            return 0;
        }
        nbytes = mprGetBufLength(cmd->stdoutBuf);
    }
    count = min(count, nbytes);
    ejsCopyToByteArray(ejs, buffer, buffer->writePosition, (char*) mprGetBufStart(cmd->stdoutBuf), count);
    ejsSetByteArrayPositions(ejs, buffer, -1, buffer->writePosition + count);
    mprAdjustBufStart(cmd->stdoutBuf, count);
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Read a UTF-8 string from the array. Read data from the read position up to the write position but not more 
    than count characters.

    function readString(count: Number = -1): String
 */
static EjsString *cmd_readString(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsString   *result;
    ssize       nbytes, count;
    
    mprAssert(0 <= argc && argc <= 1);
    
    count = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (count < 0) {
        count = MAXSSIZE;
    }
    nbytes = mprGetBufLength(cmd->stdoutBuf);
    if (nbytes == 0) {
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Command timed out");
            return 0;
        }
        nbytes = mprGetBufLength(cmd->stdoutBuf);
    }
    count = min(count, nbytes);
    result = ejsCreateStringFromBytes(ejs, mprGetBufStart(cmd->stdoutBuf), count);
    mprAdjustBufStart(cmd->stdoutBuf, count);
    mprResetBufIfEmpty(cmd->stdoutBuf);
    return result;
}


static void cmdIOCallback(MprCmd *mc, int channel, void *data)
{
    EjsCmd          *cmd;
    EjsByteArray    *ba;
    MprBuf          *buf;
    ssize           len, space;

    /*
        Note: stdin, stdout and stderr are named from the client's perspective
     */
    cmd = data;
    buf = 0;
    switch (channel) {
    case MPR_CMD_STDIN:
        ejsSendEvent(cmd->ejs, cmd->emitter, "writable", NULL, cmd);
        mprEnableCmdEvents(mc, channel);
        return;
    case MPR_CMD_STDOUT:
        buf = cmd->stdoutBuf;
        break;
    case MPR_CMD_STDERR:
        buf = cmd->stderrBuf;
        break;
    default:
        /* Child death */
        return;
    }
    /*
        Read and aggregate the result into a single string
     */
    mprResetBufIfEmpty(buf);
    space = mprGetBufSpace(buf);
    if (space < (MPR_BUFSIZE / 4)) {
        if (mprGrowBuf(buf, MPR_BUFSIZE) < 0) {
            mprCloseCmdFd(mc, channel);
            return;
        }
        space = mprGetBufSpace(buf);
    }
    len = mprReadCmd(mc, channel, mprGetBufEnd(buf), space);
    if (len <= 0) {
        if (len == 0 || (len < 0 && !(errno == EAGAIN || errno == EWOULDBLOCK))) {
            mprCloseCmdFd(mc, channel);
        }
    } else {
        mprAdjustBufEnd(buf, len);
    }
    if (len > 0) {
        mprEnableCmdEvents(mc, channel);
    }
    if (channel == MPR_CMD_STDERR) {
        if (cmd->error == 0) {
            cmd->error = ejsCreateByteArray(cmd->ejs, -1);
        }
        ba = cmd->error;
        ejsCopyToByteArray(cmd->ejs, ba, ba->writePosition, mprGetBufStart(buf), len);
        ba->writePosition += len;
        mprAdjustBufStart(buf, len);
        mprResetBufIfEmpty(buf);
    }
    if (cmd->async) {
        if (channel == MPR_CMD_STDOUT) {
            ejsSendEvent(cmd->ejs, cmd->emitter, "readable", NULL, cmd);
        }
        if (channel == MPR_CMD_STDERR) {
            if (len > 0) {
                ejsSendEvent(cmd->ejs, cmd->emitter, "error", NULL, cmd);
            } else {
                ejsSendEvent(cmd->ejs, cmd->emitter, "complete", NULL, cmd);
            }
        }
    }
}


static int parseOptions(Ejs *ejs, EjsCmd *cmd)
{
    EjsObj      *value;
    EjsPath     *path;
    int         flags;

    cmd->throw = 0;    
    flags = MPR_CMD_IN | MPR_CMD_OUT | MPR_CMD_ERR;
    if (cmd->options) {
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("detach"))) != 0) {
            if (value == S(true)) {
                flags |= MPR_CMD_DETACH;
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("dir"))) != 0) {
            path = ejsToPath(ejs, value);
            if (path) {
                mprSetCmdDir(cmd->mc, path->value);
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("exception"))) != 0) {
            if (value == S(true)) {
                cmd->throw = 1;
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("timeout"))) != 0) {
            cmd->timeout = ejsGetInt(ejs, value);
        }
    }
    return flags;
}


static bool setCmdArgs(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    char        *command;
    int         i;

    if (ejsIs(ejs, cmd->command, Array)) {
        ap = (EjsArray*) cmd->command;
        if ((cmd->argv = mprAlloc(sizeof(void*) * (ap->length + 1))) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        for (i = 0; i < ap->length; i++) {
            cmd->argv[i] = ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, cmd->command, i)));
        }
        cmd->argv[i] = 0;
        cmd->argc = ap->length;

    } else {
        cmd->command = ejsToString(ejs, cmd->command);
        command = ejsToMulti(ejs, argv[0]);
        if (mprMakeArgv(command, &cmd->argc, &cmd->argv, 0) < 0 || cmd->argv == 0) {
            ejsThrowArgError(ejs, "Can't parse command line");
            return 0;
        }
    }
    return 1;
}


/**
    function start(cmdline: Object, options: Object = null): Void
 */
static EjsObj *cmd_start(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsName     qname;
    char        *err, **env;
    int         rc, flags, len, i, status;

    cmd->command = argv[0];
    cmd->options = (argc >=2 ) ? argv[1] : 0;

    if (cmd->command == S(null)) {
        ejsThrowStateError(ejs, "Missing command line");
        return 0;
    }
    if ((cmd->mc = mprCreateCmd(ejs->dispatcher)) == 0) {
        return 0;
    }
    mprSetCmdCallback(cmd->mc, cmdIOCallback, cmd);
    if (cmd->stdoutBuf == 0) {
        cmd->stdoutBuf = mprCreateBuf(MPR_BUFSIZE, -1);
    }
    if (cmd->stderrBuf == 0) {
        cmd->stderrBuf = mprCreateBuf(MPR_BUFSIZE, -1);
    }
    if (!setCmdArgs(ejs, cmd, argc, argv)) {
        return 0;
    }
    if (cmd->env) {
        len = ejsGetPropertyCount(ejs, cmd->env);
        if ((env = mprAlloc(sizeof(void*) * (len + 1))) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        for (i = 0; i < len; i++) {
            qname = ejsGetPropertyName(ejs, cmd->env, i);
            env[i] = mprAsprintf("%s=%s", qname.name->value, 
                ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, cmd->env, i))));
        }
        env[i] = 0;
    } else {
        env = 0;
    }
    flags = parseOptions(ejs, cmd);

    if ((rc = mprStartCmd(cmd->mc, cmd->argc, cmd->argv, env, flags)) < 0) {
        if (rc == MPR_ERR_CANT_ACCESS) {
            err = "Can't access command";
        } else if (MPR_ERR_CANT_OPEN) {
            err = "Can't open standard I/O for command";
        } else if (rc == MPR_ERR_CANT_CREATE) {
            err = "Can't create process";
        } else {
            err = "";
        }
        ejsThrowError(ejs, "Command failed: %s\nError Output: %s", cmd->argv[0], err);
        return 0;
    }
    if (!(flags & MPR_CMD_DETACH)) {
        mprAssert(cmd->mc);
        mprFinalizeCmd(cmd->mc);
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Timeout %d msec waiting for command to complete: %s", cmd->timeout, cmd->argv[0]);
            return 0;
        }
        mprAssert(cmd->mc);
        if (cmd->throw) {
            status = mprGetCmdExitStatus(cmd->mc);
            if (status != 0) {
                ejsThrowIOError(ejs, "Command failed status %d, %@", status, ejsToString(ejs, cmd->error));
            }
        }
    }
    return 0;
}


/**
    function get status(): Number
 */
static EjsNumber *cmd_status(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
        ejsThrowStateError(ejs, "Command still active");
    }
    return ejsCreateNumber(ejs, mprGetCmdExitStatus(cmd->mc));
}


/**
    function stop(signal: Number = 2): Boolean
 */
static EjsObj *cmd_stop(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    int     signal;

    signal = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : SIGINT;

    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    if (mprStopCmd(cmd->mc, signal) < 0) {
        ejsThrowIOError(ejs, "Can't kill %d with signal %d, errno %d", cmd->mc->pid, signal, errno);
        return S(false);
    }
    return S(true);
}


/**
    function get timeout(): Number
 */
static EjsNumber *cmd_timeout(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) cmd->timeout);
}


/**
    function set timeout(msec: Number): Void
 */
static EjsObj *cmd_set_timeout(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->timeout = ejsGetInt(ejs, argv[0]);
    return 0;
}


/**
    function wait(timeout: Number = -1): Boolean
 */
static EjsObj *cmd_wait(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    MprTime     timeout;

    timeout = argc > 0 ? ejsGetInt(ejs, argv[0]) : cmd->timeout;
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    /* NOTE: mprWaitForCmd will auto-finalize */
    if (mprWaitForCmd(cmd->mc, timeout) < 0) {
        return S(false);
    }
    return S(true);
}


/**
    function write(...data): Number
 */
static EjsNumber *cmd_write(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *bp;
    EjsString       *sp;
    EjsObj          *vp;
    ssize           len, wrote;
    int             i;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    /*
        Unwrap nested arrays
     */
    args = (EjsArray*) argv[0];
    while (ejsIs(ejs, args, Array) && args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (!ejsIs(ejs, vp, Array)) {
            break;
        }
        args = (EjsArray*) vp;
    }
    wrote = 0;
    for (i = 0; i < args->length; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) == 0) {
            continue;
        }
        if (ejsIs(ejs, vp, ByteArray)) {
            bp = (EjsByteArray*) vp;
            len = bp->writePosition - bp->readPosition;
            wrote += mprWriteCmd(cmd->mc, MPR_CMD_STDIN, (char*) &bp->value[bp->readPosition], len);
        } else {
            sp = (EjsString*) ejsToString(ejs, vp);
            wrote += mprWriteCmd(cmd->mc, MPR_CMD_STDIN, sp->value, sp->length);
        }
    }
    return ejsCreateNumber(ejs, (MprNumber) wrote);
}


/*
    function exec(cmd: Object): Void
 */
static EjsObj *cmd_exec(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_UNIX_LIKE
    char    **argVector;
    int     argCount;

    mprMakeArgv(ejsToMulti(ejs, argv[0]), &argCount, &argVector, 0);
    execv(argVector[0], argVector);
#endif
    ejsThrowStateError(ejs, "Can't exec %@", ejsToString(ejs, argv[0]));
    return 0;
}



static void manageEjsCmd(EjsCmd *cmd, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(cmd, flags);
        mprMark(cmd->emitter);
        mprMark(cmd->mc);
        mprMark(cmd->stdoutBuf);
        mprMark(cmd->stderrBuf);
        mprMark(cmd->command);
        mprMark(cmd->env);
        mprMark(cmd->options);
        mprMark(cmd->error);
        mprMark(cmd->argv);

    } else {
        if (cmd->mc) {
            mprDestroyCmd(cmd->mc);
            cmd->mc = 0;
        }
    }
}


void ejsConfigureCmdType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsGetTypeByName(ejs, N("ejs", "Cmd"))) == 0) {
        mprError("Can't find Cmd type");
        return;
    }
    type->instanceSize = sizeof(EjsCmd);
    type->mutableInstances = 1;
    type->manager = (MprManager) manageEjsCmd;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, cmd_constructor);
    ejsBindMethod(ejs, type, ES_Cmd_kill, cmd_kill);
    ejsBindMethod(ejs, type, ES_Cmd_exec, cmd_exec);

    ejsBindMethod(ejs, prototype, ES_Cmd_close, cmd_close);
    ejsBindAccess(ejs, prototype, ES_Cmd_errorStream, cmd_errorStream, 0);
    ejsBindAccess(ejs, prototype, ES_Cmd_env, cmd_env, cmd_set_env);
    ejsBindMethod(ejs, prototype, ES_Cmd_finalize, cmd_finalize);
    ejsBindMethod(ejs, prototype, ES_Cmd_flush, cmd_flush);
    ejsBindMethod(ejs, prototype, ES_Cmd_on, cmd_on);
    ejsBindMethod(ejs, prototype, ES_Cmd_off, cmd_off);
    ejsBindAccess(ejs, prototype, ES_Cmd_pid, cmd_pid, 0);
    ejsBindMethod(ejs, prototype, ES_Cmd_read, cmd_read);
    ejsBindMethod(ejs, prototype, ES_Cmd_readString, cmd_readString);
    ejsBindMethod(ejs, prototype, ES_Cmd_start, cmd_start);
    ejsBindAccess(ejs, prototype, ES_Cmd_status, cmd_status, 0);
    ejsBindMethod(ejs, prototype, ES_Cmd_stop, cmd_stop);
    ejsBindAccess(ejs, prototype, ES_Cmd_timeout, cmd_timeout, cmd_set_timeout);

    ejsBindMethod(ejs, prototype, ES_Cmd_wait, cmd_wait);
    ejsBindMethod(ejs, prototype, ES_Cmd_write, cmd_write);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsCmd.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsConfig.c"
 */
/************************************************************************/

/*
    ejsConfig.c -- Config class
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




void ejsCreateConfigType(Ejs *ejs)
{
    ejsCreateNativeType(ejs, N("ejs", "Config"), sizeof(EjsObj), S_Config, ES_Config_NUM_CLASS_PROP, ejsManagePot, 
        EJS_POT_HELPERS);
}


void ejsDefineConfigProperties(Ejs *ejs)
{
    EjsType     *type;
    char        version[16];
    int         att;

    if (ejs->configSet) {
        return;
    }
    ejs->configSet = 1;
    type = ST(Config);
    att = EJS_PROP_STATIC | EJS_PROP_ENUMERABLE;
    type->mutable = 0;

    /*
        Must use -1 for slotNumber as this function is called by the compiler when compiling ejs.mod. 
        There will still be a -Config- property in slot[0]
     */
    ejsDefineProperty(ejs, type, -1, N("public", "Debug"), 0, att, BLD_DEBUG ? S(true): S(false));
    ejsDefineProperty(ejs, type, -1, N("public", "CPU"), 0, att, ejsCreateStringFromAsc(ejs, BLD_HOST_CPU));
    ejsDefineProperty(ejs, type, -1, N("public", "OS"), 0, att, ejsCreateStringFromAsc(ejs, BLD_OS));
    ejsDefineProperty(ejs, type, -1, N("public", "Product"), 0, att, 
        ejsCreateStringFromAsc(ejs, BLD_PRODUCT));
    ejsDefineProperty(ejs, type, -1, N("public", "Title"), 0, att, ejsCreateStringFromAsc(ejs, BLD_NAME));
    mprSprintf(version, sizeof(version), "%s-%s", BLD_VERSION, BLD_NUMBER);
    ejsDefineProperty(ejs, type, -1, N("public", "Version"), 0, att, ejsCreateStringFromAsc(ejs, version));

    ejsDefineProperty(ejs, type, -1, N("public", "Legacy"), 0, att, ejsCreateBoolean(ejs, BLD_FEATURE_LEGACY_API));
    ejsDefineProperty(ejs, type, -1, N("public", "SSL"), 0, att, ejsCreateBoolean(ejs, BLD_FEATURE_SSL));
    ejsDefineProperty(ejs, type, -1, N("public", "SQLITE"), 0, att, ejsCreateBoolean(ejs, BLD_FEATURE_SQLITE));

#if BLD_WIN_LIKE
{
    EjsString    *path;

    path = ejsCreateStringFromAsc(ejs, mprGetAppDir(ejs));
    ejsDefineProperty(ejs, type, -1, N("public", "BinDir"), 0, att, path);
    ejsDefineProperty(ejs, type, -1, N("public", "ModDir"), 0, att, path);
    ejsDefineProperty(ejs, type, -1, N("public", "LibDir"), 0, att, path);
}
#else
#ifdef BLD_BIN_PREFIX
    ejsDefineProperty(ejs, type, -1, N("public", "BinDir"), 0, att, ejsCreateStringFromAsc(ejs, BLD_BIN_PREFIX));
#endif
#ifdef BLD_MOD_PREFIX
    ejsDefineProperty(ejs, type, -1, N("public", "ModDir"), 0, att, ejsCreateStringFromAsc(ejs, BLD_MOD_PREFIX));
#endif
#ifdef BLD_LIB_PREFIX
    ejsDefineProperty(ejs, type, -1, N("public", "LibDir"), 0, att, ejsCreateStringFromAsc(ejs, BLD_LIB_PREFIX));
#endif
#endif
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsConfig.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsDate.c"
 */
/************************************************************************/

/**
    ejsDate.c - Date type class

    Date/time is store internally as milliseconds since 1970/01/01 GMT

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    TODO - move to ejsNumber.h. But would have to rename fixed() to ejsFixed()
 */
#define fixed(n) ((int64) (floor(n)))

#if BLD_WIN_LIKE
#pragma warning (disable:4244)
#endif

//  TODO this is a generic need. Make an API

#define getNumber(ejs, a) ejsGetNumber(ejs, ejsToNumber(ejs, a))
#define getInt(ejs, a) ((int) ejsGetNumber(ejs, ejsToNumber(ejs, a)))

/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */

static EjsAny *castDate(Ejs *ejs, EjsDate *dp, EjsType *type)
{
    struct tm   tm;

    switch (type->sid) {

    case S_Boolean:
        return S(true);

    case S_Number:
        return ejsCreateNumber(ejs, (MprNumber) dp->value);

    case S_String:
        /*
            Format:  Tue Jul 15 2011 10:53:23 GMT-0700 (PDT)
         */
        mprDecodeLocalTime(&tm, dp->value);
        return ejsCreateStringFromAsc(ejs, mprFormatTime("%a %b %d %Y %T GMT%z (%Z)", &tm));

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


static EjsDate *cloneDate(Ejs *ejs, EjsDate *dp, int deep)
{
    return ejsCreateDate(ejs, dp->value);
}


/*
    TODO - this is the same as number. Should share code
 */
static EjsAny *coerceDateOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return S(nan);
        } else if (ejsIs(ejs, rhs, Null)) {
            rhs = S(zero);
        } else if (ejsIs(ejs, rhs, Boolean) || ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        } else {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsDate*) lhs)->value ? S(true) : S(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsDate*) lhs)->value ? S(false): S(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeDateOperator(Ejs *ejs, EjsDate *lhs, int opcode, EjsDate *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Date) || !ejsIs(ejs, rhs, Date)) {
            if ((result = coerceDateOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    switch (opcode) {
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ejsCreateBoolean(ejs, lhs->value == rhs->value);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs, !(lhs->value == rhs->value));

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs, lhs->value < rhs->value);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs, lhs->value <= rhs->value);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, lhs->value > rhs->value);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, lhs->value >= rhs->value);

    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? S(true): S(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, - (MprNumber) lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, (int) !fixed(lhs->value));

    case EJS_OP_NOT:
        return ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsCreateDate(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return ejsCreateDate(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateDate(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) - fixed(rhs->value)));

    case EJS_OP_USHR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    /* Should never get here */
}


/*
    Date constructor
        Date()
        Date(milliseconds)
        Date(dateString)
        Date(year, month, date, hour, minute, second, msec)
        @param milliseconds Integer representing milliseconds since 1 January 1970 00:00:00 UTC.
        @param dateString String date value in a format recognized by parse().
        @param year Integer value for the year. Should be a Four digit year (e.g. 1998).
        @param month Integer month value (0-11)
        @param date Integer date of the month (1-31)
        @param hour Integer hour value (0-23)
        @param minute Integer minute value (0-59)
        @param second Integer second value (0-59)
        @param msec Integer millisecond value (0-999)
*/
static EjsDate *date_Date(Ejs *ejs, EjsDate *date, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *vp;
    struct tm   tm;
    int         year;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    if (args->length == 0) {
        /* Now */
        date->value = mprGetTime();

    } else if (args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (ejsIs(ejs, vp, Number)) {
            /* Milliseconds */
            date->value = ejsGetNumber(ejs, vp);

        } else if (ejsIs(ejs, vp, String)) {
            if (mprParseTime(&date->value, ejsToMulti(ejs, vp), MPR_LOCAL_TIMEZONE, NULL) < 0) {
                ejsThrowArgError(ejs, "Can't parse date string: %@", ejsToString(ejs, vp));
                return 0;
            }
        } else if (ejsIs(ejs, vp, Date)) {
            date->value = ((EjsDate*) vp)->value;

        } else {
            ejsThrowArgError(ejs, "Can't construct date from this argument");
            return 0;
        }

    } else {
        /* Date(year, month, date, hour, minute, second, msec) or any portion thereof */
        memset(&tm, 0, sizeof(tm));
        tm.tm_isdst = -1;
        vp = ejsGetProperty(ejs, args, 0);
        year = getInt(ejs, vp);
        if (0 <= year && year < 100) {
            year += 1900;
        }
        tm.tm_year = year - 1900;
        if (args->length > 1) {
            vp = ejsGetProperty(ejs, args, 1);
            tm.tm_mon = getInt(ejs, vp);
        }
        if (args->length > 2) {
            vp = ejsGetProperty(ejs, args, 2);
            tm.tm_mday = getInt(ejs, vp);
        } else {
            tm.tm_mday = 1;
        }
        if (args->length > 3) {
            vp = ejsGetProperty(ejs, args, 3);
            tm.tm_hour = getInt(ejs, vp);
        }
        if (args->length > 4) {
            vp = ejsGetProperty(ejs, args, 4);
            tm.tm_min = getInt(ejs, vp);
        }
        if (args->length > 5) {
            vp = ejsGetProperty(ejs, args, 5);
            tm.tm_sec = getInt(ejs, vp);
        }
        date->value = mprMakeTime(&tm);
        if (date->value == -1) {
            ejsThrowArgError(ejs, "Can't construct date from this argument");
        } else if (args->length > 6) {
            vp = ejsGetProperty(ejs, args, 6);
            date->value += getNumber(ejs, vp);
        }
    }
    return date;
}


/*
    function get day(): Number
    Range: 0-6, where 0 is Sunday
 */
static EjsNumber *date_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function set day(day: Number): Void
    Range: 0-6, where 0 is Sunday
*/
static EjsObj *date_set_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_wday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get dayOfYear(): Number
    Return day of year (0 - 365)
 */
static EjsNumber *date_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_yday);
}


/*
    function set dayOfYear(day: Number): Void
    Set the day of year (0 - 365)
 */
static EjsObj *date_set_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_yday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get date(): Number
    Return day of month (1-31)
 */
static EjsNumber *date_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function set date(date: Number): Void
    Range day of month (1-31)
 */
static EjsObj *date_set_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get elapsed(): Number
    Get the elapsed time in milliseconds since the Date object was constructed
 */
static EjsNumber *date_elapsed(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetElapsedTime(dp->value));
}


/*
    function format(layout: String): String
 */
static EjsString *date_format(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateStringFromAsc(ejs, mprFormatTime(ejsToMulti(ejs, argv[0]), &tm));
}


/*
    function formatUTC(layout: String): String
 */
static EjsString *date_formatUTC(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateStringFromAsc(ejs, mprFormatTime(ejsToMulti(ejs, argv[0]), &tm));
}


/*
    function get fullYear(): Number
    Return year in 4 digits
 */
static EjsNumber *date_fullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function set fullYear(year: Number): void
    Update the year component using a 4 digit year
 */
static EjsObj *date_set_fullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_year = (int) ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function future(msec: Number): Date
 */
static EjsDate *date_future(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    MprTime     inc;

    inc = ejsGetNumber(ejs, argv[0]);
    return ejsCreateDate(ejs, dp->value + inc);
}


/**
    Return the number of minutes between the local computer time and Coordinated Universal Time.
    @return Integer containing the number of minutes between UTC and local time. The offset is positive if
    local time is behind UTC and negative if it is ahead. E.g. American PST is UTC-8 so 420/480 will be retured
    depending on if daylight savings is in effect.

    function getTimezoneOffset(): Number
*/
static EjsNumber *date_getTimezoneOffset(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, -mprGetTimeZoneOffset(dp->value) / (MPR_TICKS_PER_SEC * 60));
}


/*
    function getUTCDate(): Number
    Range: 0-31
 */
static EjsNumber *date_getUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function getUTCDay(): Number
    Range: 0-6
 */
static EjsNumber *date_getUTCDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function getUTCFullYear(): Number
    Range: 4 digits
 */
static EjsNumber *date_getUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function getUTCHours(): Number
    Range: 0-23
 */
static EjsNumber *date_getUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function getUTCMilliseconds(): Number
    Range: 0-999
 */
static EjsNumber *date_getUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function getUTCMinutes(): Number
    Range: 0-31
 */
static EjsNumber *date_getUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function getUTCMonth(): Number
    Range: 1-12
 */
static EjsNumber *date_getUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function getUTCSeconds(): Number
    Range: 0-59
 */
static EjsNumber *date_getUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function get hours(): Number
    Return hour of day (0-23)
 */
static EjsNumber *date_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function set hours(hour: Number): void
    Update the hour of the day using a 0-23 hour
 */
static EjsObj *date_set_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_hour = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function get milliseconds(): Number
 */
static EjsNumber *date_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function set milliseconds(ms: Number): void
 */
static EjsObj *date_set_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function get minutes(): Number
 */
static EjsNumber *date_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function set minutes(min: Number): void
 */
static EjsObj *date_set_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_min = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function get month(): Number
    Get the month (0-11)
 */
static EjsNumber *date_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function set month(month: Number): void
 */
static EjsObj *date_set_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_mon = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function nextDay(inc: Number = 1): Date
 */
static EjsDate *date_nextDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    MprTime     inc;

    if (argc == 1) {
        inc = ejsGetNumber(ejs, argv[0]);
    } else {
        inc = 1;
    }
    return ejsCreateDate(ejs, dp->value + (inc * 86400 * 1000));
}


/*
    static function now(): Number
 */
static EjsNumber *date_now(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetTime());
}


/*
    static function parse(arg: String): Date
 */
static EjsDate *date_parse(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    MprTime     when;

    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_LOCAL_TIMEZONE, NULL) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateDate(ejs, when);
}


/*
    static function parseDate(arg: String, defaultDate: Date = null): Date
 */
static EjsDate *date_parseDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeLocalTime(&tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_LOCAL_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateDate(ejs, when);
}


/*
    static function parseUTCDate(arg: String, defaultDate: Date = null): Date
 */
static EjsDate *date_parseUTCDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeUniversalTime(&tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_UTC_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateDate(ejs, when);
}


/*
    function get seconds(): Number
    Get seconds (0-59)
 */
static EjsNumber *date_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function set seconds(sec: Number): void
 */
static EjsObj *date_set_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_sec = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function setUTCDate(date: Number): Void
    Range month (1-31)
 */
static EjsObj *date_setUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeUniversalTime(&tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
   function setUTCFullYear(y: Number): void
 */
static EjsObj *date_setUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_year = (int) ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCHours(h: Number): void
 */
static EjsObj *date_setUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_hour = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCMilliseconds(ms: Number): void
 */
static EjsObj *date_setUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    /* Same as set_milliseconds */
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function setUTCMinutes(min: Number): void
 */
static EjsObj *date_setUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_min = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCMonth(mon: Number): void
 */
static EjsObj *date_setUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_mon = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCSeconds(sec: Number, msec: Number = null): void
 */
static EjsObj *date_setUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_sec = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    if (argc >= 2) {
        dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[1]);
    }
    return 0;
}


/*
    static function ticks(): Number
 */
static EjsNumber *date_ticks(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetTicks());
}


/*
    Get the number of millseconds since Jan 1, 1970 UTC.
    function get time(): Number
 */
static EjsNumber *date_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, dp->value);
}


/*
    function set time(value: Number): Number
 */
static EjsNumber *date_set_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = ejsGetNumber(ejs, argv[0]);
    return 0;
}


/**
    Return an ISO formatted date string.
    Sample format: "2006-12-15T23:45:09.33-08:00"
    function toISOString(): String
*/
static EjsString *date_toISOString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    char        *base, *str;

    mprDecodeUniversalTime(&tm, dp->value);
    base = mprFormatTime("%Y-%m-%dT%H:%M:%S", &tm);
    str = mprAsprintf("%s.%03dZ", base, dp->value % MPR_TICKS_PER_SEC);
    return ejsCreateStringFromAsc(ejs, str);
}


/*
    Serialize using JSON encoding. This uses the ISO date format

    function toJSON(): String
 */
static EjsString *date_toJSON(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    char        *base, *str;

    mprDecodeUniversalTime(&tm, dp->value);
    base = mprFormatTime("%Y-%m-%dT%H:%M:%S", &tm);
    str = mprAsprintf("\"%sZ\"", base);
    return ejsCreateStringFromAsc(ejs, str);
}


/*
    override native function toString(): String
 */
static EjsString *date_toString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return castDate(ejs, dp, ST(String));
}


/*
    Construct a date from UTC values
    function UTC(year, month, date, hour = 0, minute = 0, second = 0, msec = 0): Number
 */
static EjsNumber *date_UTC(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    EjsDate     *dp;
    struct tm   tm;
    int         year;

    memset(&tm, 0, sizeof(tm));
    year = getInt(ejs, argv[0]);
    if (year < 100) {
        year += 1900;
    }
    tm.tm_year = year - 1900;
    if (argc > 1) {
        tm.tm_mon = getInt(ejs, argv[1]);
    }
    if (argc > 2) {
        tm.tm_mday = getInt(ejs, argv[2]);
    }
    if (argc > 3) {
        tm.tm_hour = getInt(ejs, argv[3]);
    }
    if (argc > 4) {
        tm.tm_min = getInt(ejs, argv[4]);
    }
    if (argc > 5) {
        tm.tm_sec = getInt(ejs, argv[5]);
    }
    dp = ejsCreateDate(ejs, mprMakeUniversalTime(&tm));
    if (argc > 6) {
        dp->value += getNumber(ejs, argv[6]);
    }
    return ejsCreateNumber(ejs, dp->value);
}


/*
    function get year(): Number
 */
static EjsNumber *date_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function set year(year: Number): void
 */
static EjsObj *date_set_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_year = (int) ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeTime(&tm);
    return 0;
}

/*
    Create an initialized date object. Set to the current time if value is zero.
 */

EjsDate *ejsCreateDate(Ejs *ejs, MprTime value)
{
    EjsDate *vp;

    vp = ejsCreateObj(ejs, S(Date), 0);
    if (vp != 0) {
        vp->value = value;
    }
    return vp;
}


void ejsConfigureDateType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsConfigureNativeType(ejs, N("ejs", "Date"), sizeof(EjsDate), NULL, EJS_OBJ_HELPERS)) == 0) {
        return;
    }
    type->mutableInstances = 1;
    ejsSetSpecialType(ejs, S_Date, type);
    prototype = type->prototype;

    type->helpers.cast = (EjsCastHelper) castDate;
    type->helpers.clone = (EjsCloneHelper) cloneDate;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeDateOperator;

    ejsBindMethod(ejs, type, ES_Date_now, date_now);
#if ES_Date_ticks
    ejsBindAccess(ejs, type, ES_Date_ticks, date_ticks, NULL);
#endif
    ejsBindMethod(ejs, type, ES_Date_parseDate, date_parseDate);
    ejsBindMethod(ejs, type, ES_Date_parseUTCDate, date_parseUTCDate);
    ejsBindMethod(ejs, type, ES_Date_parse, date_parse);
    ejsBindMethod(ejs, type, ES_Date_UTC, date_UTC);

    ejsBindConstructor(ejs, type, date_Date);
    ejsBindAccess(ejs, prototype, ES_Date_day, date_day, date_set_day);
    ejsBindAccess(ejs, prototype, ES_Date_dayOfYear, date_dayOfYear, date_set_dayOfYear);
    ejsBindAccess(ejs, prototype, ES_Date_date, date_date, date_set_date);
    ejsBindMethod(ejs, prototype, ES_Date_elapsed, date_elapsed);
    ejsBindMethod(ejs, prototype, ES_Date_format, date_format);
    ejsBindMethod(ejs, prototype, ES_Date_formatUTC, date_formatUTC);
    ejsBindAccess(ejs, prototype, ES_Date_fullYear, date_fullYear, date_set_fullYear);
    ejsBindMethod(ejs, prototype, ES_Date_future, date_future);
    ejsBindMethod(ejs, prototype, ES_Date_getTimezoneOffset, date_getTimezoneOffset); 
    ejsBindMethod(ejs, prototype, ES_Date_getUTCDate, date_getUTCDate);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCDay, date_getUTCDay);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCFullYear, date_getUTCFullYear);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCHours, date_getUTCHours);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMilliseconds, date_getUTCMilliseconds);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMinutes, date_getUTCMinutes);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMonth, date_getUTCMonth);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCSeconds, date_getUTCSeconds);
    ejsBindAccess(ejs, prototype, ES_Date_hours, date_hours, date_set_hours);
    ejsBindAccess(ejs, prototype, ES_Date_milliseconds, date_milliseconds, date_set_milliseconds);
    ejsBindAccess(ejs, prototype, ES_Date_minutes, date_minutes, date_set_minutes);
    ejsBindAccess(ejs, prototype, ES_Date_month, date_month, date_set_month);
    ejsBindMethod(ejs, prototype, ES_Date_nextDay, date_nextDay);
    ejsBindAccess(ejs, prototype, ES_Date_seconds, date_seconds, date_set_seconds);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCDate, date_setUTCDate);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCFullYear, date_setUTCFullYear);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCHours, date_setUTCHours);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMilliseconds, date_setUTCMilliseconds);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMinutes, date_setUTCMinutes);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMonth, date_setUTCMonth);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCSeconds, date_setUTCSeconds);
    ejsBindAccess(ejs, prototype, ES_Date_time, date_time, date_set_time);
    ejsBindMethod(ejs, prototype, ES_Date_toJSON, date_toJSON);
    ejsBindMethod(ejs, prototype, ES_Date_toISOString, date_toISOString);
    ejsBindMethod(ejs, prototype, ES_Date_toString, date_toString);
    ejsBindAccess(ejs, prototype, ES_Date_year, date_year, date_set_year);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsDate.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsDebug.c"
 */
/************************************************************************/

/*
    ejsDebug.c - Debug.Debug class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


/*
    Trap to the debugger

    static function breakpoint(): Void
 */
static EjsObj *debug_breakpoint(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_DEBUG && DEBUG_IDE && 0
    #if BLD_WIN_LIKE && !MPR_64_BIT
        __asm { int 3 };
    #elif (MACOSX || LINUX) && (BLD_HOST_CPU_ARCH == MPR_CPU_IX86 || BLD_HOST_CPU_ARCH == MPR_CPU_IX64)
        asm("int $03");
        /*  __asm__ __volatile__ ("int $03"); */
    #endif
#else
    mprBreakpoint();
#endif
    return 0;
}


/*
    function get mode(): Boolean
 */
static EjsObj *debug_mode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return mprGetDebugMode() ? S(true) : S(false);
}


/*
    function set mode(on: Boolean): Void
 */
static EjsObj *debug_set_mode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprSetDebugMode(argv[0] == S(true));
    return 0;
}


void ejsConfigureDebugType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, N("ejs", "Debug"))) == 0) {
        mprError("Can't find Debug type");
        return;
    }
    ejsBindMethod(ejs, type, ES_Debug_breakpoint, debug_breakpoint);
    ejsBindAccess(ejs, type, ES_Debug_mode, debug_mode, debug_set_mode);

    ejsBindFunction(ejs, ejs->global, ES_breakpoint, debug_breakpoint);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsDebug.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsError.c"
 */
/************************************************************************/

/**
    ejsError.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castError(Ejs *ejs, EjsError *error, EjsType *type)
{
    EjsString   *stack, *msg;
    EjsString   *us;
    char        *buf;

    switch (type->sid) {
    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_String:
        stack = (EjsString*) ejsRunFunctionBySlot(ejs, error, ES_Error_formatStack, 0, NULL);
        us = ejsIs(ejs, stack, String) ? stack : S(empty);
        msg = ejsGetProperty(ejs, error, ES_Error_message);
        if ((buf = mprAsprintf("%@ Exception: %@\nStack:\n%@\n", TYPE(error)->qname.name, msg, us)) == NULL) {
            ejsThrowMemoryError(ejs);
        }
        return ejsCreateStringFromAsc(ejs, buf);
        break;

    default:
        ejsThrowTypeError(ejs, "Unknown type");
    }
    return 0;
}


/*
    Error Constructor and constructor for all the core error classes.

    public function Error(message: String = null)
 */
static EjsError *errorConstructor(Ejs *ejs, EjsError *error, int argc, EjsObj **argv)
{
    if (argc > 0) {
        ejsSetProperty(ejs, error, ES_Error_message, ejsToString(ejs, argv[0]));
    }
    if (ST(Date)) {
        ejsSetProperty(ejs, error, ES_Error_timestamp, ejsCreateDate(ejs, mprGetTime()));
        ejsSetProperty(ejs, error, ES_Error_stack, ejsCaptureStack(ejs, 0));
    }
    return error;
}


/*
    static function capture(uplevels: Number): Array
 */
static EjsArray *error_capture(Ejs *ejs, EjsError *error, int argc,  EjsObj **argv)
{
    int     uplevels;
    
    uplevels = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    return ejsCaptureStack(ejs, uplevels);
}


EjsError *ejsCreateError(Ejs *ejs, EjsType *type, EjsObj *msg) 
{
    EjsError    *error;

    error = ejsCreatePot(ejs, type, 0);
    if (error) {
        ejsSetProperty(ejs, error, ES_Error_message, msg);
        ejsSetProperty(ejs, error, ES_Error_timestamp, ejsCreateDate(ejs, mprGetTime()));
        ejsSetProperty(ejs, error, ES_Error_stack, ejsCaptureStack(ejs, 0));
    }
    return error;
}


static EjsType *defineType(Ejs *ejs, cchar *name, int id)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", name), sizeof(EjsError), id, ES_Error_NUM_CLASS_PROP, ejsManagePot, 
        EJS_POT_HELPERS);
    ejsSetTypeAttributes(type, EJS_TYPE_DYNAMIC_INSTANCE | EJS_TYPE_HAS_INSTANCE_VARS);
    type->constructor.block.nobind = 1;
    type->helpers.cast = (EjsCastHelper) castError;
    return type;
}


void ejsCreateErrorType(Ejs *ejs)
{
    defineType(ejs, "Error", S_Error);
    defineType(ejs, "ArgError", -1);
    defineType(ejs, "ArithmeticError", -1);
    defineType(ejs, "AssertError", -1);
    defineType(ejs, "InstructionError", -1);
    defineType(ejs, "IOError", -1);
    defineType(ejs, "InternalError", -1);
    defineType(ejs, "MemoryError", -1);
    defineType(ejs, "OutOfBoundsError", -1);
    defineType(ejs, "ReferenceError", -1);
    defineType(ejs, "ResourceError", -1);
    defineType(ejs, "SecurityError", -1);
    defineType(ejs, "StateError", -1);
    defineType(ejs, "SyntaxError", -1);
    defineType(ejs, "TypeError", -1);
    defineType(ejs, "URIError", -1);
}


static void configureType(Ejs *ejs, cchar *name)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, N("ejs", name));
    mprAssert(type);
    ejsBindConstructor(ejs, type, errorConstructor);
}


void ejsConfigureErrorType(Ejs *ejs)
{
    //  OPT simplify
    configureType(ejs, "Error");
    configureType(ejs, "ArgError");
    configureType(ejs, "ArithmeticError");
    configureType(ejs, "AssertError");
    configureType(ejs, "InstructionError");
    configureType(ejs, "IOError");
    configureType(ejs, "InternalError");
    configureType(ejs, "MemoryError");
    configureType(ejs, "OutOfBoundsError");
    configureType(ejs, "ReferenceError");
    configureType(ejs, "ResourceError");
    configureType(ejs, "SecurityError");
    configureType(ejs, "StateError");
    configureType(ejs, "SyntaxError");
    configureType(ejs, "TypeError");
    configureType(ejs, "URIError");

    ejsBindMethod(ejs, ST(Error), ES_Error_capture, error_capture);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsError.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsFile.c"
 */
/************************************************************************/

/**
    ejsFile.c - File class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#if BLD_WIN_LIKE
#define isDelim(fp, c)  (c == '/' || c == fp->delimiter)
#else
#define isDelim(fp, c)  (c == fp->delimiter)
#endif

#define FILE_OPEN           0x1
#define FILE_READ           0x2
#define FILE_WRITE          0x4


static EjsObj *closeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv);
static int mapMode(cchar *mode);
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv);
static ssize readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, ssize offset, ssize count);

#if BLD_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode);
static void unmapFile(EjsFile *fp);
#endif


/*  
    Index into a file and extract a byte. This is random access reading.
 */
static EjsNumber *getFileProperty(Ejs *ejs, EjsFile *fp, int slotNum)
{
    MprOff  offset;
    int     c;

    if (!(fp->mode & FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
#if KEEP
    if (fp->mode & FILE_READ) {
        if (slotNum >= fp->info.size) {
            ejsThrowOutOfBoundsError(ejs, "Bad file index");
            return 0;
        }
    }
    if (slotNum < 0) {
        ejsThrowOutOfBoundsError(ejs, "Bad file index");
        return 0;
    }
#endif

#if BLD_CC_MMU && FUTURE
    //  must check against mapped size here.
    c = fp->mapped[slotNum];
#else
    offset = mprSeekFile(fp->file, SEEK_CUR, 0);
    if (offset != slotNum) {
        if (mprSeekFile(fp->file, SEEK_SET, slotNum) != slotNum) {
            ejsThrowIOError(ejs, "Can't seek to file offset");
            return 0;
        }
    }
    c = mprPeekFileChar(fp->file);
    if (c < 0) {
        ejsThrowIOError(ejs, "Can't read file");
        return 0;
    }
#endif
    return ejsCreateNumber(ejs, c);
}



static int lookupFileProperty(Ejs *ejs, EjsFile *fp, EjsName qname)
{
    int     index;

    if (qname.name == 0 || !isdigit((int) qname.name->value[0])) {
        return EJS_ERR;
    }
    if (!(fp->mode & FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < mprGetFileSize(fp->file)) {
        return index;
    }
    return EJS_ERR;
}


/*  
    Set a byte in the file at the offset designated by slotNum.
 */
static int setFileProperty(Ejs *ejs, EjsFile *fp, int slotNum, EjsObj *value)
{
    MprOff  offset;
    int     c;

    if (!(fp->mode & FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
    if (!(fp->mode & FILE_WRITE)) {
        ejsThrowIOError(ejs, "File is not opened for writing");
        return 0;
    }
    c = ejsIs(ejs, value, Number) ? ejsGetInt(ejs, value) : ejsGetInt(ejs, ejsToNumber(ejs, value));

    offset = mprSeekFile(fp->file, SEEK_CUR, 0);
    if (slotNum < 0) {
        //  could have an mprGetPosition(file) API
        slotNum = (int) offset;
    }

#if BLD_CC_MMU && FUTURE
    fp->mapped[slotNum] = c;
#else
    if (offset != slotNum && mprSeekFile(fp->file, SEEK_SET, slotNum) != slotNum) {
        ejsThrowIOError(ejs, "Can't seek to file offset");
        return 0;
    }
    if (mprPutFileChar(fp->file, c) < 0) {
        ejsThrowIOError(ejs, "Can't write file");
        return 0;
    }
#endif
    return slotNum;
}



//  TODO - rename
static int ejsGetNumOption(Ejs *ejs, EjsObj *options, cchar *field, int defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsNumber   *num;

    vp = ejsGetPropertyByName(ejs, options, EN(field));
    if (vp == 0) {
        if (optional) {
            return defaultValue;
        }
        ejsThrowArgError(ejs, "Required option \"%s\" is missing", field);
        return 0;
    }
    num = ejsToNumber(ejs, vp);
    if (!ejsIs(ejs, num, Number)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return (int) num->value;
}


static cchar *getStrOption(Ejs *ejs, EjsObj *options, cchar *field, cchar *defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsString   *str;

    vp = ejsGetPropertyByName(ejs, options, EN(field));
    if (vp == 0) {
        if (optional) {
            return sclone(defaultValue);
        }
        ejsThrowArgError(ejs, "Required option %s is missing", field);
        return 0;
    }
    str = ejsToString(ejs, vp);
    if (!ejsIs(ejs, str, String)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return ejsToMulti(ejs, str);
}


/*  
    Constructor
    function File(path: Object, options: Object = null)
 */
static EjsFile *fileConstructor(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj      *pp;
    cchar       *path;

    if (argc < 1 || argc > 2) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    pp = argv[0];
    if (ejsIs(ejs, pp, Path)) {
        path = ((EjsPath*) pp)->value;
    } else if (ejsIs(ejs, pp, String)) {
        path = ejsToMulti(ejs, pp);
    } else {
        ejsThrowIOError(ejs, "Bad path");
        return 0;
    }
    fp->path = mprGetNormalizedPath(path);
    if (argc == 2) {
        openFile(ejs, fp, 1, &argv[1]);
    }
    return fp;
}


/*  
    function get canRead(): Boolean
 */
static EjsBoolean *canReadFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->mode & FILE_OPEN && (fp->mode & FILE_READ));
}


/*  
    function get canRead(): Boolean
 */
static EjsBoolean *canWriteFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->mode & FILE_OPEN && (fp->mode & FILE_WRITE));
}

/*  
    Close the file and free up all associated resources.
    function close(): void
 */
static EjsObj *closeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->mode & FILE_OPEN && fp->mode & FILE_WRITE) {
        if (mprFlushFile(fp->file) < 0) {
            if (ejs) {
                ejsThrowIOError(ejs, "Can't flush file data");
            } else {
                mprError("Can't flush file data");
            }
            return 0;
        }
    }
    if (fp->file) {
        mprCloseFile(fp->file);
        fp->file = 0;
    }
#if BLD_CC_MMU && FUTURE
    if (fp->mapped) {
        unmapFile(fp);
        fp->mapped = 0;
    }
#endif
    fp->mode = 0;
    fp->modeString = 0;
    return 0;
}


/*  
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIs(ejs, fp, File)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < fp->info.size) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return the default iterator for use with "for ... in". This returns byte offsets in the file.
    iterator native function get(): Iterator
 */
static EjsIterator *getFileIterator(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(fp->path, &fp->info);
    return ejsCreateIterator(ejs, fp, nextKey, 0, NULL);
}


/*  
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIs(ejs, fp, File)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < fp->info.size) {
#if !BLD_CC_MMU || 1
        if (mprSeekFile(fp->file, SEEK_CUR, 0) != ip->index) {
            if (mprSeekFile(fp->file, SEEK_SET, ip->index) != ip->index) {
                ejsThrowIOError(ejs, "Can't seek to %d", ip->index);
                return 0;
            }
        }
        ip->index++;
        return (EjsObj*) ejsCreateNumber(ejs, mprGetFileChar(fp->file));
#else
        return (EjsObj*) ejsCreateNumber(ejs, fp->mapped[ip->index++]);
#endif
    }

#if BLD_CC_MMU && FUTURE
    unmapFile(fp);
    fp->mapped = 0;
#endif

    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator native function getValues(): Iterator
 */
static EjsObj *getFileValues(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(fp->path, &fp->info);

    return (EjsObj*) ejsCreateIterator(ejs, (EjsObj*) fp, nextValue, 0, NULL);
}


/*  
    Get a path object for the file
    function get path(): Path
 */
static EjsObj *getFilePath(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathFromAsc(ejs, fp->path);
}


/*  
    Get the current I/O position in the file.
    function get position(): Number
 */
static EjsObj *getFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) mprGetFilePosition(fp->file));
}


/*  
    Seek to a new location in the file and set the File marker to a new read/write position.
    function set position(value: Number): void
 */
static EjsObj *setFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    MprOff      pos;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
    pos = ejsGetInt(ejs, argv[0]);

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    pos = ejsGetInt(ejs, argv[0]);
    if (mprSeekFile(fp->file, SEEK_SET, pos) != pos) {
        ejsThrowIOError(ejs, "Can't seek to %Ld", pos);
    }
    return 0;
}


/*  
    function get isOpen(): Boolean
 */
static EjsObj *isFileOpen(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->mode & FILE_OPEN);
}


/*  
    Constructor
    function open(options: Object = null): File
    NOTE: options can be an options hash or as mode string
 */
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj  *options;
    cchar   *mode;
    int     perms, omode;

    if (argc < 0 || argc > 1) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    options = argv[0];
    if (argc == 0 || !ejsIsDefined(ejs, options)) {
        omode = O_RDONLY | O_BINARY;
        perms = EJS_FILE_PERMS;
        fp->mode = FILE_READ;
        mode = "r";
    } else {
        if (ejsIs(ejs, options, String)) {
            mode = ejsToMulti(ejs, options);
            perms = EJS_FILE_PERMS;
        } else {
            perms = ejsGetNumOption(ejs, options, "permissions", EJS_FILE_PERMS, 1);
            mode = getStrOption(ejs, options, "mode", "r", 1);
            if (ejs->exception) {
                return 0;
            }
        }
        omode = mapMode(mode);
        if (!(omode & O_WRONLY)) {
            fp->mode |= FILE_READ;
        }
        if (omode & (O_WRONLY | O_RDWR)) {
            fp->mode |= FILE_WRITE;
        }
    }
    fp->modeString = sclone(mode);
    fp->perms = perms;

    if (fp->file) {
        mprCloseFile(fp->file);
    }
    fp->file = mprOpenFile(fp->path, omode, perms);
    if (fp->file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", fp->path);
        return 0;
    }

#if BLD_CC_MMU && FUTURE
    mprGetPathInfo(&fp->info);
    fp->mapped = mapFile(fp, fp->info.size, MPR_MAP_READ | MPR_MAP_WRITE);
#endif
    fp->mode |= FILE_OPEN;
    return (EjsObj*) fp;
}


static EjsObj *getFileOptions(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj      *options;

    options = (EjsObj*) ejsCreateEmptyPot(ejs);
    ejsSetPropertyByName(ejs, options, EN("mode"), ejsCreateStringFromAsc(ejs, fp->modeString));
    ejsSetPropertyByName(ejs, options, EN("permissions"), ejsCreateNumber(ejs, fp->perms));
    return options;
}

/*  
    Read data bytes from a file
    function readBytes(count: Number = -1): ByteArray
 */
static EjsObj *readFileBytes(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *result;
    MprPath         info;
    ssize           count, totalRead;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    result = ejsCreateByteArray(ejs, count);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = readData(ejs, fp, result, 0, count);
    if (totalRead < 0) {
        ejsThrowIOError(ejs, "Can't read from file: %s", fp->path);
        return 0;
    } else if (totalRead == 0) {
        return S(null);
    }
    ejsSetByteArrayPositions(ejs, result, 0, totalRead);
    return (EjsObj*) result;
}


/*  
    Read data as a string
    function readString(count: Number = -1): String
 */
static EjsString *readFileString(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsString       *result;
    MprPath         info;
    ssize           totalRead;
    int             count;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    if ((result = ejsCreateBareString(ejs, count)) == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = mprReadFile(fp->file, result->value, count);
    if (totalRead != count) {
        ejsThrowIOError(ejs, "Can't read from file: %s", fp->path);
        return 0;
    }
    return ejsInternString(result);
}


/*  
    Read data bytes from a file. If offset is < 0, then append to the write position.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *readFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    MprPath         info;
    ssize           offset, count, totalRead;

    mprAssert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]): 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset == 0) {
        ejsSetByteArrayPositions(ejs, buffer, 0, 0);
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    totalRead = readData(ejs, fp, buffer, offset, count);
    if (totalRead < 0) {
        return 0;
    } else if (totalRead == 0) {
        return S(zero);
    }
    ejsSetByteArrayPositions(ejs, buffer, -1, offset + totalRead);
    return ejsCreateNumber(ejs, (MprNumber) totalRead);
}


/*  
    Get the size of the file associated with this File object.
    override function get size(): Number
 */
static EjsObj *getFileSize(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(fp->path, &info) < 0) {
        return (EjsObj*) S(minusOne);
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) info.size);
}


/*  
    function truncate(size: Number): Void
 */
EjsObj *truncateFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncateFile(fp->path, size) < 0) {
        ejsThrowIOError(ejs, "Cant truncate %s", fp->path);
    }
    return 0;
}


/*  
    Write data to the file
    function write(data: Object): Number
 */
EjsObj *writeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ap;
    EjsObj          *vp;
    EjsString       *str;
    cchar           *buf;
    ssize           len, written;
    int             i;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    if (!(fp->mode & FILE_WRITE)) {
        ejsThrowStateError(ejs, "File not opened for writing");
        return 0;
    }
    written = 0;

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, (EjsObj*) args, i);
        mprAssert(vp);
        switch (TYPE(vp)->sid) {
        case S_ByteArray:
            ap = (EjsByteArray*) vp;
            //  TODO UNICODE ENCODING
            buf = (cchar*) &ap->value[ap->readPosition];
            len = ap->writePosition - ap->readPosition;
            break;

        case S_String:
            buf = awtom(((EjsString*) vp)->value, &len);
            break;

        default:
            str = ejsToString(ejs, vp);
            buf = awtom(((EjsString*) str)->value, &len);
            break;
        }
        if (mprWriteFile(fp->file, buf, len) != len) {
            ejsThrowIOError(ejs, "Can't write to %s", fp->path);
            return 0;
        }
        written += len;
        /* Use GC to free buf as it may not be allocated */
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) written);
}



/*  
    Read the specified count of bytes into the byte array. Grow the array if required and growable
 */
static ssize readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, ssize offset, ssize count)
{
    ssize   len, bytes;

    if (count <= 0) {
        return 0;
    }
    len = ap->length - offset;
    if (len < count) {
        if (ap->resizable) {
            ejsGrowByteArray(ejs, ap, ap->length + (count - len));
        }
        len = ap->length - offset;
    }
    bytes = mprReadFile(fp->file, &ap->value[offset], len);
    if (bytes < 0) {
        ejsThrowIOError(ejs, "Error reading from %s", fp->path);
    }
    return bytes;
}


#if BLD_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode)
{
    Mpr         *mpr;
    void        *ptr;

    mpr = mprGetMpr();
    x = ~(mpr->alloc.pageSize - 1);
    size = (size + mpr->alloc.pageSize - 1) & ~(mpr->alloc.pageSize - 1);
#if MACOSX || LINUX || FREEBSD
    //  USE MAP_SHARED instead of MAP_PRIVATE if opened for write
    ptr = mmap(0, size, mode, MAP_FILE | MAP_PRIVATE, fp->file->fd, 0);
#else
    ptr = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, mapProt(mode));
#endif

    if (ptr == 0) {
        mprSetMemError(mpr);
        return 0;
    }
    return ptr;
}


static void unmapFile(EjsFile *fp)
{
#if MACOSX || LINUX || FREEBSD
    munmap(fp->mapped, fp->info.size);
#else
    VirtualFree(file->mapped, 0, MEM_RELEASE);
#endif
}
#endif

static int mapMode(cchar *mode)
{
    int     omode;

    omode = O_BINARY;
    if (strchr(mode, 'r')) {
        omode |= O_RDONLY;
    }
    if (strchr(mode, 'w')) {
        if (omode & O_RDONLY) {
            omode &= ~O_RDONLY;
            omode |= O_RDWR;
        } else {
            omode |= O_CREAT | O_WRONLY | O_TRUNC;
        }
    }
    if (strchr(mode, 'a')) {
        omode |= O_WRONLY | O_APPEND;
        omode &= ~O_TRUNC;
    }
    if (strchr(mode, '+')) {
        omode &= ~O_TRUNC;
    }
    if (strchr(mode, 't')) {
        omode &= ~O_BINARY;
    }
    return omode;
}



EjsFile *ejsCreateFile(Ejs *ejs, cchar *path)
{
    EjsFile     *fp;
    EjsObj      *arg;

    mprAssert(path && *path);

    fp = ejsCreateObj(ejs, ST(File), 0);
    if (fp == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    fileConstructor(ejs, fp, 1, (EjsObj**) &arg);
    return fp;
}


EjsFile *ejsCreateFileFromFd(Ejs *ejs, int fd, cchar *name, int mode)
{
    EjsFile     *fp;

    mprAssert(fd >= 0);
    mprAssert(name);

    if ((fp = ejsCreateObj(ejs, ST(File), 0)) == NULL) {
        return NULL;
    }
    fp->perms = EJS_FILE_PERMS;
    fp->mode = FILE_OPEN;
    if (!(mode & O_WRONLY)) {
        fp->mode |= FILE_READ;
    }
    if (mode & (O_WRONLY | O_RDWR)) {
        fp->mode |= FILE_WRITE;
    }
    if ((fp->file = mprAttachFileFd(fd, name, mode)) == 0) {
        return 0;
    }
    fp->attached = 1;
    fp->path = MPR->emptyString;
    return fp;
}


static void manageFile(void *ptr, int flags)
{
    EjsFile     *fp;

    fp = (EjsFile*) ptr;

    if (flags & MPR_MANAGE_MARK) {
        mprMark(fp->file);
        mprMark(fp->path);
        mprMark(fp->modeString);
        mprMark(TYPE(fp));

    } else if (flags & MPR_MANAGE_FREE) {
        if (fp->file && !fp->attached) {
            closeFile(0, fp, 0, NULL);
        }
    }
}


void ejsConfigureFileType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "File"), sizeof(EjsFile), manageFile, EJS_OBJ_HELPERS);
    ejsSetSpecialType(ejs, S_File, type);

    type->numericIndicies = 1;
    type->virtualSlots = 1;
    type->mutableInstances = 1;
    prototype = type->prototype;

    type->helpers.getProperty    = (EjsGetPropertyHelper) getFileProperty;
    type->helpers.lookupProperty = (EjsLookupPropertyHelper) lookupFileProperty;
    type->helpers.setProperty    = (EjsSetPropertyHelper) setFileProperty;

    ejsBindConstructor(ejs, type, fileConstructor);
    ejsBindMethod(ejs, prototype, ES_File_canRead, canReadFile);
    ejsBindMethod(ejs, prototype, ES_File_canWrite, canWriteFile);
    ejsBindMethod(ejs, prototype, ES_File_close, closeFile);
    ejsBindMethod(ejs, prototype, ES_File_iterator_get, getFileIterator);
    ejsBindMethod(ejs, prototype, ES_File_iterator_getValues, getFileValues);
    ejsBindMethod(ejs, prototype, ES_File_isOpen, isFileOpen);
    ejsBindMethod(ejs, prototype, ES_File_open, openFile);
    ejsBindMethod(ejs, prototype, ES_File_options, getFileOptions);
    ejsBindMethod(ejs, prototype, ES_File_path, getFilePath);
    ejsBindAccess(ejs, prototype, ES_File_position, getFilePosition, setFilePosition);
    ejsBindMethod(ejs, prototype, ES_File_readBytes, readFileBytes);
    ejsBindMethod(ejs, prototype, ES_File_readString, readFileString);
    ejsBindMethod(ejs, prototype, ES_File_read, readFile);
    ejsBindMethod(ejs, prototype, ES_File_size, getFileSize);
    ejsBindMethod(ejs, prototype, ES_File_truncate, truncateFile);
    ejsBindMethod(ejs, prototype, ES_File_write, writeFile);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsFile.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsFileSystem.c"
 */
/************************************************************************/

/**
    ejsFileSystem.c - FileSystem class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Constructor

    function FileSystem(path: String)
 */
static EjsFileSystem *fileSystemConstructor(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    path = ejsToMulti(ejs, argv[0]);
    fp->path = mprGetNormalizedPath(path);
    fp->fs = mprLookupFileSystem(path);
    return fp;
}


#if ES_space
/*
    Return the amount of free space in the file system that would contain the given path.

    function freeSpace(path: String = null): Number
 */
static EjsObj *fileSystemSpace(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
#if BREW
    Mpr     *mpr;
    uint    space;

    mpr = mprGetMpr();
    space = IFILEMGR_GetFreeSpace(mpr->fileMgr, 0);
    ejsSetReturnValueToInteger(ejs, space);
#endif
    return 0;
}
#endif


/*
    Determine if the file system has a drive specs (C:) in paths

    static function hasDrives(): Boolean
 */
static EjsBoolean *hasDrives(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->fs->hasDriveSpecs);
}


#if ES_isReady
/*
    Determine if the file system is ready for I/O

    function get isReady(): Boolean
 */
static EjsBoolean *isReady(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


#if ES_isWritable
static EjsBoolean *isWritable(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


/*
    Get the newline characters

    function get newline(): String
 */
static EjsString *getNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprGetPathNewline(fp->path));
}


/*
    set the newline characters

    function set newline(terminator: String): Void
 */
static EjsObj *setNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *nl;

    mprAssert(ejsIs(ejs, argv[0], String));
    nl = ejsToMulti(ejs, (EjsString*) argv[0]);
    mprSetPathNewline(fp->path, nl);
    return 0;
}


static EjsPath *root(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *separators;
    char    *path, *cp;

    separators = mprGetPathSeparators(fp->path);
    path = mprGetAbsPath(fp->path);
    if ((cp = strchr(path, separators[0])) != 0) {
        *++cp = '\0';
    }
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    Return the path directory separators

    static function get separators(): String
 */
static EjsString *getSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->fs->separators);
}


/*
    Set the path directory separators

    static function set separators(value: String): void
 */
static EjsObj *setSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));
    mprSetPathSeparators(fp->path, ejsToMulti(ejs, argv[0]));
    return 0;
}


#if ES_size
static EjsObj *size(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif


static void manageFileSystem(EjsFileSystem *fs, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(TYPE(fs));
        mprMark(fs->path);
    }
}


EjsFileSystem *ejsCreateFileSystem(Ejs *ejs, cchar *path)
{
    EjsFileSystem   *fs;
    EjsObj          *arg;

    fs = ejsCreateObj(ejs, ST(FileSystem), 0);
    if (fs == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    fileSystemConstructor(ejs, fs, 1, (EjsObj**) &arg);
    return fs;
}


void ejsConfigureFileSystemType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "FileSystem"), sizeof(EjsFileSystem), manageFileSystem, EJS_OBJ_HELPERS);
    ejsSetSpecialType(ejs, S_FileSystem, type);
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, fileSystemConstructor);
#if ES_space
    ejsBindMethod(ejs, prototype, ES_FileSystem_space, fileSystemSpace);
#endif
    ejsBindMethod(ejs, prototype, ES_FileSystem_hasDrives, hasDrives);
#if ES_isReady
    ejsBindMethod(ejs, prototype, ES_FileSystem_isReady, isReady);
#endif
#if ES_isWritable
    ejsBindMethod(ejs, prototype, ES_FileSystem_isWritable, isWritable);
#endif
    ejsBindAccess(ejs, prototype, ES_FileSystem_newline, getNewline, setNewline);
    ejsBindMethod(ejs, prototype, ES_FileSystem_root, root);
    ejsBindAccess(ejs, prototype, ES_FileSystem_separators, getSeparators, setSeparators);
#if ES_size
    ejsBindMethod(ejs, prototype, ES_FileSystem_size, size);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsFileSystem.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsFrame.c"
 */
/************************************************************************/

/**
    ejsFrame.c - Activation frame class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void manageFrame(EjsFrame *frame, int flags)
{
    mprAssert(frame);
    if (frame) {
        if (flags & MPR_MANAGE_MARK) {
            ejsManageFunction((EjsFunction*) frame, flags);
            mprMark(frame->orig);
            mprMark(frame->caller);
            mprMark(TYPE(frame));
            /* Marking the stack is done in ejsGarbage.c:mark() */
#if BLD_DEBUG && UNUSED
            mprMark(frame->loc.source);
            mprMark(frame->loc.filename);
#endif
        }
    }
}


static EjsFrame *allocFrame(Ejs *ejs, int numProp)
{
    EjsObj      *obj;
    ssize       size;

    mprAssert(ejs);

    size = sizeof(EjsFrame) + sizeof(EjsProperties) + numProp * sizeof(EjsSlot);
    if ((obj = mprAllocBlock(size, MPR_ALLOC_MANAGER | MPR_ALLOC_ZERO)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    mprSetManager(obj, manageFrame);
    SET_TYPE(obj, ST(Frame));
    ejsSetMemRef(obj);
    return (EjsFrame*) obj;
}


/*
    Create a frame object just for the compiler
 */
EjsFrame *ejsCreateCompilerFrame(Ejs *ejs, EjsFunction *fun)
{
    EjsFrame    *fp;

    if ((fp = ejsCreatePot(ejs, ST(Frame), 0)) == 0) {
        return 0;
    }
    fp->orig = fun;
    fp->function.name = fun->name;
    fp->function.block.pot.isBlock = 1;
    fp->function.block.pot.isFrame = 1;
    fp->function.isConstructor = fun->isConstructor;
    fp->function.isInitializer = fun->isInitializer;
    fp->function.staticMethod = fun->staticMethod;
    mprSetName(fp, "frame");
    return fp;
}


EjsFrame *ejsCreateFrame(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, EjsObj **argv)
{
    EjsFrame    *frame;
    EjsPot      *obj, *activation;
    int         numProp, size, i;

    activation = fun->activation;
    numProp = (activation) ? activation->numProp : 0;
    size = max(numProp, EJS_MIN_FRAME_SLOTS);

    frame = allocFrame(ejs, size);
    obj = (EjsPot*) frame;
    obj->properties = (EjsProperties*) &(((char*) obj)[sizeof(EjsFrame)]);
    obj->properties->size = size;
    obj->numProp = numProp;
    if (activation) {
        //  OPT -- could the function be setup as the prototype and thus avoid doing this?
        //  OPT -- assumes that the function is sealed
        memcpy(obj->properties->slots, activation->properties->slots, numProp * sizeof(EjsSlot));
        ejsMakeHash(ejs, obj);
    }
    ejsZeroSlots(ejs, &obj->properties->slots[numProp], size - numProp);
    //  OPT - should not need to do this
    SET_DYNAMIC(obj, 1);

    frame->orig = fun;
    frame->function.name = fun->name;
    frame->function.block.pot.isBlock = 1;
    frame->function.block.pot.isFrame = 1;
    frame->function.block.namespaces = fun->block.namespaces;
    frame->function.block.scope = fun->block.scope;
    frame->function.block.prev = fun->block.prev;
    frame->function.block.breakCatch = fun->block.breakCatch;
    frame->function.block.nobind = fun->block.nobind;

    //  OPT
    frame->function.numArgs = fun->numArgs;
    frame->function.numDefault = fun->numDefault;
    frame->function.castNulls = fun->castNulls;
    frame->function.fullScope = fun->fullScope;
    frame->function.hasReturn = fun->hasReturn;
    frame->function.isConstructor = fun->isConstructor;
    frame->function.isInitializer = fun->isInitializer;
    frame->function.isNativeProc = fun->isNativeProc;
    frame->function.rest = fun->rest;
    frame->function.staticMethod = fun->staticMethod;
    frame->function.strict = fun->strict;
    frame->function.throwNulls = fun->throwNulls;

    frame->function.boundArgs = fun->boundArgs;

#if UNUSED
    //  MOB thisObj is always set
    mprAssert(thisObj);
    if (thisObj) {
        frame->function.boundThis = thisObj;
    } else if (fun->boundThis) {
        mprAssert(fun->boundThis != ejs->global);
        frame->function.boundThis = fun->boundThis;
    } else {
        frame->function.boundThis = ejs->global;
    }
#else
    /* NOTE: this can be set to ejs->global in frames */
    frame->function.boundThis = thisObj;
#endif
    
    frame->function.resultType = fun->resultType;
    frame->function.body = fun->body;
    frame->pc = fun->body.code->byteCode;
    mprAssert(frame->pc);

    if (argc > 0) {
        frame->argc = argc;
        if ((uint) argc < (fun->numArgs - fun->numDefault - fun->rest) || (uint) argc > fun->numArgs) {
            ejsThrowArgError(ejs, "Incorrect number of arguments");
            return 0;
        }
        for (i = 0; i < argc; i++) {
            frame->function.block.pot.properties->slots[i].value.ref = argv[i];
        }
    }
    //  UNICODE
    mprSetName(frame, fun->name->value);
    return frame;
}


void ejsCreateFrameType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Frame"), sizeof(EjsFrame), S_Frame, ES_Frame_NUM_CLASS_PROP,
        manageFrame, EJS_POT_HELPERS);
    type->mutableInstances = 1;
    ejsSetTypeAttributes(type, EJS_TYPE_DYNAMIC_INSTANCE);
    type->constructor.block.pot.shortScope = 1;
    type->helpers.clone = (EjsCloneHelper) ejsCloneBlock;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsFrame.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsFunction.c"
 */
/************************************************************************/

/**
    ejsFunction.c - Function class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void setFunctionAttributes(EjsFunction *fun, int attributes);

/*
    Create a function object.
 */
static EjsFunction *createFunction(Ejs *ejs, EjsType *type, int numProp)
{
    EjsFunction     *fun;

    if ((fun = ejsCreatePot(ejs, ST(Function), 0)) == 0) {
        return 0;
    }
    fun->block.pot.isFunction = 1;
    SET_DYNAMIC(fun, 1);
    return fun;
}


/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castFunction(Ejs *ejs, EjsFunction *vp, EjsType *type)
{
    switch (type->sid) {
    case S_String:
        return ejsCreateStringFromAsc(ejs, "[function Function]");

    case S_Number:
        return S(nan);

    case S_Boolean:
        return S(true);
            
    default:
        ejsThrowTypeError(ejs, "Can't cast type \"%@\"", type->qname.name);
        return 0;
    }
    return 0;
}


EjsFunction *ejsCloneFunction(Ejs *ejs, EjsFunction *src, int deep)
{
    EjsFunction     *dest;

    if ((dest = (EjsFunction*) ejsCloneBlock(ejs, &src->block, deep)) == 0) {
        return 0;
    }
    dest->body.code = src->body.code;
    dest->resultType = src->resultType;
    dest->boundArgs = src->boundArgs;
    dest->boundThis = src->boundThis;
    dest->numArgs = src->numArgs;
    dest->numDefault = src->numDefault;

    /*
        OPT
     */
    dest->staticMethod = src->staticMethod;
    dest->hasReturn = src->hasReturn;
    dest->isConstructor = src->isConstructor;
    dest->isInitializer = src->isInitializer;
    dest->isNativeProc = src->isNativeProc;
    dest->moduleInitializer = src->moduleInitializer;
    dest->rest = src->rest;
    dest->fullScope = src->fullScope;
    dest->strict = src->strict;
    dest->name = src->name;

    if (src->activation) {
        dest->activation = ejsClonePot(ejs, src->activation, 0);
    }
    mprCopyName(dest, src);
    return dest;
}


/*
    function Function(...[args], body)
 */
static EjsFunction *fun_Function(Ejs *ejs, EjsFunction *fun, int argc, void *argv)
{
#if UNUSED && FUTURE
    EjsArray        *args;
    EjsString       *str;
    MprBuf          *buf;
    cchar           *body, *param, *script;
    int             i, count;
    
    mprAssert(argc > 1);
    args = (EjsArray*) argv[1];
    mprAssert(ejsIs(ejs, args, Array));

    if (args->length <= 0) {
        ejsThrowArgError(ejs, "Missing function body");
        return 0;
    }
    str = ejsToString(ejs, args->data[args->length - 1]);
    body = ejsToMulti(ejs, str);

    buf = mprCreateBuf(ejs, -1, -1);
    mprPutStringToBuf(buf, "function(");
    count = args->length - 1;
    for (i = 0; i < count; i++) {
        str = ejsToString(ejs, args->data[i]);
        param = ejsToMulti(ejs, str);
        mprPutStringToBuf(buf, param);
        if (i < (count - 1)) {
            mprPutCharToBuf(buf, ',');
        }
        mprPutStringToBuf(buf, "\n{");
    }
    mprPutStringToBuf(buf, body);
    mprPutStringToBuf(buf, "\n}");

    script = mprGetBufStart(buf);
    if (ejsLoadScriptLiteral(ejs, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW | EC_FLAGS_VISIBLE) < 0) {
        //  TODO -- what happens to compiler errors
        return 0;
    }
    fun->body.code = ;
    fun->body.codeLen
#endif
    return fun;
}

/*
    function apply(thisObj: Object, args: Array)
 */
static EjsObj *fun_applyFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *save, *result, *thisObj;
    
    mprAssert(argc > 1);
    args = (EjsArray*) argv[1];
    mprAssert(ejsIs(ejs, args, Array));

    save = fun->boundThis;
    thisObj = argv[0];
    if (thisObj == S(null)) {
        thisObj = fun->boundThis ? fun->boundThis : ejs->global;
    }
    result =  ejsRunFunction(ejs, fun, thisObj, args->length, args->data);
    fun->boundThis = save;
    return result;
}


/*
    function bind(thisObj: Object, ...args): Void
 */
static EjsObj *fun_bindFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsAny      *thisObj;

    mprAssert(argc >= 1);

    thisObj = argv[0];
    fun->boundThis = ejsIsDefined(ejs, thisObj) ? thisObj : 0;
    if (argc == 2) {
        fun->boundArgs = (EjsArray*) argv[1];
        mprAssert(ejsIs(ejs, fun->boundArgs, Array));
    }
    return 0;
}


/*
    function get bound(): Object
 */
static EjsAny *fun_bound(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    return fun->boundThis ? fun->boundThis : S(undefined);
}


/*
    function call(thisObj, ...args)
 */
static EjsObj *fun_call(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    mprAssert(argc > 1);
    return fun_applyFunction(ejs, fun, argc, argv);
}


/*
    Return the number of required args.

    function get length(): Number
 */
static EjsNumber *fun_length(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, fun->numArgs);
}


/*
    function get name(): String
 */
static EjsString *fun_name(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    if (fun->name && fun->name->value[0] == '-') {
        return S(empty);
    }
    return fun->name;
}


/*
    function setScope(obj): Void
 */
static EjsObj *fun_setScope(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsBlock    *scope;

    scope = (EjsBlock*) argv[0];
    if (!ejsIsBlock(ejs, scope)) {
        scope = (EjsBlock*) TYPE(scope);
        if (!ejsIsBlock(ejs, scope)) {
            ejsThrowArgError(ejs, "Scope object must be a class or function");
            return 0;
        }
    }
    fun->block.scope = scope;
    return 0;
}



void ejsDisableFunction(Ejs *ejs, EjsFunction *fun)
{
    fun->block.pot.isFunction = 0;
    fun->isConstructor = 0;
    fun->isInitializer = 0;
    fun->activation = 0;
}


static void setFunctionAttributes(EjsFunction *fun, int attributes)
{
    if (attributes & EJS_FUN_CONSTRUCTOR) {
        fun->isConstructor = 1;
    }
    if (attributes & EJS_FUN_INITIALIZER) {
        fun->isInitializer = 1;
    }
    if (attributes & EJS_PROP_NATIVE) {
        fun->isNativeProc = 1;
    }
    if (attributes & EJS_FUN_MODULE_INITIALIZER) {
        fun->moduleInitializer = 1;
    }
    if (attributes & EJS_FUN_REST_ARGS) {
        fun->rest = 1;
    }
    if (attributes & EJS_PROP_STATIC) {
        fun->staticMethod = 1;
    }
    if (attributes & EJS_FUN_FULL_SCOPE) {
        fun->fullScope = 1;
    }
    if (attributes & EJS_FUN_HAS_RETURN) {
        fun->hasReturn = 1;
    }
    if (attributes & EJS_TRAIT_CAST_NULLS) {
        fun->castNulls = 1;
    }
    if (attributes & EJS_TRAIT_THROW_NULLS) {
        fun->throwNulls = 1;
    }
}


void ejsSetFunctionName(Ejs *ejs, EjsFunction *fun, EjsString *name)
{
    fun->name = name;
}


EjsEx *ejsAddException(Ejs *ejs, EjsFunction *fun, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart,
        uint handlerEnd, int numBlocks, int numStack, int flags, int preferredIndex)
{
    EjsEx           *exception;
    EjsCode         *code;
    int             size;

    mprAssert(fun);

    /* Managed by manageCode */
    if ((exception = mprAllocZeroed(sizeof(EjsEx))) == 0) {
        mprAssert(0);
        return 0;
    }
    exception->flags = flags;
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;

    code = fun->body.code;
    if (preferredIndex < 0) {
        preferredIndex = code->numHandlers++;
    }
    if (preferredIndex >= code->sizeHandlers) {
        size = code->sizeHandlers + EJS_EX_INC;
        code->handlers = mprRealloc(code->handlers, size * sizeof(EjsEx));
        if (code->handlers == 0) {
            mprAssert(0);
            return 0;
        }
        memset(&code->handlers[code->sizeHandlers], 0, EJS_EX_INC * sizeof(EjsEx)); 
        code->sizeHandlers = size;
    }
    code->handlers[preferredIndex] = exception;
    return exception;
}


void ejsOffsetExceptions(EjsFunction *fun, int offset)
{
    EjsEx           *ex;
    int             i;

    mprAssert(fun);

    for (i = 0; i < fun->body.code->numHandlers; i++) {
        ex = fun->body.code->handlers[i];
        ex->tryStart += offset;
        ex->tryEnd += offset;
        ex->handlerStart += offset;
        ex->handlerEnd += offset;
    }
}


static void manageCode(EjsCode *code, int flags)
{
    int     i;

    mprAssert(code->magic == EJS_CODE_MAGIC);

    if (flags & MPR_MANAGE_MARK) {
        mprMark(code->module);
        mprMark(code->debug);
        if (code->debug) {
            mprAssert(code->debug->magic == EJS_DEBUG_MAGIC);
        }
        if (code->handlers) {
            mprMark(code->handlers);
            for (i = 0; i < code->numHandlers; i++) {
                /* Manage EjsEx */
                mprMark(code->handlers[i]);
            }
        }
    }
}


EjsCode *ejsCreateCode(Ejs *ejs, EjsFunction *fun, EjsModule *module, cuchar *byteCode, ssize len, 
    EjsDebug *debug)
{
    EjsCode     *code;

    mprAssert(fun);
    mprAssert(module);
    mprAssert(byteCode);
    mprAssert(len >= 0);

    if ((code = mprAllocBlock(sizeof(EjsCode) + len, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(code, manageCode);
    code->codeLen = (int) len;
    code->module = module;
    code->debug = debug;
    code->magic = EJS_CODE_MAGIC;
    memcpy(code->byteCode, byteCode, len);
    return code;
}


/*
    Set the byte code for a script function
 */
int ejsSetFunctionCode(Ejs *ejs, EjsFunction *fun, EjsModule *module, cuchar *byteCode, ssize len, EjsDebug *debug)
{
    mprAssert(fun);
    mprAssert(byteCode);
    mprAssert(len >= 0);

    fun->body.code = ejsCreateCode(ejs, fun, module, byteCode, len, debug);
    return 0;
}


static EjsObj *nopFunction(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return S(undefined);
}


void ejsUseActivation(Ejs *ejs, EjsFunction *fun)
{
    EjsPot  *activation;
    int     numProp;

    if ((activation = fun->activation) == 0) {
        return;
    }
    numProp = activation->numProp;
    if (numProp > 0) {
        ejsGrowPot(ejs, (EjsPot*) fun, numProp);
        ejsCopySlots(ejs, (EjsPot*) fun, fun->block.pot.properties->slots, fun->activation->properties->slots, numProp);
        fun->block.pot.numProp = numProp;
    }
}


EjsPot *ejsCreateActivation(Ejs *ejs, EjsFunction *fun, int numProp)
{
    EjsPot  *activation;

    activation = ejsCreatePot(ejs, ST(Object), numProp);
    mprCopyName(activation, fun);
    return activation;
}



EjsFunction *ejsCreateSimpleFunction(Ejs *ejs, EjsString *name, int attributes)
{
    EjsFunction     *fun;

    if ((fun = ejsCreateObj(ejs, ST(Function), 0)) == NULL) {
        return 0;
    }
    fun->name = name;
    fun->block.pot.isBlock = 1;
    fun->block.pot.isFunction = 1;
    mprCopyName(fun, fun->name);
    setFunctionAttributes(fun, attributes);
    return fun;
}


/*
    Create a script function. This defines the method traits. It does not create a  method slot. ResultType may
    be null to indicate untyped. NOTE: untyped functions may return a result at their descretion.
 */
EjsFunction *ejsCreateFunction(Ejs *ejs, EjsString *name, cuchar *byteCode, int codeLen, int numArgs, int numDefault, 
    int numExceptions, EjsType *resultType, int attributes, EjsModule *module, EjsBlock *scope, int strict)
{
    EjsFunction     *fun;

    if ((fun = ejsCreateSimpleFunction(ejs, name, attributes)) == 0) {
        return 0;
    }
    ejsInitFunction(ejs, fun, name, byteCode, codeLen, numArgs, numDefault, numExceptions, resultType, attributes, 
        module, scope, strict);
    return fun;
}


/*
    Init function to initialize constructors inside types
 */
int ejsInitFunction(Ejs *ejs, EjsFunction *fun, EjsString *name, cuchar *byteCode, int codeLen, int numArgs, 
    int numDefault, int numExceptions, EjsType *resultType, int attributes, EjsModule *module, EjsBlock *scope, int strict)
{
    if (scope) {
        fun->block.scope = scope;
    }
    fun->block.pot.isBlock = 1;
    fun->block.pot.isFunction = 1;
    fun->numArgs = numArgs;
    fun->numDefault = numDefault;
    fun->resultType = resultType;
    fun->strict = strict;

    if (codeLen > 0) {
        fun->body.code = ejsCreateCode(ejs, fun, module, byteCode, codeLen, NULL);
        fun->body.code->numHandlers = numExceptions;
    }
    fun->name = name;
    setFunctionAttributes(fun, attributes);
    return 0;
}


void ejsManageFunction(EjsFunction *fun, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManageBlock((EjsBlock*) fun, flags);
        mprMark(fun->name);
        mprMark(fun->activation);
        mprMark(fun->setter);
        mprMark(fun->archetype);
        mprMark(fun->resultType);
        mprMark(fun->boundThis);
        mprMark(fun->boundArgs);
        if (!fun->isNativeProc) {
            mprMark(fun->body.code);
        }
    }
}


void ejsCreateFunctionType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;
    EjsFunction     *nop;

    type = ejsCreateNativeType(ejs, N("ejs", "Function"), sizeof(EjsFunction), S_Function, ES_Function_NUM_CLASS_PROP,
        ejsManageFunction, EJS_POT_HELPERS);

    helpers = &type->helpers;
    helpers->create = (EjsCreateHelper) createFunction;
    helpers->cast   = (EjsCastHelper) castFunction;
    helpers->clone  = (EjsCloneHelper) ejsCloneFunction;

    nop = ejsCreateFunction(ejs, ejsCreateStringFromAsc(ejs, "nop"), NULL, 0, -1, 0, 0, NULL, EJS_PROP_NATIVE, NULL, NULL,0);
    ejsSetSpecial(ejs, S_nop, nop);
    nop->body.proc = (EjsFun) nopFunction;
    nop->isNativeProc = 1;
}


void ejsConfigureFunctionType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Function);
    //  MOB - testing functions with immutable instances
    type->mutableInstances = 0;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, fun_Function);
    ejsBindMethod(ejs, prototype, ES_Function_apply, fun_applyFunction);
    ejsBindMethod(ejs, prototype, ES_Function_bind, fun_bindFunction);
    ejsBindMethod(ejs, prototype, ES_Function_bound, fun_bound);
    ejsBindMethod(ejs, prototype, ES_Function_call, fun_call);
    ejsBindMethod(ejs, prototype, ES_Function_length, fun_length);
    ejsBindMethod(ejs, prototype, ES_Function_name, fun_name);
    ejsBindMethod(ejs, prototype, ES_Function_setScope, fun_setScope);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsFunction.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsGC.c"
 */
/************************************************************************/

/**
    ejsGC.c - Garbage collector class for the EJS Object Model

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    native static function get enabled(): Boolean
 */
static EjsBoolean *gc_enabled(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return ((mprGetMpr()->heap.enabled) ? S(true): S(false));
}


/*
    native static function set enabled(on: Boolean): Void
 */
static EjsObj *gc_set_enabled(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Boolean));
    mprGetMpr()->heap.enabled = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    run(deep: Boolean = false)
    TODO -- change args to be a string "check", "all"
 */
static EjsObj *gc_run(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     deep;

    mprAssert(!ejs->state->frozen);
    
    if (!ejs->state->frozen) {
        deep = ((argc == 1) && ejsIs(ejs, argv[1], Boolean));
        mprRequestGC(MPR_FORCE_GC | (deep ? MPR_COMPLETE_GC : 0));
    }
    return 0;
}


/*
    native static function get newQuota(): Number
 */
static EjsNumber *gc_newQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetMpr()->heap.newQuota);
}


/*
    native static function set newQuota(quota: Number): Void
 */
static EjsObj *gc_set_newQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     quota;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
    quota = ejsGetInt(ejs, argv[0]);

    if (quota < MPR_NEW_QUOTA && quota != 0) {
        ejsThrowArgError(ejs, "Bad work quota");
        return 0;
    }
    mprGetMpr()->heap.newQuota = quota;
    return 0;
}


/*
    verify(): Void
 */
static EjsObj *gc_verify(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    mprVerifyMem();
    return 0;
}


void ejsConfigureGCType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, N("ejs", "GC"))) == 0) {
        mprError("Can't find GC type");
        return;
    }
    ejsBindAccess(ejs, type, ES_GC_enabled, gc_enabled, gc_set_enabled);
    ejsBindAccess(ejs, type, ES_GC_newQuota, gc_newQuota, gc_set_newQuota);
    ejsBindMethod(ejs, type, ES_GC_run, gc_run);
    ejsBindMethod(ejs, type, ES_GC_verify, gc_verify);
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsGC.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsGlobal.c"
 */
/************************************************************************/

/**
    ejsGlobal.c - Global functions and variables

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*  
    Assert a condition is true.
    static function assert(condition: Boolean): Boolean
 */
static EjsBoolean *g_assert(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsFrame        *fp;
    MprChar         *source;
    EjsBoolean      *b;

    mprAssert(argc == 1);

    if (!ejsIs(ejs, argv[0], Boolean)) {
        b = (EjsBoolean*) ejsCast(ejs, argv[0], Boolean);
    } else {
        b = (EjsBoolean*) argv[0];
    }
    mprAssert(b);

    if (b == 0 || !b->value) {
        fp = ejs->state->fp;
        if (ejsGetDebugInfo(ejs, (EjsFunction*) fp, fp->pc, NULL, NULL, &source) >= 0) {
            ejsThrowAssertError(ejs, "%w", source);
        } else {
            ejsThrowAssertError(ejs, "Assertion error");
        }
        return 0;
    }
    return S(true);
}


/*  
    function blend(dest: Object, src: Object, overwrite: Boolean = true): void
 */
static EjsObj *g_blend(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *src, *dest;
    int         overwrite;

    overwrite = (argc == 3) ? (argv[2] == S(true)) : 1;
    dest = argv[0];
    src = argv[1];
    ejsBlendObject(ejs, dest, src, overwrite);
    return dest;
}


/*  
    Clone the base class. Used by Record.es
    static function cloneBase(klass: Type): Void
 */
static EjsObj *g_cloneBase(Ejs *ejs, EjsObj *ignored, int argc, EjsObj **argv)
{
    EjsType     *type;
    
    mprAssert(argc == 1);
    
    type = (EjsType*) argv[0];
    type->baseType = ejsClone(ejs, type->baseType, 0);
    return 0;
}


/*  
    function eval(script: String, cache: String = null): String
 */
static EjsObj *g_eval(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *script;
    cchar       *cache;

    script = (EjsString*) argv[0];
    if (argc < 2 || ejsIs(ejs, argv[1], Null)) {
        cache = NULL;
    } else {
        cache = ejsToMulti(ejs, argv[1]);
    }
    MPR_VERIFY_MEM();
    if (ejsLoadScriptLiteral(ejs, script, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW | EC_FLAGS_VISIBLE) < 0) {
        return 0;
    }
    MPR_VERIFY_MEM();
    return ejs->result;
}


#if ES_hashcode
/*  
    Get the hash code for the object.
    function hashcode(o: Object): Number
 */
static EjsNumber *g_hashcode(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1);
    return ejsCreateNumber(ejs, (MprNumber) PTOL(argv[0]));
}
#endif


/*  
    Load a script or module. Name should have an extension. Name will be located according to the EJSPATH search strategy.
    static function load(filename: String, cache: String): void
 */
static EjsObj *g_load(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar       *path, *cache, *cp;

    MPR_VERIFY_MEM();

    path = ejsToMulti(ejs, argv[0]);
    cache = (argc < 2) ? 0 : ejsToMulti(ejs, argv[1]);

    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
        } else {
            return (ejs->service->loadScriptFile)(ejs, path, cache);
        }
    } else {
        ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, EJS_LOADER_RELOAD);
        return (ejs->exception) ? 0 : ejs->result;
    }
    return 0;
}


/*  
    Compute an MD5 checksum
    static function md5(name: String): String
 */
static EjsString *g_md5(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;
    char        *hash;

    MPR_VERIFY_MEM();
    str = (EjsString*) argv[0];
    hash = mprGetMD5Hash(ejsToMulti(ejs, str), str->length, NULL);
    return ejsCreateStringFromAsc(ejs, hash);
}


/*  
    Merge one object into another. This is useful for inheriting and optionally overwriting option hashes (among other
    things). The blending is done at the primitive property level. If overwrite is true, the property is replaced. If
    overwrite is false, the property will be added if it does not already exist
 */
int ejsBlendObject(Ejs *ejs, EjsObj *dest, EjsObj *src, int overwrite)
{
    EjsObj      *vp, *dp;
    EjsName     name;
    int         i, count;

    count = ejsGetPropertyCount(ejs, src);
    for (i = 0; i < count; i++) {
        vp = ejsGetProperty(ejs, src, i);
        if (vp == 0) {
            continue;
        }
        name = ejsGetPropertyName(ejs, src, i);
        /* NOTE: treats arrays as primitive types */
        if (!ejsIs(ejs, vp, Array) && !ejsIsXML(ejs, vp) && ejsGetPropertyCount(ejs, vp) > 0) {
            if ((dp = ejsGetPropertyByName(ejs, dest, name)) == 0 || ejsGetPropertyCount(ejs, dp) == 0) {
                ejsSetPropertyByName(ejs, dest, name, ejsClonePot(ejs, vp, 1));
            } else {
                ejsBlendObject(ejs, dp, vp, overwrite);
            }
        } else {
            /* Primitive type (including arrays) */
            if (overwrite) {
                ejsSetPropertyByName(ejs, dest, name, vp);
            } else {
                if (ejsLookupProperty(ejs, dest, name) < 0) {
                    ejsSetPropertyByName(ejs, dest, name, vp);
                }
            }
        }
    }
    return 0;
}


/*     
    Parse the input and convert to a primitive type
    static function parse(input: String, preferredType: Type = null): void
 */
static EjsObj *g_parse(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *input;
    int         preferred;

    input = (EjsString*) argv[0];
    if (argc == 2 && !ejsIsType(ejs, argv[1])) {
        ejsThrowArgError(ejs, "PreferredType argument is not a type");
        return 0;
    }
    preferred = (argc == 2) ? ((EjsType*) argv[1])->sid : -1;
    return ejsParse(ejs, input->value, preferred);
}


/*
    Parse the input as an integer
    static function parseInt(input: String, radix: Number = 10): Number
    Formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
 */
static EjsNumber *g_parseInt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;
    cchar       *str;
    int         radix, err;

    str = ejsToMulti(ejs, argv[0]);
    radix = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    while (isspace((int) *str)) {
        str++;
    }
    if (*str == '-' || *str == '+' || isdigit((int) *str)) {
        n = (MprNumber) stoi(str, radix, &err);
        if (err) {
            return S(nan);
        }
        return ejsCreateNumber(ejs, n);
    }
    return S(nan);
}


/*  
    Print the arguments to the standard output with a new line.
    static function print(...args): void
    DEPRECATED static function output(...args): void
 */
static EjsObj *g_printLine(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *s;
    EjsObj      *args, *vp;
    cchar       *data;
    ssize       rc;
    int         i, count;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = argv[0];
    count = ejsGetPropertyCount(ejs, args);

    for (i = 0; i < count; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) != 0) {
            s  = (ejsIs(ejs, vp, String)) ? (EjsString*) vp : (EjsString*) ejsToString(ejs, vp);
            if (ejs->exception) {
                return 0;
            }
            data = ejsToMulti(ejs, s);
            rc = write(1, (char*) data, (int) strlen(data));
            if ((i+1) < count) {
                rc = write(1, " ", 1);
            }
        }
    }
    rc = write(1, "\n", 1);
    return 0;
}


void ejsFreezeGlobal(Ejs *ejs)
{
    EjsTrait    *trait;
    int         i;

    for (i = 0; i < ES_global_NUM_CLASS_PROP; i++) {
        if ((trait = ejsGetPropertyTraits(ejs, ejs->global, i)) != 0) {
            ejsSetPropertyTraits(ejs, ejs->global, i, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
        }
    }
}


void ejsCreateGlobalBlock(Ejs *ejs)
{
    EjsBlock    *block;
    int         sizeSlots;

    sizeSlots = (ejs->empty) ? 0 : max(ES_global_NUM_CLASS_PROP, EJS_NUM_GLOBAL);
    block = ejsCreateBlock(ejs, sizeSlots);
    ejs->global = block;
    block->isGlobal = 1;
    block->pot.numProp = (ejs->empty) ? 0: ES_global_NUM_CLASS_PROP;
    block->pot.shortScope = 1;
    SET_DYNAMIC(block, 1);
    mprSetName(block, "global");

    /*  
        Create the standard namespaces. Order matters here. This is the (reverse) order of lookup.
        Empty is first to maximize speed of searching dynamic properties. Ejs second to maximize builtin lookups.
     */
    ejsSetSpecial(ejs, S_iteratorSpace, ejsDefineReservedNamespace(ejs, block, NULL, EJS_ITERATOR_NAMESPACE));
    ejsSetSpecial(ejs, S_publicSpace, ejsDefineReservedNamespace(ejs, block, NULL, EJS_PUBLIC_NAMESPACE));
    ejsSetSpecial(ejs, S_ejsSpace, ejsDefineReservedNamespace(ejs, block, NULL, EJS_EJS_NAMESPACE));
    ejsSetSpecial(ejs, S_emptySpace, ejsDefineReservedNamespace(ejs, block, NULL, EJS_EMPTY_NAMESPACE));
}


void ejsConfigureGlobalBlock(Ejs *ejs)
{
    EjsBlock    *block;

    block = (EjsBlock*) ejs->global;
    mprAssert(block);
    
    ejsBindFunction(ejs, block, ES_assert, g_assert);
    ejsBindFunction(ejs, block, ES_cloneBase, g_cloneBase);
    ejsBindFunction(ejs, block, ES_eval, g_eval);
    ejsBindFunction(ejs, block, ES_hashcode, g_hashcode);
    ejsBindFunction(ejs, block, ES_load, g_load);
    ejsBindFunction(ejs, block, ES_md5, g_md5);
    ejsBindFunction(ejs, block, ES_blend, g_blend);
    ejsBindFunction(ejs, block, ES_parse, g_parse);
    ejsBindFunction(ejs, block, ES_parseInt, g_parseInt);
    ejsBindFunction(ejs, block, ES_print, g_printLine);

    ejsSetProperty(ejs, ejs->global, ES_global, ejs->global);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsGlobal.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsHttp.c"
 */
/************************************************************************/

/**
    ejsHttp.c - Http client class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsDate  *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static EjsString *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static void     httpIOEvent(HttpConn *conn, MprEvent *event);
static void     httpNotify(HttpConn *conn, int state, int notifyFlags);
static void     prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data);
static ssize    readHttpData(Ejs *ejs, EjsHttp *hp, ssize count);
static void     sendHttpCloseEvent(Ejs *ejs, EjsHttp *hp);
static void     sendHttpErrorEvent(Ejs *ejs, EjsHttp *hp);
static EjsObj   *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv);
static bool     waitForResponseHeaders(EjsHttp *hp, int timeout);
static bool     waitForState(EjsHttp *hp, int state, int timeout, int throw);
static ssize    writeHttpData(Ejs *ejs, EjsHttp *hp);

/*  
    function Http(uri: Uri = null)
 */
static EjsHttp *httpConstructor(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsLoadHttpService(ejs);
    hp->ejs = ejs;

    if ((hp->conn = httpCreateConn(ejs->http, NULL, ejs->dispatcher)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    httpPrepClientConn(hp->conn, 0);
    httpSetConnNotifier(hp->conn, httpNotify);
    httpSetConnContext(hp->conn, hp);
    if (argc == 1 && ejsIs(ejs, argv[0], Null)) {
        hp->uri = httpUriToString(((EjsUri*) argv[0])->uri, 1);
    }
    hp->method = sclone("GET");
    hp->requestContent = mprCreateBuf(HTTP_BUFSIZE, -1);
    hp->responseContent = mprCreateBuf(HTTP_BUFSIZE, -1);
    return hp;
}


/*  
    function get async(): Boolean
 */
static EjsBoolean *http_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return httpGetAsync(hp->conn) ? S(true) : S(false);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *http_set_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    int         async;

    conn = hp->conn;
    async = (argv[0] == S(true));
    httpSetAsync(conn, async);
    httpSetIOCallback(conn, httpIOEvent);
    return 0;
}


#if ES_Http_available
/*  
    function get available(): Number
    DEPRECATED 1.0.0B3 (11/09)
 */
static EjsNumber *http_available(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprOff      len;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    len = httpGetContentLength(hp->conn);
    if (len > 0) {
        return ejsCreateNumber(ejs, (MprNumber) len);
    }
    return (EjsNumber*) S(minusOne);
}
#endif


/*  
    function close(): Void
 */
static EjsObj *http_close(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn) {
        httpFinalize(hp->conn);
        sendHttpCloseEvent(ejs, hp);
        httpDestroyConn(hp->conn);
        hp->conn = httpCreateConn(ejs->http, NULL, ejs->dispatcher);
        httpPrepClientConn(hp->conn, 0);
        httpSetConnNotifier(hp->conn, httpNotify);
        httpSetConnContext(hp->conn, hp);
    }
    return 0;
}


/*  
    function connect(method: String, url = null, data ...): Void
 */
static EjsObj *http_connect(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->method = ejsToMulti(ejs, argv[0]);
    return startHttpRequest(ejs, hp, NULL, argc - 1, &argv[1]);
}


/*  
    function get certificate(): String
 */
static EjsString *http_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->certFile) {
        return ejsCreateStringFromAsc(ejs, hp->certFile);
    }
    return S(null);
}


/*  
    function set setCertificate(value: String): Void
 */
static EjsObj *http_set_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->certFile = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get contentLength(): Number
 */
static EjsNumber *http_contentLength(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprOff      length;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    length = httpGetContentLength(hp->conn);
    return ejsCreateNumber(ejs, (MprNumber) length);
}


/*  
    function get contentType(): String
 */
static EjsString *http_contentType(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getStringHeader(ejs, hp, "CONTENT-TYPE");
}


/*  
    function get date(): Date
 */
static EjsDate *http_date(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "DATE");
}


/*  
    function finalize(): Void
 */
static EjsObj *http_finalize(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn) {
        httpFinalize(hp->conn);
    }
    return 0;
}


/*  
    function get finalized(): Boolean
 */
static EjsBoolean *http_finalized(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn && hp->conn->tx) {
        return ejsCreateBoolean(ejs, hp->conn->tx->finalized);
    }
    return S(false);
}


/*  
    function flush(dir: Number = Stream.WRITE): Void
 */
static EjsObj *http_flush(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     dir;

    dir = (argc == 1) ? ejsGetInt(ejs, argv[0]) : EJS_STREAM_WRITE;
    if (dir & EJS_STREAM_WRITE) {
        httpFlush(hp->conn);
    }
    return 0;
}


/*  
    function form(uri: String = null, formData: Object = null): Void
    Issue a POST method with form data
 */
static EjsObj *http_form(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsObj  *data;

    if (argc == 2 && !ejsIs(ejs, argv[1], Null)) {
        /*
            Prep here to reset the state. The ensures the current headers will be preserved.
            Users may have called setHeader to define custom headers. Users must call reset if they want to clear 
            prior headers.
         */
        httpPrepClientConn(hp->conn, 1);
        mprFlushBuf(hp->requestContent);
        data = argv[1];
        if (ejsGetPropertyCount(ejs, data) > 0) {
            prepForm(ejs, hp, NULL, data);
        } else {
            mprPutStringToBuf(hp->requestContent, ejsToMulti(ejs, data));
        }
        mprAddNullToBuf(hp->requestContent);
        httpSetHeader(hp->conn, "Content-Type", "application/x-www-form-urlencoded");
        /* Ensure this gets recomputed */
        httpRemoveHeader(hp->conn, "Content-Length");
    }
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*  
    function get followRedirects(): Boolean
 */
static EjsBoolean *http_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, hp->conn->followRedirects);
}


/*  
    function set followRedirects(flag: Boolean): Void
 */
static EjsObj *http_set_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpFollowRedirects(hp->conn, ejsGetBoolean(ejs, argv[0]));
    return 0;
}


/*  
    function get(uri: String = null, ...data): Void
    The spec allows GET methods to have body data, but is rarely, if ever, used.
 */
static EjsObj *http_get(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    startHttpRequest(ejs, hp, "GET", argc, argv);
    if (hp->conn) {
        httpFinalize(hp->conn);
    }
    return 0;
}


/*  
    Return the (proposed) request headers
    function getRequestHeaders(): Object
 */
static EjsPot *http_getRequestHeaders(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprHash         *p;
    HttpConn        *conn;
    EjsPot          *headers;

    conn = hp->conn;
    headers = ejsCreateEmptyPot(ejs);
    for (p = 0; conn->tx && (p = mprGetNextHash(conn->tx->headers, p)) != 0; ) {
        ejsSetPropertyByName(ejs, headers, EN(p->key), ejsCreateStringFromAsc(ejs, p->data));
    }
    return headers;
}


/*  
    function head(uri: String = null): Void
 */
static EjsObj *http_head(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "HEAD", argc, argv);
}


/*  
    function header(key: String): String
 */
static EjsString *http_header(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsString   *result;
    cchar       *value;
    char        *str;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    str = slower(ejsToMulti(ejs, argv[0]));
    value = httpGetHeader(hp->conn, str);
    if (value) {
        result = ejsCreateStringFromAsc(ejs, value);
    } else {
        result = S(null);
    }
    return result;
}


/*  
    function get headers(): Object
 */
static EjsPot *http_headers(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprHashTable    *hash;
    MprHash         *p;
    EjsPot          *results;
    int             i;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    results = ejsCreateEmptyPot(ejs);
    hash = httpGetHeaderHash(hp->conn);
    if (hash == 0) {
        return results;
    }
    for (i = 0, p = mprGetFirstHash(hash); p; p = mprGetNextHash(hash, p), i++) {
        ejsSetPropertyByName(ejs, results, EN(p->key), ejsCreateStringFromAsc(ejs, p->data));
    }
    return results;
}


/*  
    function get isSecure(): Boolean
 */
static EjsBoolean *http_isSecure(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, hp->conn->secure);
}


/*  
    function get key(): String
 */
static EjsAny *http_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->keyFile) {
        return ejsCreateStringFromAsc(ejs, hp->keyFile);
    }
    return S(null);
}


/*  
    function set key(keyFile: String): Void
 */
static EjsObj *http_set_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->keyFile = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get lastModified(): Date
 */
static EjsDate *http_lastModified(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "LAST-MODIFIED");
}


/*
    function get limits(): Object
 */
static EjsObj *http_limits(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->limits == 0) {
        hp->limits = (EjsObj*) ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, hp->limits, hp->conn->limits, 0);
    }
    return hp->limits;
}


/*  
    function get method(): String
 */
static EjsString *http_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, hp->method);
}


/*  
    function set method(value: String): Void
 */
static EjsObj *http_set_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar    *method;

    method = ejsToMulti(ejs, argv[0]);
    if (strcmp(method, "DELETE") != 0 && strcmp(method, "GET") != 0 &&  strcmp(method, "HEAD") != 0 &&
            strcmp(method, "OPTIONS") != 0 && strcmp(method, "POST") != 0 && strcmp(method, "PUT") != 0 &&
            strcmp(method, "TRACE") != 0) {
        ejsThrowArgError(ejs, "Unknown HTTP method");
        return 0;
    }
    hp->method = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function off(name, observer: function): Void
 */
static EjsObj *http_off(Ejs *ejs, EjsHttp *hp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, hp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name, observer: function): Void
 */
static EjsObj *http_on(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsFunction     *observer;
    HttpConn        *conn;

    observer = (EjsFunction*) argv[1];
    if (observer->boundThis == 0 || observer->boundThis == ejs->global) {
        observer->boundThis = hp;
    }
    ejsAddObserver(ejs, &hp->emitter, argv[0], observer);

    conn = hp->conn;
    if (conn->readq && conn->readq->count > 0) {
        ejsSendEvent(ejs, hp->emitter, "readable", NULL, hp);
    }
    if (!conn->writeComplete && !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_COMPLETE &&
            conn->writeq->ioCount == 0) {
        ejsSendEvent(ejs, hp->emitter, "writable", NULL, hp);
    }
    return 0;
}


/*  
    function post(uri: String = null, ...requestContent): Void
 */
static EjsObj *http_post(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*  
    function put(uri: String = null, form object): Void
 */
static EjsObj *http_put(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "PUT", argc, argv);
}


/*  
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
    Returns a count of bytes read. Non-blocking if a callback is defined. Otherwise, blocks.
 */
static EjsNumber *http_read(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    HttpConn        *conn;
    MprOff          contentLength;
    ssize           offset, count;

    conn = hp->conn;
    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    contentLength = httpGetContentLength(conn);
    if (conn->state >= HTTP_STATE_PARSED && contentLength == hp->readCount) {
        /* End of input */
        return S(null);
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        ejsSetByteArrayPositions(ejs, buffer, 0, 0);
    }
    if ((count = readHttpData(ejs, hp, count)) < 0) {
        mprAssert(ejs->exception);
        return 0;
    } 
    hp->readCount += count;
    ejsCopyToByteArray(ejs, buffer, buffer->writePosition, (char*) mprGetBufStart(hp->responseContent), count);
    ejsSetByteArrayPositions(ejs, buffer, -1, buffer->writePosition + count);
    mprAdjustBufStart(hp->responseContent, count);
    mprResetBufIfEmpty(hp->responseContent);
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*  
    function readString(count: Number = -1): String
    Read count bytes (default all) of content as a string. This always starts at the first character of content.
 */
static EjsString *http_readString(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsString   *result;
    HttpConn    *conn;
    ssize       count;
    int         timeout;
    
    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;
    conn = hp->conn;

    if (conn->async) {
        timeout = 0;
    } else {
        timeout = conn->limits->inactivityTimeout;
        if (timeout <= 0) {
            timeout = MAXINT;
        }
    }
    if (!waitForState(hp, HTTP_STATE_CONTENT, timeout, 1)) {
        return 0;
    }
    if ((count = readHttpData(ejs, hp, count)) < 0) {
        mprAssert(ejs->exception);
        return 0;
    }
    //  UNICODE ENCODING
    result = ejsCreateStringFromMulti(ejs, mprGetBufStart(hp->responseContent), count);
    mprAdjustBufStart(hp->responseContent, count);
    mprResetBufIfEmpty(hp->responseContent);
    return result;
}


/*  
    function reset(): Void
 */
static EjsObj *http_reset(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpResetCredentials(hp->conn);
    httpPrepClientConn(hp->conn, 0);
    return 0;
}


/*  
    function get response(): String
 */
static EjsString *http_response(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->responseCache) {
        return hp->responseCache;
    }
    hp->responseCache = http_readString(ejs, hp, argc, argv);
    return hp->responseCache;
}


/*  
    function set response(data: String): Void
 */
static EjsObj *http_set_response(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->responseCache = (EjsString*) argv[0];
    return 0;
}


/*  
    function get retries(): Number
 */
static EjsNumber *http_retries(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, hp->conn->retries);
}


/*  
    function set retries(count: Number): Void
 */
static EjsObj *http_set_retries(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpSetRetries(hp->conn, ejsGetInt(ejs, argv[0]));
    return 0;
}


/*  
    function setCredentials(username: String, password: String): Void
 */
static EjsObj *http_setCredentials(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (ejsIs(ejs, argv[0], Null)) {
        httpResetCredentials(hp->conn);
    } else {
        httpSetCredentials(hp->conn, ejsToMulti(ejs, argv[0]), ejsToMulti(ejs, argv[1]));
    }
    return 0;
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
static EjsObj *http_setHeader(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    cchar       *key, *value;
    bool        overwrite;

    mprAssert(argc >= 2);

    conn = hp->conn;
    if (conn->state >= HTTP_STATE_CONNECTED) {
        ejsThrowArgError(ejs, "Can't update request headers once the request has started");
        return 0;
    }
    key = ejsToMulti(ejs, argv[0]);
    value = ejsToMulti(ejs, argv[1]);
    overwrite = (argc == 3) ? ejsGetBoolean(ejs, argv[2]) : 1;
    if (overwrite) {
        httpSetHeaderString(hp->conn, key, value);
    } else {
        httpAppendHeaderString(hp->conn, key, value);
    }
    return 0;
}


/*  
    function set limits(limits: Object): Void
 */
static EjsObj *http_setLimits(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn->limits == ejs->http->clientLimits) {
        httpSetUniqueConnLimits(hp->conn);
    }
    if (hp->limits == 0) {
        hp->limits = (EjsObj*) ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, hp->limits, hp->conn->limits, 0);
    }
    ejsBlendObject(ejs, hp->limits, argv[0], 1);
    ejsSetHttpLimits(ejs, hp->conn->limits, hp->limits, 0);
    return 0;
}


static int getNumOption(Ejs *ejs, EjsObj *options, cchar *field)
{
    EjsObj      *obj;

    if ((obj = ejsGetPropertyByName(ejs, options, EN(field))) != 0) {
        return ejsGetInt(ejs, obj);
    }
    return -1;
}


static void setupTrace(Ejs *ejs, HttpTrace *trace, int dir, EjsObj *options)
{
    EjsArray    *extensions;
    EjsObj      *ext;
    HttpTrace   *tp;
    int         i, level, *levels;

    tp = &trace[dir];
    levels = tp->levels;
    if ((level = getNumOption(ejs, options, "all")) >= 0) {
        for (i = 0; i < HTTP_TRACE_MAX_ITEM; i++) {
            levels[i] = level;
        }
    } else {
        levels[HTTP_TRACE_CONN] = getNumOption(ejs, options, "conn");
        levels[HTTP_TRACE_FIRST] = getNumOption(ejs, options, "first");
        levels[HTTP_TRACE_HEADER] = getNumOption(ejs, options, "headers");
        levels[HTTP_TRACE_BODY] = getNumOption(ejs, options, "body");
    }
    tp->size = getNumOption(ejs, options, "size");
    if ((extensions = (EjsArray*) ejsGetPropertyByName(ejs, options, EN("include"))) != 0) {
        if (!ejsIs(ejs, extensions, Array)) {
            ejsThrowArgError(ejs, "include is not an array");
            return;
        }
        tp->include = mprCreateHash(0, 0);
        for (i = 0; i < extensions->length; i++) {
            if ((ext = ejsGetProperty(ejs, extensions, i)) != 0) {
                mprAddKey(tp->include, ejsToMulti(ejs, ejsToString(ejs, ext)), "");
            }
        }
    }
    if ((extensions = (EjsArray*) ejsGetPropertyByName(ejs, options, EN("exclude"))) != 0) {
        if (!ejsIs(ejs, extensions, Array)) {
            ejsThrowArgError(ejs, "exclude is not an array");
            return;
        }
        tp->exclude = mprCreateHash(0, 0);
        for (i = 0; i < extensions->length; i++) {
            if ((ext = ejsGetProperty(ejs, extensions, i)) != 0) {
                mprAddKey(tp->exclude, ejsToMulti(ejs, ejsToString(ejs, ext)), MPR->emptyString);
            }
        }
    }
}


int ejsSetupTrace(Ejs *ejs, HttpTrace *trace, EjsObj *options)
{
    EjsObj      *rx, *tx;

    if ((rx = ejsGetPropertyByName(ejs, options, EN("rx"))) != 0) {
        setupTrace(ejs, trace, HTTP_TRACE_RX, rx);
    }
    if ((tx = ejsGetPropertyByName(ejs, options, EN("tx"))) != 0) {
        setupTrace(ejs, trace, HTTP_TRACE_TX, tx);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *http_trace(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsSetupTrace(ejs, hp->conn->trace, argv[0]);
    return 0;
}


/*  
    function get uri(): Uri
 */
static EjsUri *http_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateUriFromMulti(ejs, hp->uri);
}


/*  
    function set uri(newUri: Uri): Void
 */
static EjsObj *http_set_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->uri = httpUriToString(((EjsUri*) argv[0])->uri, 1);
    return 0;
}


/*  
    function get status(): Number
 */
static EjsNumber *http_status(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     code;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    code = httpGetStatus(hp->conn);
    if (code <= 0) {
        return S(null);
    }
    return ejsCreateNumber(ejs, code);
}


/*  
    function get statusMessage(): String
 */
static EjsString *http_statusMessage(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    conn = hp->conn;
    if (conn->errorMsg) {
        return ejsCreateStringFromAsc(ejs, conn->errorMsg);
    }
    return ejsCreateStringFromAsc(ejs, httpGetStatusMessage(hp->conn));
}


/*  
    Wait for a request to complete. Timeout is in msec.

    function wait(timeout: Number = -1): Boolean
 */
static EjsBoolean *http_wait(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprTime     mark;
    int         timeout;

    timeout = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (timeout < 0) {
        timeout = hp->conn->limits->requestTimeout;
        if (timeout == 0) {
            timeout = MAXINT;
        }
    }
    mark = mprGetTime();
    if (!waitForState(hp, HTTP_STATE_COMPLETE, timeout, 0)) {
        return S(false);
    }
    return S(true);
}


/*
    function write(...data): Void
 */
static EjsNumber *http_write(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ssize     nbytes;

    hp->data = ejsCreateByteArray(ejs, -1);
    if (ejsWriteToByteArray(ejs, hp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeHttpData(ejs, hp)) < 0) {
        return 0;
    }
    hp->writeCount += nbytes;
    if (hp->conn->async) {
        if (ejsGetByteArrayAvailable(hp->data) > 0) {
            httpEnableConnEvents(hp->conn);
        }
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*
    function [get|put|delete|post...](uri = null, ...data): Void
 */
static EjsObj *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *data;
    EjsNumber       *written;
    EjsUri          *uriObj;
    HttpConn        *conn;
    ssize           nbytes;

    conn = hp->conn;
    hp->responseCache = 0;
    hp->requestContentCount = 0;
    mprFlushBuf(hp->responseContent);

    if (argc >= 1 && !ejsIs(ejs, argv[0], Null)) {
        uriObj = (EjsUri*) argv[0];
        hp->uri = httpUriToString(uriObj->uri, 1);
    }
    if (argc == 2 && ejsIs(ejs, argv[1], Array)) {
        args = (EjsArray*) argv[1];
        if (args->length > 0) {
            data = ejsCreateByteArray(ejs, -1);
            written = ejsWriteToByteArray(ejs, data, 1, &argv[1]);
            mprPutBlockToBuf(hp->requestContent, (char*) data->value, (int) written->value);
            mprAddNullToBuf(hp->requestContent);
            mprAssert(written > 0);
        }
    }
    if (hp->uri == 0) {
        ejsThrowArgError(ejs, "URL is not defined");
        return 0;
    }
    if (method && strcmp(hp->method, method) != 0) {
        hp->method = sclone(method);
    }
    if (hp->method == 0) {
        ejsThrowArgError(ejs, "HTTP Method is not defined");
        return 0;
    }
    if (httpConnect(conn, hp->method, hp->uri) < 0) {
        ejsThrowIOError(ejs, "Can't issue request for \"%s\"", hp->uri);
        return 0;
    }
    if (mprGetBufLength(hp->requestContent) > 0) {
        nbytes = httpWriteBlock(conn->writeq, mprGetBufStart(hp->requestContent), mprGetBufLength(hp->requestContent));
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write request data for \"%s\"", hp->uri);
            return 0;
        } else if (nbytes > 0) {
            mprAdjustBufStart(hp->requestContent, nbytes);
            hp->requestContentCount += nbytes;
        }
        httpFinalize(conn);
    }
    ejsSendEvent(ejs, hp->emitter, "writable", NULL, hp);
    if (conn->async) {
        httpEnableConnEvents(hp->conn);
    }
    return 0;
}


static void httpNotify(HttpConn *conn, int state, int notifyFlags)
{
    Ejs         *ejs;
    EjsHttp     *hp;

    hp = httpGetConnContext(conn);
    ejs = hp->ejs;

    switch (state) {
    case HTTP_STATE_BEGIN:
        break;

    case HTTP_STATE_PARSED:
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "headers", NULL, hp);
        }
        break;

    case HTTP_STATE_CONTENT:
    case HTTP_STATE_RUNNING:
        break;

    case HTTP_STATE_COMPLETE:
        if (hp->emitter) {
            if (conn->error) {
                sendHttpErrorEvent(ejs, hp);
            }
            sendHttpCloseEvent(ejs, hp);
        }
        break;

    case 0:
        if (hp && hp->emitter) {
            if (notifyFlags & HTTP_NOTIFY_READABLE) {
                ejsSendEvent(ejs, hp->emitter, "readable", NULL, hp);
            } 
            if (notifyFlags & HTTP_NOTIFY_WRITABLE) {
                ejsSendEvent(ejs, hp->emitter, "writable", NULL, hp);
            }
        }
        break;
    }
}


/*  
    Read the required number of bytes into the response content buffer. Count < 0 means transfer the entire content.
    Returns the number of bytes read.
 */ 
static ssize readHttpData(Ejs *ejs, EjsHttp *hp, ssize count)
{
    MprBuf      *buf;
    HttpConn    *conn;
    ssize       len, space, nbytes;

    conn = hp->conn;

    buf = hp->responseContent;
    mprResetBufIfEmpty(buf);
    while (count < 0 || mprGetBufLength(buf) < count) {
        len = (count < 0) ? HTTP_BUFSIZE : (count - mprGetBufLength(buf));
        space = mprGetBufSpace(buf);
        if (space < len) {
            mprGrowBuf(buf, len - space);
        }
        if ((nbytes = httpRead(conn, mprGetBufEnd(buf), len)) < 0) {
            ejsThrowIOError(ejs, "Can't read required data");
            return MPR_ERR_CANT_READ;
        }
        mprAdjustBufEnd(buf, nbytes);
        if (hp->conn->async || (nbytes == 0 && conn->state >= HTTP_STATE_COMPLETE)) {
            break;
        }
    }
    if (count < 0) {
        return mprGetBufLength(buf);
    }
    return min(count, mprGetBufLength(buf));
}


/* 
    Write another block of data
 */
static ssize writeHttpData(Ejs *ejs, EjsHttp *hp)
{
    EjsByteArray    *ba;
    HttpConn        *conn;
    ssize           count, nbytes;

    conn = hp->conn;
    ba = hp->data;
    nbytes = 0;
    if (ba && (count = ejsGetByteArrayAvailable(ba)) > 0) {
        if (conn->tx->finalized) {
            ejsThrowIOError(ejs, "Can't write to socket");
            return 0;
        }
        nbytes = httpWriteBlock(conn->writeq, (cchar*) &ba->value[ba->readPosition], count);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    httpServiceQueues(conn);
    return nbytes;
}


/*  
    Respond to an IO event. This wraps the standard httpEvent() call.
 */
static void httpIOEvent(HttpConn *conn, MprEvent *event)
{
    EjsHttp     *hp;
    Ejs         *ejs;

    mprAssert(conn->async);

    hp = conn->context;
    ejs = hp->ejs;

    httpEvent(conn, event);
    if (event->mask & MPR_WRITABLE) {
        if (hp->data) {
            writeHttpData(ejs, hp);
        }
    }
}


static EjsDate *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    MprTime     when;
    cchar       *value;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return S(null);
    }
    if (mprParseTime(&when, value, MPR_UTC_TIMEZONE, NULL) < 0) {
        value = 0;
    }
    return ejsCreateDate(ejs, when);
}


static EjsString *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    cchar       *value;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return S(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


/*  
    Prepare form data as a series of key-value pairs. Data is formatted according to www-url-encoded specs by 
    mprSetHttpFormData. Objects are flattened into a one level key/value pairs. Keys can have embedded "." separators.
    E.g.  name=value&address=77%20Park%20Lane
 */
static void prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsString   *value;
    cchar       *key, *sep, *vstr;
    char        *encodedKey, *encodedValue, *newPrefix, *newKey;
    int         i, count;

    count = ejsGetPropertyCount(ejs, data);
    for (i = 0; i < count; i++) {
        qname = ejsGetPropertyName(ejs, data, i);

        vp = ejsGetProperty(ejs, data, i);
        if (vp == 0) {
            continue;
        }
        if (ejsGetPropertyCount(ejs, vp) > 0 && !ejsIs(ejs, vp, Array)) {
            if (prefix) {
                newPrefix = mprAsprintf("%s.%@", prefix, qname.name);
                prepForm(ejs, hp, newPrefix, vp);
            } else {
                prepForm(ejs, hp, (char*) qname.name->value, vp);
            }
        } else {
            key = ejsToMulti(ejs, qname.name);
            if (ejsIs(ejs, vp, Array)) {
                value = ejsToJSON(ejs, vp, NULL);
            } else {
                value = ejsToString(ejs, vp);
            }
            sep = (mprGetBufLength(hp->requestContent) > 0) ? "&" : "";
            if (prefix) {
                newKey = sjoin(prefix, ".", key, NULL);
                encodedKey = mprUriEncode(newKey, MPR_ENCODE_URI_COMPONENT); 
            } else {
                encodedKey = mprUriEncode(key, MPR_ENCODE_URI_COMPONENT);
            }
            vstr = ejsToMulti(ejs, value);
            encodedValue = mprUriEncode(vstr, MPR_ENCODE_URI_COMPONENT);
            mprPutFmtToBuf(hp->requestContent, "%s%s=%s", sep, encodedKey, encodedValue);
        }
    }
}

#if FUTURE && KEEP
/*  
    Prepare form data using json encoding. The objects are json encoded then URI encoded to be safe. 
 */
static void prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsString   *value;
    cchar       *key, *sep;
    char        *encodedKey, *encodedValue, *newPrefix, *newKey;
    int         i, count;

    jdata = ejsToJSON(ejs, data, NULL);
    if (prefix) {
        newKey = sjoin(prefix, ".", key, NULL);
        encodedKey = mprUriEncode(newKey, MPR_ENCODE_URI_COMPONENT); 
    } else {
        encodedKey = mprUriEncode(key, MPR_ENCODE_URI_COMPONENT);
    }
    encodedValue = mprUriEncode(value->value, MPR_ENCODE_URI_COMPONENT);
    mprPutFmtToBuf(hp->requestContent, "%s%s=%s", sep, encodedKey, encodedValue);
}
#endif


#if FUTURE
static bool expired(EjsHttp *hp)
{
    int     requestTimeout, inactivityTimeout, diff, inactivity;

    requestTimeout = conn->limits->requestTimeout ? conn->limits->requestTimeout : MAXINT;
    inactivityTimeout = conn->limits->inactivityTimeout ? conn->limits->inactivityTimeout : MAXINT;

    /* 
        Workaround for a GCC bug when comparing two 64bit numerics directly. Need a temporary.
     */
    diff = (conn->lastActivity + inactivityTimeout) - http->now;
    inactivity = 1;
    if (diff > 0 && conn->rx) {
        diff = (conn->started + requestTimeout) - http->now;
        inactivity = 0;
    }
    if (diff < 0) {
        if (conn->rx) {
            if (inactivity) {
                mprLog(http, 4, "Inactive request timed out %s, exceeded inactivity timeout %d", 
                    conn->rx->uri, inactivityTimeout);
            } else {
                mprLog(http, 4, "Request timed out %s, exceeded timeout %d", conn->rx->uri, requestTimeout);
            }
        } else {
            mprLog(http, 4, "Idle connection timed out");
        }
    }
}
#endif


/*  
    Wait for the connection to acheive a requested state
    Timeout is in msec. <= 0 means don't wait.
 */
static bool waitForState(EjsHttp *hp, int state, int timeout, int throw)
{
    Ejs             *ejs;
    MprTime         mark;
    HttpConn        *conn;
    HttpUri         *uri;
    char            *url;
    int             count, redirectCount, success, rc, remaining;

    mprAssert(state >= HTTP_STATE_PARSED);

    ejs = hp->ejs;
    conn = hp->conn;
    mprAssert(conn->state >= HTTP_STATE_CONNECTED);

    if (conn->state >= state) {
        return 1;
    }
    if (conn->state < HTTP_STATE_CONNECTED) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: not connected");
        }
        return 0;
    }
    if (timeout < 0) {
        timeout = 0;
    } else if (mprGetDebugMode()) {
        timeout = MAXINT;
    }
    remaining = timeout;
    mark = mprGetTime();
    redirectCount = 0;
    success = count = 0;

    if (!conn->async) {
        httpFinalize(conn);
    }
    while (conn->state < state && count <= conn->retries && redirectCount < 16 && 
           !conn->error && !ejs->exiting && !mprIsStopping(conn)) {
        count++;
        if ((rc = httpWait(conn, HTTP_STATE_PARSED, remaining)) == 0) {
            if (httpNeedRetry(conn, &url)) {
                if (url) {
                    uri = httpCreateUri(url, 0);
                    hp->uri = httpUriToString(uri, 1);
                }
                count--; 
                redirectCount++;
            } else if (httpWait(conn, state, remaining) == 0) {
                success = 1;
                break;
            }
        } else {
            if (rc == MPR_ERR_CANT_CONNECT) {
                httpFormatError(conn, HTTP_CODE_COMMS_ERROR, "Connection error");
            } else if (rc == MPR_ERR_TIMEOUT) {
                if (timeout > 0) {
                    httpFormatError(conn, HTTP_CODE_REQUEST_TIMEOUT, "Request timed out");
                }
            } else {
                httpFormatError(conn, HTTP_CODE_CLIENT_ERROR, "Client request error");
            }
            break;
        }
        if (conn->rx) {
            if (conn->rx->status == HTTP_CODE_REQUEST_TOO_LARGE || 
                    conn->rx->status == HTTP_CODE_REQUEST_URL_TOO_LARGE) {
                /* No point retrying */
                break;
            }
        }
        if (hp->writeCount > 0) {
            /* Can't auto-retry with manual writes */
            break;
        }
        remaining = (int) (mark + timeout - mprGetTime());
        if (count > 0 && remaining <= 0) {
            break;
        }
        if (hp->requestContentCount > 0) {
            mprAdjustBufStart(hp->requestContent, -hp->requestContentCount);
        }
        /* Force a new connection */
        if (conn->rx == 0 || conn->rx->status != HTTP_CODE_UNAUTHORIZED) {
            httpSetKeepAliveCount(conn, -1);
        }
        httpPrepClientConn(conn, 1);
        if (startHttpRequest(ejs, hp, NULL, 0, NULL) < 0) {
            return 0;
        }
        if (!conn->async) {
            httpFinalize(conn);
        }
    }
    if (!success) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: %s", (conn->errorMsg) ? conn->errorMsg : "");
        }
        return 0;
    }
    return 1;
}


/*  
    Wait till the response headers have been received. Safe in sync and async mode. Async mode never blocks.
    Timeout < 0 means use default inactivity timeout. Timeout of zero means wait forever.
 */
static bool waitForResponseHeaders(EjsHttp *hp, int timeout)
{
    if (hp->conn->async) {
        timeout = 0;
    }
    if (hp->conn->state < HTTP_STATE_CONNECTED) {
        return 0;
    }
    if (timeout < 0) {
        timeout = hp->conn->limits->inactivityTimeout;
        if (timeout <= 0) {
            timeout = MAXINT;
        }
    }
    if (hp->conn->state < HTTP_STATE_PARSED && !waitForState(hp, HTTP_STATE_PARSED, timeout, 1)) {
        return 0;
    }
    return 1;
}


/*
    Get limits:  obj[*] = limits
 */
void ejsGetHttpLimits(Ejs *ejs, EjsObj *obj, HttpLimits *limits, int server) 
{
    ejsSetPropertyByName(ejs, obj, EN("chunk"), ejsCreateNumber(ejs, (MprNumber) limits->chunkSize));
    ejsSetPropertyByName(ejs, obj, EN("receive"), ejsCreateNumber(ejs, (MprNumber) limits->receiveBodySize));
    ejsSetPropertyByName(ejs, obj, EN("reuse"), ejsCreateNumber(ejs, limits->keepAliveCount));
    ejsSetPropertyByName(ejs, obj, EN("transmission"), ejsCreateNumber(ejs, (MprNumber) limits->transmissionBodySize));
    ejsSetPropertyByName(ejs, obj, EN("upload"), ejsCreateNumber(ejs, (MprNumber) limits->uploadSize));
    ejsSetPropertyByName(ejs, obj, EN("inactivityTimeout"), 
        ejsCreateNumber(ejs, limits->inactivityTimeout / MPR_TICKS_PER_SEC));
    ejsSetPropertyByName(ejs, obj, EN("requestTimeout"), ejsCreateNumber(ejs, limits->requestTimeout / MPR_TICKS_PER_SEC));
    ejsSetPropertyByName(ejs, obj, EN("sessionTimeout"), ejsCreateNumber(ejs, limits->sessionTimeout / MPR_TICKS_PER_SEC));

    if (server) {
        ejsSetPropertyByName(ejs, obj, EN("clients"), ejsCreateNumber(ejs, (MprNumber) limits->clientCount));
        ejsSetPropertyByName(ejs, obj, EN("header"), ejsCreateNumber(ejs, (MprNumber) limits->headerSize));
        ejsSetPropertyByName(ejs, obj, EN("headers"), ejsCreateNumber(ejs, (MprNumber) limits->headerCount));
        ejsSetPropertyByName(ejs, obj, EN("requests"), ejsCreateNumber(ejs, (MprNumber) limits->requestCount));
#if UNUSED
        ejsSetPropertyByName(ejs, obj, EN("sessions"), ejsCreateNumber(ejs, (MprNumber) limits->sessionCount));
#endif
        ejsSetPropertyByName(ejs, obj, EN("stageBuffer"), ejsCreateNumber(ejs, (MprNumber) limits->stageBufferSize));
        ejsSetPropertyByName(ejs, obj, EN("uri"), ejsCreateNumber(ejs, (MprNumber) limits->uriSize));
    }
}


/*
    Set the limit field: 
        *limit = obj[field]
 */
static int64 setLimit(Ejs *ejs, EjsObj *obj, cchar *field, int factor)
{
    EjsObj      *vp;

    if ((vp = ejsGetPropertyByName(ejs, obj, EN(field))) != 0) {
        return ejsGetInt64(ejs, ejsToNumber(ejs, vp)) * factor;
    }
    return 0;
}


void ejsSetHttpLimits(Ejs *ejs, HttpLimits *limits, EjsObj *obj, int server) 
{
    limits->chunkSize = (ssize) setLimit(ejs, obj, "chunk", 1);
    limits->inactivityTimeout = (int) setLimit(ejs, obj, "inactivityTimeout", MPR_TICKS_PER_SEC);
    limits->receiveBodySize = (MprOff) setLimit(ejs, obj, "receive", 1);
    limits->keepAliveCount = (int) setLimit(ejs, obj, "reuse", 1);
    limits->requestTimeout = (int) setLimit(ejs, obj, "requestTimeout", MPR_TICKS_PER_SEC);
    limits->sessionTimeout = (int) setLimit(ejs, obj, "sessionTimeout", MPR_TICKS_PER_SEC);
    limits->transmissionBodySize = (MprOff) setLimit(ejs, obj, "transmission", 1);
    limits->uploadSize = (MprOff) setLimit(ejs, obj, "upload", 1);
    if (limits->requestTimeout <= 0) {
        limits->requestTimeout = MPR_MAX_TIMEOUT;
    }
    if (limits->inactivityTimeout <= 0) {
        limits->inactivityTimeout = MPR_MAX_TIMEOUT;
    }
    if (limits->sessionTimeout <= 0) {
        limits->sessionTimeout = MPR_MAX_TIMEOUT;
    }
    if (server) {
        limits->clientCount = (int) setLimit(ejs, obj, "clients", 1);
        limits->requestCount = (int) setLimit(ejs, obj, "requests", 1);
#if UNUSED
        limits->sessionCount = (int) setLimit(ejs, obj, "sessions", 1);
#endif
        limits->stageBufferSize = (ssize) setLimit(ejs, obj, "stageBuffer", 1);
        limits->uriSize = (ssize) setLimit(ejs, obj, "uri", 1);
        limits->headerCount = (int) setLimit(ejs, obj, "headers", 1);
        limits->headerSize = (ssize) setLimit(ejs, obj, "header", 1);
    }
}


static void sendHttpCloseEvent(Ejs *ejs, EjsHttp *hp)
{
    if (!hp->closed && ejs->service) {
        hp->closed = 1;
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "close", NULL, hp);
        }
    }
}


static void sendHttpErrorEvent(Ejs *ejs, EjsHttp *hp)
{
    if (!hp->error) {
        hp->error = 1;
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "error", NULL, hp);
        }
    }
}



/*  
    Manage the object properties for the garbage collector
 */
static void manageHttp(EjsHttp *http, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(http->responseCache);
        mprMark(http->emitter);
        mprMark(http->data);
        mprMark(http->limits);
        mprMark(http->requestContent);
        mprMark(http->responseContent);
        mprMark(http->uri);
        mprMark(http->method);
        mprMark(http->keyFile);
        mprMark(http->certFile);
        mprMark(TYPE(http));
        mprMark(http->conn);

    } else if (flags & MPR_MANAGE_FREE) {
        if (http->conn) {
            sendHttpCloseEvent(http->ejs, http);
            httpDestroyConn(http->conn);
            http->conn = 0;
        }
    }
}


void ejsConfigureHttpType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "Http"), sizeof(EjsHttp), (MprManager) manageHttp, EJS_OBJ_HELPERS);
    prototype = type->prototype;
    type->mutableInstances = 1;

    ejsBindConstructor(ejs, type, httpConstructor);
    ejsBindAccess(ejs, prototype, ES_Http_async, http_async, http_set_async);
#if ES_Http_available
    /* DEPRECATED */
    ejsBindMethod(ejs, prototype, ES_Http_available, http_available);
#endif
    ejsBindMethod(ejs, prototype, ES_Http_close, http_close);
    ejsBindMethod(ejs, prototype, ES_Http_connect, http_connect);
    ejsBindAccess(ejs, prototype, ES_Http_certificate, http_certificate, http_set_certificate);
    ejsBindMethod(ejs, prototype, ES_Http_contentLength, http_contentLength);
    ejsBindMethod(ejs, prototype, ES_Http_contentType, http_contentType);
    ejsBindMethod(ejs, prototype, ES_Http_date, http_date);
    ejsBindMethod(ejs, prototype, ES_Http_finalize, http_finalize);
    ejsBindMethod(ejs, prototype, ES_Http_finalized, http_finalized);
    ejsBindMethod(ejs, prototype, ES_Http_flush, http_flush);
    ejsBindAccess(ejs, prototype, ES_Http_followRedirects, http_followRedirects, http_set_followRedirects);
    ejsBindMethod(ejs, prototype, ES_Http_form, http_form);
    ejsBindMethod(ejs, prototype, ES_Http_get, http_get);
    ejsBindMethod(ejs, prototype, ES_Http_getRequestHeaders, http_getRequestHeaders);
    ejsBindMethod(ejs, prototype, ES_Http_head, http_head);
    ejsBindMethod(ejs, prototype, ES_Http_header, http_header);
    ejsBindMethod(ejs, prototype, ES_Http_headers, http_headers);
    ejsBindMethod(ejs, prototype, ES_Http_isSecure, http_isSecure);
    ejsBindAccess(ejs, prototype, ES_Http_key, http_key, http_set_key);
    ejsBindMethod(ejs, prototype, ES_Http_lastModified, http_lastModified);
    ejsBindMethod(ejs, prototype, ES_Http_limits, http_limits);
    ejsBindAccess(ejs, prototype, ES_Http_method, http_method, http_set_method);
    ejsBindMethod(ejs, prototype, ES_Http_off, http_off);
    ejsBindMethod(ejs, prototype, ES_Http_on, http_on);
    ejsBindMethod(ejs, prototype, ES_Http_post, http_post);
    ejsBindMethod(ejs, prototype, ES_Http_put, http_put);
    ejsBindMethod(ejs, prototype, ES_Http_read, http_read);
    ejsBindMethod(ejs, prototype, ES_Http_readString, http_readString);
    ejsBindMethod(ejs, prototype, ES_Http_reset, http_reset);
    ejsBindAccess(ejs, prototype, ES_Http_response, http_response, http_set_response);
    ejsBindAccess(ejs, prototype, ES_Http_retries, http_retries, http_set_retries);
    ejsBindMethod(ejs, prototype, ES_Http_setCredentials, http_setCredentials);
    ejsBindMethod(ejs, prototype, ES_Http_setHeader, http_setHeader);
    ejsBindMethod(ejs, prototype, ES_Http_setLimits, http_setLimits);
    ejsBindMethod(ejs, prototype, ES_Http_status, http_status);
    ejsBindMethod(ejs, prototype, ES_Http_statusMessage, http_statusMessage);
    ejsBindMethod(ejs, prototype, ES_Http_trace, http_trace);
    ejsBindAccess(ejs, prototype, ES_Http_uri, http_uri, http_set_uri);
    ejsBindMethod(ejs, prototype, ES_Http_write, http_write);
    ejsBindMethod(ejs, prototype, ES_Http_wait, http_wait);
}

/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsHttp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsIterator.c"
 */
/************************************************************************/

/**
    ejsIterator.c - Iterator class

    This provides a high performance iterator construction for native classes.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Call the supplied next() function to return the next enumerable item
 */
static EjsObj *nextIterator(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (ip->nativeNext) {
        return (ip->nativeNext)(ejs, ip, argc, argv);
    } else {
        ejsThrowStopIteration(ejs);
        return 0;
    }
}


EjsObj *ejsThrowStopIteration(Ejs *ejs)
{
#if FUTURE
    ejs->exception = ejs->iterator;
#else
    ejs->exception = ST(StopIteration);
#endif
    ejsAttention(ejs);
    return ejs->exception;
}


#if KEEP
/*
    Constructor to create an iterator using a scripted next().

    public function Iterator(obj, f, deep, ...namespaces)
 */
static EjsObj *iteratorConstructor(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (argc != 2 || !ejsIsFunction(ejs, argv[1])) {
        ejsThrowArgError(ejs, "usage: Iterator(obj, function)");
        return 0;
    }
    ip->target = argv[0];
    ip->next = (EjsFunction*) argv[1];
    mprAssert(ip->nativeNext == 0);

    return ip;
}
#endif


/*
    Create an iterator.
 */
EjsIterator *ejsCreateIterator(Ejs *ejs, EjsAny *obj, void *nativeNext, bool deep, EjsArray *namespaces)
{
    EjsIterator     *ip;

    ip = ejsCreateObj(ejs, ST(Iterator), 0);
    if (ip) {
        ip->index = 0;
        ip->indexVar = 0;
        ip->nativeNext = nativeNext;
        ip->target = obj;
        ip->deep = deep;
        ip->namespaces = namespaces;
    }
    return ip;
}


static void manageIterator(EjsIterator *ip, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ip->target);
        mprMark(ip->namespaces);
        mprMark(ip->indexVar);
    }
}


/*
    Create the Iterator and StopIteration types
 */
void ejsCreateIteratorType(Ejs *ejs)
{
    EjsType     *type;

    if (ST(Iterator) == 0) {
        type = ejsCreateNativeType(ejs, N(EJS_ITERATOR_NAMESPACE, "Iterator"), sizeof(EjsIterator), S_Iterator,  
            ES_iterator_Iterator_NUM_CLASS_PROP, manageIterator, EJS_OBJ_HELPERS);
    }
    if (ST(StopIteration) == 0) {
        type = ejsCreateNativeType(ejs, N(EJS_ITERATOR_NAMESPACE, "StopIteration"), sizeof(EjsError), S_StopIteration, 
            ES_iterator_StopIteration_NUM_CLASS_PROP, manageIterator, EJS_OBJ_HELPERS);
    }
}


void ejsConfigureIteratorType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;
    static int once = 0;

    if (once++ == 0) {
        type = ST(Iterator);
        prototype = type->prototype;
        ejsBindMethod(ejs, prototype, ES_iterator_Iterator_next, nextIterator);
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsIterator.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsJSON.c"
 */
/************************************************************************/

/**
    ejsJSON.c - JSON encoding and decoding

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




typedef struct JsonState {
    MprChar    *data;
    MprChar    *end;
    MprChar    *next;
    MprChar    *error;
} JsonState;

typedef struct Json {
    MprBuf      *buf;
    EjsObj      *current;
    EjsObj      *options;           /* Options object */
    EjsFunction *replacer;
    char        *indent;
    int         baseClasses;
    int         depth;
    int         hidden;
    int         namespaces;
    int         pretty;
    int         nest;              /* Json serialize nest level */
} Json;


static EjsObj *parseLiteral(Ejs *ejs, JsonState *js);
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js);
static EjsString *serialize(Ejs *ejs, EjsAny *vp, Json *json);

/*
    function deserialize(obj: String, options: Object): Object
 */
EjsObj *g_deserialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprAssert(argc >=1);
    return ejsDeserialize(ejs, (EjsString*) argv[0]);
}

/*
    function serialize(obj: Object, options: Object = null): String
        Options: baseClasses, depth, indent, hidden, pretty, replacer
 */
static EjsString *g_serialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsToJSON(ejs, argv[0], (argc == 2) ? argv[1] : NULL);
}


EjsAny *ejsDeserialize(Ejs *ejs, EjsString *str)
{
    EjsObj      *obj;
    JsonState   js;

    if (!ejsIs(ejs, str, String)) {
        ejsThrowSyntaxError(ejs, "Object is not a string");
        return 0;
    }
    if (str->length == 0) {
        return S(empty);
    }
    js.next = js.data = str->value;
    js.end = &js.data[str->length];
    js.error = 0;
    if ((obj = parseLiteral(ejs, &js)) == 0) {
        if (js.error) {
            ejsThrowSyntaxError(ejs, 
                "Can't parse object literal. Error at position %d.\n"
                "===========================\n"
                "Offending text: %w\n"
                "===========================\n"
                "In literal %w"
                "\n===========================\n",
                (int) (js.error - js.data), js.error, js.data);
        } else {
            ejsThrowSyntaxError(ejs, "Can't parse object literal. Undefined error");
        }
        return 0;
    }
    return obj;
}


static EjsObj *parseLiteral(Ejs *ejs, JsonState *js)
{
    mprAssert(js);

    return parseLiteralInner(ejs, mprCreateBuf(0, 0), js);
}


typedef enum Token {
    TOK_ERR,            /* Error */
    TOK_EOF,            /* End of input */
    TOK_LBRACE,         /* { */
    TOK_LBRACKET,       /* [ */
    TOK_RBRACE,         /* } */
    TOK_RBRACKET,       /* ] */
    TOK_COLON,          /* : */
    TOK_COMMA,          /* , */
    TOK_ID,             /* Unquoted ID */
    TOK_QID,            /* Quoted ID */
} Token;


static MprChar *skipComments(MprChar *cp, MprChar *end)
{
    int     inComment;

    for (; cp < end && isspace((int) *cp); cp++) {}

    while (cp < &end[-1]) {
        if (cp < &end[-1] && *cp == '/' && cp[1] == '*') {
            inComment = 1;
            for (cp += 2; cp < &end[-1]; cp++) {
                if (*cp == '*' && cp[1] == '/') {
                    inComment = 0;
                    cp += 2;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((int) *cp)) cp++;

        } else  if (cp < &end[-1] && *cp == '/' && cp[1] == '/') {
            inComment = 1;
            for (cp += 2; cp < end; cp++) {
                if (*cp == '\n') {
                    inComment = 0;
                    cp++;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((int) *cp)) cp++;

        } else {
            break;
        }
    }
    return cp;
}


Token getNextJsonToken(MprBuf *buf, MprChar **token, JsonState *js)
{
    MprChar     *start, *cp, *end, *next;
    MprChar     *src, *dest;
    int         quote, tid, c;

    if (buf) {
        mprFlushBuf(buf);
    }
    cp = js->next;
    end = js->end;
    cp = skipComments(cp, end);
    next = cp + 1;
    quote = -1;

    if (*cp == '\0') {
        tid = TOK_EOF;

    } else  if (*cp == '{') {
        tid = TOK_LBRACE;

    } else if (*cp == '[') {
        tid = TOK_LBRACKET;

    } else if (*cp == '}' || *cp == ']') {
        tid = *cp == '}' ? TOK_RBRACE: TOK_RBRACKET;
        while (*++cp && isspace((int) *cp)) ;
        if (*cp == ',' || *cp == ':') {
            cp++;
        }
        next = cp;

    } else {
        if (*cp == '"' || *cp == '\'') {
            tid = TOK_QID;
            quote = *cp++;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == quote) {
                        cp++;
                    }
                    continue;
                }
                if (*cp == quote) {
                    break;
                }
            }
            if (*cp != quote) {
                js->error = cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (cp - start));
            }
            cp++;

        } else if (*cp == '/') {
            tid = TOK_ID;
            for (start = cp++; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == '/') {
                        cp++;
                    }
                    continue;
                }
                if (*cp == '/') {
                    break;
                }
            }
            if (*cp != '/') {
                js->error = cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (cp - start));
            }
            cp++;

        } else {
            tid = TOK_ID;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    continue;
                }
                /* Not an allowable character outside quotes */
                if (!(isalnum((int) *cp) || *cp == '_' || *cp == ' ' || *cp == '-' || *cp == '+' || *cp == '.')) {
                    break;
                }
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (int) (cp - start));
            }
        }
        if (buf) {
            mprAddNullToBuf(buf);
        }
        if (*cp == ',' || *cp == ':') {
            cp++;
        } else if (*cp != '}' && *cp != ']' && *cp != '\0' && *cp != '\n' && *cp != '\r' && *cp != ' ') {
            js->error = cp;
            return TOK_ERR;
        }
        next = cp;

        if (buf) {
            for (dest = src = (MprChar*) buf->start; src < (MprChar*) buf->end; ) {
                c = *src++;
                if (c == '\\') {
                    c = *src++;
                    if (c == 'r') {
                        c = '\r';
                    } else if (c == 'n') {
                        c = '\n';
                    } else if (c == 'b') {
                        c = '\b';
                    }
                }
                *dest++ = c;
            }
            *dest = '\0';
            *token = (MprChar*) mprGetBufStart(buf);
        }
    }
    js->next = next;
    return tid;
}


Token peekNextJsonToken(JsonState *js)
{
    JsonState   discard = *js;
    return getNextJsonToken(NULL, NULL, &discard);
}


/*
    Parse an object literal string pointed to by js->next into the given buffer. Update js->next to point
    to the next input token in the object literal. Supports nested object literals.
 */
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js)
{
    EjsAny      *obj, *vp;
    MprBuf      *valueBuf;
    MprChar     *token, *key, *value;
    int         tid, isArray;

    isArray = 0;

    tid = getNextJsonToken(buf, &token, js);
    if (tid == TOK_ERR || tid == TOK_EOF) {
        return 0;
    }
    if (tid == TOK_LBRACKET) {
        isArray = 1;
        obj = (EjsObj*) ejsCreateArray(ejs, 0);
    } else if (tid == TOK_LBRACE) {
        obj = ejsCreateEmptyPot(ejs);
    } else {
        return ejsParse(ejs, token, S_String);
    }
    if (obj == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    while (1) {
        vp = 0;
        tid = peekNextJsonToken(js);
        if (tid == TOK_ERR) {
            return 0;
        } else if (tid == TOK_EOF) {
            break;
        } else if (tid == TOK_RBRACE || tid == TOK_RBRACKET) {
            getNextJsonToken(buf, &key, js);
            break;
        }
        if (tid == TOK_LBRACKET) {
            /* For array values */
            vp = parseLiteral(ejs, js);
            mprAssert(vp);
            
        } else if (tid == TOK_LBRACE) {
            /* For object values */
            vp = parseLiteral(ejs, js);
            mprAssert(vp);
            
        } else if (isArray) {
            tid = getNextJsonToken(buf, &value, js);
            vp = ejsParse(ejs, value, (tid == TOK_QID) ? S_String: -1);
            mprAssert(vp);
            
        } else {
            getNextJsonToken(buf, &key, js);
            tid = peekNextJsonToken(js);
            if (tid == TOK_ERR) {
                return 0;
            } else if (tid == TOK_EOF) {
                break;
            } else if (tid == TOK_LBRACE || tid == TOK_LBRACKET) {
                vp = parseLiteral(ejs, js);

            } else if (tid == TOK_ID || tid == TOK_QID) {
                valueBuf = mprCreateBuf(0, 0);
                getNextJsonToken(valueBuf, &value, js);
                if (tid == TOK_QID) {
                    vp = ejsCreateString(ejs, value, strlen(value));
                } else {
                    if (mcmp(value, "null") == 0) {
                        vp = S(null);
                    } else if (mcmp(value, "undefined") == 0) {
                        vp = S(undefined);
                    } else {
                        vp = ejsParse(ejs, value, -1);
                    }
                }
                mprAssert(vp);
            } else {
                getNextJsonToken(buf, &value, js);
                js->error = js->next;
                return 0;
            }
        }
        if (vp == 0) {
            js->error = js->next;
            return 0;
        }
        if (isArray) {
            if (ejsSetProperty(ejs, obj, -1, vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        } else {
            if (ejsSetPropertyByName(ejs, obj, WEN(key), vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        }
    }
    return obj;
}


/**
    Get a serialized string representation of a variable using JSON encoding.
    This will look for a "toJSON" function on the specified object. Use ejsSerialize for low level JSON.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsString *ejsToJSON(Ejs *ejs, EjsAny *vp, EjsObj *options)
{
    EjsFunction     *fn;
    EjsString       *result;
    EjsObj          *argv[1];
    int             argc;

    fn = (EjsFunction*) ejsGetPropertyByName(ejs, TYPE(vp)->prototype, N(NULL, "toJSON"));
    if (!ejsIsFunction(ejs, fn) || (fn->isNativeProc && fn->body.proc == (EjsFun) ejsObjToJSON)) {
        result = ejsSerialize(ejs, vp, options);
    } else {
        argv[0] = options;
        argc = options ? 1 : 0;
        result = (EjsString*) ejsRunFunction(ejs, fn, vp, argc, argv);
    }
    return result;
}


/*
    Low level JSON encoding.
 */
EjsString *ejsSerialize(Ejs *ejs, EjsAny *vp, EjsObj *options)
{
    Json        json;
    EjsObj      *arg;
    EjsString   *result;
    int         i;

    memset(&json, 0, sizeof(Json));

    json.depth = 99;
    
    if (options) {
        json.options = options;
        if ((arg = ejsGetPropertyByName(ejs, options, EN("baseClasses"))) != 0) {
            json.baseClasses = (arg == S(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("depth"))) != 0) {
            json.depth = ejsGetInt(ejs, arg);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("indent"))) != 0) {
            if (ejsIs(ejs, arg, String)) {
               json.indent = (char*) ejsToMulti(ejs, arg);
                //  TODO - get another solution to hold
                mprHold(json.indent);
            } else if (ejsIs(ejs, arg, Number)) {
                i = ejsGetInt(ejs, arg);
                if (0 <= i && i < MPR_MAX_STRING) {
                    json.indent = mprAlloc(i + 1);
                    //  TODO - get another solution to hold
                    mprHold(json.indent);
                    memset(json.indent, ' ', i);
                    json.indent[i] = '\0';
                }
            }
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("hidden"))) != 0) {
            json.hidden = (arg == S(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("namespaces"))) != 0) {
            json.namespaces = (arg == S(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("pretty"))) != 0) {
            json.pretty = (arg == S(true));
        }
        json.replacer = ejsGetPropertyByName(ejs, options, EN("replacer"));
        if (!ejsIsFunction(ejs, json.replacer)) {
            json.replacer = NULL;
        }
    }
    result = serialize(ejs, vp, &json);
    //  TODO - get another solution to hold
    mprRelease(json.indent);
    return result;
}


static EjsString *serialize(Ejs *ejs, EjsAny *vp, Json *json)
{
    EjsName     qname;
    EjsFunction *fn;
    EjsString   *result, *sv;
    EjsTrait    *trait;
    EjsObj      *pp, *obj, *replacerArgs[2];
    MprChar     *cp;
    char        key[16];
    int         c, isArray, i, count, slotNum;

    /*
        The main code below can handle Arrays, Objects, objects derrived from Object and also native classes with properties.
        All others just use toString.
     */
    count = ejsGetPropertyCount(ejs, vp);
    if (count == 0 && TYPE(vp) != ST(Object) && TYPE(vp) != ST(Array)) {
        //  OPT - need some flag for this test.
        if (!ejsIsDefined(ejs, vp) || ejsIs(ejs, vp, Boolean) || ejsIs(ejs, vp, Number) || ejsIs(ejs, vp, String)) {
            return ejsToString(ejs, vp);
        } else {
            return ejsStringToJSON(ejs, vp);
        }
    }
    obj = vp;
    json->nest++;
    if (json->buf == 0) {
        json->buf = mprCreateBuf(0, 0);
        mprAddRoot(json->buf);
    }
    isArray = ejsIs(ejs, vp, Array);
    mprPutCharToWideBuf(json->buf, isArray ? '[' : '{');
    if (json->pretty || json->indent) {
        mprPutCharToWideBuf(json->buf, '\n');
    }
    if (++ejs->serializeDepth <= json->depth && !VISITED(obj)) {
        SET_VISITED(obj, 1);
        for (slotNum = 0; slotNum < count && !ejs->exception; slotNum++) {
            trait = ejsGetPropertyTraits(ejs, obj, slotNum);
            if (trait && (trait->attributes & (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | 
                    EJS_FUN_MODULE_INITIALIZER)) && !json->hidden) {
                continue;
            }
            pp = ejsGetProperty(ejs, obj, slotNum);
            if (ejs->exception) {
                SET_VISITED(obj, 0);
                json->nest--;
                return 0;
            }
            if (pp == 0) {
                mprAssert(0);
                continue;
            }
            if (isArray) {
                itos(key, sizeof(key), slotNum, 10);
                qname.name = ejsCreateStringFromAsc(ejs, key);
                qname.space = S(empty);
            } else {
                qname = ejsGetPropertyName(ejs, vp, slotNum);
            }
            if (json->pretty) {
                for (i = 0; i < ejs->serializeDepth; i++) {
                    mprPutStringToWideBuf(json->buf, "  ");
                }
            } else {
                if (json->indent) {
                    mprPutStringToWideBuf(json->buf, json->indent);
                }
            }
            if (!isArray) {
                if (json->namespaces) {
                    if (qname.space != S(empty)) {
                        mprPutFmtToWideBuf(json->buf, "\"%@\"::", qname.space);
                    }
                }
//  TODO -- should this be in unicode?  yes?
                mprPutCharToWideBuf(json->buf, '"');
                for (cp = qname.name->value; cp && *cp; cp++) {
                    c = *cp;
                    if (c == '"' || c == '\\') {
                        mprPutCharToWideBuf(json->buf, '\\');
                        mprPutCharToWideBuf(json->buf, c);
                    } else {
                        mprPutCharToWideBuf(json->buf, c);
                    }
                }
                mprPutStringToWideBuf(json->buf, "\":");
                if (json->pretty || json->indent) {
                    mprPutCharToWideBuf(json->buf, ' ');
                }
            }
            fn = (EjsFunction*) ejsGetPropertyByName(ejs, TYPE(pp)->prototype, N(NULL, "toJSON"));
// TODO - check that this is going directly to serialize most of the time
            if (!ejsIsFunction(ejs, fn) || (fn->isNativeProc && fn->body.proc == (EjsFun) ejsObjToJSON)) {
                sv = serialize(ejs, pp, json);
            } else {
                sv = (EjsString*) ejsRunFunction(ejs, fn, pp, 1, &json->options);
            }
            if (sv == 0 || !ejsIs(ejs, sv, String)) {
                if (ejs->exception) {
                    ejsThrowTypeError(ejs, "Can't serialize property %@", qname.name);
                    SET_VISITED(obj, 0);
                    return 0;
                }
            } else {
                if (json->replacer) {
                    replacerArgs[0] = (EjsObj*) qname.name; 
                    replacerArgs[1] = (EjsObj*) sv; 

                    /* function replacer(key: String, value: String): String */
                    sv = ejsRunFunction(ejs, json->replacer, obj, 2, (EjsObj**) replacerArgs);
                }
                mprPutBlockToBuf(json->buf, sv->value, sv->length * sizeof(MprChar));
            }
            if ((slotNum + 1) < count) {
                mprPutCharToWideBuf(json->buf, ',');
            }
            if (json->pretty || json->indent) {
                mprPutCharToWideBuf(json->buf, '\n');
            }
        }
        SET_VISITED(obj, 0);
    }
    --ejs->serializeDepth; 
    if (json->pretty || json->indent) {
        for (i = ejs->serializeDepth; i > 0; i--) {
            mprPutStringToWideBuf(json->buf, "  ");
        }
    }
    mprPutCharToWideBuf(json->buf, isArray ? ']' : '}');
    mprAddNullToWideBuf(json->buf);

    if (--json->nest == 0) {
        result = ejsCreateString(ejs, mprGetBufStart(json->buf), mprGetBufLength(json->buf) / sizeof(MprChar));
        mprRemoveRoot(json->buf);
    } else {
        result = 0;
    }
    return result;
}


void ejsConfigureJSONType(Ejs *ejs)
{
    ejsBindFunction(ejs, ejs->global, ES_deserialize, g_deserialize);
    ejsBindFunction(ejs, ejs->global, ES_serialize, g_serialize);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsJSON.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsLogFile.c"
 */
/************************************************************************/

/*
    ejsLogFile.c -- LogFile class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    function emit(level: Number, ...data): Number
 */
static EjsNumber *lf_emit(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ap;
    EjsObj          *vp;
    EjsString       *str;
    char            *msg, *arg;
    ssize           len, written;
    int             i, level, frozen;

    mprAssert(argc >= 2 && ejsIs(ejs, argv[1], Array));

    level = ejsGetInt(ejs, argv[0]);
    args = (EjsArray*) argv[1];
    written = 0;
    msg = 0;
    frozen = ejsFreeze(ejs, 1);

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, args, i);
        mprAssert(vp);
        switch (TYPE(vp)->sid) {
        case S_ByteArray:
            ap = (EjsByteArray*) vp;
            //  TODO ENCODING
            arg = (char*) &ap->value[ap->readPosition];
            len = ap->writePosition - ap->readPosition;
            break;

        case S_String:
            arg = awtom(((EjsString*) vp)->value, &len);
            break;

        default:
            str = ejsToString(ejs, vp);
            arg = awtom(((EjsString*) str)->value, &len);
            break;
        }
        msg = srejoin(msg, arg, NULL);
    }
    if (msg) {
        mprRawLog(level, "%s", msg);
        written += slen(msg);
    }
    ejsFreeze(ejs, frozen);
    return ejsCreateNumber(ejs, (MprNumber) slen(msg));
}


/*  
    function get logging(): Boolean
 */
static EjsBoolean *lf_logging(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, MPR->logging);
}

/*  
    function get level(): Number
 */
static EjsNumber *lf_level(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetLogLevel(ejs));
}


/*  
    function set level(value: Number): Void
 */
static EjsObj *lf_set_level(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprSetLogLevel(ejsGetInt(ejs, argv[0]));
    return 0;
}


/*  
    function redirect(location: String, level: Number = null): Void
 */
static EjsFile *lf_redirect(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *logSpec;
    int     level;

    logSpec = ejsToMulti(ejs, argv[0]);
    level = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : -1;

    ejsRedirectLogging(logSpec);
    if (level >= 0) {
        mprSetLogLevel(level);
    }
    return 0;
}



void ejsConfigureLogFileType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsGetTypeByName(ejs, N("ejs", "LogFile"));
    mprAssert(type);
    prototype = type->prototype;

    ejsBindAccess(ejs, prototype, ES_LogFile_logging, lf_logging, 0);
    ejsBindMethod(ejs, prototype, ES_LogFile_emit, lf_emit);
    ejsBindAccess(ejs, prototype, ES_LogFile_level, lf_level, lf_set_level);
    ejsBindMethod(ejs, prototype, ES_LogFile_redirect, lf_redirect);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsLogFile.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsMath.c"
 */
/************************************************************************/

/**
    ejsMath.c - Math type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


#include     <math.h>


#define fixed(n) ((int64) (floor(n)))

/*
    function abs(value: Number): Number
 */
static EjsNumber *math_abs(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    //  TODO - can a null slip through?
    return ejsCreateNumber(ejs, (MprNumber) fabs(ejsGetNumber(ejs, argv[0])));
}


/*
    function acos(value: Number): Number
 */
static EjsNumber *math_acos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   value;
    
    value = ejsGetNumber(ejs, argv[0]);
    return ejsCreateNumber(ejs, (MprNumber) acos(ejsGetNumber(ejs, argv[0])));
}


/*
    function asin(value: Number): Number
 */
static EjsNumber *math_asin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) asin(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan(value: Number): Number
 */
static EjsNumber *math_atan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) atan(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan2(x: Number, y: Number): Number
 */
static EjsNumber *math_atan2(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) atan2(ejsGetNumber(ejs, argv[0]), ejsGetNumber(ejs, argv[1])));
}


/*
    function ceil(value: Number): Number
 */
static EjsNumber *math_ceil(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ceil(ejsGetNumber(ejs, argv[0])));
}


/*
    function cos(value: Number): Number
 */
static EjsNumber *math_cos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) cos(ejsGetNumber(ejs, argv[0])));
}


/*
    function exp(value: Number): Number
 */
static EjsNumber *math_exp(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) exp(ejsGetNumber(ejs, argv[0])));
}


/*
    function floor(value: Number): Number
 */
static EjsNumber *math_floor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) floor(ejsGetNumber(ejs, argv[0])));
}


/*
    function log10(value: Number): Number
 */
static EjsNumber *math_log10(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) log10(ejsGetNumber(ejs, argv[0])));
}


/*
    function log(value: Number): Number
 */
static EjsNumber *math_log(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) log(ejsGetNumber(ejs, argv[0])));
}


/*
    function max(x: Number, y: Number): Number
 */
static EjsNumber *math_max(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x > y) {
        return (EjsNumber*) argv[0];
    }
    return (EjsNumber*) argv[1];
}


/*
    function min(value: Number): Number
 */
static EjsObj *math_min(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x < y) {
        return argv[0];
    }
    return argv[1];
}


/*
    function pow(x: Number, y: Number): Number
 */
static EjsNumber *math_pow(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y, result;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    result = pow(x, y);
#if CYGWIN
    /* Cygwin computes (0.0 / -1) == -Infinity */
    if (result < 0 && x == 0.0) {
        result = -result;
    }
#endif
    return ejsCreateNumber(ejs, (MprNumber) result);
}


/*
    function random(value: Number): Number
 */
static EjsNumber *math_random(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   value;
    uint        uvalue;
    static int  initialized = 0;
    
    if (!initialized) {
#if WIN
        uint seed = (uint) time(0);
        srand(seed);
#elif !MACOSX && !VXWORKS
        srandom(time(0));
#endif
        initialized = 1;
    }
    
#if WIN
{
    errno_t rand_s(uint *value);
    rand_s(&uvalue);
}
#elif LINUX
    uvalue = random();
#elif MACOSX
    uvalue = arc4random();
#else
{
    int64   data[16];
    int     i;
    mprGetRandomBytes((char*) data, sizeof(data), 0);
    uvalue = 0;
    for (i = 0; i < sizeof(data) / sizeof(int64); i++) {
        uvalue += data[i];
    }
}
#endif
    value = ((MprNumber) (uvalue & 0x7FFFFFFF)) / MAXINT;
    return ejsCreateNumber(ejs, value);
}


/*
    function round(value: Number): Number
 */
static EjsNumber *math_round(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;

    n = ejsGetNumber(ejs, argv[0]);
    if (-0.5 <= n && n < 0) {
        n = -0.0;
    } else {
        n += 0.5;
    }
    return ejsCreateNumber(ejs, floor(n));
}


/*
    function sin(value: Number): Number
 */
static EjsNumber *math_sin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) sin(ejsGetNumber(ejs, argv[0])));
}


/*
    function sqrt(value: Number): Number
 */
static EjsNumber *math_sqrt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) sqrt(ejsGetNumber(ejs, argv[0])));
}


/*
    function tan(value: Number): Number
 */
static EjsNumber *math_tan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) tan(ejsGetNumber(ejs, argv[0])));
}



void ejsConfigureMathType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, N("ejs", "Math"), sizeof(EjsObj), NULL, EJS_OBJ_HELPERS);
    ejsBindMethod(ejs, type, ES_Math_abs, math_abs);
    ejsBindMethod(ejs, type, ES_Math_acos, math_acos);
    ejsBindMethod(ejs, type, ES_Math_asin, math_asin);
    ejsBindMethod(ejs, type, ES_Math_atan, math_atan);
    ejsBindMethod(ejs, type, ES_Math_atan2, math_atan2);
    ejsBindMethod(ejs, type, ES_Math_ceil, math_ceil);
    ejsBindMethod(ejs, type, ES_Math_cos, math_cos);
    ejsBindMethod(ejs, type, ES_Math_exp, math_exp);
    ejsBindMethod(ejs, type, ES_Math_floor, math_floor);
    ejsBindMethod(ejs, type, ES_Math_log, math_log);
    ejsBindMethod(ejs, type, ES_Math_log10, math_log10);
    ejsBindMethod(ejs, type, ES_Math_max, math_max);
    ejsBindMethod(ejs, type, ES_Math_min, math_min);
    ejsBindMethod(ejs, type, ES_Math_pow, math_pow);
    ejsBindMethod(ejs, type, ES_Math_random, math_random);
    ejsBindMethod(ejs, type, ES_Math_round, math_round);
    ejsBindMethod(ejs, type, ES_Math_sin, math_sin);
    ejsBindMethod(ejs, type, ES_Math_sqrt, math_sqrt);
    ejsBindMethod(ejs, type, ES_Math_tan, math_tan);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsMath.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsMemory.c"
 */
/************************************************************************/

/*
    ejsMemory.c - Memory class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


/*
    native static function get allocated(): Number
 */
static EjsNumber *getAllocatedMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->bytesAllocated);
}


#if UNUSED
/*
    native static function callback(fn: Function): Void
 */
static EjsNumber *setRedlineCallback(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIsFunction(ejs, argv[0]));

    if (!ejsIsFunction(ejs, argv[0])) {
        ejsThrowArgError(ejs, "Callaback is not a function");
        return 0;
    }
    ejs->memoryCallback = (EjsFunction*) argv[0];
    return 0;
}
#endif


/*
    native static function get maximum(): Number
 */
static EjsNumber *getMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->maxMemory);
}


/*
    native static function set maximum(limit: Number): Void
 */
static EjsObj *setMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     maxMemory;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    maxMemory = ejsGetInt(ejs, argv[0]);
    mprSetMemLimits(-1, maxMemory);
    return 0;
}


/*
    native static function get redline(): Number
 */
static EjsNumber *getRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->redLine);
}


/*
    native static function set redline(limit: Number): Void
 */
static EjsObj *setRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     redline;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    redline = ejsGetInt(ejs, argv[0]);
    if (redline <= 0) {
        //  TODO - 64 bit
        redline = MAXINT;
    }
    mprSetMemLimits(redline, -1);
    return 0;
}


/*
    native static function get resident(): Number
 */
static EjsNumber *getResident(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->rss);
}


/*
    native static function get system(): Number
 */
static EjsNumber *getSystemRam(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (double) mem->ram);
}


/*
    native static function stats(): Void
 */
static EjsObj *printStats(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    //  TODO - should go to log file and not to stdout
    mprPrintMem("Memory Report", 0);
    return 0;
}



void ejsConfigureMemoryType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsGetTypeByName(ejs, N(EJS_EJS_NAMESPACE, "Memory"))) == 0) {
        mprError("Can't find Memory type");
        return;
    }
    ejsBindMethod(ejs, type, ES_Memory_allocated, getAllocatedMemory);
    ejsBindAccess(ejs, type, ES_Memory_maximum, getMaxMemory, setMaxMemory);
    ejsBindAccess(ejs, type, ES_Memory_redline, getRedline, setRedline);
    ejsBindMethod(ejs, type, ES_Memory_resident, getResident);
    ejsBindMethod(ejs, type, ES_Memory_system, getSystemRam);
    ejsBindMethod(ejs, type, ES_Memory_stats, printStats);

#if UNUSED
    EjsPot      *prototype;
    prototype = type->prototype;
    ejsBindAccess(ejs, type, ES_Memory_callback, NULL, setRedlineCallback);
#endif
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsMemory.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsNamespace.c"
 */
/************************************************************************/

/**
    ejsNamespace.c - Ejscript Namespace class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to the specified type
 */

static EjsAny *castNamespace(Ejs *ejs, EjsNamespace *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_String:
        return ejsCreateStringFromAsc(ejs, "[object Namespace]");

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsAny *invokeNamespaceOperator(Ejs *ejs, EjsNamespace *lhs, int opCode, EjsNamespace *rhs)
{
    bool        boolResult;

    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opCode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        }
        boolResult = ejsCompareString(ejs, lhs->value, rhs->value) == 0;
        break;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = lhs == rhs;
        break;

    case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opCode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        }
        boolResult = !(ejsCompareString(ejs, lhs->value, rhs->value) == 0);
        break;

    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        ejsThrowTypeError(ejs, "Operation is not valid on this type");
        return 0;
    }
    return ejsCreateBoolean(ejs, boolResult);
}


/*
    Define a reserved namespace in a block.
 */
EjsNamespace *ejsDefineReservedNamespace(Ejs *ejs, EjsBlock *block, EjsName *typeName, cchar *spaceName)
{
    EjsNamespace    *namespace;

    namespace = ejsCreateReservedNamespace(ejs, typeName, ejsCreateStringFromAsc(ejs, spaceName));
    if (namespace) {
        if (ejsAddNamespaceToBlock(ejs, block, namespace) < 0) {
            return 0;
        }
    }
    return namespace;
}


/*
    Format a reserved namespace to create a unique namespace. "internal, public, private, protected"

    Namespaces are formatted as strings using the following format, where type is optional. Types may be qualified.
        [type,space]

    Example:
        [debug::Shape,public] where Shape was declared as "debug class Shape"
 */
EjsString *ejsFormatReservedNamespace(Ejs *ejs, EjsName *typeName, EjsString *spaceName)
{
    EjsString   *namespace;

    if (typeName) {
        if (typeName->space && typeName->space == S(public)) {
            namespace = ejsSprintf(ejs, "[%N,%@]", *typeName, spaceName);
        } else {
            namespace = ejsSprintf(ejs, "[%@,%@]", typeName->name, spaceName);
        }
    } else {
        namespace = ejsSprintf(ejs, "[%@]", spaceName);
    }
    return namespace;
}


/*
    Create a namespace with the given Uri as its definition qualifying value.
 */
EjsNamespace *ejsCreateNamespace(Ejs *ejs, EjsString *name)
{
    EjsNamespace    *np;

    if ((np = ejsCreateObj(ejs, ST(Namespace), 0)) == 0) {
        return 0;
    }
    np->value = name;
    mprSetName(np, "namespace");
    return np;
}


/*
    Create a reserved namespace. Format the package, type and space names to create a unique namespace.
 */
EjsNamespace *ejsCreateReservedNamespace(Ejs *ejs, EjsName *typeName, EjsString *spaceName)
{
    EjsString       *formattedName;

    mprAssert(spaceName);

    if (typeName) {
        formattedName = ejsFormatReservedNamespace(ejs, typeName, spaceName);
    } else {
        formattedName = spaceName;
    }
    return ejsCreateNamespace(ejs, formattedName);
}


static void manageNamespace(EjsNamespace *ns, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ns->value);
    }
}


void ejsCreateNamespaceType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Namespace"), sizeof(EjsNamespace), S_Namespace, ES_Namespace_NUM_CLASS_PROP,
        manageNamespace, EJS_OBJ_HELPERS);
    type->helpers.cast = (EjsCastHelper) castNamespace;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeNamespaceOperator;
}


void ejsConfigureNamespaceType(Ejs *ejs)
{
    ejsSetProperty(ejs, ejs->global, ES_iterator, S(iteratorSpace));
    ejsSetProperty(ejs, ejs->global, ES_public, S(publicSpace));
    ejsSetProperty(ejs, ejs->global, ES_ejs, S(ejsSpace));
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsNamespace.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsNull.c"
 */
/************************************************************************/

/**
    ejsNull.c - Ejscript Null class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the null operand to a primitive type
 */

static EjsAny *castNull(Ejs *ejs, EjsObj *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return S(false);

    case S_Number:
        return S(zero);

    case S_Object:
    default:
        /*
            Cast null to anything else results in a null
         */
        return vp;

    case S_String:
        return ejsCreateStringFromAsc(ejs, "null");
    }
}


static EjsAny *coerceNullOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(zero), opcode, rhs);

    /*
        Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, S(zero), opcode, rhs);
        } else if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, Void)) {
            return S(false);
        }
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_EQ:
        if (ejsIs(ejs, rhs, Void)) {
            return S(true);
        }
        return S(false);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeNullOperator(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceNullOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
        Types now match. Both left and right types are both "null"
     */
    switch (opcode) {

    /*
        NOTE: strict eq is the same as eq
     */
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return S(one);

    /*
        Binary operators. Reinvoke with left = zero
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(zero), opcode, rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*
    iterator native function get(): Iterator
 */
static EjsIterator *getNullIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, NULL, 0, NULL);
}


static EjsObj *getNullProperty(Ejs *ejs, EjsNull *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*
    We dont actually allocate any nulls. We just reuse the singleton instance.
 */

EjsNull *ejsCreateNull(Ejs *ejs)
{
    return S(null);
}


void ejsCreateNullType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Null"), sizeof(EjsNull), S_Null, ES_Null_NUM_CLASS_PROP, 
        NULL, EJS_OBJ_HELPERS);

    type->helpers.cast             = (EjsCastHelper) castNull;
    type->helpers.getProperty      = (EjsGetPropertyHelper) getNullProperty;
    type->helpers.invokeOperator   = (EjsInvokeOperatorHelper) invokeNullOperator;

    ejsSetSpecial(ejs, S_null, ejsCreateObj(ejs, type, 0));
    mprSetName(S(null), "null");
}


void ejsConfigureNullType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Null);
    prototype = type->prototype;

    ejsSetProperty(ejs, ejs->global, ES_null, S(null));
    ejsBindMethod(ejs, prototype, ES_Null_iterator_get, getNullIterator);
    ejsBindMethod(ejs, prototype, ES_Null_iterator_getValues, getNullIterator);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsNull.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsNumber.c"
 */
/************************************************************************/

/**
    ejsNumber.c - Number type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define fixed(n) ((int64) (floor(n)))

/*
    Cast the operand to the specified type
 */
static EjsAny *castNumber(Ejs *ejs, EjsNumber *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ((vp->value) ? S(true) : S(false));

    case S_String:
        //  OPT. mprDtoa does a sclone.
        return ejsCreateStringFromAsc(ejs, mprDtoa(vp->value, 0, 0, 0));

    case S_Number:
        return vp;
            
    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsNumber *cloneNumber(Ejs *ejs, EjsNumber *np, int deep)
{
    return ejsCreateNumber(ejs, np->value);
}


static EjsAny *coerceNumberOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return S(nan);
        } else if (ejsIs(ejs, rhs, Null)) {
            return lhs;
        } else if (ejsIs(ejs, rhs, Boolean) || ejsIs(ejs, rhs, Date)) {
            return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));
        } else {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        } else if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsNumber*) lhs)->value ? S(true) : S(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsNumber*) lhs)->value ? S(false): S(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeNumberOperator(Ejs *ejs, EjsNumber *lhs, int opcode, EjsNumber *rhs)
{
    EjsObj      *result;

    mprAssert(lhs);
    
    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Number) || !ejsIs(ejs, rhs, Number)) {
            if ((result = coerceNumberOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match, both numbers
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ((lhs->value == rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ((lhs->value != rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_LT:
        return ((lhs->value < rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_LE:
        return ((lhs->value <= rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_GT:
        return ((lhs->value > rhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_GE:
        return ((lhs->value >= rhs->value) ? S(true): S(false));

    /*
     *  Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? S(true): S(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return S(false);

    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, -lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, !fixed(lhs->value));

    case EJS_OP_NOT:
        return ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));


    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return ejsCreateNumber(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        return ejsCreateNumber(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateNumber(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return ejsCreateNumber(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*
    Number constructor.
    function Number(value: Object = null)
 */
static EjsNumber *numberConstructor(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    EjsNumber   *num;

    mprAssert(argc == 0 || argc == 1);

    if (argc == 1) {
        num = ejsToNumber(ejs, argv[0]);
        if (num) {
            np->value = num->value;
        }
    }
    return np;
}


/*
    Function to iterate and return each number in sequence.
    NOTE: this is not a method of Number. Rather, it is a callback function for Iterator.
 */
static EjsNumber *nextNumber(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsNumber   *np;

    np = (EjsNumber*) ip->target;
    if (!ejsIs(ejs, np, Number)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < np->value) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    function integral(size: Number: 32): Number
 */
static EjsNumber *integral(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    int64   mask, result;
    int     size;

    size = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 32;

    result = ((int64) np->value);
    if (size < 64) {
        mask = 1;
        mask = (mask << size) - 1;
        result &= mask;
    }
    return ejsCreateNumber(ejs, (MprNumber) result);
}


/*
    function get isFinite(): Boolean
 */
static EjsBoolean *isFinite(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    if (np->value == ((EjsNumber*) S(nan))->value || np->value == ((EjsNumber*) S(infinity))->value || 
            np->value == ((EjsNumber*) S(negativeInfinity))->value) {
        return S(false);
    }
    return S(true);
}


/*
    function get isNaN(): Boolean
 */
static EjsBoolean *isNaN(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    return (mprIsNan(np->value) ? S(true) : S(false));
}


/*
    function toExponential(fractionDigits: Number = 0): String

    Display with only one digit before the decimal point.
 */
static EjsString *toExponential(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]): 0;
    result = mprDtoa(np->value, ndigits, MPR_DTOA_N_DIGITS, MPR_DTOA_EXPONENT_FORM);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    function toFixed(fractionDigits: Number = 0): String

    Display the specified number of fractional digits
 */
static EjsString *toFixed(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = mprDtoa(np->value, ndigits, MPR_DTOA_N_FRACTION_DIGITS, MPR_DTOA_FIXED_FORM);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    function toPrecision(numDigits: Number = MAX_VALUE): String

    Display the specified number of total digits
 */
static EjsString *toPrecision(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = mprDtoa(np->value, ndigits, MPR_DTOA_N_DIGITS, 0);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    Return the default iterator. This returns the index names.

    iterator native function get(): Iterator
 */
static EjsIterator *getNumberIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, nextNumber, 0, NULL);
}


/*
    Convert the number to a string.
    function toString(): String
 */
static EjsObj *numberToString(Ejs *ejs, EjsNumber *vp, int argc, EjsObj **argv)
{
    return castNumber(ejs, vp, ST(String));
}



#ifndef ejsIsNan
int ejsIsNan(double f)
{
#if BLD_WIN_LIKE
    return _isnan(f);
#elif VXWORKS
    /* TODO */
    return 0;
#else
    return (f == FP_NAN);
#endif
}
#endif


bool ejsIsInfinite(MprNumber f)
{
#if BLD_WIN_LIKE
    return !_finite(f);
#elif VXWORKS
    /* TODO */
    return 0;
#else
    return (f == FP_INFINITE);
#endif
}

/*
    Create an initialized number
 */

EjsNumber *ejsCreateNumber(Ejs *ejs, MprNumber value)
{
    EjsNumber   *vp;

    if (value == 0) {
        return S(zero);
    } else if (value == 1) {
        return S(one);
    } else if (value == -1) {
        return S(minusOne);
    }
    if ((vp = ejsCreateObj(ejs, ST(Number), 0)) != 0) {
        vp->value = value;
    }
    return vp;
}


void ejsCreateNumberType(Ejs *ejs)
{
    EjsNumber   *np;
    EjsType     *type;
    static int  zero = 0;

    type = ejsCreateNativeType(ejs, N("ejs", "Number"), sizeof(EjsNumber), S_Number, ES_Number_NUM_CLASS_PROP, 
        NULL, EJS_OBJ_HELPERS);

    type->helpers.cast = (EjsCastHelper) castNumber;
    type->helpers.clone = (EjsCloneHelper) cloneNumber;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeNumberOperator;

    np = ejsCreateObj(ejs, type, 0);
    np->value = 0;
    ejsSetSpecial(ejs, S_zero, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1;
    ejsSetSpecial(ejs, S_one, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = -1;
    ejsSetSpecial(ejs, S_minusOne, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1.0 / zero;
    ejsSetSpecial(ejs, S_infinity, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = -1.0 / zero;
    ejsSetSpecial(ejs, S_negativeInfinity, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 0.0 / zero;
    ejsSetSpecial(ejs, S_nan, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1.7976931348623157e+308;
    ejsSetSpecial(ejs, S_max, np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 5e-324;
    ejsSetSpecial(ejs, S_min, np);
}


void ejsConfigureNumberType(Ejs *ejs)
{
    EjsType    *type;
    EjsPot     *prototype;

    type = ST(Number);
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, numberConstructor);
    ejsBindMethod(ejs, prototype, ES_Number_iterator_get, getNumberIterator);
    ejsBindMethod(ejs, prototype, ES_Number_iterator_getValues, getNumberIterator);
    ejsBindMethod(ejs, prototype, ES_Number_integral, integral);
    ejsBindMethod(ejs, prototype, ES_Number_isFinite, isFinite);
    ejsBindMethod(ejs, prototype, ES_Number_isNaN, isNaN);
    ejsBindMethod(ejs, prototype, ES_Number_toExponential, toExponential);
    ejsBindMethod(ejs, prototype, ES_Number_toFixed, toFixed);
    ejsBindMethod(ejs, prototype, ES_Number_toPrecision, toPrecision);
    ejsBindMethod(ejs, prototype, ES_Number_toString, numberToString);

    ejsSetProperty(ejs, type, ES_Number_MaxValue, S(max));
    ejsSetProperty(ejs, type, ES_Number_MinValue, S(min));
    ejsSetProperty(ejs, type, ES_Number_NEGATIVE_INFINITY, S(negativeInfinity));
    ejsSetProperty(ejs, type, ES_Number_POSITIVE_INFINITY, S(infinity));
    ejsSetProperty(ejs, type, ES_Number_NaN, S(nan));

    ejsSetProperty(ejs, ejs->global, ES_NegativeInfinity, S(negativeInfinity));
    ejsSetProperty(ejs, ejs->global, ES_Infinity, S(infinity));
    ejsSetProperty(ejs, ejs->global, ES_NaN, S(nan));
    ejsSetProperty(ejs, ejs->global, ES_double, type);
    ejsSetProperty(ejs, ejs->global, ES_num, type);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsNumber.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsObject.c"
 */
/************************************************************************/

/**
    ejsObject.c - Object class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj   *obj_defineProperty(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv);

/*
    function get constructor(): Object
 */
static EjsType *obj_constructor(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsType     *constructor;

    if ((constructor = ejsGetPropertyByName(ejs, obj, EN("constructor"))) != 0) {
        return constructor;
    }
    return TYPE(obj);
}


/*
    function get prototype(): Object

    The prototype method is special. It is declared as static so it is generated in the type slots, but it is
    patched to be an instance method so the value of "this" will be preserved when it is invoked.
 */
static EjsAny *obj_prototype(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsType         *type;
    EjsPot          *prototype;

    if (ejs->compiling) {
        mprAssert(0);
        prototype = S(undefined);
        
    } else if (ejsIsType(ejs, obj)) {
        prototype = ((EjsType*) obj)->prototype;
        
    } else if (ejsIsFunction(ejs, obj)) {
        fun = (EjsFunction*) obj;
        if (fun->archetype) {
            prototype = fun->archetype->prototype;
        
        } else {
            type = ejsCreateArchetype(ejs, fun, NULL);
            prototype = type->prototype;
        }
    } else {
        prototype = S(undefined);
    }
    return prototype;
}


/*
    function set prototype(p: Object): Void
 */
static EjsObj *obj_set_prototype(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsPot          *prototype;
    EjsFunction     *fun;

    if (ejs->compiling) {
        mprAssert(0);
        return S(undefined);
    }
    prototype = (EjsPot*) argv[0];
    if (ejsIsType(ejs, obj)) {
        ((EjsType*) obj)->prototype = prototype;
    } else {
        if (ejsIsFunction(ejs, obj)) {
            fun = (EjsFunction*) obj;
            if (ejsIsType(ejs, fun->archetype)) {
                fun->archetype->prototype = prototype;
            } else {
                ejsCreateArchetype(ejs, fun, prototype);
            }
        } else {
            /*
                Normal property creation. This "prototype" property is not used internally.
             */
            ejsSetPropertyByName(ejs, obj, EN("prototype"), prototype);
        }
    }
    return 0;
}


/*
    function clone(deep: Boolean = true) : Object
 */
static EjsObj *obj_clone(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    bool    deep;

    deep = (argc == 1 && argv[0] == S(true));
    return ejsClone(ejs, obj, deep);
}


/*
    static function create(proto: Object, props: Object = undefined): Objectd 
 */
static EjsObj *obj_create(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *constructor;
    EjsObj          *obj, *properties, *options;
    EjsPot          *prototype;
    EjsType         *type;
    EjsName         qname;
    int             count, slotNum;

    prototype = (EjsPot*) argv[0];
    properties = (argc >= 1) ? argv[1] : 0;

    if (ejsIsType(ejs, prototype)) {
        type = (EjsType*) prototype;
    } else {
        constructor = ejsGetPropertyByName(ejs, prototype, EN("constructor"));
        if (constructor) {
            if (ejsIsType(ejs, constructor)) {
                type = (EjsType*) constructor;
            } else if (ejsIsFunction(ejs, constructor)) {
                if (constructor->archetype == 0) {
                    if ((type = ejsCreateArchetype(ejs, constructor, prototype)) == 0) {
                        return 0;
                    }
                }
                type = constructor->archetype;
            } else {
                ejsThrowTypeError(ejs, "Bad type for the constructor property. Must be a function or type");
                return 0;
            }

        } else {
            if ((type = ejsCreateArchetype(ejs, NULL, prototype)) == 0) {
                return 0;
            }
            ejsSetPropertyByName(ejs, prototype, EN("constructor"), type);
        }
    }
    obj = ejsCreateObj(ejs, type, 0);
    if (properties) {
        count = ejsGetPropertyCount(ejs, properties);
        for (slotNum = 0; slotNum < count; slotNum++) {
            qname = ejsGetPropertyName(ejs, properties, slotNum);
            options = ejsGetProperty(ejs, properties, slotNum);
            argv[0] = obj;
            argv[1] = (EjsObj*) qname.name;
            argv[2] = options;
            obj_defineProperty(ejs, (EjsObj*) type, 3, argv);
        }
    }
    return obj;
}


/*
    static function defineProperty(obj: Object, prop: String, options: Object): Void
*/
static EjsObj *obj_defineProperty(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun, *get, *set;
    EjsType         *type;
    EjsObj          *obj, *options, *configurable, *enumerable, *namespace, *value, *writable;
    EjsName         qname;
    int             attributes, slotNum;

    mprAssert(argc == 3);

    obj = argv[0];
    if (!ejsIsPot(ejs, obj)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return NULL;
    }
    qname.name = (EjsString*) argv[1];
    qname.space = S(empty);
    options = argv[2];
    value = 0;
    set = get = 0;
    attributes = 0;

    if ((namespace = ejsGetPropertyByName(ejs, options, EN("namespace"))) != 0) {
        qname.space = (EjsString*) namespace;
    }
    if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
        if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_FIXED)) {
            ejsThrowTypeError(ejs, "Property \"%N\" is not configurable", qname);
            return 0;
        }
    }
    type = ejsGetPropertyByName(ejs, options, EN("type"));

    if ((configurable = ejsGetPropertyByName(ejs, options, EN("configurable"))) != 0) {
        if (configurable == S(false)) {
            attributes |= EJS_TRAIT_FIXED;
        }
    }
    if ((enumerable = ejsGetPropertyByName(ejs, options, EN("enumerable"))) != 0) {
        if (enumerable == S(false)) {
            attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    value = ejsGetPropertyByName(ejs, options, EN("value"));
    if (value && type && !ejsIsA(ejs, value, type)) {
        ejsThrowArgError(ejs, "Value is not of the required type");
        return 0;
    }
    if ((get = ejsGetPropertyByName(ejs, options, EN("get"))) != 0) {
        if (ejsIsFunction(ejs, get)) {
            EjsName qset = { qname.space, ejsCreateStringFromAsc(ejs, "set") };
            get->setter = ejsGetPropertyByName(ejs, obj, qset);
            attributes |= EJS_TRAIT_GETTER;
        } else {
            ejsThrowArgError(ejs, "The \"get\" property is not a function");
            return 0;
        }
    }
    if ((set = ejsGetPropertyByName(ejs, options, EN("set"))) != 0) {
        if (ejsIsFunction(ejs, set)) {
            if (get == 0 && (fun = ejsGetPropertyByName(ejs, obj, qname)) != 0) {
                get = fun;
            }
            if (get) {
                get->setter = set;
            }
        } else {
            ejsThrowArgError(ejs, "The \"set\" property is not a function");
            return 0;
        }
        attributes |= EJS_TRAIT_SETTER;
    }
    if (value && (get || set)) {
        ejsThrowArgError(ejs, "Can't provide a value and getters or setters");
        return 0;
    }
    if (get) {
        value = (EjsObj*) get;
    }
    if ((writable = ejsGetPropertyByName(ejs, options, EN("writable"))) != 0) {
        if (writable == S(false)) {
            attributes |= EJS_TRAIT_READONLY;
        }
    }
    mprAssert((attributes & EJS_TRAIT_MASK) == attributes);
    if (ejsDefineProperty(ejs, obj, -1, qname, type, attributes, value) < 0) {
        ejsThrowTypeError(ejs, "Can't define property %@", qname.name);
    }
    return 0;
}


/*
    static function freeze(obj: Object): Void
 */
static EjsObj *obj_freeze(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         slotNum, numProp;

    obj = (EjsObj*) argv[0];
    SET_DYNAMIC(obj, 0);
    numProp = ejsGetPropertyCount(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            ejsSetPropertyTraits(ejs, obj, slotNum, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
        }
    }
    if (ejsIsType(ejs, obj)) {
        obj = (EjsObj*) ((EjsType*) obj)->prototype;
        numProp = ejsGetPropertyCount(ejs, obj);
        for (slotNum = 0; slotNum < numProp; slotNum++) {
            if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
                ejsSetPropertyTraits(ejs, obj, slotNum, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
            }
        }
    }
    return 0;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator.
 */
static EjsObj *nextObjectKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsName     qname;
    EjsTrait    *trait;
    int         numProp;

    obj = ip->target;
    numProp = ejsGetPropertyCount(ejs, obj);
    for (; ip->index < numProp; ip->index++) {
        qname = ejsGetPropertyName(ejs, obj, ip->index);
        if (qname.name == NULL) {
            continue;
        }
        trait = ejsGetPropertyTraits(ejs, obj, ip->index);
        if (trait && trait->attributes & 
                (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
            continue;
        }
        ip->index++;
        return (EjsObj*) qname.name;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator.

    iterator function get(options: Object = null): Iterator
 */
static EjsIterator *obj_get(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, obj, nextObjectKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator
 */
static EjsObj *nextObjectValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         numProp;

    obj = ip->target;
    numProp = ejsGetPropertyCount(ejs, obj);
    for (; ip->index < numProp; ip->index++) {
        trait = ejsGetPropertyTraits(ejs, obj, ip->index);
        if (trait && trait->attributes & 
                (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
            continue;
        }
        return ejsGetProperty(ejs, obj, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator function getValues(options: Object = null): Iterator
 */
static EjsIterator *obj_getValues(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, obj, nextObjectValue, 0, NULL);
}


/*
    Get the number of properties in the object.

    function get getOwnPropertyCount(obj): Number
 */
static EjsNumber *obj_getOwnPropertyCount(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return ejsCreateNumber(ejs, ejsGetPropertyCount(ejs, obj) - TYPE(obj)->numInherited);
}


/*
    static function getOwnPropertyDescriptor(obj: Object, prop: String): Object
 */
static EjsObj *obj_getOwnPropertyDescriptor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsTrait        *trait;
    EjsObj          *obj, *result, *value;
    EjsName         qname, qn;
    EjsType         *type;
    EjsLookup       lookup;
    int             slotNum;

    obj = argv[0];
    //  TODO - ugly
    qname.space = S(empty);
    qname.name = (EjsString*) argv[1];
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup)) < 0) {
        return S(false);
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    result = ejsCreateEmptyPot(ejs);
    value = ejsGetVarByName(ejs, obj, qname, &lookup);
    if (value == 0) {
        value = S(null);
    }
    type = (trait) ? trait->type: 0;
    if (trait && trait->attributes & EJS_TRAIT_GETTER) {
        ejsSetPropertyByName(ejs, result, EN("get"), value);
    } else if (trait && trait->attributes & EJS_TRAIT_SETTER) {
        fun = (EjsFunction*) value;
        if (ejsIsFunction(ejs, fun)) {
            ejsSetPropertyByName(ejs, result, EN("set"), fun->setter);
        }
    } else if (value) {
        ejsSetPropertyByName(ejs, result, EN("value"), value);
    }
    ejsSetPropertyByName(ejs, result, EN("configurable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_FIXED)));
    ejsSetPropertyByName(ejs, result, EN("enumerable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN)));
    qn = ejsGetPropertyName(ejs, obj, slotNum);
    ejsSetPropertyByName(ejs, result, EN("namespace"), qn.space);
    ejsSetPropertyByName(ejs, result, EN("type"), type ? (EjsObj*) type : S(null));
    ejsSetPropertyByName(ejs, result, EN("writable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_READONLY)));
    return result;
}


/*
    Get all properties names including non-enumerable properties

    static function getOwnPropertyNames(obj: Object, options: Object): Array
 */
static EjsArray *obj_getOwnPropertyNames(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj, *options, *arg;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         slotNum, numProp, index, includeBases, excludeFunctions;

    obj = (EjsObj*) argv[0];
    includeBases = 0;
    excludeFunctions = 0;
    if (argc > 0) {
        options = argv[1];
        if ((arg = ejsGetPropertyByName(ejs, options, EN("includeBases"))) != 0) {
            includeBases = (arg == S(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("excludeFunctions"))) != 0) {
            excludeFunctions = (arg == S(true));
        }
    }
    if ((result = ejsCreateArray(ejs, 0)) == 0) {
        return 0;
    }
    index = 0;
    slotNum = (includeBases) ? 0 : TYPE(obj)->numInherited;
    numProp = ejsGetPropertyCount(ejs, obj);
    for (; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (trait->attributes & (EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
                continue;
            }
        }
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        if (excludeFunctions && ejsIsFunction(ejs, ejsGetProperty(ejs, obj, slotNum))) {
            continue;
        }
        ejsSetProperty(ejs, result, index++, qname.name);
    }
    if (ejsIsType(ejs, obj) || ejsIsFunction(ejs, obj)) {
        if (ejsLookupProperty(ejs, obj, EN("prototype")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "prototype"));
        }
        if (ejsLookupProperty(ejs, obj, EN("length")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "length"));
        }
    } else if (ejsIsPrototype(ejs, obj)) {
        if (ejsLookupProperty(ejs, obj, EN("constructor")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "constructor"));
        }
    }
    return result;
}


//  MOB - is this really a type?
/*
    static function getOwnPrototypeOf(obj: Object): Type
 */
static EjsType *obj_getOwnPrototypeOf(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return (EjsType*) TYPE(obj)->prototype;
}


/*
    function hasOwnProperty(name: String): Boolean
 */
static EjsBoolean *obj_hasOwnProperty(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsName     qname;
    EjsLookup   lookup;
    int         slotNum;

    qname.space = S(empty);
    qname.name = (EjsString*) argv[0];
    slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup);
    return ejsCreateBoolean(ejs, slotNum >= 0);
}


/*
    static function isExtensible(obj: Object): Boolean
 */
static EjsBoolean *obj_isExtensible(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return ejsCreateBoolean(ejs, DYNAMIC(obj));
}


/*
    static function isFrozen(obj: Object): Boolean
 */
static EjsBoolean *obj_isFrozen(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsPot      *obj;
    int         numProp, frozen, slotNum;

    obj = (EjsPot*) argv[0];
    frozen = 1;
    numProp = ejsGetPropertyCount(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_READONLY)) {
                frozen = 0;
                break;
            }
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                frozen = 0;
                break;
            }
        }
    }
    if (DYNAMIC(obj)) {
        frozen = 0;
    }
    return ejsCreateBoolean(ejs, frozen);
}


/*
    static function isPrototypeOf(obj: Object): Boolean
 */
static EjsBoolean *obj_isPrototypeOf(Ejs *ejs, EjsObj *prototype, int argc, EjsObj **argv)
{
    EjsObj  *obj;
    
    obj = argv[0];
    return (prototype == ((EjsObj*) TYPE(obj)->prototype)) ? S(true) : S(false);
}


/*
    static function isSealed(obj: Object): Boolean
 */
static EjsBoolean *obj_isSealed(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsPot      *obj;
    int         numProp, sealed, slotNum;

    obj = (EjsPot*) argv[0];
    sealed = 1;
    numProp = ejsGetPropertyCount(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                sealed = 0;
                break;
            }
        }
    }
    if (DYNAMIC(obj)) {
        sealed = 0;
    }
    return ejsCreateBoolean(ejs, sealed);
}


#if FUTURE
/*
    Get enumerable properties names

    static function keys(obj: Object): Array
 */
static EjsArray *obj_keys(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj, *vp;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         numProp, slotNum;

    obj = argv[0];
    numProp = ejsGetPropertyCount(ejs, obj);
    if ((result = ejsCreateArray(ejs, numProp)) == 0) {
        return 0;
    }
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (trait->attributes & EJS_TRAIT_DELETED) {
                continue;
            }
        }
        vp = ejsGetProperty(ejs, obj, slotNum);
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        ejsSetProperty(ejs, result, slotNum, ejsCreateStringFromAsc(ejs, qname.name));
    }
    return result;
}
#endif


/*
    static function preventExtensions(obj: Object): Object
 */
static EjsObj *obj_preventExtensions(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    SET_DYNAMIC(obj, 0);
    return obj;
}


/*
    static function seal(obj: Object): Void
*/
static EjsObj *obj_seal(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         slotNum, numProp;

    obj = argv[0];
    numProp = ejsGetPropertyCount(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            trait->attributes |= EJS_TRAIT_FIXED;
        }
    }
    SET_DYNAMIC(obj, 0);
    return 0;
}


/*
    function propertyIsEnumerable(property: String, flag: Object = undefined): Boolean
 */
static EjsBoolean *obj_propertyIsEnumerable(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsName     qname;
    EjsLookup   lookup;
    int         slotNum;

    mprAssert(argc == 1 || argc == 2);

    qname.space = S(empty);
    qname.name = (EjsString*) argv[0];
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup)) < 0) {
        return S(false);
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    return ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN));
}


/*
    Convert the object to a JSON string. This also handles Json for Arrays.

    function toJSON(options: Object = null): String
 */
EjsString *ejsObjToJSON(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return ejsSerialize(ejs, vp, (argc == 1) ? argv[0] : NULL);
}


#if ES_Object_toLocaleString
/*
    Convert the object to a localized string

    function toLocaleString(): String
 */
static EjsString *toLocaleString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return ejsObjToString(ejs, vp, argc, argv);
}
#endif


EjsString *ejsObjToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    if (ejsIs(ejs, vp, String)) {
        return (EjsString*) vp;
    }
    return (ejs->objHelpers.cast)(ejs, vp, ST(String));
}


/*
    Get the base class of a type object.

    function getBaseType(obj: Type): Type
 */
static EjsType *obj_getBaseType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = argv[0];
    if (ejsIsType(ejs, vp)) {
        return (((EjsType*) vp)->baseType);
    }
    return S(null);
}


/*
    function isPrototype(obj: Object): Boolean
 */
static EjsBoolean *obj_isPrototype(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejsIsPrototype(ejs, argv[0]));
}


/*
    function isType(obj: Object): Boolean
 */
static EjsBoolean *obj_isType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejsIsType(ejs, argv[0]));
}


/*
    Get the type of the object.

    function getType(obj: Object): Type
 */
static EjsType *obj_getType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return TYPE(obj);
}


/*
    Return the name of the type of an object. If the obj is a type, get the base type.
 */
EjsString *ejsGetTypeName(Ejs *ejs, EjsAny *obj)
{
    EjsType     *type;

    if (obj == 0) {
        return S(undefined);
    }
    type = (EjsType*) TYPE(obj);
    if (type == 0) {
        return S(null);
    }
    return type->qname.name;
}


/*
    function getTypeName(obj): String
 */
static EjsString *obj_getTypeName(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    mprAssert(argc >= 1);
    return ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the name of a function or type object

    function getName(obj: Object): String
 */
static EjsString *obj_getName(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];

    if (ejsIsType(ejs, obj)) {
        return ((EjsType*) obj)->qname.name;
    } else if (ejsIsFunction(ejs, obj)) {
        return ((EjsFunction*) obj)->name;
    }
    return S(empty);
}

/*
    function typeOf(obj): String
 */
static EjsString *obj_typeOf(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    mprAssert(argc >= 1);
    return ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the ecma "typeof" value for an object. Unfortunately, typeof is pretty lame.
 */
EjsString *ejsGetTypeOf(Ejs *ejs, EjsAny *vp)
{
    cchar   *word;

    if (vp == S(undefined)) {
        word = "undefined";

    } else if (ejsIs(ejs, vp, Null)) {
        /* Yea - I know, ECMAScript is broken */
        word = "object";

    } else if (ejsIs(ejs, vp, Boolean)) {
        word = "boolean";

    } else if (ejsIs(ejs, vp, Number)) {
        word = "number";

    } else if (ejsIs(ejs, vp, String)) {
        word = "string";

    } else if (ejsIs(ejs, vp, Function)) {
        word = "function";
               
    } else {
        word = "object";
    }
    return ejsCreateStringFromAsc(ejs, word);
}


void ejsConfigureObjectType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;
    EjsFunction *fun;

    type = ST(Object);
    type->mutableInstances = 1;
    prototype = type->prototype;

    ejsBindMethod(ejs, type, ES_Object_create, obj_create);
    ejsBindMethod(ejs, type, ES_Object_defineProperty, obj_defineProperty);
    ejsBindMethod(ejs, type, ES_Object_freeze, obj_freeze);
    ejsBindMethod(ejs, type, ES_Object_getOwnPropertyCount, obj_getOwnPropertyCount);
    ejsBindMethod(ejs, type, ES_Object_getOwnPropertyDescriptor, obj_getOwnPropertyDescriptor);
    ejsBindMethod(ejs, type, ES_Object_getOwnPropertyNames, obj_getOwnPropertyNames);
    ejsBindMethod(ejs, type, ES_Object_getOwnPrototypeOf, obj_getOwnPrototypeOf);
    ejsBindMethod(ejs, type, ES_Object_isExtensible, obj_isExtensible);
    ejsBindMethod(ejs, type, ES_Object_isFrozen, obj_isFrozen);
    ejsBindMethod(ejs, type, ES_Object_isSealed, obj_isSealed);
    ejsBindMethod(ejs, type, ES_Object_preventExtensions, obj_preventExtensions);
    ejsBindAccess(ejs, type, ES_Object_prototype, obj_prototype, obj_set_prototype);
    ejsBindMethod(ejs, type, ES_Object_seal, obj_seal);

    /* Reflection */
    ejsBindMethod(ejs, type, ES_Object_getBaseType, obj_getBaseType);
    ejsBindMethod(ejs, type, ES_Object_getType, obj_getType);
    ejsBindMethod(ejs, type, ES_Object_getTypeName, obj_getTypeName);
    ejsBindMethod(ejs, type, ES_Object_getName, obj_getName);
    ejsBindMethod(ejs, type, ES_Object_isPrototype, obj_isPrototype);
    ejsBindMethod(ejs, type, ES_Object_isType, obj_isType);

    ejsBindMethod(ejs, prototype, ES_Object_constructor, obj_constructor);
    ejsBindMethod(ejs, prototype, ES_Object_clone, obj_clone);
    ejsBindMethod(ejs, prototype, ES_Object_iterator_get, obj_get);
    ejsBindMethod(ejs, prototype, ES_Object_iterator_getValues, obj_getValues);
    ejsBindMethod(ejs, prototype, ES_Object_hasOwnProperty, obj_hasOwnProperty);
    ejsBindMethod(ejs, prototype, ES_Object_isPrototypeOf, obj_isPrototypeOf);
    ejsBindMethod(ejs, prototype, ES_Object_propertyIsEnumerable, obj_propertyIsEnumerable);
    ejsBindMethod(ejs, prototype, ES_Object_toLocaleString, toLocaleString);
    ejsBindMethod(ejs, prototype, ES_Object_toString, ejsObjToString);
    ejsBindMethod(ejs, prototype, ES_Object_toJSON, ejsObjToJSON);

    ejsBindFunction(ejs, ejs->global, ES_typeOf, obj_typeOf);

    /*
        The prototype method is special. It is declared as static so it is generated in the type slots, but it is
        patched to be an instance method so the value of "this" will be preserved when it is invoked.
     */
    fun = ejsGetProperty(ejs, type, ES_Object_prototype);
    fun->staticMethod = 0;
    fun->setter->staticMethod = 0;
    type->constructor.block.pot.properties->slots[ES_Object_prototype].trait.attributes &= ~EJS_PROP_STATIC;
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsObject.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsPath.c"
 */
/************************************************************************/

/*
    ejsPath.c - Path class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static cchar *getPathString(Ejs *ejs, EjsObj *vp);


static EjsAny *castPath(Ejs *ejs, EjsPath *fp, EjsType *type)
{
    if (type->sid == S_String) {
        return ejsCreateStringFromAsc(ejs, fp->value);
    }
    return (ejs->potHelpers.cast)(ejs, fp, type);
}


static EjsPath *clonePath(Ejs *ejs, EjsPath *src, bool deep)
{
    return ejsCreatePathFromAsc(ejs, src->value);
}


static EjsAny *coercePathOperands(Ejs *ejs, EjsPath *lhs, int opcode,  EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, lhs->value), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        }
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, lhs->value), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return S(true);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return S(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokePathOperator(Ejs *ejs, EjsPath *lhs, int opcode,  EjsPath *rhs, void *data)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coercePathOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*  Types now match, both paths
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->value == rhs->value)) {
            return S(true);
        }
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) == 0);

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) != 0);

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? S(true): S(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return S(false);

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsCreatePathFromAsc(ejs, mprJoinPath(lhs->value, rhs->value));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Constructor
    function Path(path: String)
 */
static EjsPath *pathConstructor(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1);
    if ((path = getPathString(ejs, argv[0])) == 0) {
        return fp;
    }
    fp->value = path;
    return fp;
}


/*
    Return an absolute path name for the file
    function get absolute(): Path
 */
static EjsPath *absolutePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAbsPath(fp->value));
}


/*
    Get when the file was last accessed.
    function get accessed(): Date
 */
static EjsDate *getAccessedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return S(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.atime) * 1000);
}


/*
    Get the base name of a file
    function basename(): Path
 */
static EjsPath *getPathBasename(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetPathBase(fp->value));
}


/*
    Get the path components
    function components(): Array
 */
static EjsArray *getPathComponents(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    EjsArray        *ap;
    char            *cp, *last;
    int             index;

    fs = mprLookupFileSystem(fp->value);
    ap = ejsCreateArray(ejs, 0);
    index = 0;
    for (last = cp = mprGetAbsPath(fp->value); *cp; cp++) {
        if (*cp == fs->separators[0] || *cp == fs->separators[1]) {
            *cp++ = '\0';
            ejsSetProperty(ejs, ap, index++, ejsCreateStringFromAsc(ejs, last));
            last = cp;
        }
    }
    if (cp > last) {
        ejsSetProperty(ejs, ap, index++, ejsCreateStringFromAsc(ejs, last));
    }
    return ap;
}


/*
    Copy a file
    function copy(to: Object, options: Object = null): Void
    TODO - not implementing copy options parameter.
 */
static EjsObj *copyPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *from, *to;
    cchar       *toPath;
    ssize       bytes;
    char        *buf;

    mprAssert(argc == 1);

    from = to = 0;
    if ((toPath = getPathString(ejs, argv[0])) == 0) {
        return 0;
    }
    from = mprOpenFile(fp->value, O_RDONLY | O_BINARY, 0);
    if (from == 0) {
        ejsThrowIOError(ejs, "Cant open %s", fp->value);
        return 0;
    }
    to = mprOpenFile(toPath, O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, EJS_FILE_PERMS);
    if (to == 0) {
        ejsThrowIOError(ejs, "Cant create %s", toPath);
        mprCloseFile(from);
        return 0;
    }
    if ((buf = mprAlloc(MPR_BUFSIZE)) == NULL) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(to);
        mprCloseFile(from);
        return 0;
    }
    while ((bytes = mprReadFile(from, buf, MPR_BUFSIZE)) > 0) {
        if (mprWriteFile(to, buf, bytes) != bytes) {
            ejsThrowIOError(ejs, "Write error to %s", toPath);
            break;
        }
    }
    mprCloseFile(from);
    mprCloseFile(to);
    return 0;
}


/*
    Return when the file was created.
    function get created(): Date
 */
static EjsDate *getCreatedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return S(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.ctime) * 1000);
}


/**
    Get the directory name portion of a file.
    function get dirname(): Path
 */
static EjsPath *getPathDirname(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsPath*) ejsCreatePathFromAsc(ejs, mprGetPathDir(fp->value));
}


/*
    Test to see if this file exists.
    function get exists(): Boolean
 */
static EjsBoolean *getPathExists(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    return ejsCreateBoolean(ejs, mprGetPathInfo(fp->value, &info) == 0);
}


/*
    Get the file extension portion of the file name.
    function get extension(): String
 */
static EjsString *getPathExtension(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *ext;

    if ((ext = mprGetPathExtension(fp->value)) == 0) {
        return S(empty);
    }
    return ejsCreateStringFromAsc(ejs, ext);
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsAny *nextPathKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;

    fp = (EjsPath*) ip->target;
    if (!ejsIs(ejs, fp, Path)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListLength(fp->files)) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator for use with "for ... in". This will iterate over the files in a directory.
    iterator function get(): Iterator
 */
static EjsAny *getPathIterator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    fp->files = mprGetPathFiles(fp->value, 0);
    return ejsCreateIterator(ejs, fp, nextPathKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsAny *nextPathValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;
    MprDirEntry *dp;

    fp = (EjsPath*) ip->target;
    if (!ejsIs(ejs, fp, Path)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListLength(fp->files)) {
        dp = (MprDirEntry*) mprGetItem(fp->files, ip->index++);
        return ejsCreatePathFromAsc(ejs, dp->name);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator function getValues(): Iterator
 */
static EjsAny *getPathValues(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    fp->files = mprGetPathFiles(fp->value, 0);
    return ejsCreateIterator(ejs, fp, nextPathValue, 0, NULL);
}


/*
    Get the files in a directory.
    function getFiles(enumDirs: Boolean = false): Array

    TODO - need pattern to match (what about "." and ".." and ".*")
    TODO - move this functionality into mprFile (see appweb dirHandler.c)
 */
static EjsArray *getPathFiles(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray        *array;
    MprList         *list;
    MprDirEntry     *dp;
    char            *path;
    bool            enumDirs, noPath;
    int             next;

    mprAssert(argc == 0 || argc == 1);
    enumDirs = (argc == 1) ? ejsGetBoolean(ejs, argv[0]): 0;

    array = ejsCreateArray(ejs, 0);
    if (array == 0) {
        return 0;
    }
    list = mprGetPathFiles(fp->value, enumDirs);
    if (list == 0) {
        ejsThrowIOError(ejs, "Can't read directory");
        return 0;
    }
    noPath = (fp->value[0] == '.' && fp->value[1] == '\0') || 
        (fp->value[0] == '.' && fp->value[1] == '/' && fp->value[2] == '\0');

    for (next = 0; (dp = mprGetNextItem(list, &next)) != 0; ) {
        if (strcmp(dp->name, ".") == 0 || strcmp(dp->name, "..") == 0) {
            continue;
        }
        if (enumDirs || !(dp->isDir)) {
            if (noPath) {
                ejsSetProperty(ejs, array, -1, ejsCreatePathFromAsc(ejs, dp->name));
            } else {
                /*
                    Prepend the directory name
                 */
                path = mprJoinPath(fp->value, dp->name);
                ejsSetProperty(ejs, array, -1, ejsCreatePathFromAsc(ejs, path));
            }
        }
    }
    return array;
}


#if FUTURE
static EjsObj *fileSystem(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    //  TODO
    return 0;
}
#endif


/*
    Determine if the file path has a drive spec (C:) in the file name
    static function hasDrive(): Boolean
 */
static EjsBoolean *pathHasDrive(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, 
        (isalpha((int) fp->value[0]) && fp->value[1] == ':' && (fp->value[2] == '/' || fp->value[2] == '\\')));
}


/*
    function get isAbsolute(): Boolean
 */
static EjsBoolean *isPathAbsolute(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (mprIsAbsPath(fp->value) ? S(true): S(false));
}


/*
    Determine if the file name is a directory
    function get isDir(): Boolean
 */
static EjsBoolean *isPathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}


/*
    function get isLink(): Boolean
 */
static EjsBoolean *isPathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isLink);
}


/*
    Determine if the file name is a regular file
    function get isRegular(): Boolean
 */
static EjsBoolean *isPathRegular(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, info.isReg);
}


/*
    function get isRelative(): Boolean
 */
static EjsBoolean *isPathRelative(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (mprIsRelPath(fp->value) ? S(true): S(false));
}


/*
    Join path segments. Returns a normalized path.
    function join(...others): Path
 */
static EjsPath *joinPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    cchar       *other, *result;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp->value;
    for (i = 0; i < args->length; i++) {
        if ((other = getPathString(ejs, ejsGetProperty(ejs, args, i))) == NULL) {
            return 0;
        }
        result = mprJoinPath(result, other);
    }
    return ejsCreatePathFromAsc(ejs, result);
}


/*
    Join extension
  
    function joinExt(ext: String): Path
 */
static EjsPath *joinPathExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *ext;

    if (mprGetPathExtension(fp->value)) {
        return fp;
    }
    ext = ejsToMulti(ejs, argv[0]);
    while (ext && *ext == '.') {
        ext++;
    }
    return ejsCreatePathFromAsc(ejs, sjoin(fp->value, ".", ext, NULL));
}


/*
    Get the length of the path name.
  
    override function get length(): Number
 */
static EjsNumber *pathLength(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) strlen(fp->value));
}


/*
    function get linkTarget(): Path
 */
static EjsPath *pathLinkTarget(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetPathLink(fp->value)) == 0) {
        return S(null);
    }
    return ejsCreatePathFromAsc(ejs, mprGetPathLink(fp->value));
}


/*
    function makeDir(options: Object = null): Void
  
    Options: permissions, owner, group
 */
static EjsObj *makePathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    EjsObj      *options, *permissions;
#if FUTURE
    EjsObj      *owner, *group;
    cchar       *ownerName, *groupName;
#endif
    int         perms;
    
    perms = 0755;

    if (argc == 1) {
        options = argv[0];

        permissions = ejsGetPropertyByName(ejs, options, N(EJS_PUBLIC_NAMESPACE, "permissions"));
#if FUTURE
        owner = ejsGetPropertyByName(ejs, options, N(EJS_PUBLIC_NAMESPACE, "owner"));
        group = ejsGetPropertyByName(ejs, options, N(EJS_PUBLIC_NAMESPACE, "group"));
#endif
        if (permissions) {
            perms = ejsGetInt(ejs, permissions);
        }
    }
    if (mprGetPathInfo(fp->value, &info) == 0 && info.isDir) {
        return 0;
    }
    if (mprMakeDir(fp->value, perms, 1) < 0) {
        ejsThrowIOError(ejs, "Cant create directory %s", fp->value);
        return 0;
    }
#if FUTURE
    if (owner) {
        ownerName = ejsToMulti(ejs, owner);
    }
    if (group) {
        groupName = ejsToMulti(ejs, group);
    }
#endif
    return 0;
}


/*
    function makeLink(target: Path, hard: Boolean = false): Void
 */
static EjsObj *makePathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *target;
    int     hard;

    target = ((EjsPath*) argv[0])->value;
    hard = (argc >= 2) ? (argv[1] == S(true)) : 0;
    if (mprMakeLink(fp->value, target, hard) < 0) {
        ejsThrowIOError(ejs, "Can't make link");
    }
    return 0;
}


/*
    Make a temporary file. Creates a new, uniquely named temporary file. The path object specifies the directory
    to contain the temp file.
    NOTE: Still the callers responsibility to remove the temp file
  
    function temp(): Path
 */
static EjsPath *pathTemp(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetTempPath(fp->value)) == NULL) {
        ejsThrowIOError(ejs, "Can't make temp file");
        return 0;
    }
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    function map(separator: String): Path
 */
static EjsPath *pa_map(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *sep;
    char    *path;
    int     separator;

    sep = ejsToMulti(ejs, argv[0]);
    separator = *sep ? *sep : '/';
    path = sclone(fp->value);
    mprMapSeparators(path, separator);
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    function get mimeType(): String
 */
static EjsString *getMimeType(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprLookupMime(NULL, fp->value));
}


/*
    Get when the file was created or last modified.
  
    function get modified(): Date
 */
static EjsDate *getModifiedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return S(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.mtime) * 1000);
}


/*
    function get name(): String
 */
static EjsString *pa_name(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->value);
}


/*
    function get natural(): Path
 */
static EjsPath *getNaturalPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetNativePath(fp->value));
}


/*
    function get normalize(): Path
 */
static EjsPath *normalizePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetNormalizedPath(fp->value));
}


/*
    Get the parent directory of the absolute path of the file.
  
    function get parent(): Path
 */
static EjsPath *getPathParent(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetPathParent(fp->value));
}


/*
    Get the path permissions
  
    function get perms(): Number
 */
static EjsNumber *getPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(fp->value, &info) < 0) {
        return S(null);
    }
    return ejsCreateNumber(ejs, info.perms);
}


/*
    Set the path permissions
  
    function set perms(perms: Number): Void
 */
static EjsObj *setPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
#if !VXWORKS
    int     perms;

    perms = ejsGetInt(ejs, argv[0]);
    if (chmod(fp->value, perms) < 0) {
        ejsThrowIOError(ejs, "Can't update permissions for %s", fp->value);
    }
#endif
    return 0;
}


/*
    Get a portable (unix-like) representation of the path
  
    function get portable(lower: Boolean = false): Path
 */
static EjsPath *getPortablePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;
    int     lower;

    lower = (argc >= 1 && argv[0] == S(true));
    path = mprGetPortablePath(fp->value);
    if (lower) {
        path = slower(path);
    }
    return ejsCreatePathFromAsc(ejs, path);
}


#if KEEP
/*
    Get the file contents as a byte array
  
    static function readBytes(path: String): ByteArray
 */
static EjsByteArray *readBytes(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile         *file;
    EjsByteArray    *result;
    cchar           *path;
    char            buffer[MPR_BUFSIZE];
    int             bytes, offset, rc;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    result = ejsCreateByteArray(ejs, (int) mprGetFileSize(file));
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }

    rc = 0;
    offset = 0;
    while ((bytes = mprReadFile(file, buffer, MPR_BUFSIZE)) > 0) {
        if (ejsCopyToByteArray(ejs, result, offset, buffer, bytes) < 0) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
        offset += bytes;
    }
    ejsSetByteArrayPositions(ejs, result, 0, offset);
    mprCloseFile(file);
    return result;
}


/**
    Read the file contents as an array of lines.
  
    static function readLines(path: String): Array
 */
static EjsArray *readLines(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    EjsArray    *result;
    cchar       *path;
    char        *start, *end, *cp, buffer[MPR_BUFSIZE];
    int         bytes, rc, lineno;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    result = ejsCreateArray(ejs, 0);
    if (result == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(0, (int) mprGetFileSize(file) + 1);
    result = ejsCreateArray(ejs, 0);
    if (result == NULL || data == NULL) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }

    rc = 0;
    while ((bytes = mprReadFile(file, buffer, MPR_BUFSIZE)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
    }

    start = mprGetBufStart(data);
    end = mprGetBufEnd(data);
    for (lineno = 0, cp = start; cp < end; cp++) {
        if (*cp == '\n') {
            //  TODO - UNICODE ENCODING
            if (ejsSetProperty(ejs, result, lineno++, ejsCreateStringFromAsc(ejs, start, (int) (cp - start))) < 0) {
                break;
            }
            start = cp + 1;
        } else if (*cp == '\r') {
            start = cp + 1;
        }
    }
    if (cp > start) {
        //  TODO - UNICODE ENCODING
        ejsSetProperty(ejs, result, lineno++, ejsCreateStringFromAsc(ejs, start, (int) (cp - start)));
    }
    mprCloseFile(file);
    return result;
}


/*
    Read the file contents as a string
  
    static function readString(path: String): String
 */
static EjsString *readFileAsString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    cchar       *path;
    char        buffer[MPR_BUFSIZE];
    int         bytes;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(0, (int) mprGetFileSize(file) + 1);
    if (data == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }
    while ((bytes = mprReadFile(file, buffer, MPR_BUFSIZE)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            break;
        }
    }
    mprCloseFile(file);
    //  TODO - UNICODE ENCODING
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(data),  mprGetBufLength(data));
}


/*
    Get the file contents as an XML object
  
    static function readXML(path: String): XML
 */
static EjsXML *readXML(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif


/*
    Return a relative path name for the file.
  
    function get relative(): Path
 */
static EjsPath *relativePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetRelPath(fp->value));
}


/*
    Remove the file associated with the File object. This may be a file or directory.
  
    function remove(): Boolean
 */
static EjsObj *removePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(fp->value, &info) == 0) {
        if (mprDeletePath(fp->value) < 0) {
            return S(false);
        }
    }
    return S(true);
}


/*
    Rename the file
  
    function rename(to: String): Void
 */
static EjsObj *renamePathFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar    *to;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));
    to = ejsToMulti(ejs, argv[0]);
    unlink((char*) to);
    if (rename(fp->value, to) < 0) {
        ejsThrowIOError(ejs, "Cant rename file %s to %s", fp->value, to);
        return 0;
    }
    return 0;
}


/*
    Resolve paths against others. Returns a normalized path.
  
    function resolve(...paths): Path
 */
static EjsPath *resolvePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsPath     *result;
    cchar       *next;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp;
    for (i = 0; i < args->length; i++) {
        if ((next = getPathString(ejs, ejsGetProperty(ejs, args, i))) == NULL) {
            return 0;
        }
        result = ejsCreatePathFromAsc(ejs, mprResolvePath(result->value, next));
    }
    return result;
}


/*
    Return true if the paths refer to the same file.
  
    function same(other: Object): Boolean
 */
static EjsBoolean *isPathSame(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *other;

    if (ejsIs(ejs, argv[0], String)) {
        other = ejsToMulti(ejs, argv[0]);
    } else if (ejsIs(ejs, argv[0], Path)) {
        other = ((EjsPath*) (argv[0]))->value;
    } else {
        return S(false);
    }
    return (mprSamePath(fp->value, other) ? S(true) : S(false));
}


/*
    function get separator(): String
 */
static EjsString *pathSeparator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    cchar           *cp;

    if ((cp = mprGetFirstPathSeparator(fp->value)) != 0) {
        return ejsCreateStringFromMulti(ejs, cp, 1);
    }
    fs = mprLookupFileSystem(fp->value);
    return ejsCreateStringFromMulti(ejs, fs->separators, 1);
}


/*
    Get the size of the file associated with this Path
  
    function get size(): Number
 */
static EjsNumber *getPathFileSize(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    if (mprGetPathInfo(fp->value, &fp->info) < 0) {
        return S(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) fp->info.size);
}


/*
    override function toJSON(): String
 */
static EjsString *pathToJSON(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprBuf  *buf;
    int     i, c, len;

    buf = mprCreateBuf(0, 0);
    len = (int) strlen(fp->value);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < len; i++) {
        c = fp->value[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    function toString(): String
 */
static EjsString *pathToString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->value);
}


/*
    function trimExt(): Path
 */
static EjsPath *trimExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprTrimPathExtension(fp->value));
}


/*
    function truncate(size: Number): Void
 */
static EjsObj *truncatePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncateFile(fp->value, size) < 0) {
        ejsThrowIOError(ejs, "Cant truncate %s", fp->value);
    }
    return 0;
}


#if KEEP
/*
    Put the file contents
  
    static function write(path: String, permissions: Number, ...args): void
 */
static EjsObj *writeToFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    EjsArray    *args;
    char        *path, *data;
    int         i, bytes, length, permissions;

    mprAssert(argc == 3);

    path = ejsToMulti(ejs, argv[0]);
    permissions = ejsGetInt(ejs, argv[1]);
    args = (EjsArray*) argv[2];

    /*
        Create fails if already present
     */
    mprDeletePath(path);
    file = mprOpenFile(path, O_CREAT | O_WRONLY | O_BINARY, permissions);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cant create %s", path);
        mprCloseFile(file);
        return 0;
    }

    for (i = 0; i < args->length; i++) {
        data = ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, args, i)));
        length = (int) strlen(data);
        bytes = mprWriteFile(file, data, length);
        if (bytes != length) {
            ejsThrowIOError(ejs, "Write error to %s", path);
            break;
        }
    }
    mprCloseFile(file);
    return 0;
}
#endif


static cchar *getPathString(Ejs *ejs, EjsObj *vp)
{
    if (ejsIs(ejs, vp, String)) {
        return (char*) ejsToMulti(ejs, vp);
    } else if (ejsIs(ejs, vp, Path)) {
        return ((EjsPath*) vp)->value;
    }
    ejsThrowIOError(ejs, "Bad path");
    return NULL;
}


EjsPath *ejsCreatePath(Ejs *ejs, EjsString *path)
{
    EjsPath     *fp;

    if ((fp = ejsCreateObj(ejs, ST(Path), 0)) == 0) {
        return 0;
    }
    pathConstructor(ejs, fp, 1, (EjsObj**) &path);
    return fp;
}


EjsPath *ejsCreatePathFromAsc(Ejs *ejs, cchar *value)
{
    return ejsCreatePath(ejs, ejsCreateStringFromAsc(ejs, value));
}


static void managePath(EjsPath *path, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(path->value);
        mprMark(path->files);
    }
}


void ejsCreatePathType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Path"), sizeof(EjsPath), S_Path, ES_Path_NUM_CLASS_PROP, 
        managePath, EJS_OBJ_HELPERS);
    type->helpers.cast = (EjsCastHelper) castPath;
    type->helpers.clone = (EjsCloneHelper) clonePath;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokePathOperator;
}


void ejsConfigurePathType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Path);
    mprAssert(type);
    prototype = type->prototype;

    type->helpers.cast = (EjsCastHelper) castPath;
    type->helpers.clone = (EjsCloneHelper) clonePath;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokePathOperator;

    //  TODO - rename all and use pa_ prefix
    ejsBindConstructor(ejs, type, pathConstructor);
    ejsBindMethod(ejs, prototype, ES_Path_absolute, absolutePath);
    ejsBindMethod(ejs, prototype, ES_Path_accessed, getAccessedDate);
    ejsBindMethod(ejs, prototype, ES_Path_basename, getPathBasename);
    ejsBindMethod(ejs, prototype, ES_Path_components, getPathComponents);
    ejsBindMethod(ejs, prototype, ES_Path_copy, copyPath);
    ejsBindMethod(ejs, prototype, ES_Path_created, getCreatedDate);
    ejsBindMethod(ejs, prototype, ES_Path_dirname, getPathDirname);
    ejsBindMethod(ejs, prototype, ES_Path_exists, getPathExists);
    ejsBindMethod(ejs, prototype, ES_Path_extension, getPathExtension);
    ejsBindMethod(ejs, prototype, ES_Path_files, getPathFiles);
    ejsBindMethod(ejs, prototype, ES_Path_iterator_get, getPathIterator);
    ejsBindMethod(ejs, prototype, ES_Path_iterator_getValues, getPathValues);
    ejsBindMethod(ejs, prototype, ES_Path_hasDrive, pathHasDrive);
    ejsBindMethod(ejs, prototype, ES_Path_isAbsolute, isPathAbsolute);
    ejsBindMethod(ejs, prototype, ES_Path_isDir, isPathDir);
    ejsBindMethod(ejs, prototype, ES_Path_isLink, isPathLink);
    ejsBindMethod(ejs, prototype, ES_Path_isRegular, isPathRegular);
    ejsBindMethod(ejs, prototype, ES_Path_isRelative, isPathRelative);
    ejsBindMethod(ejs, prototype, ES_Path_join, joinPath);
    ejsBindMethod(ejs, prototype, ES_Path_joinExt, joinPathExt);
    ejsBindMethod(ejs, prototype, ES_Path_length, pathLength);
    ejsBindMethod(ejs, prototype, ES_Path_linkTarget, pathLinkTarget);
    ejsBindMethod(ejs, prototype, ES_Path_makeDir, makePathDir);
    ejsBindMethod(ejs, prototype, ES_Path_makeLink, makePathLink);
    ejsBindMethod(ejs, prototype, ES_Path_temp, pathTemp);
    ejsBindMethod(ejs, prototype, ES_Path_map, pa_map);
    ejsBindAccess(ejs, prototype, ES_Path_mimeType, getMimeType, NULL);
    ejsBindMethod(ejs, prototype, ES_Path_modified, getModifiedDate);
    ejsBindMethod(ejs, prototype, ES_Path_name, pa_name);
    ejsBindMethod(ejs, prototype, ES_Path_natural, getNaturalPath);
    ejsBindMethod(ejs, prototype, ES_Path_normalize, normalizePath);
    ejsBindMethod(ejs, prototype, ES_Path_parent, getPathParent);
    ejsBindAccess(ejs, prototype, ES_Path_perms, getPerms, setPerms);
    ejsBindMethod(ejs, prototype, ES_Path_portable, getPortablePath);
    ejsBindMethod(ejs, prototype, ES_Path_relative, relativePath);
    ejsBindMethod(ejs, prototype, ES_Path_remove, removePath);
    ejsBindMethod(ejs, prototype, ES_Path_rename, renamePathFile);
    ejsBindMethod(ejs, prototype, ES_Path_resolve, resolvePath);
    ejsBindMethod(ejs, prototype, ES_Path_same, isPathSame);
    ejsBindMethod(ejs, prototype, ES_Path_separator, pathSeparator);
    ejsBindMethod(ejs, prototype, ES_Path_size, getPathFileSize);
    ejsBindMethod(ejs, prototype, ES_Path_toJSON, pathToJSON);
    ejsBindMethod(ejs, prototype, ES_Path_toString, pathToString);
    ejsBindMethod(ejs, prototype, ES_Path_trimExt, trimExt);
    ejsBindMethod(ejs, prototype, ES_Path_truncate, truncatePath);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsPath.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsPot.c"
 */
/************************************************************************/

/**
    ejsPot.c - Property Object class (Objects with properties)

    This is the base for all scripted classes.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define CMP_QNAME(a,b) ((a)->name == (b)->name && (a)->space == (b)->space)
#define CMP_NAME(a,b) ((a)->name == (b)->name)


static int  growSlots(Ejs *ejs, EjsPot *obj, int size);
static int  hashProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname);
static void removeHashEntry(Ejs *ejs, EjsPot *obj, EjsName qname);


EjsAny *ejsCreateEmptyPot(Ejs *ejs)
{
    return ejsCreatePot(ejs, ST(Object), 0);
}


EjsAny *ejsClonePot(Ejs *ejs, EjsAny *obj, bool deep)
{
    EjsPot      *dest, *src;
    EjsSlot     *dp, *sp;
    EjsType     *type;
    EjsObj      *vp;
    int         numProp, i;

    if (!ejsIsPot(ejs, obj)) {
        mprAssert(ejsIsPot(ejs, obj));
        return NULL;
    }
    src = (EjsPot*) obj;
    numProp = src->numProp;
    if ((dest = ejsCreatePot(ejs, TYPE(src), numProp)) == 0) {
        return 0;
    }
    dest->obj = src->obj;
    dest->isBlock = src->isBlock;
    dest->isFrame = src->isFrame;
    dest->isFunction = src->isFunction;
    dest->isPrototype = src->isPrototype;
    dest->isType = src->isType;
    dest->numProp = numProp;
    dest->shortScope = src->shortScope;

    dp = dest->properties->slots;
    sp = src->properties->slots;
    for (i = 0; i < numProp; i++, sp++, dp++) {
        *dp = *sp;
        dp->hashChain = -1;
        if (deep) {
            vp = sp->value.ref;
            type = TYPE(vp);
            if ((ejsIsType(ejs, vp) && ((EjsType*) vp)->mutable) || (!ejsIsType(ejs, vp) && type->mutableInstances)) {
                EjsName qname = ejsGetPropertyName(ejs, src, i);
                // mprLog(0, "CLONE %N", qname);
                dp->value.ref = ejsClone(ejs, vp, deep);
                //  UNICODE
                mprSetName(dp->value.ref, qname.name->value);
            } else {
                extern int cloneRef;
                cloneRef++;
            }
            if (dp->trait.type && dp->trait.type->mutable) {
                if ((type = ejsGetPropertyByName(ejs, ejs->global, dp->trait.type->qname)) != 0) {
                    dp->trait.type = type;
                } else {
                    //MOB - forward reference
                    mprAssert(0);
                }
            }
        }
    }
    if (dest->numProp > EJS_HASH_MIN_PROP) {
        ejsMakeHash(ejs, dest);
    }
    mprCopyName(dest, src);
    return dest;
}


static EjsObj *prepareAccessors(Ejs *ejs, EjsPot *obj, int slotNum, int64 *attributes, EjsObj *value)
{
    EjsFunction     *fun;
    EjsTrait        *trait;

    fun = ejsGetProperty(ejs, obj, slotNum);

    if (*attributes & EJS_TRAIT_SETTER) {
        if (ejsIsFunction(ejs, fun)) {
            /* Existing getter, add a setter */
            fun->setter = (EjsFunction*) value;
            if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
                *attributes |= trait->attributes;
            }
        } else {
            /* No existing getter, must define a dummy getter - will not be called */
            fun = (EjsFunction*) ejsCloneFunction(ejs, S(nop), 0);
            fun->setter = (EjsFunction*) value;
        }
        value = (EjsObj*) fun;

    } else if (*attributes & EJS_TRAIT_GETTER) {
        if (ejsIsFunction(ejs, fun) && ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_SETTER)) {
            /* Existing getter and setter - preserve any defined setter, overwrite getter */
            if (fun->setter) {
                ((EjsFunction*) value)->setter = fun->setter;
                *attributes |= EJS_TRAIT_SETTER;
            }
        }
    }
    return value;
}


/*
    Define (or redefine) a property and set its name, type, attributes and property value.
 */
static int definePotProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname, EjsType *propType, int64 attributes, 
    EjsObj *value)
{
    EjsFunction     *fun;
    EjsType         *type;
    int             priorSlot;

    mprAssert(ejs);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= -1);

    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER) && !ejsIsFunction(ejs, value)) {
        ejsThrowTypeError(ejs, "Property \"%@\" is not a function", qname.name);
        return 0;
    }
    priorSlot = ejsLookupProperty(ejs, obj, qname);
    if (slotNum < 0) {
        if (priorSlot < 0) {
            slotNum = obj->numProp;
        } else {
            slotNum = priorSlot;
        }
    }
    mprAssert(priorSlot < 0 || priorSlot == slotNum);

    if (slotNum >= obj->numProp && !DYNAMIC(obj)) {
        if (obj->properties == 0 || slotNum >= obj->properties->size) {
            if (growSlots(ejs, obj, slotNum + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
        }
        obj->numProp = slotNum + 1;
    }
#if UNUSED
    if (slotNum >= obj->numProp && (obj->properties && slotNum < obj->properties->size)) {
        /* When types are created, slots are allocated but numProp is zero -  */
        obj->numProp = slotNum + 1;
    }
#endif
    if (priorSlot < 0 && ejsSetPropertyName(ejs, obj, slotNum, qname) < 0) {
        return EJS_ERR;
    }
    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
        value = prepareAccessors(ejs, obj, slotNum, &attributes, value);
    }
    if (value) {
        if (ejsSetProperty(ejs, obj, slotNum, value ? value: S(null)) < 0) {
            return EJS_ERR;
        }
    }
    if (ejsSetPropertyTraits(ejs, obj, slotNum, propType, (int) attributes) < 0) {
        return EJS_ERR;
    }
    if (value && ejsIsFunction(ejs, value)) {
        fun = ((EjsFunction*) value);
        if (!ejsIsNativeFunction(ejs, fun) && ejsIsType(ejs, obj)) {
            ((EjsType*) obj)->hasScriptFunctions = 1;
        }
        if (fun->staticMethod && ejsIsType(ejs, obj)) {
            type = (EjsType*) obj;
            if (!type->isInterface) {
                /* For static methods, find the right base class and set thisObj to speed up later invocations */
                fun->boundThis = obj;
            }
        }
    }
    return slotNum;
}


/*
    Delete an instance property. To delete class properties, use the type as the obj. This sets the property to null.
    It does not reclaim the property slot.
 */
static int deletePotProperty(Ejs *ejs, EjsPot *obj, int slotNum)
{
    EjsName     qname;
    EjsSlot     *sp;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        ejsThrowReferenceError(ejs, "Invalid property slot to delete");
        return EJS_ERR;
    }
#if UNUSED
    //  TODO -- this should be in the VM and not here
    if (!DYNAMIC(obj)) {
        //  TODO -- probably can remove this and rely on fixed below as per ecma spec
        ejsThrowTypeError(ejs, "Can't delete properties in a non-dynamic object");
        return EJS_ERR;
    } else if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_FIXED)) {
        ejsThrowTypeError(ejs, "Property \"%@\" is not deletable", qname.name);
        return EJS_ERR;
    }
#endif
    qname = ejsGetPotPropertyName(ejs, obj, slotNum);
    if (qname.name) {
        removeHashEntry(ejs, obj, qname);
    }
    sp = &obj->properties->slots[slotNum];
    sp->value.ref = S(undefined);
    sp->trait.type = 0;
    sp->trait.attributes = EJS_TRAIT_DELETED | EJS_TRAIT_HIDDEN;
    return 0;
}


static int deletePotPropertyByName(Ejs *ejs, EjsPot *obj, EjsName qname)
{
    int     slotNum;

    mprAssert(ejsIsPot(ejs, obj));

    slotNum = ejsLookupPotProperty(ejs, obj, qname);
    if (slotNum < 0) {
        ejsThrowReferenceError(ejs, "Property does not exist");
        return EJS_ERR;
    }
    return deletePotProperty(ejs, obj, slotNum);
}


static EjsPot *getPotProperty(Ejs *ejs, EjsPot *obj, int slotNum)
{
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(obj);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        ejsThrowReferenceError(ejs, "Property at slot \"%d\" is not found", slotNum);
        return 0;
    }
    return obj->properties->slots[slotNum].value.ref;
}


static int getPotPropertyCount(Ejs *ejs, EjsPot *obj)
{
    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));

    return obj->numProp;
}


EjsName ejsGetPotPropertyName(Ejs *ejs, EjsPot *obj, int slotNum)
{
    EjsName     qname;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        qname.name = 0;
        qname.space = 0;
        return qname;
    }
    return obj->properties->slots[slotNum].qname;
}


#if UNUSED
static EjsTrait *getPotPropertyTrait(Ejs *ejs, EjsPot *obj, int slotNum)
{
    mprAssert(ejsIsPot(ejs, obj));
    return ejsGetPropertyTraits(ejs, obj, slotNum);
}
#endif


/*
    Lookup a property with a namespace qualifier in an object and return the slot if found. Return EJS_ERR if not found.
    If qname.space is NULL, then only return a positive slot if there is only one property of the given name.
    Only the name portion is hashed. The namespace is not included in the hash. This is used to do a one-step lookup 
    for properties regardless of the namespace.
 */
int ejsLookupPotProperty(struct Ejs *ejs, EjsPot *obj, EjsName qname)
{
    EjsProperties   *props;
    EjsHash         *hash;
    EjsSlot         *slots, *sp, *np;
    int             slotNum, index, prior;

    mprAssert(qname.name);
    mprAssert(ejsIsPot(ejs, obj));

    if ((props = obj->properties) == 0 || obj->numProp == 0) {
        return -1;
    }
    slots = props->slots;
    if ((hash = props->hash) == 0 || hash->size == 0) {
        /* No hash. Just do a linear search */
        if (qname.space) {
            for (slotNum = 0; slotNum < obj->numProp; slotNum++) {
                sp = &slots[slotNum];
                if (CMP_QNAME(&sp->qname, &qname)) {
                    return slotNum;
                }
            }
            return -1;
        } else {
            for (slotNum = 0, prior = -1; slotNum < obj->numProp; slotNum++) {
                sp = &slots[slotNum];
                if (CMP_NAME(&sp->qname, &qname)) {
                    if (prior >= 0) {
                        /* Multiple properties with the same name */
                        return -1;
                    }
                    prior = slotNum;
                }
            }
            return prior;
        }

    } else {
        /*
            Find the property in the hash chain if it exists. Note the hash does not include the namespace portion.
            We assume that names rarely clash with different namespaces. We do this so variable lookup and do a one
            hash probe and find matching names. Lookup will then pick the right namespace.
         */
        mprAssert(props->hash);
        mprAssert(props->hash->size > 0);
        index = whash(qname.name->value, qname.name->length) % props->hash->size;
        if (qname.space) {
            mprAssert(hash->buckets);
            mprAssert(index < hash->size);
            for (slotNum = hash->buckets[index]; slotNum >= 0; slotNum = slots[slotNum].hashChain) {
                sp = &slots[slotNum];
                if (CMP_QNAME(&sp->qname, &qname)) {
                    return slotNum;
                }
            }
        } else {
            for (slotNum = hash->buckets[index]; slotNum >= 0; slotNum = sp->hashChain) {
                sp = &slots[slotNum];
                if (CMP_NAME(&sp->qname, &qname)) {
                    /* Now ensure there are no more matching names - must be unique in the "name" only */
                    for (np = sp; np->hashChain >= 0; ) {
                        np = &slots[np->hashChain];
                        if (CMP_NAME(&sp->qname, &np->qname)) {
                            /* Multiple properties with the same name */
                            return -1;
                        }
                    }
                    return slotNum;
                }
            }
        }
    }
    return -1;
}


/*
    Validate the supplied slot number. If set to -1, then return the next available property slot number.
    Grow the object if required and update numProp
 */
int ejsGetSlot(Ejs *ejs, EjsPot *obj, int slotNum)
{
    mprAssert(ejsIsPot(ejs, obj));

    //  TODO - should this be here or only in the VM. probably only in the VM.
    //  TODO -- or move this routine to the VM
    if (slotNum < 0 || slotNum >= obj->numProp) {
        if (!DYNAMIC(obj)) {
            if (ejsIs(ejs, obj, Null)) {
                ejsThrowReferenceError(ejs, "Object is null");
            } else if (ejsIs(ejs, obj, Void)) {
                ejsThrowReferenceError(ejs, "Object is undefined");
            } else {
                ejsThrowReferenceError(ejs, "Object is not extendable");
            }
            return EJS_ERR;
        }
        if (slotNum < 0) {
            slotNum = obj->numProp;
        }
        if (obj->properties == 0 || slotNum >= obj->properties->size) {
            if (growSlots(ejs, obj, slotNum + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
        }
        if (slotNum > obj->numProp) {
            obj->numProp = slotNum;
        }
        obj->numProp++;
    }
    mprAssert(obj->numProp <= obj->properties->size);
#if BLD_DEBUG && 0
    if (obj == ejs->global && obj->numProp > 220) {
        mprAssert(obj != ejs->global || obj->numProp < 220);
        mprBreakpoint();
    }
#endif
    return slotNum;
}


/**
    Set the value of a property.
    @param slot If slot is -1, then allocate the next free slot
    @return Return the property slot if successful. Return < 0 otherwise.
 */
static int setPotProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsObj *value)
{
    mprAssert(ejs);
    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(value);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    mprAssert(slotNum < obj->numProp);
    mprAssert(obj->numProp <= obj->properties->size);
    obj->properties->slots[slotNum].value.ref = value;
    return slotNum;
}


/*
    Set the name for a property. Objects maintain a hash lookup for property names. This is hash is created on demand 
    if there are more than N properties. If an object is not dynamic, it will use the types name hash. If dynamic, 
    then the types name hash will be copied when required. 
 */
static int setPotPropertyName(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname)
{
    EjsProperties   *props;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(qname.name);
    mprAssert(qname.space);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    mprAssert(slotNum < obj->numProp);
    props = obj->properties;

    /* Remove the old hash entry if the name will change */
    if (props->slots[slotNum].hashChain >= 0) {
        if (CMP_QNAME(&props->slots[slotNum].qname, &qname)) {
            return slotNum;
        }
        removeHashEntry(ejs, obj, props->slots[slotNum].qname);
    }
    props->slots[slotNum].qname = qname;
    
    mprAssert(slotNum < obj->numProp);
    mprAssert(obj->numProp <= props->size);
    
    if (props->hash || obj->numProp > EJS_HASH_MIN_PROP) {
        if (hashProperty(ejs, obj, slotNum, qname) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
    return slotNum;
}


#if UNUSED
/*
    Set the property Trait. Grow traits if required.
 */
static int setPotPropertyTrait(Ejs *ejs, EjsPot *obj, int slotNum, EjsType *type, int attributes)
{
    EjsSlots   *slots;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= 0);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    slots = obj->properties->slots;
    slots[slotNum].trait.type = type;
    slots[slotNum].trait.attributes = attributes;
    return slotNum;
}
#endif


/*
    Grow and object and update numProp and numTraits if required
 */
int ejsGrowPot(Ejs *ejs, EjsPot *obj, int numProp)
{
    mprAssert(ejsIsPot(ejs, obj));

    if (obj->properties == 0 || numProp > obj->properties->size) {
        if (growSlots(ejs, obj, numProp) < 0) {
            return EJS_ERR;
        }
    }
    if (numProp > obj->numProp) {
        obj->numProp = numProp;
    }
    return 0;
}


//  TODO-- inconsistent with growObject which takes numProp. This takes incr.
/*
    Grow the slots, traits, and names by the specified "incr". The new slots|traits|names are created at the "offset"
    Does not update numProp or numTraits.
 */
int ejsInsertPotProperties(Ejs *ejs, EjsPot *obj, int incr, int offset)
{
    EjsSlot         *sp, *slots;
    int             i, size, mark;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(incr >= 0);

    if (incr <= 0) {
        return 0;
    }
    size = obj->numProp + incr;
    if (obj->properties == 0 || obj->properties->size < size) {
        if (growSlots(ejs, obj, size) < 0) {
            return EJS_ERR;
        }
    }
    obj->numProp += incr;
    mprAssert(obj->numProp <= obj->properties->size);
    slots = obj->properties->slots;
    for (mark = offset + incr, i = obj->numProp - 1; i >= mark; i--) {
        sp = &slots[i - mark];
        slots[i] = *sp;
    }
    ejsZeroSlots(ejs, &slots[offset], incr);
    if (ejsMakeHash(ejs, obj) < 0) {
        return EJS_ERR;
    }   
    return 0;
}


/*
    Allocate or grow the slots storage for an object. Does not update numProp.
 */
static int growSlots(Ejs *ejs, EjsPot *obj, int slotCount)
{
    EjsProperties   *props;
    ssize           size;
    int             factor, oldSize;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotCount > 0);
    mprAssert(obj->properties == 0 || slotCount > obj->properties->size);

    props = obj->properties;
    oldSize = props ? props->size : 0;
    
    if (slotCount > oldSize) {
        if (slotCount > EJS_LOTSA_PROP) {
            factor = max(oldSize / 4, EJS_ROUND_PROP);
            slotCount = (slotCount + factor) / factor * factor;
        }
        slotCount = EJS_PROP_ROUNDUP(slotCount);
        size = sizeof(EjsProperties) + (sizeof(EjsSlot) * slotCount);

        if (props == 0) {
            mprAssert(obj->numProp == 0);
            mprAssert(slotCount > 0);
            if ((props = mprAllocZeroed(size)) == 0) {
                return EJS_ERR;
            }
            obj->properties = props;
            ejsZeroSlots(ejs, props->slots, slotCount);
            obj->separateSlots = 1;
        } else {
            if (obj->separateSlots) {
                mprAssert(props->size > 0);
                props = mprRealloc(props, size);
            } else {
                if ((props = mprAlloc(size)) != 0) {
                    memcpy(props, obj->properties, sizeof(EjsProperties) + obj->properties->size * sizeof(EjsSlot));
                    obj->properties = props;
                    obj->separateSlots = 1;
                }
            }
            if (props == 0) {
                return EJS_ERR;
            }
            ejsZeroSlots(ejs, &props->slots[props->size], (slotCount - props->size));
            obj->properties = props;
        }
        props->size = slotCount;
    }
    mprAssert(obj->numProp <= props->size);
    return 0;
}


/*
    Remove a slot and name. Copy up all other properties. WARNING: this can only be used before property binding and 
    should only be used by the compiler.
 */
static void removeSlot(Ejs *ejs, EjsPot *obj, int slotNum, int compact)
{
    EjsSlot     *slots;
    int         i;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= 0);
    mprAssert(compact);

    if (obj->properties) {
        slots = obj->properties->slots;
        if (compact) {
            for (i = slotNum + 1; i < obj->numProp; i++) {
                slots[i - 1] = slots[i];
            }
            obj->numProp--;
            i--;
        } else {
            i = slotNum;
        }
        ejsZeroSlots(ejs, &slots[i], 1);
        ejsMakeHash(ejs, obj);
    }
}


void ejsZeroSlots(Ejs *ejs, EjsSlot *slots, int count)
{
    EjsSlot     *sp;

    mprAssert(slots);
    mprAssert(count >= 0);

    if (slots) {
        //  TODO OPT. If hashChans were biased by +1 and NULL was allowed for names, then a simple zero would suffice.
        for (sp = &slots[count - 1]; sp >= slots; sp--) {
            sp->value.ref = S(null);
            sp->hashChain = -1;
            //  TODO -- why set names to this. Better to set to null?
            sp->qname.name = S(empty);
            sp->qname.space = S(empty);
            sp->trait.type = 0;
            sp->trait.attributes = 0;
        }
    }
}


//  TODO - bad API. Should take two EjsPots
void ejsCopySlots(Ejs *ejs, EjsPot *obj, EjsSlot *dest, EjsSlot *src, int count)
{
    while (count-- > 0) {
        *dest = *src;
        dest->hashChain = -1;
        dest++;
        src++;
    }
}


/*
    Remove a property and copy up all other properties. WARNING: This does much more than just a delete and should 
    only be used by the compiler.
 */
int ejsRemovePotProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsPot      *obj;

    mprAssert(ejsIsPot(ejs, vp));

    if (!ejsIsPot(ejs, vp)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return EJS_ERR;
    }
    obj = vp;
    mprAssert(ejs);
    mprAssert(obj);
    if (slotNum < 0 || slotNum >= obj->numProp) {
        return EJS_ERR;
    }
    removeSlot(ejs, obj, slotNum, 1);
    return 0;
}


#if UNUSED

void ejsSetTraitType(Ejs *ejs, EjsTrait *trait, EjsType *type)
{
    mprAssert(trait);
    mprAssert(type == 0 || ejsIsType(ejs, type));
    trait->type = type;
}


void ejsSetTraitAttributes(Ejs *ejs, EjsTrait *trait, int attributes)
{
    mprAssert(trait);
    mprAssert((attributes & EJS_TRAIT_MASK) == attributes);
    trait->attributes = attributes;
}
#endif


static EjsTrait *getPotPropertyTraits(Ejs *ejs, EjsPot *obj, int slotNum)
{
    mprAssert(ejsIsPot(ejs, obj));
    if (slotNum < 0 || slotNum >= obj->numProp) {
        return NULL;
    }
    return &obj->properties->slots[slotNum].trait;
}


static int setPotPropertyTraits(Ejs *ejs, EjsPot *obj, int slotNum, EjsType *type, int attributes)
{
    mprAssert(ejsIsPot(ejs, obj));
    mprAssert(slotNum >= 0);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    if (type) {
        obj->properties->slots[slotNum].trait.type = type;
    }
    if (attributes != -1) {
        obj->properties->slots[slotNum].trait.attributes = attributes;
    }
    return slotNum;
}


#if UNUSED
int ejsGetTraitAttributes(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsPot      *obj;

    if (!ejsIsPot(ejs, vp)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return EJS_ERR;
    }
    obj = vp;
    mprAssert(obj);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        mprAssert(0);
        return 0;
    }
    return obj->properties->slots[slotNum].trait.attributes;
}


EjsType *ejsGetTraitType(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsPot      *obj;

    mprAssert(ejsIsPot(ejs, obj));

    if (!ejsIsPot(ejs, vp)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return NULL;
    }
    obj = vp;
    mprAssert(obj);
    mprAssert(slotNum >= 0);
    if (slotNum < 0 || slotNum >= obj->numProp) {
        mprAssert(0);
        return NULL;
    }
    return obj->properties->slots[slotNum].trait.type;
}
#endif


/*
    Exponential primes
 */
static int hashSizes[] = {
     19, 29, 59, 79, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 0
};


int ejsGetHashSize(int numProp)
{
    int     i;

    for (i = 0; hashSizes[i]; i++) {
        if (numProp < hashSizes[i]) {
            return hashSizes[i];
        }
    }
    return hashSizes[i - 1];
}


static int hashProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname)
{
    EjsProperties   *props;
    EjsHash         *hash;
    EjsName         *slotName;
    EjsSlot         *slots;
    int             chainSlotNum, lastSlot, index;

    mprAssert(ejsIsPot(ejs, obj));

    props = obj->properties;
    if (props == NULL || props->hash == NULL || props->hash->size < obj->numProp) {
        /*  Remake the entire hash */
        return ejsMakeHash(ejs, obj);
    }
    hash = props->hash;
    slots = props->slots;
    index = whash(qname.name->value, qname.name->length) % hash->size;

    /* Scan the collision chain */
    lastSlot = -1;
    chainSlotNum = hash->buckets[index];
    mprAssert(chainSlotNum < obj->numProp);
    mprAssert(chainSlotNum < props->size);

    while (chainSlotNum >= 0) {
        slotName = &slots[chainSlotNum].qname;
        if (CMP_QNAME(slotName, &qname)) {
            return 0;
        }
        mprAssert(lastSlot != chainSlotNum);
        lastSlot = chainSlotNum;
        mprAssert(chainSlotNum != slots[chainSlotNum].hashChain);
        chainSlotNum = slots[chainSlotNum].hashChain;
        mprAssert(0 <= lastSlot && lastSlot < props->size);
    }
    if (lastSlot >= 0) {
        mprAssert(lastSlot < obj->numProp);
        mprAssert(lastSlot != slotNum);
        slots[lastSlot].hashChain = slotNum;

    } else {
        /* Start a new hash chain */
        hash->buckets[index] = slotNum;
    }
    slots[slotNum].hashChain = -2;
    slots[slotNum].qname = qname;
    return 0;
}


/*
    Allocate or grow the properties storage for an object. This routine will also manage the hash index for the object. 
    If numInstanceProp is < 0, then grow the number of properties by an increment. Otherwise, set the number of properties 
    to numInstanceProp. We currently don't allow reductions.
 */
//  TODO -- rename
int ejsMakeHash(Ejs *ejs, EjsPot *obj)
{
    EjsSlot         *sp;
    EjsHash         *oldHash, *hash;
    int             i, newHashSize;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));

    if (obj->numProp <= EJS_HASH_MIN_PROP && obj->properties->hash == 0) {
        /* Too few properties */
        return 0;
    }
    /*
        Reallocate the hash buckets if the hash needs to grow larger
     */
    oldHash = obj->properties->hash;
    newHashSize = ejsGetHashSize(obj->numProp);
    if (oldHash == NULL || oldHash->size < newHashSize) {
        hash = (EjsHash*) mprAlloc(sizeof(EjsHash) + (newHashSize * sizeof(int)));
        if (hash == 0) {
            return EJS_ERR;
        }
        hash->buckets = (int*) (((char*) hash) + sizeof(EjsHash));
        hash->size = newHashSize;
        mprAssert(newHashSize > 0);
        obj->properties->hash = hash;
        obj->separateHash = 1;
    }
    hash = obj->properties->hash;
    mprAssert(hash);
    memset(hash->buckets, -1, hash->size * sizeof(int));

    /*
        Clear out hash linkage
     */
    if (oldHash) {
        for (sp = obj->properties->slots, i = 0; i < obj->numProp; i++, sp++) {
            sp->hashChain = -1;
        }
    }

    /*
        Rehash existing properties
     */
    for (sp = obj->properties->slots, i = 0; i < obj->numProp; i++, sp++) {
        if (sp->qname.name && hashProperty(ejs, obj, i, sp->qname) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


//  TODO -- rename
void ejsClearPotHash(EjsPot *obj)
{
    EjsSlot         *sp;
    int             i;

    mprAssert(obj);
    mprAssert(ejsIsPot(ejs, obj));

    if (obj->properties->hash) {
        memset(obj->properties->hash->buckets, -1, obj->properties->hash->size * sizeof(int));
        for (sp = obj->properties->slots, i = 0; i < obj->numProp; i++, sp++) {
            sp->hashChain = -1;
        }
    }
}


static void removeHashEntry(Ejs *ejs, EjsPot *obj, EjsName qname)
{
    EjsSlot     *sp;
    EjsName     *nextName;
    int         index, slotNum, lastSlot, *buckets;

    mprAssert(ejsIsPot(ejs, obj));

    if (obj->properties->hash == 0) {
        /*
            No hash. Just do a linear search
         */
        for (slotNum = 0; slotNum < obj->numProp; slotNum++) {
            sp = &obj->properties->slots[slotNum];
            if (CMP_QNAME(&sp->qname, &qname)) {
                //  TODO -- would null be better
                sp->qname.name = S(empty);
                sp->qname.space = S(empty);
                sp->hashChain = -1;
                return;
            }
        }
        mprAssert(0);
        return;
    }
    index = whash(qname.name->value, qname.name->length) % obj->properties->hash->size;
    slotNum = obj->properties->hash->buckets[index];
    lastSlot = -1;
    buckets = obj->properties->hash->buckets;
    while (slotNum >= 0) {
        sp = &obj->properties->slots[slotNum];
        nextName = &sp->qname;
        if (CMP_QNAME(nextName, &qname)) {
            if (lastSlot >= 0) {
                obj->properties->slots[lastSlot].hashChain = obj->properties->slots[slotNum].hashChain;
            } else {
                buckets[index] = obj->properties->slots[slotNum].hashChain;
            }
            //  TODO -- null would be better
            sp->qname.name = S(empty);
            sp->qname.space = S(empty);
            sp->hashChain = -1;
            return;
        }
        lastSlot = slotNum;
        slotNum = obj->properties->slots[slotNum].hashChain;
    }
    mprAssert(0);
}


int ejsCompactPot(Ejs *ejs, EjsPot *obj)
{
    EjsSlot     *slots, *src, *dest;
    int         i, removed;

    mprAssert(ejsIsPot(ejs, obj));

    src = dest = slots = obj->properties->slots;
    for (removed = i = 0; i < obj->numProp; i++, src++) {
        if (!ejsIsDefined(ejs, src->value.ref)) {
            removed++;
            continue;
        }
        *dest++ = *src;
    }
    obj->numProp -= removed;
    ejsMakeHash(ejs, obj);
    return obj->numProp;
}


bool ejsMatchName(Ejs *ejs, EjsName *a, EjsName *b)
{
    return a->name == b->name && a->space == b->space;
}


/*
    Create an object which is an instance of a given type. NOTE: only initialize the Object base class. It is up to the 
    caller to complete the initialization for all other base classes by calling the appropriate constructors. The numProp 
    arg is the number of property slots to pre-allocate. It is typically zero and slots are allocated on-demand. If the 
    type creates dynamic instances, then the property slots are allocated separately and can grow. 
 */
void *ejsCreatePot(Ejs *ejs, EjsType *type, int numProp)
{
    EjsPot      *obj, *prototype;

    mprAssert(type);
    
    prototype = (EjsPot*) type->prototype;
    if (type->hasInstanceVars) {
        numProp = max(numProp, prototype->numProp);
    }
    if (type->dynamicInstances) {
        if ((obj = ejsAlloc(ejs, type, 0)) == 0) {
            return 0;
        }
        if (numProp > 0) {
            growSlots(ejs, obj, numProp);
        }
        SET_DYNAMIC(obj, 1);
    } else {
        if ((obj = ejsAlloc(ejs, type, sizeof(EjsProperties) + numProp * sizeof(EjsSlot))) == 0) {
            return 0;
        }
        if (numProp > 0) {
            obj->properties = (EjsProperties*) &(((char*) obj)[type->instanceSize]);
            obj->properties->size = numProp;
        }
    }
    obj->numProp = numProp;
    if (numProp > 0) {
        if (type->hasInstanceVars) {
            if (prototype->numProp > 0) {
                ejsCopySlots(ejs, obj, obj->properties->slots, prototype->properties->slots, prototype->numProp);
            }
            ejsZeroSlots(ejs, &obj->properties->slots[prototype->numProp], obj->properties->size - prototype->numProp);
            if (numProp > EJS_HASH_MIN_PROP) {
                ejsMakeHash(ejs, obj);
            }
        } else {
            ejsZeroSlots(ejs, obj->properties->slots, obj->properties->size);
        }
    }
    ejsSetMemRef(obj);
    return obj;
}


/*
    Manage the object properties for the garbage collector
 */
void ejsManagePot(void *ptr, int flags)
{
    EjsSlot     *sp;
    EjsPot      *obj;
    int         i, numProp;

    if (ptr) {
        obj = (EjsPot*) ptr;

        if (flags & MPR_MANAGE_MARK) {
            if (obj->separateSlots) {
                mprMark(obj->properties);
            }
            if (obj->separateHash) {
                mprMark(obj->properties->hash);
            }
            /*
                Cache numProp incase the object grows while traversing
             */
            numProp = obj->numProp;
            for (sp = obj->properties->slots, i = 0; i < numProp; i++, sp++) {
                if (sp->qname.name) {
                    mprMark(sp->qname.name);
                    mprMark(sp->qname.space);
                    mprMark(sp->value.ref);
#if FUTURE
                    mprMark(sp->trait.type);
#endif
                }
            }
        }
    }
}


void ejsCreatePotHelpers(Ejs *ejs)
{
    EjsHelpers      *helpers;

    ejs->potHelpers = ejs->objHelpers;
    helpers = &ejs->potHelpers;
    helpers->clone                  = (EjsCloneHelper) ejsClonePot;
    helpers->create                 = (EjsCreateHelper) ejsCreatePot;
    helpers->defineProperty         = (EjsDefinePropertyHelper) definePotProperty;
    helpers->deleteProperty         = (EjsDeletePropertyHelper) deletePotProperty;
    helpers->deletePropertyByName   = (EjsDeletePropertyByNameHelper) deletePotPropertyByName;
    helpers->getProperty            = (EjsGetPropertyHelper) getPotProperty;
    helpers->getPropertyCount       = (EjsGetPropertyCountHelper) getPotPropertyCount;
    helpers->getPropertyName        = (EjsGetPropertyNameHelper) ejsGetPotPropertyName;
    helpers->getPropertyTraits      = (EjsGetPropertyTraitsHelper) getPotPropertyTraits;
    helpers->lookupProperty         = (EjsLookupPropertyHelper) ejsLookupPotProperty;
    helpers->setProperty            = (EjsSetPropertyHelper) setPotProperty;
    helpers->setPropertyName        = (EjsSetPropertyNameHelper) setPotPropertyName;
    helpers->setPropertyTraits      = (EjsSetPropertyTraitsHelper) setPotPropertyTraits;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsPot.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsReflect.c"
 */
/************************************************************************/

/**
    ejsReflect.c - Reflection class and API

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



#if UNUSED
/*
    Constructor

    public function Reflect(o: Object)
 */
static EjsObj *ref_Reflect(Ejs *ejs, EjsReflect *rp, int argc,  EjsObj **argv)
{
    mprAssert(argc == 1);
    rp->subject = argv[0];
    mprAssert(rp->subject->type);
    return rp;
}


/*
    Get the base class of the object.

    function get base(): Object
 */
static EjsObj *ref_base(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = rp->subject;
    if (ejsIsType(ejs, vp)) {
        return (((EjsType*) vp)->baseType);
    }
    if (vp->type == 0) {
        return S(null);
    }
    return vp->type;
}


/*
    function get isType(): Boolean
 */
static EjsBoolean *ref_isType(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejsIsType(ejs, rp->subject));
}


/*
    Get the type of the object.

    function get type(): Object
 */
static EjsType *ref_type(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = rp->subject;
    if (vp->type == 0) {
        return S(null);
    }
    return vp->type;
}


/*
    Return the type name of a var as a string. If the var is a type, get the base type.
 */
EjsString *ejsGetTypeName(Ejs *ejs, EjsObj *vp)
{
    EjsType     *type;

    if (vp == 0) {
        return S(undefined);
    }
    type = (EjsType*) vp->type;
    if (type == 0) {
        return S(null);
    }
    return ejsCreateStringFromAsc(ejs, type->qname.name);
}


/*
    Get the type name of a type object

    function get name(): String
 */
static EjsString *ref_name(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsType     *type;

    type = (EjsType*) rp->subject;
    if (!ejsIsType(ejs, type)) {
        return S(empty);
    }
    return ejsCreateStringFromAsc(ejs, type->qname.name);
}


/*
    function get typeOf(obj): String
 */
static EjsString *ref_typeOf(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    mprAssert(argc >= 1);
    return ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the ecma "typeof" value for an object. Unfortunately, typeof is pretty lame.
 */
EjsString *ejsGetTypeOf(Ejs *ejs, EjsObj *vp)
{
    if (vp == S(undefined)) {
        return ejsCreateStringFromAsc(ejs, "undefined");

    } else if (ejsIs(ejs, vp, Null)) {
        /* Yea - I know, ECMAScript is broken */
        return ejsCreateStringFromAsc(ejs, "object");

    } if (ejsIs(ejs, vp, Boolean)) {
        return ejsCreateStringFromAsc(ejs, "boolean");

    } else if (ejsIs(ejs, vp, Number)) {
        return ejsCreateStringFromAsc(ejs, "number");

    } else if (ejsIs(ejs, vp, String)) {
        return ejsCreateStringFromAsc(ejs, "string");

    } else if (ejsIs(ejs, vp, Function)) {
        return ejsCreateStringFromAsc(ejs, "function");
               
    } else {
        return ejsCreateStringFromAsc(ejs, "object");
    }
}



static void manageReflect(EjsReflect *rp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(rp->subject);
    }
}


void ejsConfigureReflectType(Ejs *ejs)
{
    EjsType     *type;
    EjsObj      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "Reflect"), sizeof(EjsReflect), manageReflect, EJS_OBJ_HELPERS);
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, ref_Reflect);
    ejsBindMethod(ejs, prototype, ES_Reflect_base, ref_base);
    ejsBindMethod(ejs, prototype, ES_Reflect_isType, ref_isType);
    ejsBindMethod(ejs, prototype, ES_Reflect_name, ref_name);
#if UNUSED
    ejsBindMethod(ejs, prototype, ES_Reflect_isPrototype, ref_isPrototype);
    ejsBindMethod(ejs, prototype, ES_Reflect_prototype, ref_prototype);
#endif
    ejsBindMethod(ejs, prototype, ES_Reflect_type, ref_type);
    ejsBindFunction(ejs, ejs->globalBlock, ES_typeOf, ref_typeOf);
}

#else
void dummy_Reflection() {}
#endif


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsReflect.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsRegExp.c"
 */
/************************************************************************/

/**
    ejsRegExp.c - RegExp type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

#include    "pcre.h"


static char *makeFlags(EjsRegExp *rp);
static int parseFlags(EjsRegExp *rp, MprChar *flags);

/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castRegExp(Ejs *ejs, EjsRegExp *rp, EjsType *type)
{
    char    *flags;

    switch (type->sid) {
    case S_Boolean:
        return S(true);

    case S_String:
        flags = makeFlags(rp);
        return ejsSprintf(ejs, "/%w/%s", rp->pattern, flags);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


/*
    RegExp constructor

    RegExp(pattern: String, flags: String = null)
 */

static EjsRegExp *regex_Constructor(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    cchar       *errMsg;
    int         column, errCode;

    rp->pattern = wclone(ejsToString(ejs, argv[0])->value);
    rp->options = PCRE_JAVASCRIPT_COMPAT;

    if (argc == 2) {
        rp->options |= parseFlags(rp, ejsToString(ejs, argv[1])->value);
    }
    if (rp->compiled) {
        free(rp->compiled);
    }
    rp->compiled = (void*) pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL);
    if (rp->compiled == NULL) {
        ejsThrowArgError(ejs, "Can't compile regular expression. Error %s at column %d", errMsg, column);
        return 0;
    }
    return rp;
}


static EjsNumber *regex_getLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, rp->endLastMatch);
}


/*
    function set lastIndex(value: Number): Void
 */
static EjsObj *regex_setLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    rp->endLastMatch = (int) ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function exec(str: String, start: Number = 0): Array
 */
static EjsArray *regex_exec(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *match, *str;
    int         matches[EJS_MAX_REGEX_MATCHES * 3];
    int         count, start, len, i, index;

    str = (EjsString*) argv[0];
    if (argc == 2) {
        start = (int) ejsGetNumber(ejs, argv[1]);
    } else {
        start = rp->endLastMatch;
    }
    rp->matched = 0;
    mprAssert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str->value, (int) str->length, start, 0, matches, sizeof(matches) / sizeof(int));
    if (count < 0) {
        rp->endLastMatch = 0;
        return S(null);
    }
    results = ejsCreateArray(ejs, count);
    for (index = 0, i = 0; i < count; i++, index += 2) {
        len = matches[index + 1] - matches[index];
        match = ejsCreateString(ejs, &str->value[matches[index]], len);
        ejsSetProperty(ejs, results, i, match);
        if (index == 0) {
            rp->matched = match;
        }
    }
    if (rp->global) {
        /* Only save if global flag used as per spec */
        rp->startLastMatch = matches[0];
        rp->endLastMatch = matches[1];
    }
    return results;
}


static EjsBoolean *regex_getGlobalFlag(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->global);
}


static EjsBoolean *regex_getIgnoreCase(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->ignoreCase);
}


static EjsBoolean *regex_getMultiline(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->multiline);
}


static EjsString *regex_getSource(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateString(ejs, rp->pattern, wlen(rp->pattern));
}


static EjsString *regex_matched(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    if (rp->matched == 0) {
        return S(null);
    }
    return rp->matched;
}


static EjsNumber *regex_start(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, rp->startLastMatch);
}


static EjsBoolean *regex_sticky(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->sticky);
}


static EjsBoolean *regex_test(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    EjsString   *str;
    int         count;

    str = (EjsString*) argv[0];
    mprAssert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str->value, (int) str->length, rp->endLastMatch, 0, 0, 0);
    if (count < 0) {
        rp->endLastMatch = 0;
        return S(false);
    }
    return S(true);
}


EjsString *ejsRegExpToString(Ejs *ejs, EjsRegExp *rp)
{
    return (EjsString*) castRegExp(ejs, rp, ST(String));
}

/*
    Create an initialized regular expression object. The pattern should include
    the slash delimiters. For example: /abc/ or /abc/g
 */
EjsRegExp *ejsCreateRegExp(Ejs *ejs, EjsString *pattern)
{
    EjsRegExp   *rp;
    cchar       *errMsg;
    MprChar     *flags;
    int         column, errCode;

    if (pattern->length == 0 || pattern->value[0] != '/') {
        ejsThrowArgError(ejs, "Bad regular expression pattern. Must start with '/'");
        return 0;
    }
    rp = ejsCreateObj(ejs, ST(RegExp), 0);
    if (rp != 0) {
        /*
            Strip off flags for passing to pcre_compile2
         */
        rp->pattern = sclone(&pattern->value[1]);
        if ((flags = wrchr(rp->pattern, '/')) != 0) {
            rp->options = parseFlags(rp, &flags[1]);
            *flags = 0;
        }
        //  TODO - UNICODE is pattern meant to be 
        rp->compiled = pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL);
        if (rp->compiled == NULL) {
            ejsThrowArgError(ejs, "Can't compile regular expression. Error %s at column %d", errMsg, column);
            return 0;
        }
    }
    return rp;
}


static int parseFlags(EjsRegExp *rp, MprChar *flags)
{
    MprChar     *cp;
    int         options;

    if (flags == 0 || *flags == '\0') {
        return 0;
    }
    options = PCRE_JAVASCRIPT_COMPAT;
    for (cp = flags; *cp; cp++) {
        switch (tolower((int) *cp)) {
        case 'g':
            rp->global = 1;
            break;
        case 'i':
            rp->ignoreCase = 1;
            options |= PCRE_CASELESS;
            break;
        case 'm':
            rp->multiline = 1;
            options |= PCRE_MULTILINE;
            break;
        case 's':
            options |= PCRE_DOTALL;
            break;
        case 'y':
            rp->sticky = 1;
            break;
        case 'x':
            options |= PCRE_EXTENDED;
            break;
        case 'X':
            options |= PCRE_EXTRA;
            break;
        case 'U':
            options |= PCRE_UNGREEDY;
            break;
        }
    }
    return options;
}


static char *makeFlags(EjsRegExp *rp)
{
    char    buf[16], *cp;

    cp = buf;
    if (rp->global) {
        *cp++ = 'g';
    }
    if (rp->ignoreCase) {
        *cp++ = 'i';
    }
    if (rp->multiline) {
        *cp++ = 'm';
    }
    if (rp->sticky) {
        *cp++ = 'y';
    }
    if (rp->options & PCRE_DOTALL) {
        *cp++ = 's';
    }
    if (rp->options & PCRE_EXTENDED) {
        *cp++ = 'x';
    }
    if (rp->options & PCRE_EXTRA) {
        *cp++ = 'X';
    }
    if (rp->options & PCRE_UNGREEDY) {
        *cp++ = 'U';
    }
    *cp++ = '\0';
    return sclone(buf);
}


static void manageRegExp(EjsRegExp *rp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(rp->pattern);

    } else if (flags & MPR_MANAGE_FREE) {
        if (rp->compiled) {
            free(rp->compiled);
            rp->compiled = 0;
        }
    }
}


void ejsCreateRegExpType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "RegExp"), sizeof(EjsRegExp), S_RegExp, ES_RegExp_NUM_CLASS_PROP,
        manageRegExp, EJS_OBJ_HELPERS);
    type->helpers.cast = (EjsCastHelper) castRegExp;
}


void ejsConfigureRegExpType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(RegExp);
    type->mutableInstances = 1;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, regex_Constructor);
    ejsBindMethod(ejs, prototype, ES_RegExp_exec, regex_exec);
    ejsBindAccess(ejs, prototype, ES_RegExp_lastIndex, regex_getLastIndex, regex_setLastIndex);
    ejsBindMethod(ejs, prototype, ES_RegExp_global, regex_getGlobalFlag);
    ejsBindMethod(ejs, prototype, ES_RegExp_ignoreCase, regex_getIgnoreCase);
    ejsBindMethod(ejs, prototype, ES_RegExp_multiline, regex_getMultiline);
    ejsBindMethod(ejs, prototype, ES_RegExp_source, regex_getSource);
    ejsBindMethod(ejs, prototype, ES_RegExp_matched, regex_matched);
    ejsBindMethod(ejs, prototype, ES_RegExp_start, regex_start);
    ejsBindMethod(ejs, prototype, ES_RegExp_sticky, regex_sticky);
    ejsBindMethod(ejs, prototype, ES_RegExp_test, regex_test);
    ejsBindMethod(ejs, prototype, ES_RegExp_toString, ejsRegExpToString);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsRegExp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsSocket.c"
 */
/************************************************************************/

/**
    ejsSocket.c - Socket class. This implements TCP/IP v4 and v6 connectivity.
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event));
#if UNUSED
static int socketConnectEvent(EjsSocket *sp, MprEvent *event);
#endif
static int socketIOEvent(EjsSocket *sp, MprEvent *event);
static int socketListenEvent(EjsSocket *listen, MprEvent *event);

/*
    function Socket()
 */
static EjsSocket *sock_Socket(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    //  TODO -- ssl?
    sp->ejs = ejs;
    sp->sock = mprCreateSocket(NULL);
    if (sp->sock == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
#if UNUSED
    sp->waitHandler.fd = -1;
#endif
    return sp;
}


/*
    function accept(): Socket
 */
EjsSocket *sock_accept(Ejs *ejs, EjsSocket *listen, int argc, EjsObj **argv)
{
    MprSocket   *sock;
    EjsSocket   *sp;

    if ((sock = mprAcceptSocket(listen->sock)) == 0) {
        ejsThrowIOError(ejs, "Can't accept new socket");
        return 0;
    }
    sp = ejsCreateSocket(ejs);
    sp->sock = sock;
    sp->async = listen->async;
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketIOEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return sp;
}


/*
    function get address(): String
 */
EjsString *sock_address(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, sp->address);
}


/*
    function get async(): Boolean
 */
EjsBoolean *sock_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (sp->async) ? S(true) : S(false);
}


/*
    function set async(enable: Boolean): Void
 */
EjsObj *sock_set_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    sp->async = (argv[0] == S(true));
    return 0;
}


/*
    function close(): Void
    TODO - should support graceful option
 */
static EjsObj *sock_close(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ejsSendEvent(ejs, sp->emitter, "close", NULL, sp);
    if (sp->sock) {
        mprCloseSocket(sp->sock, 0);
        sp->sock = 0;
    }
    return 0;
}


/*
    function connect(address): Void
 */
static EjsObj *sock_connect(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString       *address;
    char            *cp;

    address = (EjsString*) argv[0];
    if (ejsIs(ejs, address, Number)) {
        sp->address = sclone("127.0.0.1");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIs(ejs, address, String)) {
            address = ejsToString(ejs, address);
        }
        sp->address = ejsToMulti(ejs, address);
        if ((cp = strchr(sp->address, ':')) != 0) {
            *cp++ = '\0';
            sp->port = atoi(cp);
        } else {
            ejsThrowArgError(ejs, "Address must have a port");
            return 0;
        }
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprConnectSocket(sp->sock, sp->address, sp->port, 0) < 0) {
        ejsThrowArgError(ejs, "Can't open client socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketIOEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    ejsSendEvent(ejs, sp->emitter, "writable", NULL, sp);
    return 0;
}


/**
    function listen(address): Void
    @param address Can be either a "ip", "ip:port" or port
 */
static EjsObj *sock_listen(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString   *address;
    char        *cp;

    address = (EjsString*) argv[0];
    if (ejsIs(ejs, address, Number)) {
        sp->address = sclone("");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIs(ejs, address, String)) {
            address = ejsToString(ejs, address);
        }
        sp->address = ejsToMulti(ejs, address);
        if ((cp = strchr(sp->address, ':')) != 0) {
            *cp++ = '\0';
            sp->port = atoi(cp);
        } else {
            ejsThrowArgError(ejs, "Address must have a port");
            return 0;
        }
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprListenOnSocket(sp->sock, sp->address, sp->port, 0) < 0) {
        ejsThrowArgError(ejs, "Can't open listening socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketListenEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return 0;
}


/*
    function off(name, observer: Function): Void
 */
static EjsObj *sock_off(Ejs *ejs, EjsSocket *sp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


/*
    function on(name: [String|Array], observer: Function): Void
 */
EjsObj *sock_on(Ejs *ejs, EjsSocket *sp, int argc, EjsAny **argv)
{
    ejsAddObserver(ejs, &sp->emitter, argv[0], argv[1]);
    return 0;
}


/*
    function get port(): Number
 */
static EjsNumber *sock_port(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, sp->port);
}


/*
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *sock_read(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    ssize           nbytes, offset, count;

    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 1) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 2) ? ejsGetInt(ejs, argv[2]) : -1;

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->length - offset;
    }
    if (count < 0) {
        //  Do something
    }
    nbytes = mprReadSocket(sp->sock, &ba->value[offset], count);
    if (nbytes < 0) {
        //  TODO -- should not be using EOF event
        ejsSendEvent(ejs, sp->emitter, "eof", NULL, sp);
        //  TODO - do we need to set the mask here?
        return S(null);
    }
    if (nbytes == 0) {
        //  TODO - but in async, this does not mean eof. See mpr for how to tell eof
        //  TODO -- should not be using EOF event
        ejsSendEvent(ejs, sp->emitter, "eof", NULL, sp);
        //  TODO - do we need to set the mask here?
        return S(null);
    }
    ba->writePosition += nbytes;
    sp->mask |= MPR_READABLE;
    enableSocketEvents(sp, socketIOEvent);
    return ejsCreateNumber(ejs, (int) nbytes);
}


/*
    function get remoteAddress(): String
 */
static EjsString *sock_remoteAddress(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, sp->address);
}


static ssize writeSocketData(Ejs *ejs, EjsSocket *sp)
{
    EjsByteArray    *ba;
    ssize           nbytes, count;

    ba = sp->data;
    nbytes = 0;
    count = 0;
    if (ba && (count = ejsGetByteArrayAvailable(ba)) > 0) {
        nbytes = mprWriteSocket(sp->sock, &ba->value[ba->readPosition], count);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    if (ejsGetByteArrayAvailable(ba) == 0) {
        if (sp->emitter) {
            ejsSendEvent(ejs, sp->emitter, "writable", NULL, sp);
        }
        if (sp->async) {
            sp->mask &= ~MPR_WRITABLE;
        }
    } else if (sp->async) {
        if (nbytes < count) {
            sp->mask |= MPR_WRITABLE;
        } else {
            sp->mask &= ~MPR_WRITABLE;
        }
    }
    return nbytes;
}


/*
    function write(...data): Number
 */
static EjsNumber *sock_write(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ssize     nbytes;

    if (sp->data) {
        ejsResetByteArray(sp->data);
    } else {
        sp->data = ejsCreateByteArray(ejs, -1);
    } 
    //  TODO - OPT. Could not copy and write directly from original source if source is a byte array
    if (ejsWriteToByteArray(ejs, sp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeSocketData(ejs, sp)) < 0) {
        return 0;
    }
    if (sp->async) {
        enableSocketEvents(sp, socketIOEvent);
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}



static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event))
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (sp->sock->handler == 0) {
        mprAddSocketHandler(sp->sock, sp->mask, ejs->dispatcher, (MprEventProc) proc, sp, 0);
    } else {
        mprEnableSocketEvents(sp->sock, sp->mask);
    }
}


#if UNUSED
static int socketConnectEvent(EjsSocket *sp, MprEvent *event)
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (sp->emitter) {
        ejsSendEvent(ejs, sp->emitter, "connect", NULL, sp);
        ejsSendEvent(ejs, sp->emitter, "writable", NULL, sp);
    }
    enableSocketEvents(sp, socketIOEvent);
    return 0;
}
#endif


static int socketListenEvent(EjsSocket *listen, MprEvent *event)
{
    Ejs     *ejs;

    ejs = listen->ejs;
    if (listen->emitter) {
        ejsSendEvent(ejs, listen->emitter, "accept", NULL, listen);
    }
    enableSocketEvents(listen, socketListenEvent);
    return 0;
}


static int socketIOEvent(EjsSocket *sp, MprEvent *event)
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (event->mask & MPR_READABLE) {
        if (sp->emitter) {
            ejsSendEvent(ejs, sp->emitter, "readable", NULL, sp);
        }
        sp->mask |= MPR_READABLE;
    } 
    if (event->mask & MPR_WRITABLE) {
        writeSocketData(ejs, sp);
    }
    enableSocketEvents(sp, socketIOEvent);
    return 0;
}


/*  
   Manage the object properties for the garbage collector
 */
static void manageSocket(EjsSocket *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(sp->emitter);
        mprMark(sp->data);
        mprMark(sp->sock);
        mprMark(sp->address);
    }
}


EjsSocket *ejsCreateSocket(Ejs *ejs)
{
    EjsSocket   *sp;

    sp = ejsCreateObj(ejs, ejsGetTypeByName(ejs, N(EJS_EJS_NAMESPACE, "Socket")), 0);
    sp->ejs = ejs;
#if UNUSED
    sp->waitHandler.fd = -1;
#endif
    return sp;
}


void ejsConfigureSocketType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "Socket"), sizeof(EjsSocket), (MprManager) manageSocket, EJS_OBJ_HELPERS);
    type->mutableInstances = 1;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, sock_Socket);
    ejsBindMethod(ejs, prototype, ES_Socket_accept, sock_accept);
    ejsBindMethod(ejs, prototype, ES_Socket_address, sock_address);
    ejsBindAccess(ejs, prototype, ES_Socket_async, sock_async, sock_set_async);
    ejsBindMethod(ejs, prototype, ES_Socket_close, sock_close);
    ejsBindMethod(ejs, prototype, ES_Socket_connect, sock_connect);
    ejsBindMethod(ejs, prototype, ES_Socket_listen, sock_listen);
    ejsBindMethod(ejs, prototype, ES_Socket_off, sock_off);
    ejsBindMethod(ejs, prototype, ES_Socket_on, sock_on);
    ejsBindMethod(ejs, prototype, ES_Socket_port, sock_port);
    ejsBindMethod(ejs, prototype, ES_Socket_read, sock_read);
    ejsBindMethod(ejs, prototype, ES_Socket_remoteAddress, sock_remoteAddress);
    ejsBindMethod(ejs, prototype, ES_Socket_write, sock_write);
}

/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsSocket.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsStore.c"
 */
/************************************************************************/

/**
    ejsStore.c - API for the Store class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




EjsVoid *ejsStoreExpire(Ejs *ejs, EjsObj *store, EjsString *key, EjsDate *when)
{
    EjsAny  *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    argv[1] = when;
    return ejsRunFunctionBySlot(ejs, store, ES_Store_expire, 2, argv);
}


EjsAny *ejsStoreRead(Ejs *ejs, EjsObj *store, EjsString *key, EjsObj *options)
{
    EjsAny  *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    argv[1] = (options) ? options : S(null);
    return ejsRunFunctionBySlot(ejs, store, ES_Store_read, 2, argv);
}


EjsAny *ejsStoreReadObj(Ejs *ejs, EjsObj *store, EjsString *key, EjsObj *options)
{
    EjsAny  *value, *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    argv[1] = (options) ? options : S(null);
    if ((value = ejsRunFunctionBySlot(ejs, store, ES_Store_read, 2, argv)) == 0 || value == S(null)) {
        return 0;
    }
    return ejsDeserialize(ejs, value);
}


EjsBoolean *ejsStoreRemove(Ejs *ejs, EjsObj *store, EjsString *key)
{
    EjsAny  *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    return ejsRunFunctionBySlot(ejs, store, ES_Store_remove, 1, argv);
}


EjsVoid *ejsStoreSetLimits(Ejs *ejs, EjsObj *store, EjsObj *limits)
{
    EjsAny  *argv[2];

    ejsFreeze(ejs, 1);
    argv[0] = limits;
    return ejsRunFunctionBySlot(ejs, store, ES_Store_setLimits, 2, argv);
}


EjsNumber *ejsStoreWrite(Ejs *ejs, EjsObj *store, EjsString *key, EjsString *value, EjsObj *options)
{
    EjsAny  *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    argv[1] = value;
    argv[2] = (options) ? options : S(null);
    return ejsRunFunctionBySlot(ejs, store, ES_Store_write, 3, argv);
}


EjsNumber *ejsStoreWriteObj(Ejs *ejs, EjsObj *store, EjsString *key, EjsAny *value, EjsObj *options)
{
    EjsAny  *argv[3];

    ejsFreeze(ejs, 1);
    argv[0] = key;
    argv[1] = ejsSerialize(ejs, value, 0);
    argv[2] = (options) ? options : S(null);
    return ejsRunFunctionBySlot(ejs, store, ES_Store_write, 3, argv);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsStore.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsString.c"
 */
/************************************************************************/

/**
    ejsString.c - Ejscript string class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

#include    "pcre.h"


static int internHashSizes[] = {
     389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 0
};

/*
    XXX 
    Intern locking
 */
static MprSpin      internLock;
static MprSpin      *ispin = &internLock;
#define ilock()     mprSpinLock(ispin);
#define iunlock()   mprSpinUnlock(ispin);


static EjsString *buildString(Ejs *ejs, EjsString *result, MprChar *str, ssize len);
static ssize indexof(MprChar *str, ssize len, EjsString *pattern, ssize patternLength, int dir);
static void linkString(EjsString *head, EjsString *sp);
static void manageIntern(EjsIntern *intern, int flags);
static int rebuildIntern(EjsIntern *intern);
static void unlinkString(EjsString *sp);

/*
    Cast the string operand to a primitive type
 */
static EjsAny *castString(Ejs *ejs, EjsString *sp, EjsType *type)
{
    mprAssert(sp);
    mprAssert(type);

#if UNUSED
    if (type == ST(Path)) {
        return ejsCreatePath(ejs, sp);
    } else if (type == ST(Uri)) {
        return ejsCreateUri(ejs, sp);
    }
#endif

    switch (type->sid) {
    case S_Boolean:
        if (sp != S(empty)) {
            return S(true);
        }
        return S(false);

    case S_Number:
        return ejsParse(ejs, sp->value, S_Number);

    case S_Path:
        return ejsCreatePath(ejs, sp);

    case S_RegExp:
        if (sp && sp->value[0] == '/') {
            return ejsCreateRegExp(ejs, sp);
        }
        return ejsCreateRegExp(ejs, ejsSprintf(ejs, "/%@/", sp));

    case S_String:
        return sp;

    case S_Uri:
        return ejsCreateUri(ejs, sp);

    default:
        ejsThrowTypeError(ejs, "Can't cast to required type");
        return 0;
    }
    return 0;
}


static EjsString *cloneString(Ejs *ejs, EjsString *sp, bool deep)
{
    /* Strings are immutable, interned and shared across all interps */
    return sp;
}


/*
    Get a string element. Slot numbers correspond to character indicies.
 */
static EjsString *getStringProperty(Ejs *ejs, EjsString *sp, int index)
{
    if (index < 0 || index >= sp->length) {
        return S(empty);
    }
    return ejsCreateString(ejs, &sp->value[index], 1);
}


static EjsAny *coerceStringOperands(Ejs *ejs, EjsAny *lhs, int opcode,  EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToString(ejs, rhs));

    /*
        Overloaded operators
     */
    case EJS_OP_MUL:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_REM:
        return 0;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToString(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT:
        return ejsInvokeOperator(ejs, ejsToBoolean(ejs, lhs), opcode, rhs);

    case EJS_OP_NOT:
    case EJS_OP_NEG:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsString*) lhs) ? S(true) : S(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsString*) lhs) ? S(false): S(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeStringOperator(Ejs *ejs, EjsString *lhs, int opcode, EjsString *rhs, void *data)
{
    EjsAny  *result, *arg;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, String) || !ejsIs(ejs, rhs, String)) {
            if ((result = coerceStringOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }
    /*
        Types now match, both strings
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        //  OPT -- should use lhs == rhs
        if (lhs->value == rhs->value) {
            mprAssert(lhs == rhs);
            return S(true);
        }
        return S(false);

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        //  OPT -- should use lhs == rhs
        if (lhs->value != rhs->value) {
            mprAssert(lhs != rhs);
            return S(true);
        }
        return S(false);

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(MprChar), rhs->value, rhs->length * sizeof(MprChar)) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(MprChar), rhs->value, rhs->length * sizeof(MprChar)) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(MprChar), rhs->value, rhs->length * sizeof(MprChar)) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, 
                mprMemcmp(lhs->value, lhs->length * sizeof(MprChar), rhs->value, rhs->length * sizeof(MprChar)) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs == 0) ? S(true): S(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return S(false);

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsCatString(ejs, lhs, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

#if EXTENSIONS || 1
    /*
        Overloaded
     */
    case EJS_OP_SUB:
        arg = rhs;
        return ejsRunFunctionBySlot(ejs, lhs, ES_String_MINUS, 1, &arg);

    case EJS_OP_REM:
        arg = rhs;
        return ejsRunFunctionBySlot(ejs, lhs, ES_String_MOD, 1, &arg);
#endif

    case EJS_OP_NEG:
    case EJS_OP_LOGICAL_NOT:
    case EJS_OP_NOT:
        /* Already handled in coerceStringOperands */
    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Lookup an string index.
 */
static int lookupStringProperty(Ejs *ejs, EjsString *sp, EjsName qname)
{
    int     index;

    //  TODO UNICODE
    if (!isdigit((int) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < sp->length) {
        return index;
    }
    return EJS_ERR;
}


/*
    String constructor

        function String()
        function String(str: String)
 */
static EjsString *stringConstructor(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;

    mprAssert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], Array)));
    sp->length = 0;

    if (argc == 1) {
        args = (EjsArray*) argv[0];
        if (args->length > 0) {
            return ejsToString(ejs, ejsGetProperty(ejs, args, 0));
        }
    }
    return ejsInternString(sp);
}


/*
    Do a case sensitive comparison between this string and another.

    function caseCompare(compare: String): Number
 */
static EjsNumber *caseCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    result = wcmp(sp->value, ((EjsString*) argv[0])->value);
    return ejsCreateNumber(ejs, result);
}


/*
    Do a case insensitive comparison between this string and another.

    function caselessCompare(compare: String): Number
 */
static EjsNumber *caselessCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    result = wcasecmp(sp->value, ((EjsString*) argv[0])->value);
    return ejsCreateNumber(ejs, result);
}


/*
    Return a string containing the character at a given index

    function charAt(index: Number): String
 */
static EjsString *charAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));
    index = ejsGetInt(ejs, argv[0]);
    if (index < 0 || index >= sp->length) {
        return S(empty);
    }
    return ejsCreateString(ejs, &sp->value[index], 1);
}


/*
    Return an integer containing the character at a given index

    function charCodeAt(index: Number = 0): Number
 */

static EjsNumber *charCodeAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    index = (argc == 1) ? ejsGetInt(ejs, argv[0]) : 0;
    if (index < 0) {
        index = (int) sp->length -1 ;
    }
    if (index < 0 || index >= sp->length) {
        return S(nan);
    }
    return ejsCreateNumber(ejs, (uchar) sp->value[index]);
}


/*
    Catenate args to a string and return a new string.

    function concat(...args): String
 */
static EjsString *concatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsString   *result, *str;
    int         i, count;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));
    args = (EjsArray*) argv[0];

    result = (EjsString*) ejsClone(ejs, sp, 0);
    count = ejsGetPropertyCount(ejs, args);
    for (i = 0; i < args->length; i++) {
        str = ejsToString(ejs, ejsGetProperty(ejs, args, i));
        if ((result = ejsCatString(ejs, result, str)) == NULL) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return result;
}


/**
    Check if a string contains the pattern (string or regexp)

    function contains(pattern: Object): Boolean
 */
static EjsBoolean *containsString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsObj      *pat;
    EjsString   *spat;

    pat = argv[0];

    if (ejsIs(ejs, pat, String)) {
        spat = (EjsString*) pat;
        return ejsCreateBoolean(ejs, wcontains(sp->value, spat->value, -1) != 0);

    } else if (ejsIs(ejs, pat, RegExp)) {
        EjsRegExp   *rp;
        int         count;
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, 0, 0, 0, 0);
        return ejsCreateBoolean(ejs, count >= 0);
    }
    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string ends with a given pattern

    function endsWith(pattern: String): Boolean
 */
static EjsBoolean *endsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *pattern;
    ssize       len;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    len = pattern->length;
    if (len > sp->length) {
        return S(false);
    }
    return ejsCreateBoolean(ejs, wncmp(&sp->value[sp->length - len], pattern->value, len) == 0);
}


/**
    Format the arguments

    function format(...args): String

    Format:         %[modifier][width][precision][type]
    Modifiers:      +- #,
 */
static EjsString *formatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args, *inner;
    EjsString   *result;
    EjsAny      *value;
    MprChar     *buf, fmt[32];
    ssize       i, flen, start, len, last;
    int         c, nextArg, kind;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    /*
        Flatten the args if there is only one element and it is itself an array. This happens when invoked
        via the overloaded operator '%' which in turn invokes format()
     */
    if (args->length == 1) {
        inner = ejsGetProperty(ejs, args, 0);
        if (ejsIs(ejs, inner, Array)) {
            args = inner;
        }
    }
    if ((result = ejsCreateBareString(ejs, MPR_BUFSIZE)) == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    result->length = 0;

    /*
        Parse the format string and extract one specifier at a time.
     */
    last = 0;
    for (i = 0, nextArg = 0; i < sp->length; i++) {
        c = sp->value[i];
        if (c != '%') {
            continue;
        }
        if (i > last) {
            result = buildString(ejs, result, &sp->value[last], i - last);
        }
        /*
            Find the end of the format specifier and determine the format type (kind)
         */
        start = i++;
        i += mspn(&sp->value[i], "-+ #,0*123456789.");
        kind = sp->value[i];

        if (strchr("cdefginopsSuxX", kind)) {
            len = i - start + 1;
            wncopy(fmt, (sizeof(fmt) / sizeof(MprChar)) - 4, &sp->value[start], len);

            if (nextArg < args->length) {
                value = ejsGetProperty(ejs, args, nextArg);
            } else {
                value = S(null);
            }
            buf = 0;
            //  OPT
            switch (kind) {
            case 'd': case 'i': case 'o': case 'u':
                value = ejsToNumber(ejs, value);
                flen = sizeof(fmt) - len + 1;
                mtow(&fmt[len - 1], flen, ".0f", 3);
                buf = wfmt(fmt, ejsGetNumber(ejs, value));
                break;

            case 'e': case 'g': case 'f':
                value = ejsToNumber(ejs, value);
                buf = wfmt(fmt, ejsGetNumber(ejs, value));
                break;

            case 's':
                value = ejsToString(ejs, value);
                buf = wfmt(fmt, ejsToMulti(ejs, value));
                break;

            case 'X': case 'x':
                buf = wfmt(fmt, (int64) ejsGetNumber(ejs, value));
                break;

            case 'n':
                buf = wfmt(fmt, 0);
                break;

            default:
                ejsThrowArgError(ejs, "Bad format specifier");
                return 0;
            }
            result = buildString(ejs, result, buf, wlen(buf));
            last = i + 1;
            nextArg++;

        } else if (kind == '%') {
            MprChar percent[1];
            percent[0] = '%';
            result = buildString(ejs, result, percent, 1);
            last = i + 1;
        }
    }
    if (sp->length > last) {
        result = buildString(ejs, result, &sp->value[last], sp->length - last);
    }
    return ejsInternString(result);
}


/*
    Create a string from character codes

    static function fromCharCode(...codes): String
 */
static EjsString *fromCharCode(Ejs *ejs, EjsString *unused, int argc, EjsObj **argv)
{
    EjsString   *result;
    EjsArray    *args;
    EjsObj      *vp;
    int         i;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Array));
    args = (EjsArray*) argv[0];

    if ((result = (EjsString*) ejsCreateBareString(ejs, argc + 1)) == NULL) {
        return 0;
    }
    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, args, i);
        result->value[i] = ejsGetInt(ejs, ejsToNumber(ejs, vp));
    }
    result->value[i] = '\0';
    result->length = args->length;
    return ejsInternString(result);
}


/*
    Function to iterate and return the next character code.
    NOTE: this is not a method of String. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextStringKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;

    if (!ejsIs(ejs, sp, String)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < sp->length) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator function get(): Iterator
 */
static EjsIterator *getStringIterator(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, sp, nextStringKey, 0, NULL);
}


/*
    Function to iterate and return the next string character (as a string).
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsString *nextStringValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;
    if (!ejsIs(ejs, sp, String)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < sp->length) {
        return ejsCreateString(ejs, &sp->value[ip->index++], 1);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator function getValues(): Iterator
 */
static EjsIterator *getStringValues(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, sp, nextStringValue, 0, NULL);
}


/*
    Get the length of a string.
    @return Returns the number of characters in the string

    override function get length(): Number
 */

static EjsNumber *stringLength(Ejs *ejs, EjsString *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->length);
}


/*
    Return the position of the first occurance of a substring

    function indexOf(pattern: String, startIndex: Number = 0): Number
 */
static EjsNumber *indexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;
    ssize       start, index, patternLength;

    mprAssert(1 <= argc && argc <= 2);
    mprAssert(ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    patternLength = (int) pattern->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start > sp->length) {
            start = sp->length;
        }
        if (start < 0) {
            start = 0;
        }
    } else {
        start = 0;
    }
    index = indexof(&sp->value[start], sp->length - start, pattern, patternLength, 1);
    if (index < 0) {
        return S(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) (index + start));
}


static EjsBoolean *isAlpha(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isalpha((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


static EjsBoolean *isAlphaNum(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isalnum((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


static EjsBoolean *isDigit(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isdigit((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


static EjsBoolean *isLower(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!islower((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


static EjsBoolean *isSpace(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isspace((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


static EjsBoolean *isUpper(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    MprChar     *cp;

    if (sp->length == 0) {
        return S(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isupper((int) *cp)) {
            return S(false);
        }
    }
    return S(true);
}


/*
    Return the position of the last occurance of a substring

    function lastIndexOf(pattern: String, start: Number = -1): Number
 */
static EjsNumber *lastIndexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;
    ssize       start, patternLength, index;

    mprAssert(1 <= argc && argc <= 2);

    pattern = (EjsString*) argv[0];
    patternLength = (int) pattern->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start >= (int) sp->length) {
            start = (int) sp->length - 1;
        }
        if (start < 0) {
            start = 0;
        }
    } else {
        start = 0;
    }
    index = indexof(sp->value, sp->length, pattern, patternLength, -1);
    if (index < 0) {
        return S(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) index);
}


/*
    Match a pattern

    function match(pattern: RegExp): Array
 */
static EjsArray *match(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsRegExp   *rp;
    EjsArray    *results;
    EjsString   *match;
    int         matches[EJS_MAX_REGEX_MATCHES * 3];
    int         i, count, len, resultCount;

    rp = (EjsRegExp*) argv[0];
    rp->endLastMatch = 0;
    results = NULL;
    resultCount = 0;

    do {
        count = (int) pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, rp->endLastMatch, 0, matches, 
            sizeof(matches) / sizeof(int));
        if (count <= 0) {
            break;
        }
        if (results == 0) {
            results = ejsCreateArray(ejs, count);
        }
        for (i = 0; i < count * 2; i += 2) {
            len = matches[i + 1] - matches[i];
            match = ejsCreateString(ejs, &sp->value[matches[i]], len);
            ejsSetProperty(ejs, results, resultCount++, match);
            rp->endLastMatch = matches[i + 1];
            if (rp->global) {
                break;
            }
        }
    } while (rp->global);
    if (results == NULL) {
        return S(null);
    }
    return results;
}


static EjsString *printable(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    MprChar         buf[16];
    ssize           len;
    int             i, j, k, nonprint;

    nonprint = 0;
    for (i = 0; i < sp->length; i++)  {
        if (!isprint((uchar) sp->value[i])) {
            nonprint++;
        }
    }
    if (nonprint == 0) {
        return sp;
    }
    if ((result = ejsCreateBareString(ejs, sp->length + (nonprint * 6) + 1)) == NULL) {
        return 0;
    }
    for (i = 0, j = 0; i < sp->length; i++)  {
        if (isprint((uchar) sp->value[i])) {
            result->value[j++] = sp->value[i];
        } else {
            result->value[j++] = '\\';
            result->value[j++] = 'u';
            itow(buf, 4, (uchar) sp->value[i], 16);
            len = wlen(buf);
            for (k = (int) len; k < 4; k++) {
                result->value[j++] = '0';
            }
            for (k = 0; buf[k]; k++) {
                result->value[j++] = buf[k];
            }
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return ejsInternString(result);
}


static EjsString *quote(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;

    if ((result = ejsCreateBareString(ejs, sp->length + 2)) == NULL) {
        return 0;
    }
    memcpy(&result->value[1], sp->value, sp->length);
    result->value[0] = '"';
    result->value[sp->length + 1] = '"';
    result->value[sp->length + 2] = '\0';
    result->length = sp->length + 2;
    return ejsInternString(result);
}


/*
    Remove characters and return a new string.

    function remove(start: Number, end: Number = -1): String

 */
static EjsString *removeCharsFromString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    ssize           start, end, i, j;

    mprAssert(1 <= argc && argc <= 2);

    start = ejsGetInt(ejs, argv[0]);
    end = ejsGetInt(ejs, argv[1]);

    if (start < 0) {
        start += sp->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (end < 0) {
        end = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    if ((result = ejsCreateBareString(ejs, sp->length - (end - start))) == NULL) {
        return 0;
    }
    for (j = i = 0; i < start; i++, j++) {
        result->value[j] = sp->value[i];
    }
    for (i = end; i < sp->length; i++, j++) {
        result->value[j] = sp->value[i];
    }
    result->value[j] = '\0';
    return ejsInternString(result);
}


static EjsString *getReplacementText(Ejs *ejs, EjsFunction *fn, int count, int *matches, EjsString *sp)
{
    EjsAny  *result, *argv[EJS_MAX_REGEX_MATCHES * 3];
    int     i, offset, argc;

    mprAssert(fn);
    
    argc = 0;
    argv[argc++] = ejsCreateString(ejs, &sp->value[matches[0]], matches[1] - matches[0]);
    for (i = 1; i < count; i++) {
        offset = i * 2;
        argv[argc++] = ejsCreateString(ejs, &sp->value[matches[offset]], matches[offset + 1] - matches[offset]);
    }
    argv[argc++] = ejsCreateNumber(ejs, matches[0]);
    argv[argc++] = sp;
    if ((result = ejsRunFunction(ejs, fn, ejs->global, argc, argv)) == 0) {
        return 0;
    }
    return (EjsString*) ejsToString(ejs, result);
}


/*
    Search and replace

    function replace(pattern: (String|Regexp), replacement: (String|Function)): String
 */
static EjsString *replace(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result, *replacement, *pattern;
    EjsFunction *replacementFunction;
    MprChar     cbuf[1];
    ssize       patternLength, index;
    int         matches[EJS_MAX_REGEX_MATCHES * 3], enabled;

    result = 0;
    if (ejsIsFunction(ejs, argv[1])) {
        replacementFunction = (EjsFunction*) argv[1];
        replacement = 0;
    } else {
        replacement = (EjsString*) ejsToString(ejs, argv[1]);
        replacementFunction = 0;
    }
    if (ejsIs(ejs, argv[0], String)) {
        pattern = (EjsString*) argv[0];
        patternLength = pattern->length;

        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        if (index >= 0) {
            if ((result = ejsCreateBareString(ejs, MPR_BUFSIZE)) == NULL) {
                return 0;
            }
            result->length = 0;
            result = buildString(ejs, result, sp->value, index);
            if (replacementFunction) {
                matches[0] = matches[2] = (int) index;
                matches[1] = matches[3] = (int) (index + patternLength);
                enabled = mprEnableGC(0);
                replacement = getReplacementText(ejs, replacementFunction, 2, matches, sp);
                mprEnableGC(enabled);
            }
            result = buildString(ejs, result, replacement->value, replacement->length);
            index += patternLength;
            if (index < sp->length) {
                result = buildString(ejs, result, &sp->value[index], sp->length - index);
            }
        } else {
            result = ejsClone(ejs, sp, 0);
        }

    } else if (ejsIs(ejs, argv[0], RegExp)) {
        EjsRegExp   *rp;
        MprChar     *cp, *lastReplace, *end;
        int         count, endLastMatch, startNextMatch, submatch;

        rp = (EjsRegExp*) argv[0];

        result = ejsCreateBareString(ejs, MPR_BUFSIZE);
        result->length = 0;
        startNextMatch = endLastMatch = 0;

        do {
            if (startNextMatch > sp->length) {
                break;
            }
            count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, startNextMatch, 0, matches, 
                    sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            if (endLastMatch < matches[0]) {
                /* Append prior string text */
                result = buildString(ejs, result, &sp->value[endLastMatch], matches[0] - endLastMatch);
            }
            /*
                Process the replacement template
             */
            if (replacementFunction) {
                enabled = mprEnableGC(0);
                replacement = getReplacementText(ejs, replacementFunction, count, matches, sp);
                mprEnableGC(enabled);
            }
            end = &replacement->value[replacement->length];
            lastReplace = replacement->value;

            for (cp = replacement->value; cp < end; ) {
                if (*cp == '$') {
                    if (lastReplace < cp) {
                        result = buildString(ejs, result, lastReplace, (int) (cp - lastReplace));
                    }
                    switch (*++cp) {
                    case '$':
                        cbuf[0] = '$';
                        result = buildString(ejs, result, cbuf, 1);
                        break;
                    case '&':
                        /* Replace the matched string */
                        result = buildString(ejs, result, &sp->value[matches[0]], matches[1] - matches[0]);
                        break;
                    case '`':
                        /* Insert the portion that preceeds the matched string */
                        result = buildString(ejs, result, sp->value, matches[0]);
                        break;
                    case '\'':
                        /* Insert the portion that follows the matched string */
                        result = buildString(ejs, result, &sp->value[matches[1]], sp->length - matches[1]);
                        break;
                    default:
                        /* Insert the nth submatch */
                        if (isdigit((int) *cp)) {
                            submatch = (int) wtoi(cp, 10, NULL);
                            while (isdigit((int) *++cp))
                                ;
                            cp--;
                            if (submatch < count) {
                                submatch *= 2;
                                result = buildString(ejs, result, &sp->value[matches[submatch]], 
                                    matches[submatch + 1] - matches[submatch]);
                            }

                        } else {
                            ejsThrowArgError(ejs, "Bad replacement $ specification");
                            return 0;
                        }
                    }
                    lastReplace = cp + 1;
                }
                cp++;
            }
            if (lastReplace < cp && lastReplace < end) {
                result = buildString(ejs, result, lastReplace, (int) (cp - lastReplace));
            }
            endLastMatch = matches[1];
            startNextMatch = (startNextMatch == endLastMatch) ? startNextMatch + 1 : endLastMatch;
        } while (rp->global);

        if (endLastMatch < sp->length) {
            /* Append remaining string text */
            result = buildString(ejs, result, &sp->value[endLastMatch], sp->length - endLastMatch);
        }

    } else {
        ejsThrowTypeError(ejs, "Wrong argument type");
        return 0;
    }
    return ejsInternString(result);
}


static EjsString *reverseString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *rp;
    MprChar     *cp;
    ssize       i;

    if (sp->length <= 1) {
        return sp;
    }
    if ((rp = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    cp = rp->value;
    for (i = sp->length - 1; i >= 0; i--) {
        *cp++ = sp->value[i];
    }
    return ejsInternString(rp);
}


/*
    Search for a pattern
    function search(pattern: (String | RegExp)): Number
 */
static EjsNumber *searchString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsRegExp   *rp;
    EjsString   *pattern;
    ssize       index, patternLength;
    int         count, matches[EJS_MAX_REGEX_MATCHES * 3];

    if (ejsIs(ejs, argv[0], String)) {
        pattern = (EjsString*) argv[0];
        patternLength = (int) pattern->length;
        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        return ejsCreateNumber(ejs, (MprNumber) index);

    } else if (ejsIs(ejs, argv[0], RegExp)) {
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, 0, 0, matches, sizeof(matches) / sizeof(int));
        if (count < 0) {
            return S(minusOne);
        }
        return ejsCreateNumber(ejs, matches[0]);

    } else {
        ejsThrowTypeError(ejs, "Wrong argument type");
    }
    return 0;
}


/*
    Return a substring. End is one past the last character.

    function slice(start: Number, end: Number = -1, step: Number = 1): String
 */
static EjsString *sliceString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    ssize           start, end, step, i, j, size;

    mprAssert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }
    if (start < 0) {
        start += sp->length;
    }
    if (start < 0) {
        start = 0;
    } else if (start >= sp->length) {
        start = sp->length;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (end < 0) {
        end = 0;
    } if (end >= sp->length) {
        end = sp->length;
    }
    if (step == 0) {
        step = 1;
    }
    size = (start < end) ? end - start : start - end;
    if ((result = ejsCreateBareString(ejs, ((size / (ssize) abs(((int) step))) + 1))) == NULL) {
        return 0;
    }
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step) {
            result->value[j++] = sp->value[i];
        }
    } else {
        for (i = start, j = 0; i > end; i += step) {
            result->value[j++] = sp->value[i];
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return ejsInternString(result);
}


/*
    Split a string

    function split(delimiter: (String | RegExp), limit: Number = -1): Array
 */
static EjsArray *split(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *elt, *delim;
    MprChar     *cp, *mark, *end;
    ssize      limit;

    mprAssert(1 <= argc && argc <= 2);

    limit = (argc == 2) ? ejsGetInt(ejs, argv[1]): MAXSSIZE;
    results = ejsCreateArray(ejs, 0);

    if (ejsIs(ejs, argv[0], String)) {
        delim = (EjsString*) argv[0];
        if (delim->length == 0) {
            for (cp = sp->value; (--limit != -1) && *cp; cp++) {
                ejsSetProperty(ejs, results, -1, ejsCreateString(ejs, cp, 1));
            }
        } else {
            end = &sp->value[sp->length];
            for (mark = cp = sp->value; limit > 0 && mark < end; mark++, limit--) {
                if (wncmp(mark, delim->value, delim->length) == 0) {
                    elt = ejsCreateString(ejs, cp, (int) (mark - cp));
                    ejsSetProperty(ejs, results, -1, elt);
                    cp = mark + delim->length;
                    mark = cp - 1;
                }
            }
            elt = ejsCreateString(ejs, cp, (int) (mark - cp));
            ejsSetProperty(ejs, results, -1, elt);
        }
        return results;

    } else if (ejsIs(ejs, argv[0], RegExp)) {
        EjsRegExp   *rp;
        EjsString   *match;
        int         matches[EJS_MAX_REGEX_MATCHES * 3], count, resultCount;
        
        rp = (EjsRegExp*) argv[0];
        rp->endLastMatch = 0;
        resultCount = 0;
        do {
            count = (int) pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, rp->endLastMatch, 0, matches, 
                sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            if (rp->endLastMatch <= matches[0]) {
                match = ejsCreateString(ejs, &sp->value[rp->endLastMatch], matches[0] - rp->endLastMatch);
                ejsSetProperty(ejs, results, resultCount++, match);
            }
            rp->endLastMatch = matches[1];
        } while (rp->global);

        if (rp->endLastMatch < sp->length) {
            match = ejsCreateString(ejs, &sp->value[rp->endLastMatch], sp->length - rp->endLastMatch);
            ejsSetProperty(ejs, results, resultCount++, match);
        }
        return results;
    }

    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string starts with a given pattern

    function startsWith(pattern: String): Boolean
 */
static EjsBoolean *startsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *pattern;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    return ejsCreateBoolean(ejs, wncmp(&sp->value[0], pattern->value, pattern->length) == 0);
}


/*
    Extract a substring. Simple routine with positive indicies.

    function substring(start: Number, end: Number = -1): String
 */
static EjsString *substring(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    ssize   start, end, tmp;

    start = ejsGetInt(ejs, argv[0]);
    if (argc == 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end < 0) {
        end = sp->length;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    /*
        Swap if start is bigger than end
     */
    if (start > end) {
        tmp = start;
        start = end;
        end = tmp;
    }
    return ejsSubstring(ejs, sp, start, (int) (end - start));
}


/*
    Convert the string to camelCase. Return a new string.

    function toCamel(): String
 */
static EjsString *toCamel(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    if ((result = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    memcpy(result->value, sp->value, sp->length * sizeof(MprChar));
    result->value[0] = tolower((int) sp->value[0]);
    return ejsInternString(result);
}


/*
    Convert to a JSON string
 */
EjsString *ejsStringToJSON(Ejs *ejs, EjsObj *vp)
{
    EjsString   *sp;
    MprBuf      *buf;
    int         i, c;

    if (ejsIs(ejs, vp, String)) {
        sp = (EjsString*) vp;
    } else {
        sp = ejsToString(ejs, vp);
    }
    buf = mprCreateBuf(0, 0);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < sp->length; i++) {
        c = sp->value[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the string to lower case.

    function toLowerCase(locale: String = null): String
 */
static EjsString *toLowerCase(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    return ejsToLower(ejs, sp);
}


/*
    Convert the string to PascalCase. Return a new string.

    function toPascal(): String
 */
static EjsString *toPascal(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    if ((result = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    memcpy(result->value, sp->value, sp->length * sizeof(MprChar));
    result->value[0] = toupper((int) sp->value[0]);
    return ejsInternString(result);
}


/*
    Convert to a string

    override function toString(): String
 */
static EjsString *stringToString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    return sp;
}


/*
    Convert the string to upper case.
    @return Returns a new upper case version of the string.
    @spec ejs-11

    function toUpperCase(locale: String = null): String
 */
static EjsString *toUpperCase(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    return ejsToUpper(ejs, sp);
}


/*
    Scan the input and tokenize according to the format string

    function tokenize(format: String): Array
 */
static EjsArray *tokenize(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *result;
    MprChar     *cp, *buf;
    cchar       *fmt;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    buf = sp->value;
    fmt = ejsToMulti(ejs, argv[0]);
    result = ejsCreateArray(ejs, 0);

    for (fmt = ejsToMulti(ejs, argv[0]); *fmt && buf < &sp->value[sp->length]; ) {
        if (*fmt++ != '%') {
            continue;
        }
        switch (*fmt) {
        case 's':
            for (cp = buf; *cp; cp++) {
                if (isspace((int) *cp)) {
                    break;
                }
            }
            ejsSetProperty(ejs, result, -1, ejsSubstring(ejs, sp, (int) (buf - sp->value), (int) (cp - buf)));
            buf = cp;
            break;

        case 'd':
            ejsSetProperty(ejs, result, -1, ejsParse(ejs, buf, S_Number));
            while (*buf && !isspace((int) *buf)) {
                buf++;
            }
            break;

        default:
            ejsThrowArgError(ejs, "Bad format specifier");
            return 0;
        }
        while (*buf && isspace((int) *buf)) {
            buf++;
        }
    }
    return result;
}


static EjsString *trim(Ejs *ejs, EjsString *sp, EjsString *pattern, int where)
{
    MprChar     *start, *end, *mark;
    ssize       index, patternLength;

    if (pattern == 0) {
        start = sp->value;
        if (where & MPR_TRIM_START) {
            for (; start < &sp->value[sp->length]; start++) {
                if (!isspace((int) *start)) {
                    break;
                }
            }
        }
        end = &sp->value[sp->length - 1];
        if (where & MPR_TRIM_END) {
            for (end = &sp->value[sp->length - 1]; end >= start; end--) {
                if (!isspace((int) *end)) {
                    break;
                }
            }
        }
        end++;
    } else {
        patternLength = pattern->length;
        if (patternLength <= 0 || patternLength > sp->length) {
            return sp;
        }
        mark = sp->value;
        if (where & MPR_TRIM_START) {
            for (; &mark[patternLength] <= &sp->value[sp->length]; mark += patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        start = mark;

        mark = &sp->value[sp->length - patternLength];
        if (where & MPR_TRIM_END) {
            for (; mark >= sp->value; mark -= patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        end = mark + patternLength;
    }
    return ejsSubstring(ejs, sp, (int) (start - sp->value), (int) (end - start));
}


/**
    Returns a trimmed copy of the string. Normally used to trim white space, but can be used to trim any substring
    from the start or end of the string.
    @param str May be set to a substring to trim from the string. If not set, it defaults to any white space.
    @return Returns a (possibly) modified copy of the string

    function trim(str: String = null): String
 */
static EjsString *trimString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], String)));

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_START | MPR_TRIM_END);

    } else {
        pattern = (EjsString*) argv[0];
        return trim(ejs, sp, pattern, MPR_TRIM_START | MPR_TRIM_END);
    }
}


/*  
    function trimStart(str: String = null): String
 */
static EjsString *trimStartString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], String)));

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_START);

    } else {
        pattern = (EjsString*) argv[0];
        return trim(ejs, sp, pattern, MPR_TRIM_START);
    }
}


/*  
    function trimEnd(str: String = null): String
 */
static EjsString *trimEndString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], String)));

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_END);

    } else {
        pattern = (EjsString*) argv[0];
        return trim(ejs, sp, pattern, MPR_TRIM_END);
    }
}

#if UNUSED
/**
    Fast append a string. This modifies the original "dest" string. BEWARE: strings are meant to be immutable.
    Only use this when constructing strings.
 */
static int catString(Ejs *ejs, EjsString *dest, char *str, ssize len)
{
    EjsString   *castSrc;
    char        *oldBuf, *buf;
    int         oldLen, newLen;

    mprAssert(dest);

    castSrc = 0;

    oldBuf = dest->value;
    oldLen = dest->length;
    newLen = oldLen + len + 1;

#if FUTURE
    if (newLen < MPR_SLAB_STR_MAX) {
        buf = oldBuf;
    } else {
#endif
        buf = (char*) mprRealloc(oldBuf, newLen);
        if (buf == 0) {
            return -1;
        }
        dest->value = buf;
#if FUTURE
    }
#endif
    memcpy(&buf[oldLen], str, len);
    dest->length += len;
    buf[dest->length] = '\0';

    return 0;
}
#endif


/*
    Append the given string to the result
 */
static EjsString *buildString(Ejs *ejs, EjsString *result, MprChar *str, ssize len)
{
    EjsString   *newBuf;
    ssize       size;

    mprAssert(result);

    size = mprGetBlockSize(result);
    if (result->length + len >= size) {
        len = max(result->length + len, MPR_BUFSIZE);
        if ((newBuf = ejsCreateBareString(ejs, len)) == NULL) {
            return NULL;
        }
        memcpy(newBuf->value, result->value, result->length * sizeof(MprChar));
        newBuf->length = result->length;
        result = newBuf;
    }
    memcpy(&result->value[result->length], str, len * sizeof(MprChar));
    result->length += len;
    result->value[result->length] = 0;
    /* Don't intern */
    return result;
}


/*
    Find a substring. Search forward or backwards. Return the index in the string where the pattern was found.
    Return -1 if not found.
 */
static ssize indexof(MprChar *str, ssize len, EjsString *pattern, ssize patternLength, int dir)
{
    MprChar     *s1, *s2;
    ssize       i, j;

    mprAssert(dir == 1 || dir == -1);

    if (dir > 0) {
        for (i = 0; i < len; i++) {
            s1 = &str[i];
            for (j = 0, s2 = pattern->value; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }
    } else {
        for (i = len - 1; i >= 0; i--) {
            s1 = &str[i];
            for (j = 0, s2 = pattern->value; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }
    }
    return -1;
}


#if UNUSED && MOVED_TO_MPR
static int toMulti(char *dest, MprChar *src, ssize len)
{
#if BLD_CHAR_LEN == 1
    if (dest) {
        mprStrcpy(dest, len, src);
    } else {
        len = min(strlen(src), len);
    }
#else
#if WIN || WINCE
    len = WideCharToMultiByte(CP_ACP, 0, src, -1, dest, (DWORD) len, NULL, NULL);
#else
    //  Linux wchar_t is 32 bits and so can't use this if MprChar is 16 bits
    len = wcstombs(dest, src, len);
#endif
#endif
    mprAssert(len < MAXINT);
    return len;
}


static int toUni(MprChar *dest, cchar *src, ssize len) 
{
#if BLD_CHAR_LEN == 1
    if (dest) {
        mprStrcpy(dest, len, src);
    } else {
        len = min(strlen(src), len);
    }
#else
#if WIN || WINCE
    len = MultiByteToWideChar(CP_ACP, 0, src, -1, dest, len);
#else
    //  Linux wchar_t is 32 bits and so can't use this if MprChar is 16 bits
    len = mbstowcs(dest, src, len);
#endif
#endif
    mprAssert(len < MAXINT);
    return len;
}
#endif


int ejsAtoi(Ejs *ejs, EjsString *sp, int radix)
{
    int     num, i;

    num = 0;
    for (i = 0; i < (int) sp->length; i++) {
        num = num * radix + (sp->value[i] - '0');
    }
    return num;
}


// TODO - rename to join
EjsString *ejsCatString(Ejs *ejs, EjsString *s1, EjsString *s2)
{
    EjsString   *result;
    ssize       len;

    len = s1->length + s2->length;
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    memcpy(result->value, s1->value, s1->length * sizeof(MprChar));
    memcpy(&result->value[s1->length], s2->value, s2->length * sizeof(MprChar));
    return ejsInternString(result);
}



/*
    Catenate a set of unicode string arguments onto another.
    TODO - rename to join
 */
EjsString *ejsCatStrings(Ejs *ejs, EjsString *src, ...)
{
    EjsString   *sp, *result;
    va_list     args;
    ssize       len;

    va_start(args, src);
    for (len = 0, sp = src; sp; ) {
        sp = va_arg(args, EjsString*);
        len += sp->length;
    }
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    result->length = 0;
    va_start(args, src);
    for (sp = src; sp; ) {
        sp = va_arg(args, EjsString*);
        memcpy(&result->value[result->length], src->value, src->length);
        result->length += src->length;
    }
    va_end(args);
    return ejsInternString(result);
}


int ejsStartsWithMulti(Ejs *ejs, EjsString *sp, cchar *pat)
{
    ssize   i, len;

    mprAssert(sp);
    mprAssert(pat);

    if (pat == 0 || *pat == '\0') {
        return 0;
    }
    len = strlen(pat);
    
    for (i = 0; pat[i] && i < sp->length; i++) {
        if (sp->value[i] != pat[i]) {
            break;
        }
    }
    if (pat[i]) {
        return 0;
    }
    return 1;
}


int ejsCompareMulti(Ejs *ejs, EjsString *sp, cchar *str)
{
    MprChar     *s1;
    cchar       *s2;
    int         rc;

    s1 = sp->value;
    s2 = str;

    if (s1 == 0) {
        return -1;
    }
    if (s2 == 0) {
        return 1;
    }
    if ((cchar*) s1 == s2) {
        return 0;
    }
    for (rc = 0; *s1 && *s2 && rc == 0; s1++, s2++) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    }
    if (*s1 == '\0' && *s2) {
        return -1;
    }
    if (*s2 == '\0' && *s1) {
        return 1;
    }
    return rc;
}


/*
    Compare interned strings
 */
int ejsCompareString(Ejs *ejs, EjsString *sp1, EjsString *sp2)
{
    MprChar     *s1;
    MprChar     *s2;
    int         rc;

    s1 = sp1->value;
    s2 = sp2->value;

    if (s1 == s2) {
        /* No need to compare interned strings char-by-char */
        return 0;
    } else if (s1 == 0) {
        return -1;
    } else if (s2 == 0) {
        return 1;
    }
    for (rc = 0; *s1 && *s2 && rc == 0; s1++, s2++) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    } else if (*s1 == '\0' && *s2) {
        return -1;
    } else if (*s2 == '\0' && *s1) {
        return 1;
    }
    mprAssert(0);
    return 0;
}


int ejsCompareSubstring(Ejs *ejs, EjsString *sp1, EjsString *sp2, ssize offset, ssize len)
{
    mprAssert(0 <= len && len < MAXINT);

    if (offset < 0 || offset >= sp2->length) {
        return -1;
    }
    return ejsCompareWide(ejs, sp1, &sp2->value[offset], len);
}


int ejsCompareWide(Ejs *ejs, EjsString *sp1, MprChar *sp2, ssize len)
{
    MprChar     *s1;
    MprChar     *s2;
    int         rc;

    mprAssert(0 <= len && len < MAXINT);

    s1 = sp1->value;
    s2 = sp2;

    if (s1 == s2) {
        return 0;
    } else if (s1 == 0) {
        return -1;
    } else if (s2 == 0) {
        return 1;
    }
    for (rc = 0; len > 0 && *s1 && *s2 && rc == 0; s1++, s2++, len--) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    } else if (len == 0) {
        return 0;
    } else if (*s1 == 0 && *s2 == 0) {
        return 0;
    } else if (*s1 == '\0' && *s2) {
        return -1;
    } else if (*s2 == '\0' && *s1) {
        return 1;
    }
    return 0;
}


/*
    Return the index in a unicode string of a given unicode character code. Return -1 if not found.
 */
int ejsContainsChar(Ejs *ejs, EjsString *sp, int charPat)
{
    int     i;

    mprAssert(sp);

    for (i = 0; i < sp->length; i++) {
        if (sp->value[i] == charPat) {
            return i;
        }
    }
    return 0;
}


#if UNUSED && KEEP
/*
    Return TRUE if a unicode string contains a given unicode string after doing a case insensitive comparison.
 */
int ejsContainsStringAnyCase(Ejs *ejs, EjsString *sp, EjsString *pat)
{
    int     i, j;

    mprAssert(sp);
    mprAssert(pat);
    mprAssert(pat->value);

    for (i = 0; i < sp->length; i++) {
        for (j = 0; j < pat->length; j++) {
            //  TODO UNICODE - tolower only works for ASCII
            if (tolower(sp->value[i]) != tolower(pat->value[j])) {
                break;
            }
        }
        if (j == pat->length) {
            return 1;
        }
    }
    return 0;
}
#endif


int ejsContainsMulti(Ejs *ejs, EjsString *sp, cchar *pat)
{
    ssize   len;
    int     i, j, k;

    mprAssert(sp);
    mprAssert(pat);

    if (pat == 0 || *pat == '\0') {
        return 0;
    }
    len = strlen(pat);
    
    for (i = 0; i < sp->length; i++) {
        for (j = 0, k = i; j < len; j++, k++) {
            if (sp->value[k] != pat[j]) {
                break;
            }
        }
        if (j == len) {
            return 1;
        }
    }
    return 0;
}


int ejsContainsString(Ejs *ejs, EjsString *sp, EjsString *pat)
{
    int     i, j, k;

    mprAssert(sp);
    mprAssert(pat);
    mprAssert(pat->value);

    if (pat == 0 || pat->value == 0) {
        return 0;
    }
    for (i = 0; i < sp->length; i++) {
        for (j = 0, k = i; j < pat->length; j++, k++) {
            if (sp->value[k] != pat->value[j]) {
                break;
            }
        }
        if (j == pat->length) {
            return 1;
        }
    }
    return 0;
}


char *ejsToMulti(Ejs *ejs, EjsAny *ev)
{
    if (ev == 0) {
        ev = S(empty);
    }
    if (!ejsIs(ejs, ev, String)) {
        if ((ev = ejsCast(ejs, ev, String)) == 0) {
            return "";
        }
    }
    mprAssert(ejsIs(ejs, ev, String));
    return awtom(((EjsString*) ev)->value, NULL);
}


EjsString *ejsSprintf(Ejs *ejs, cchar *fmt, ...)
{
    va_list     ap;
    char        *result;

    mprAssert(fmt);

    va_start(ap, fmt);
    result = mprAsprintfv(fmt, ap);
    va_end(ap);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    Get a substring from "src" starting at "start" of length "len"
    If len < 0, use entire string.
 */
EjsString *ejsSubstring(Ejs *ejs, EjsString *src, ssize start, ssize len)
{
    EjsString   *result;

    mprAssert(src);
    mprAssert(start >= 0);
    mprAssert((start + len) <= src->length);

    if (len < 0) {
        len = src->length - start;
    }
    if (len < 0 || (start + len) > src->length || start < 0) {
        return S(empty);
    }
    len = min(len, src->length);
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    memcpy(result->value, &src->value[start], len);
    return ejsInternString(result);
}


EjsString *ejsToLower(Ejs *ejs, EjsString *sp)
{
    EjsString   *result;
    int         i;

    mprAssert(sp);
    mprAssert(sp->value);

    result = (EjsString*) ejsCreateBareString(ejs, sp->length);
    for (i = 0; i < sp->length; i++) {
        result->value[i] = tolower((int) sp->value[i]);
    }
    return ejsInternString(result);
}


EjsString *ejsToUpper(Ejs *ejs, EjsString *sp)
{
    EjsString   *result;
    int         i;

    mprAssert(sp);
    mprAssert(sp->value);

    result = (EjsString*) ejsCreateBareString(ejs, sp->length);
    for (i = 0; i < sp->length; i++) {
        result->value[i] = toupper((int) sp->value[i]);
    }
    return ejsInternString(result);
}


#if UNUSED && KEEP
EjsString *ejsTrimString(Ejs *ejs, EjsString *sp, cchar *pat, int flags)
{
    EjsString   *result;
    MprChar     *start, *end;
    cchar       *p;
    int         plen, trimmed;

    mprAssert(pat);

    start = sp->value;
    plen = strlen(pat);
    trimmed = 0;

    if (flags & MPR_TRIM_START) {
        for (; *start; start++) {
            for (p = pat; *p; p++) {
                if (*start == *p) {
                    break;
                }
            }
            if (*start != *p) {
                break;
            }
            trimmed++;
        }
    }

    if (flags & MPR_TRIM_END) {
        for (end = &sp->value[sp->length]; end > start; end--) {
            for (p = pat; *p; p++) {
                if (*start == *p) {
                    break;
                }
            }
            if (*start != *p) {
                break;
            }
            trimmed++;
        }
    }
    result = ejsCreateBareString(ejs, sp->length - trimmed);
    memcpy(result->value, start, result->length);
    return ejsInternString(result);
}
#endif


EjsString *ejsTruncateString(Ejs *ejs, EjsString *sp, ssize len)
{
    EjsString   *result;

    mprAssert(sp);

    len = min(len, sp->length);
    result = ejsCreateBareString(ejs, len);
    memcpy(result->value, sp->value, len);
    return ejsInternString(result);
}


/*
    Intern a unicode string. Lookup a string and return an interned string (this may be an existing interned string)
 */
EjsString *ejsInternString(EjsString *str)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    int         index, i, step;

    ip = ((EjsService*) MPR->ejsService)->intern;
    step = 0;

    ilock();
    ip->accesses++;
    index = whash(str->value, str->length) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            if (sp->length == str->length) {
                for (i = 0; i < sp->length && i < str->length; i++) {
                    if (sp->value[i] != str->value[i]) {
                        break;
                    }
                }
                if (i == sp->length && i == str->length) {
                    ip->reuse++;
                    /* Revive incase almost stale or dead */
                    mprRevive(sp);
                    iunlock();
                    return sp;
                }
            }
        }
    }
    linkString(head, str);
    iunlock();
    if (step > EJS_MAX_COLLISIONS) {
        /*  Remake the entire hash - should not happen often */
        rebuildIntern(ip);
    }
    return str;
}


/*
    Intern a wide C string and return an interned wide string
 */
EjsString *ejsInternWide(Ejs *ejs, MprChar *value, ssize len)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    ssize       i, end;
    int         index, step;

    mprAssert(0 <= len && len < MAXINT);

    ip = ejs->service->intern;
    step = 0;

    ilock();
    ip->accesses++;
    index = whash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            if (sp->length == len) {
                end = min(sp->length, len);
                for (i = 0; i < end && value[i]; i++) {
                    if (sp->value[i] != value[i]) {
                        break;
                    }
                }
                if (i == sp->length) {
                    ip->reuse++;
                    /* Revive incase almost stale or dead */
                    mprRevive(sp);
                    iunlock();
                    return sp;
                }
            }
        }
    }
    if ((sp = ejsAlloc(ejs, ST(String), (len + 1) * sizeof(MprChar))) != NULL) {
        memcpy(sp->value, value, len * sizeof(MprChar));
        sp->value[len] = 0;
#if UNUSED
        if (strcmp(value, "multithread") == 0) {
            MprThread *tp = mprGetCurrentThread();
            MprMem *mp = MPR_GET_MEM(sp);
            printf("EJS %s %p, ALLOCATE multithread GEN %d MARK %d, active %d\n", ejs->name, ejs, (int) MPR_GET_GEN(mp), (int) MPR_GET_MARK(mp), MPR->heap.active);
            printf("\n");
        }
#endif
    }
    sp->length = len;
    linkString(head, sp);
    iunlock();
    if (step > EJS_MAX_COLLISIONS) {
        /*  Remake the entire hash - should not happen often */
        rebuildIntern(ip);
    }
    return sp;
}


EjsString *ejsInternAsc(Ejs *ejs, cchar *value, ssize len)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    ssize       i, end;
    int         index, step;

    mprAssert(0 <= len && len < MAXINT);

    step = 0;
    ip = ejs->service->intern;

    ilock();
    ip->accesses++;
    mprAssert(ip->size > 0);
    index = shash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            if (sp->length == len) {
                end = min(len, sp->length);
                for (i = 0; i < end && value[i]; i++) {
                    if (sp->value[i] != (uchar) value[i]) {
                        break;
                    }
                }
                if (i == sp->length) {
                    ip->reuse++;
                    /* Revive incase almost stale or dead */
                    mprRevive(sp);
#if UNUSED
                    if (strcmp(value, "multithread") == 0) {
                        MprThread *tp = mprGetCurrentThread();
                        MprMem *mp = MPR_GET_MEM(sp);
                        printf("EJS %s, @@@@ REVIVE MULTITHREAD GEN %d MARK %d, active %d\n", ejs->name, (int) MPR_GET_GEN(mp), (int) MPR_GET_MARK(mp), MPR->heap.active);
                        printf("\n");
                    }
#endif
                    iunlock();
                    return sp;
                }
            }
        }
    }
    if ((sp = ejsAlloc(ejs, ST(String), (len + 1) * sizeof(MprChar))) != NULL) {
#if BLD_CHAR_LEN > 1
        for (i = 0; i < len; i++) {
            sp->value[i] = value[i];
        }
        sp->length = len;
#else
        memcpy(sp->value, value, len * sizeof(MprChar));
#endif
        sp->value[len] = 0;
    }
    sp->length = len;
    linkString(head, sp);
    iunlock();
    if (step > EJS_MAX_COLLISIONS) {
        /*  Remake the entire hash - should not happen often */
        rebuildIntern(ip);
    }
    return sp;
}


#if BLD_CHAR_LEN == 1
EjsString *ejsInternMulti(Ejs *ejs, cchar *value, ssize len)
{
    return ejsInternAsc(ejs, value, len);
}

#else /* BLD_CHAR_LEN > 1 */

EjsString *ejsInternMulti(Ejs *ejs, cchar *value, ssize len)
{
    EjsString   *head, *sp, src;
    ssize       i, end;
    int         index;

    mprAssert(0 < len && len < MAXINT);

    len = mtow(NULL, MAXSSIZE, value, len);
    mprAssert(len < MAXINT);

    /*
        Have to convert the multibyte string to unicode before comparision. Convert into an EjsString to it is ready
        to intern if not found.
     */
    if ((src = ejsAlloc(ejs, ST(String), (len + 1) * sizeof(MprChar))) != NULL) {
        src->length = mtow(src->value, len + 1, value, len);
        value = src->value;
    }
    ilock();
    ip->accesses++;
    index = whash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next) {
            end = min(len, sp->length);
            for (i = 0; i < end && value[i]; i++) {
                if (sp->value[i] != sp->value[i]) {
                    break;
                }
            }
            if (i == sp->length && value[i] == 0) {
                ip->reuse++;
                /* Revive incase almost stale or dead */
                mprRevive(sp);
                iunlock();
                return sp;
            }
        }
    }
    linkString(head, src);
    iunlock();
    if (step > EJS_MAX_COLLISIONS) {
        /*  Remake the entire hash - should not happen often */
        rebuildIntern(ip);
    }
    return sp;
}
#endif /* BLD_CHAR_LEN > 1 */


static int getInternHashSize(int size)
{
    int     i;

    for (i = 0; i < internHashSizes[i]; i++) {
        if (size < internHashSizes[i]) {
            return internHashSizes[i];
        }
    }
    return internHashSizes[i - 1];
}


static int rebuildIntern(EjsIntern *intern)
{
    EjsString   *oldBuckets, *sp, *next, *head;
    int         i, newSize, oldSize;

    mprAssert(intern);

    oldBuckets = intern->buckets;
    newSize = getInternHashSize(intern->size * 2);
    oldSize = 0;
    if (oldBuckets) {
        oldSize = intern->size;
        if (oldSize > newSize) {
            return 0;
        }
    }
    if ((intern->buckets = mprAllocZeroed((newSize * sizeof(EjsString)))) == NULL) {
        return MPR_ERR_MEMORY;
    }
    intern->size = newSize;
    for (i = 0; i < newSize; i++) {
        sp = &intern->buckets[i];
        sp->next = sp->prev = sp;
    }
    if (oldBuckets) {
        for (i = 0; i < oldSize; i++) {
            head = &oldBuckets[i];
            for (sp = head->next; sp != head; sp = next) {
                next = sp->next;
                sp->next = sp->prev = sp;
                ejsInternString(sp);
            }
        }
    }
    return 0;
}


/*
    Must be called locked
 */
static void linkString(EjsString *head, EjsString *sp)
{
    mprAssert(sp != head);
    mprAssert(sp->next == NULL || sp->next == sp);
    mprAssert(sp->prev == NULL || sp->next == sp);

    sp->next = head->next;
    sp->prev = head;
    head->next->prev = sp;
    head->next = sp;
    mprAssert(sp != sp->next);
    mprAssert(sp != sp->prev);
}


/*
    Unlink a string from the intern cache. This unlinks from the hash chains. 
    This routine is idempotent. ejsDestroyIntern takes advantage of this.
    Must be called locked.
 */
static void unlinkString(EjsString *sp)
{
    /*
        Some strings are not interned (ejsCreateBareString). These have sp->next == NULL.
     */
    if (sp->next) {
        sp->prev->next = sp->next;
        sp->next->prev = sp->prev;
        sp->next = sp->prev = sp;
    }
}



EjsString *ejsCreateString(Ejs *ejs, MprChar *value, ssize len)
{
    mprAssert(0 <= len && len < MAXINT);
    return ejsInternWide(ejs, value, len);
}


EjsString *ejsCreateStringFromAsc(Ejs *ejs, cchar *value)
{
    if (value == NULL) {
        value = "";
    }
    return ejsInternAsc(ejs, value, slen(value));
}


EjsString *ejsCreateStringFromMulti(Ejs *ejs, cchar *value, ssize len)
{
    if (value == NULL) {
        value = "";
    }
    mprAssert(0 <= len && len < MAXINT);
    return ejsInternMulti(ejs, value, len);
}


EjsString *ejsCreateStringFromBytes(Ejs *ejs, cchar *value, ssize len)
{
    mprAssert(0 <= len && len < MAXINT);
    return ejsInternAsc(ejs, value, len);
}


/*
    Create an empty string object and do not intern. Caller's should call ejsInternString when the string value is defined.
 */
EjsString *ejsCreateBareString(Ejs *ejs, ssize len)
{
    EjsString   *sp;
    
    mprAssert(0 <= len && len < MAXINT);
    if ((sp = ejsAlloc(ejs, ST(String), (len + 1) * sizeof(MprChar))) != NULL) {
        sp->length = len;
        sp->value[0] = 0;
        sp->value[len] = 0;
    }
    return sp;
}


EjsString *ejsCreateNonInternedString(Ejs *ejs, MprChar *value, ssize len)
{
    EjsString   *sp;
    
    mprAssert(0 <= len && len < MAXINT);
    if ((sp = ejsAlloc(ejs, ST(String), (len + 1) * sizeof(MprChar))) != NULL) {
        memcpy(sp->value, value, (len + 1) * sizeof(MprChar));
        sp->length = len;
        sp->value[len] = 0;
    }
    return sp;
}


void ejsManageString(EjsString *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(TYPE(sp));

    } else if (flags & MPR_MANAGE_FREE) {
        ilock();
        unlinkString(sp);
        iunlock();
    }
}


EjsIntern *ejsCreateIntern(EjsService *sp)
{
    EjsIntern   *intern;
    
    intern = mprAllocObj(EjsIntern, manageIntern);
#if XXX
    intern->ejs = ejs;
#endif
    return intern;
}


void ejsDestroyIntern(EjsIntern *intern)
{
    EjsString   *sp, *head, *next;
    int         i;

    /*
        Unlink strings now as when they are freed later, the intern structure may not exist in memory.
     */
    ilock();
    for (i = intern->size - 1; i >= 0; i--) {
        head = &intern->buckets[i];
        for (sp = head->next; sp != head; sp = next) {
            next = sp->next;
            unlinkString(sp);
        }
    }
    iunlock();
}


static void manageIntern(EjsIntern *intern, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(intern->buckets);

    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyIntern(intern);
    }
}


void ejsInitStringType(Ejs *ejs, EjsType *type)
{
    static int firstTime = 1;

    if (firstTime) {
        mprInitSpinLock(&internLock);
        firstTime = 0;
        rebuildIntern(ejs->service->intern);
    }
    ejsCloneObjHelpers(ejs, type);
    type->mutex = mprCreateLock();
    type->helpers.cast = (EjsCastHelper) castString;
    type->helpers.clone = (EjsCloneHelper) cloneString;
    type->helpers.getProperty = (EjsGetPropertyHelper) getStringProperty;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeStringOperator;
    type->helpers.lookupProperty = (EjsLookupPropertyHelper) lookupStringProperty;
    type->numericIndicies = 1;
    type->manager = (MprManager) ejsManageString;
    type->qname = N("ejs", "String");
    SET_TYPE_NAME(type->qname.name, type);
    SET_TYPE_NAME(type->qname.space, type);
    
    /*
        Standard string values. Create here so modules do not have to export these strings
     */
    ejsSetSpecial(ejs, S_empty, ejsCreateStringFromAsc(ejs, ""));

#if UNUSED
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_BLOCK_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_CONSTRUCTOR_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_EJS_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_INIT_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_INTERNAL_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_ITERATOR_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_META_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_PRIVATE_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_PROTECTED_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_PROTOTYPE_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_PUBLIC_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_WORKER_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_CONSTRUCTOR_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_EJS_NAMESPACE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_INITIALIZER_NAME));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_DEFAULT_MODULE));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_DEFAULT_MODULE_NAME));
    ejsSetSpecial(ejs, -1, ejsCreateStringFromAsc(ejs, EJS_DEFAULT_CLASS_NAME));
#endif
}


void ejsConfigureStringType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(String);
    prototype = type->prototype;

    ejsSetProperty(ejs, ejs->global, ES_string, type);
    
    ejsBindMethod(ejs, type, ES_String_fromCharCode, fromCharCode);
    ejsBindConstructor(ejs, type, stringConstructor);
    
    ejsBindMethod(ejs, prototype, ES_String_caseCompare, caseCompare);
    ejsBindMethod(ejs, prototype, ES_String_caselessCompare, caselessCompare);
    ejsBindMethod(ejs, prototype, ES_String_charAt, charAt);
    ejsBindMethod(ejs, prototype, ES_String_charCodeAt, charCodeAt);
    ejsBindMethod(ejs, prototype, ES_String_concat, concatString);
    ejsBindMethod(ejs, prototype, ES_String_contains, containsString);
    ejsBindMethod(ejs, prototype, ES_String_endsWith, endsWith);
    ejsBindMethod(ejs, prototype, ES_String_format, formatString);
    ejsBindMethod(ejs, prototype, ES_String_iterator_get, getStringIterator);
    ejsBindMethod(ejs, prototype, ES_String_iterator_getValues, getStringValues);
    ejsBindMethod(ejs, prototype, ES_String_indexOf, indexOf);
    ejsBindMethod(ejs, prototype, ES_String_isDigit, isDigit);
    ejsBindMethod(ejs, prototype, ES_String_isAlpha, isAlpha);
    ejsBindMethod(ejs, prototype, ES_String_isAlphaNum, isAlphaNum);
    ejsBindMethod(ejs, prototype, ES_String_isLower, isLower);
    ejsBindMethod(ejs, prototype, ES_String_isSpace, isSpace);
    ejsBindMethod(ejs, prototype, ES_String_isUpper, isUpper);
    ejsBindMethod(ejs, prototype, ES_String_lastIndexOf, lastIndexOf);
    ejsBindMethod(ejs, prototype, ES_String_length, stringLength);
    ejsBindMethod(ejs, prototype, ES_String_match, match);
    ejsBindMethod(ejs, prototype, ES_String_remove, removeCharsFromString);
    ejsBindMethod(ejs, prototype, ES_String_slice, sliceString);
    ejsBindMethod(ejs, prototype, ES_String_split, split);
    ejsBindMethod(ejs, prototype, ES_String_printable, printable);
    ejsBindMethod(ejs, prototype, ES_String_quote, quote);
    ejsBindMethod(ejs, prototype, ES_String_replace, replace);
    ejsBindMethod(ejs, prototype, ES_String_reverse, reverseString);
    ejsBindMethod(ejs, prototype, ES_String_search, searchString);
    ejsBindMethod(ejs, prototype, ES_String_startsWith, startsWith);
    ejsBindMethod(ejs, prototype, ES_String_substring, substring);
    ejsBindMethod(ejs, prototype, ES_String_toCamel, toCamel);
    ejsBindMethod(ejs, prototype, ES_String_toJSON, ejsStringToJSON);
    ejsBindMethod(ejs, prototype, ES_String_toLowerCase, toLowerCase);
    ejsBindMethod(ejs, prototype, ES_String_toPascal, toPascal);
    ejsBindMethod(ejs, prototype, ES_String_toString, stringToString);
    ejsBindMethod(ejs, prototype, ES_String_toUpperCase, toUpperCase);
    ejsBindMethod(ejs, prototype, ES_String_tokenize, tokenize);
    ejsBindMethod(ejs, prototype, ES_String_trim, trimString);
    ejsBindMethod(ejs, prototype, ES_String_trimStart, trimStartString);
    ejsBindMethod(ejs, prototype, ES_String_trimEnd, trimEndString);

#if FUTURE
    ejsBindMethod(ejs, prototype, ES_String_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, prototype, ES_String_PLUS, operPLUS);
    ejsBindMethod(ejs, prototype, ES_String_MINUS, operMINUS);
    ejsBindMethod(ejs, prototype, ES_String_LT, operLT);
    ejsBindMethod(ejs, prototype, ES_String_GT, operGT);
    ejsBindMethod(ejs, prototype, ES_String_EQ, operEQ);
    ejsBindMethod(ejs, prototype, ES_String_MOD, operMOD);
    ejsBindMethod(ejs, prototype, ES_String_MUL, operMUL);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsString.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsSystem.c"
 */
/************************************************************************/

/*
    ejsSystem.c -- System class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    function run(cmd: String): String
 */
static EjsString *system_run(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    char        *cmdline;
    char        *err, *output;
    int         status;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    cmd = mprCreateCmd(ejs->dispatcher);
    ejs->result = cmd;
    cmdline = ejsToMulti(ejs, argv[0]);
    status = mprRunCmd(cmd, cmdline, &output, &err, 0);
    if (status) {
        ejsThrowError(ejs, "Command failed: status: %d\n\nError Output: \n%s\nPrevious Output: \n%s\n", status, err, output);
        mprDestroyCmd(cmd);
        return 0;
    }
    mprDestroyCmd(cmd);
    return ejsCreateStringFromAsc(ejs, output);
}


/*
    function runx(cmd: String): Void
 */
static EjsObj *system_runx(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    char        *err;
    int         status;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    cmd = mprCreateCmd(ejs->dispatcher);
    ejs->result = cmd;
    status = mprRunCmd(cmd, ejsToMulti(ejs, argv[0]), NULL, &err, 0);
    if (status) {
        ejsThrowError(ejs, "Can't run command: %@\nDetails: %s", ejsToString(ejs, argv[0]), err);
    }
    mprDestroyCmd(cmd);
    return 0;
}


/*
    function daemon(cmd: String): Number
 */
static EjsNumber *system_daemon(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    int         status, pid;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    cmd = mprCreateCmd(ejs->dispatcher);
    ejs->result = cmd;
    status = mprRunCmd(cmd, ejsToMulti(ejs, argv[0]), NULL, NULL, MPR_CMD_DETACH);
    if (status) {
        ejsThrowError(ejs, "Can't run command: %@", ejsToString(ejs, argv[0]));
    }
    pid = cmd->pid;
    mprDestroyCmd(cmd);
    return ejsCreateNumber(ejs, pid);
}


//  TODO - refactor and rename
/*
    function exec(cmd: String): Void
 */
static EjsObj *system_exec(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_UNIX_LIKE
    char    **argVector;
    int     argCount;

    mprMakeArgv(ejsToMulti(ejs, argv[0]), &argCount, &argVector, 0);
    execv(argVector[0], argVector);
#endif
    ejsThrowStateError(ejs, "Can't exec %@", ejsToString(ejs, argv[0]));
    return 0;
}


/*
    function get hostname(): String
 */
static EjsString *system_hostname(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprGetHostName(ejs));
}


/*
    function get ipaddr(): String
 */
static EjsString *system_ipaddr(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_UNIX_LIKE || BLD_WIN_LIKE
    struct addrinfo *res, *reslist, hints;
    cchar           *ip;
    char            ipaddr[MPR_MAX_STRING], service[MPR_MAX_STRING];

    if ((ip = mprGetIpAddr(ejs)) != 0) {
        return ejsCreateStringFromAsc(ejs, mprGetIpAddr(ejs));
    }
    memset((char*) &hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_INET;
    if (getaddrinfo(mprGetHostName(ejs), NULL, &hints, &reslist) == 0) {
        ip = 0;
        //  TODO - support IPv6
        for (res = reslist; res; res = res->ai_next) {
            if (getnameinfo(res->ai_addr, (socklen_t) res->ai_addrlen, ipaddr, (int) sizeof(ipaddr) - 1, service, 
                    (int) sizeof(service) - 1, NI_NUMERICHOST | NI_NUMERICSERV | NI_NOFQDN) == 0) {
                if (strncmp(ipaddr, "10.", 3) == 0 || strncmp(ipaddr, "127.", 4) == 0 ||
                     strncmp(ipaddr, "169.", 4) == 0 || strncmp(ipaddr, "172.", 4) == 0 ||
                     strncmp(ipaddr, "192.", 4) == 0) {
                    if (ip == 0) {
                        ip = sclone(ipaddr);
                    }
                } else {
                    ip = sclone(ipaddr);
                    break;
                }
            }
        }
        return ejsCreateStringFromAsc(ejs, ip ? ip : "127.0.0.1");
    }
#endif
    return S(null);
}



void ejsConfigureSystemType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, N("ejs", "System"))) == 0) {
        mprError("Can't find System type");
        return;
    }
    ejsBindMethod(ejs, type, ES_System_daemon, system_daemon);
    ejsBindMethod(ejs, type, ES_System_exec, system_exec);
    ejsBindMethod(ejs, type, ES_System_run, system_run);
    ejsBindMethod(ejs, type, ES_System_runx, system_runx);
    ejsBindMethod(ejs, type, ES_System_hostname, system_hostname);
    ejsBindMethod(ejs, type, ES_System_ipaddr, system_ipaddr);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsSystem.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsTimer.c"
 */
/************************************************************************/

/*
    ejsTimer.c -- Timer class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Create a new timer

    function Timer(period: Number, callback: Function, ...args)
 */
static EjsTimer *timer_constructor(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc >= 2);
    mprAssert(ejsIs(ejs, argv[0], Number));
    mprAssert(ejsIsFunction(ejs, argv[1]));
    mprAssert(ejsIs(ejs, argv[2], Array));

    tp->period = ejsGetInt(ejs, argv[0]);
    tp->callback = (EjsFunction*) argv[1];
    tp->args = (EjsArray*) argv[2];
    tp->repeat = 0;
    tp->drift = 1;
    tp->ejs = ejs;
    return tp;
}


/*
    function get drift(): Boolean
 */
static EjsBoolean *timer_get_drift(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);
    return ejsCreateBoolean(ejs, tp->drift);
}


/*
    function set drift(period: Boolean): Void
 */
static EjsObj *timer_set_drift(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Boolean));
    tp->drift = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    function get onerror(): Function
 */
static EjsFunction *timer_get_onerror(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);
    return tp->onerror;
}


/*
    function set onerror(callback: Function): Void
 */
static EjsObj *timer_set_onerror(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    tp->onerror = (EjsFunction*) argv[0];
    return 0;
}


/*
    function get period(): Number
 */
static EjsNumber *timer_get_period(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);
    return ejsCreateNumber(ejs, tp->period);
}


/*
    function set period(period: Number): Void
 */
static EjsObj *timer_set_period(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Number));

    tp->period = ejsGetInt(ejs, argv[0]);
    return 0;
}


/*
    function get repeat(): Boolean
 */
static EjsBoolean *timer_get_repeat(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);
    return ejsCreateBoolean(ejs, tp->repeat);
}


/*
    function set repeat(enable: Boolean): Void
 */
static EjsObj *timer_set_repeat(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIs(ejs, argv[0], Boolean));

    tp->repeat = ejsGetBoolean(ejs, argv[0]);
    if (tp->event) {
        mprEnableContinuousEvent(tp->event, tp->repeat);
    }
    return 0;
}


static int timerCallback(EjsTimer *tp, MprEvent *e)
{
    Ejs         *ejs;
    EjsObj      *thisObj, *error;

    mprAssert(tp);
    mprAssert(tp->args);
    mprAssert(tp->callback);

    ejs = tp->ejs;
    thisObj = (tp->callback->boundThis) ? tp->callback->boundThis : tp;
    ejsRunFunction(ejs, tp->callback, thisObj, tp->args->length, tp->args->data);
    if (ejs->exception) {
        if (tp->onerror) {
            error = ejs->exception;
            ejsClearException(ejs);
            ejsRunFunction(ejs, tp->onerror, thisObj, 1, &error);
        } else {
            mprError("Uncaught exception in timer\n%s", ejsGetErrorMsg(ejs, 1));
            ejsClearException(ejs);
        }
    }
    if (!tp->repeat) {
        mprRemoveRoot(tp);
        tp->event = 0;
        tp->ejs = 0;
    }
    return 0;
}


/*
    function start(): Void
 */
static EjsObj *timer_start(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    int     flags;

    if (tp->event == 0) {
        flags = tp->repeat ? MPR_EVENT_CONTINUOUS : 0;
#if UNUSED
        /*
            MOB - should not need this. When a VM is destroyed, the dispatcher (and queued events) are removed too
         */
        mprAddRoot(tp);
        /* Need to mark ejs as there may be no global references */
        tp->ejs = ejs;
#endif
        tp->event = mprCreateEvent(ejs->dispatcher, "timer", tp->period, (MprEventProc) timerCallback, tp, flags);
        if (tp->event == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return 0;
}


/*
    function stop(): Void
 */
static EjsObj *timer_stop(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    if (tp->event) {
        mprRemoveEvent(tp->event);
        mprRemoveRoot(tp);
        tp->event = 0;
    }
    return 0;
}


static void manageTimer(EjsTimer *tp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(tp->event);
        mprMark(tp->callback);
        mprMark(tp->args);
        mprMark(tp->onerror);
        mprMark(tp->ejs);

    } else if (flags & MPR_MANAGE_FREE) {
        if (tp->event) {
            mprRemoveEvent(tp->event);
        }
    }
}



void ejsConfigureTimerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsGetTypeByName(ejs, N("ejs", "Timer"));
    type->instanceSize = sizeof(EjsTimer);
    type->manager = (MprManager) manageTimer;
    type->mutableInstances = 1;
    ejsCloneObjHelpers(ejs, type);

    prototype = type->prototype;
    ejsBindConstructor(ejs, type, timer_constructor);
    ejsBindMethod(ejs, prototype, ES_Timer_start, timer_start);
    ejsBindMethod(ejs, prototype, ES_Timer_stop, timer_stop);

    ejsBindAccess(ejs, prototype, ES_Timer_drift, timer_get_drift, timer_set_drift);
    ejsBindAccess(ejs, prototype, ES_Timer_period, timer_get_period, timer_set_period);
    ejsBindAccess(ejs, prototype, ES_Timer_onerror, timer_get_onerror, timer_set_onerror);
    ejsBindAccess(ejs, prototype, ES_Timer_repeat, timer_get_repeat, timer_set_repeat);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsTimer.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsType.c"
 */
/************************************************************************/

/**
    ejsType.c - Type class

    The type class is the base class for all types (classes) in the system.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int defaultManager(EjsObj *ev, int flags);
static void fixInstanceSize(Ejs *ejs, EjsType *type);
static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom);
static int fixupTypeImplements(Ejs *ejs, EjsType *type, int makeRoom);
static int inheritProperties(Ejs *ejs, EjsType *type, EjsPot *obj, int destOffset, EjsPot *baseBlock, int srcOffset, 
    int count, bool resetScope);
static void manageType(EjsType *type, int flags);

/*
    Copy a type

    function copy(type: Object): Object
 */
static EjsType *cloneTypeVar(Ejs *ejs, EjsType *src, bool deep)
{
    EjsType     *dest;

    if (! ejsIsType(ejs, src)) {
        ejsThrowTypeError(ejs, "Expecting a Type object");
        return 0;
    }
    dest = (ST(Function)->helpers.clone)(ejs, src, deep);
    if (dest == 0) {
        return dest;
    }
    //  TODO OPT
    dest->baseType = src->baseType;
    dest->callsSuper = src->callsSuper;
    dest->dynamicInstances = src->dynamicInstances;
    dest->final = src->final;
    dest->hasBaseConstructors = src->hasBaseConstructors;
    dest->hasBaseInitializers = src->hasBaseInitializers;
    dest->hasConstructor = src->hasConstructor;
    dest->hasInitializer = src->hasInitializer;
    dest->hasInstanceVars = src->hasInstanceVars;
    dest->hasMeta = src->hasMeta;
    dest->hasScriptFunctions = src->hasScriptFunctions;
    dest->helpers = src->helpers;
    dest->implements = src->implements;
    dest->initialized = src->initialized;
    dest->instanceSize = src->instanceSize;
    dest->isInterface = src->isInterface;
    dest->isPot = src->isPot;
    dest->manager = src->manager;
    dest->mutable = src->mutable;
    dest->mutableInstances = src->mutableInstances;
    dest->mutex = src->mutex;
    dest->module = src->module;
    dest->numericIndicies = src->numericIndicies;
    dest->numInherited = src->numInherited;
    dest->prototype = src->prototype;
    dest->qname = src->qname;
    dest->sid = src->sid;
    dest->typeData = src->typeData;
    dest->virtualSlots = src->virtualSlots;

    return dest;
}


/*
    Create a new Type object. numProp is the number of property slots to pre-allocate.
 */
static EjsType *createTypeVar(Ejs *ejs, EjsType *typeType, int numProp)
{
    EjsType     *type;
    EjsPot      *obj;
    char        *start;
    ssize       typeSize;
    int         sizeHash, dynamic;

    mprAssert(ejs);
    
    /*
        If the compiler is building itself (empty mode), then the types themselves must be dynamic. Otherwise, the type
        is fixed and will contain the names hash and traits in one memory block. 
        NOTE: don't confuse this with dynamic objects.
     */
    sizeHash = 0;
    if (numProp < 0 || ejs->empty) {
        dynamic = 1;
        typeSize = sizeof(EjsType);
        numProp = 0;
    } else {
        dynamic = 0;
        typeSize = sizeof(EjsType) + sizeof(EjsProperties);
        typeSize += (int) sizeof(EjsSlot) * numProp;
        if (numProp > EJS_HASH_MIN_PROP) {
            sizeHash = ejsGetHashSize(numProp);
            typeSize += sizeof(EjsHash) + (sizeHash * (int) sizeof(EjsSlot*));
        }
    }
    if ((type = mprAllocBlock(typeSize, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    mprSetManager(type, manageType);
    mprInitList(&type->constructor.block.namespaces);
    obj = (EjsPot*) type;
    SET_TYPE(obj, typeType);
    SET_DYNAMIC(obj, dynamic);
    obj->isType = 1;
    obj->isBlock = 1;
    ejsSetMemRef(obj);

    if (!dynamic) {
        /*
            This is for a fixed type. This is the normal case when not compiling. Layout is:
                Slots: sizeof(EjsSlot) * numProp
                Hash:  ejsGetHashSize(numslots)
         */
        start = (char*) type + sizeof(EjsType);
        if (numProp > 0) {
            obj->properties = (EjsProperties*) start;
            obj->properties->size = numProp;
            ejsZeroSlots(ejs, obj->properties->slots, numProp);
            start += sizeof(EjsProperties) + sizeof(EjsSlot) * numProp;
        }
        if (sizeHash > 0) {
            obj->properties->hash = (EjsHash*) start;
            obj->properties->hash->buckets = (int*) (start + sizeof(EjsHash));
            obj->properties->hash->size = sizeHash;
            memset(obj->properties->hash->buckets, -1, sizeHash * sizeof(int));
            start += sizeof(EjsHash) + sizeof(int) * sizeHash;
        }
        mprAssert((start - (char*) type) <= typeSize);
    }
    return type;
}


static int setTypeProperty(Ejs *ejs, EjsType *type, int slotNum, EjsObj *value)
{
    if (slotNum < 0 && !DYNAMIC(type)) {
        ejsThrowTypeError(ejs, "Object is not dynamic");
        return EJS_ERR;
    }
    return (ST(Block)->helpers.setProperty)(ejs, type, slotNum, value);
}



static void createBootType(Ejs *ejs, int sid, int size, int dynamic, void *manager)
{
    EjsType     *type;

    mprAssert(0 <= sid && sid < EJS_MAX_SPECIAL);

    if ((type = createTypeVar(ejs, NULL, 0)) == NULL) {
        return;
    }
    type->sid = sid;
    type->instanceSize = size;
    type->dynamicInstances = dynamic;
    type->manager = manager;
    ejsSetSpecial(ejs, sid, type);
}


static void createBootPrototype(Ejs *ejs, int sid, cchar *name)
{
    EjsType     *type;

    mprAssert(0 <= sid && sid < EJS_MAX_SPECIAL);

    type = ejs->values[sid];
    type->qname = N("ejs", name);
    if ((type->prototype = ejsCreatePot(ejs, ST(Object), 0)) == 0) {
        return;
    }
    type->prototype->isPrototype = 1;
    mprSetName(type, name);
    mprSetName(type->prototype, name);
    ejsSetPropertyByName(ejs, ejs->service->foundation, type->qname, type);
}


/*
    Handcraft the Array, Object, String and Type classes.
 */
int ejsBootstrapTypes(Ejs *ejs)
{
    EjsPot  protostub;

    mprAssert(ejs);

    ejsCreateObjHelpers(ejs);
    ejsCreatePotHelpers(ejs);

    //  TODO - should only need to do once
    if (1 || ST(String) == 0) {
        createBootType(ejs, S_String, sizeof(EjsString), 0, ejsManageString);
        createBootType(ejs, S_Type, sizeof(EjsType), 1, manageType);
        createBootType(ejs, S_Object, sizeof(EjsPot), 1, ejsManagePot);

        ST(Type)->isPot = 1;
        ST(Object)->isPot = 1;

        ejsInitStringType(ejs, ST(String));
        ejsClonePotHelpers(ejs, ST(Type));
        ejsClonePotHelpers(ejs, ST(Object));

        memset(&protostub, 0, sizeof(protostub));
        ST(Object)->prototype = &protostub;

        ejs->service->foundation = ejsCreateEmptyPot(ejs);
        mprSetName(ejs->service->foundation, "foundation");

        createBootPrototype(ejs, S_Type, "Type");
        createBootPrototype(ejs, S_Object, "Object");
        createBootPrototype(ejs, S_String, "String");
    }
    return 0;
}


static int defaultManager(EjsObj *ev, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprAssert(!TYPE(ev)->isPot);
    }
    return 0;
}


/*
    Create a new type and initialize. BaseType is the super class for instances of the type being created. The
    returned EjsType will be an instance of EjsType. numTypeProp and numInstanceProp should be set to the number
    of non-inherited properties.
 */
EjsType *ejsCreateType(Ejs *ejs, EjsName qname, EjsModule *up, EjsType *baseType, EjsPot *prototype, int instanceSize, 
        int sid, int numTypeProp, int numInstanceProp, int64 attributes)
{
    EjsType     *type;
    
    mprAssert(ejs);
    mprAssert(instanceSize >= 0);
    
    if ((type = createTypeVar(ejs, ST(Type), numTypeProp)) == 0) {
        return 0;
    }
    type->manager = ejsManagePot;
    type->sid = sid;
    type->qname = qname;
    type->constructor.name = qname.name;
    type->module = up;
    type->baseType = baseType;
    type->instanceSize = instanceSize;
    ejsSetTypeAttributes(type, attributes);

    //  UNICODE
    mprSetName(type, qname.name->value);

    if (prototype) {
        type->prototype = prototype;
    } else {
        if ((type->prototype = ejsCreatePot(ejs, ST(Object), numInstanceProp)) == 0) {
            return 0;
        }
        //  UNICODE
        mprSetName(type->prototype, qname.name->value);
    }
    type->prototype->isPrototype = 1;

    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    if (sid >= 0) {
        ejsSetSpecial(ejs, sid, type);
    }
    return type;
}


/*
    Create a native built-in type. This is used for the core native classes of the language.
 */
EjsType *ejsCreateNativeType(Ejs *ejs, EjsName qname, int instanceSize, int sid, int numTypeProp, void *manager, int helpers)
{
    EjsType     *type;

    if ((type = ejsCreateType(ejs, qname, NULL, NULL, NULL, instanceSize, sid, numTypeProp, 0, 0)) == 0) {
        ejs->hasError = 1;
        return 0;
    }
    ejsSetPropertyByName(ejs, ejs->service->foundation, type->qname, type);

    type->manager = manager ? (MprManager) manager : (MprManager) defaultManager;
    if (helpers == EJS_POT_HELPERS) {
        ejsClonePotHelpers(ejs, type);
        mprAssert(manager);
    } else if (helpers == EJS_OBJ_HELPERS) {
        ejsCloneObjHelpers(ejs, type);
    }
    return type;
}


EjsType *ejsConfigureNativeType(Ejs *ejs, EjsName qname, int instanceSize, void *manager, int helpers)
{
    EjsType     *type;

    if ((type = ejsGetTypeByName(ejs, qname)) == 0) {
        mprError("Can't find %N type", qname);
        return 0;
    }
    type->instanceSize = instanceSize;
    type->manager = manager ? (MprManager) manager : (MprManager) defaultManager;
    if (helpers == EJS_POT_HELPERS) {
        ejsClonePotHelpers(ejs, type);
        type->isPot = 1;
    } else if (helpers == EJS_OBJ_HELPERS) {
        ejsCloneObjHelpers(ejs, type);
        type->isPot = 0;
    }
    return type;
}


EjsType *ejsConfigureType(Ejs *ejs, EjsType *type, EjsModule *up, EjsType *baseType, int numTypeProp, int numInstanceProp, 
    int64 attributes)
{
    type->module = up;
    ejsSetTypeAttributes(type, attributes);

    if (numTypeProp > 0 && ejsGrowPot(ejs, &type->constructor.block.pot, numTypeProp) < 0) {
        return 0;
    }
    if (numInstanceProp > 0) {
        ejsGrowPot(ejs, type->prototype, numInstanceProp);
    }
    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    return type;
}


EjsType *ejsCreateArchetype(Ejs *ejs, EjsFunction *fun, EjsPot *prototype)
{
    EjsName     qname;
    EjsType     *type, *baseType;
    EjsCode     *code;
    EjsString   *name;

    if (prototype == 0 && fun) {
        prototype = ejsGetPropertyByName(ejs, fun, N(NULL, "prototype"));
    }
    baseType = prototype ? TYPE(prototype): ST(Object);
    name = (fun && fun->name) ? fun->name : ejsCreateStringFromAsc(ejs, "-type-from-function-");
    qname.space = ejsCreateStringFromAsc(ejs, EJS_PROTOTYPE_NAMESPACE);
    qname.name = name;
    type = ejsCreateType(ejs, qname, NULL, baseType, prototype, ST(Object)->instanceSize, -1, 0, 0, 
        EJS_TYPE_DYNAMIC_INSTANCE);
    if (type == 0) {
        return 0;
    }
    if (fun) {
        code = fun->body.code;
        /*  using ST(Object) as the return type because the Yahoo module pattern returns {} in the constructor */
        ejsInitFunction(ejs, (EjsFunction*) type, type->qname.name, code->byteCode, code->codeLen, 
            fun->numArgs, fun->numDefault, code->numHandlers, ST(Object), EJS_TRAIT_HIDDEN | EJS_TRAIT_FIXED, 
            code->module, NULL, fun->strict);
        type->constructor.activation = ejsClone(ejs, fun->activation, 0);
        type->constructor.boundThis = 0;
        type->constructor.boundArgs = 0;
        type->constructor.isConstructor = 1;
        type->constructor.block.pot.isBlock = 1;
        type->constructor.block.pot.isFunction = 1;
        type->hasConstructor = 1;
        type->constructor.block.scope = fun->block.scope;
        fun->archetype = type;
    }
    ejsClonePotHelpers(ejs, type);
    return type;
}


/*
    OPT - should be able to just read in the attributes without having to stuff some in var and some in type.
    Should eliminate all the specific fields and just use BIT MASKS.
 */
void ejsSetTypeAttributes(EjsType *type, int64 attributes)
{
    if (attributes & EJS_TYPE_CALLS_SUPER) {
        type->callsSuper = 1;
    }
    if (attributes & EJS_TYPE_DYNAMIC_INSTANCE) {
        type->dynamicInstances = 1;
    }
    if (attributes & EJS_TYPE_FINAL) {
        type->final = 1;
    }
    if (attributes & EJS_TYPE_FIXUP) {
        type->needFixup = 1;
    }
    if (attributes & EJS_TYPE_HAS_CONSTRUCTOR) {
        type->hasConstructor = 1;
    }
    if (attributes & EJS_TYPE_HAS_INSTANCE_VARS) {
        type->hasInstanceVars = 1;
    }
#if UNUSED
    if (attributes & EJS_TYPE_IMMUTABLE_INSTANCES) {
        type->mutableInstances = 1;
    }
#endif
    if (attributes & EJS_TYPE_INTERFACE) {
        type->isInterface = 1;
    }
    if (attributes & EJS_TYPE_HAS_TYPE_INITIALIZER) {
        type->hasInitializer = 1;
    }
}


EjsType *ejsGetType(Ejs *ejs, int slotNum)
{
    EjsType     *type;

    if (slotNum < 0 || slotNum >= ((EjsPot*) ejs->global)->numProp) {
        return 0;
    }
    type = ejsGetProperty(ejs, ejs->global, slotNum);
    if (type == 0 || !ejsIsType(ejs, type)) {
        return 0;
    }
    return type;
}


EjsPot *ejsGetPrototype(Ejs *ejs, EjsAny *obj)
{
    return TYPE(obj)->prototype;
}


EjsType *ejsGetTypeByName(Ejs *ejs, EjsName qname)
{
    return ejsGetPropertyByName(ejs, ejs->global, qname);
}


static int inheritProperties(Ejs *ejs, EjsType *type, EjsPot *obj, int destOffset, EjsPot *baseBlock, int srcOffset, 
        int count, bool resetScope)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    int             i;

    mprAssert(obj);
    mprAssert(baseBlock);
    mprAssert(count > 0);
    mprAssert(destOffset < obj->numProp);
    mprAssert((destOffset + count) <= obj->numProp);
    mprAssert(srcOffset < baseBlock->numProp);
    mprAssert((srcOffset + count) <= baseBlock->numProp);

    ejsCopySlots(ejs, obj, &obj->properties->slots[destOffset], &baseBlock->properties->slots[srcOffset], count);
    
    if (resetScope) {
        for (i = destOffset; i < (destOffset + count); i++) {
            fun = ejsGetProperty(ejs, obj, i);
            if (ejsIsFunction(ejs, fun)) {
                fun = ejsCloneFunction(ejs, fun, 0);
                ejsSetProperty(ejs, obj, i, fun);
                fun->boundThis = 0;
                fun->boundArgs = 0;
                fun->block.scope = (EjsBlock*) type;
            }
        }
    }
    for (i = destOffset; i < (destOffset + count); i++) {
        if ((vp = ejsGetProperty(ejs, obj, i)) != 0 && !ejsIs(ejs, vp, Null) && !ejsIsFunction(ejs, vp)) {
            if (ejsIsType(ejs, vp)) {
                ejsSetProperty(ejs, obj, i, S(null));
            }
        }
    }
    ejsMakeHash(ejs, obj);
    return 0;
}


static void fixInstanceSize(Ejs *ejs, EjsType *type)
{
    EjsType     *tp;

    for (tp = type->baseType; tp && tp != ST(Object); tp = tp->baseType) {
        if (tp->instanceSize > type->instanceSize) {
            type->instanceSize = tp->instanceSize;
        }
    }
}


/*
    Fixup a type. This is used by the compiler and loader when it must first define a type when its base type or
    property types may not yet be defined (ie. forward references. Consequently, it must fixup the type and its 
    counts of inherited properties. It must also copy inherited slots and traits.
 */
int ejsFixupType(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    mprAssert(ejs);
    mprAssert(type);
    mprAssert(type != baseType);

    type->needFixup = 0;
    type->baseType = baseType;
    
    if (baseType) {
        //  TODO-- should be able to remove the || baseType->hasBaseConstructors
        if (baseType->hasConstructor || baseType->hasBaseConstructors) {
            type->hasBaseConstructors = 1;
        }
        //  TODO -- when compiling baseType is always != ST(Object)
        //  TODO - should not explicity reference objecttype
        if (baseType != ST(Object) && baseType->dynamicInstances) {
            type->dynamicInstances = 1;
        }
        type->hasInstanceVars |= baseType->hasInstanceVars;
    }
    if (type->implements) {
        if (fixupTypeImplements(ejs, type, makeRoom) < 0) {
            return EJS_ERR;
        }
    }
    if (baseType) {
        if (type->implements || baseType->prototype->numProp > 0) {
            fixupPrototypeProperties(ejs, type, baseType, makeRoom);
        }
        if (baseType->isPot && baseType != ST(Object)) {
            type->isPot = 1;
        }
   }
    fixInstanceSize(ejs, type);
    return 0;
}


#if UNUSED && KEEP
/*
    Import properties from the Type class. These are not inherited in the usual sense and numInherited is not updated.
    The properties are directly copied.
 */
int ejsBlendTypeProperties(Ejs *ejs, EjsType *type, EjsType *typeType)
{
    int     count, destOffset, srcOffset;

    mprAssert(type);
    mprAssert(typeType);

    count = ejsGetPropertyCount(ejs, typeType) - typeType->numInherited;
    mprAssert(count == 0);

    if (count > 0) { 
        /*  Append properties to the end of the type so as to not mess up the first slot which may be an initializer */
        destOffset = ejsGetPropertyCount(ejs, type);
        srcOffset = 0;
        if (ejsGrowPot(ejs, type, type->constructor.block.obj.numProp + count) < 0) {
            return EJS_ERR;
        }
        if (inheritProperties(ejs, type, type, destOffset, typeType, srcOffset, count, 0) < 0) {
            return EJS_ERR;
        }
    }
#if FUTURE && KEEP
    protoCount = ejsGetPropertyCount(ejs, typeType->prototype);
    if (protoCount > 0) {
        srcOffset = typeType->numInherited;
        destOffset = ejsGetPropertyCount(ejs, type->prototype);
        if (ejsGrowPot(ejs, type->prototype, type->prototype->numProp + protoCount) < 0) {
            return EJS_ERR;
        }
        if (inheritProperties(ejs, type, type->prototype, destOffset, typeType->prototype, srcOffset, 
                protoCount, 0) < 0) {
            return EJS_ERR;
        }
    }
#endif
    return 0;
}
#endif


static int fixupTypeImplements(Ejs *ejs, EjsType *type, int makeRoom)
{
    EjsType         *iface;
    EjsBlock        *bp;
    EjsNamespace    *nsp;
    int             next, offset, itotal, icount, nextNsp;

    mprAssert(type);
    mprAssert(type->implements);

    itotal = 0;
    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (!iface->isInterface) {
            itotal += iface->constructor.block.pot.numProp;
            type->hasInstanceVars |= iface->hasInstanceVars;
        }
    }
    if (makeRoom) {
        offset = type->constructor.block.pot.numProp;
        if (itotal > 0 && ejsGrowPot(ejs, (EjsPot*) type, offset + itotal) < 0) {
            return EJS_ERR;
        }
    } else {
        offset = type->constructor.block.pot.numProp - itotal;
    }
    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (!iface->isInterface) {
            icount = iface->constructor.block.pot.numProp;
            if (inheritProperties(ejs, type, (EjsPot*) type, offset, (EjsPot*) iface, 0, icount, 1) < 0) {
                return EJS_ERR;
            }
            offset += icount;
            for (nextNsp = 0; 
                    (nsp = (EjsNamespace*) mprGetNextItem(&iface->constructor.block.namespaces, &nextNsp)) != 0;) {
                ejsAddNamespaceToBlock(ejs, (EjsBlock*) type, nsp);
            }
            for (bp = iface->constructor.block.scope; bp; bp = bp->scope) {
                for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(&bp->namespaces, &nextNsp)) != 0;) {
                    ejsAddNamespaceToBlock(ejs, (EjsBlock*) type, nsp);
                }
            }
        }
    }
    return 0;
}


static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    EjsType     *iface;
    EjsPot      *basePrototype;
    int         count, offset, next;

    mprAssert(type != baseType);
    mprAssert(type->prototype);
    mprAssert(baseType->prototype);
    
    basePrototype = baseType->prototype;

    if (makeRoom) {
        count = 0;
        mprAssert(basePrototype);
        /* Must inherit if the type has instance vars */
        if (basePrototype && baseType->hasInstanceVars) {
            count = basePrototype->numProp;
        }
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (!iface->isInterface && iface->prototype) {
                count += iface->prototype->numProp - iface->numInherited;
            }
        }
        if (count > 0 && ejsInsertPotProperties(ejs, type->prototype, count, 0) < 0) {
            return EJS_ERR;
        }
    }
    offset = 0;
    if (baseType->hasInstanceVars) {
        mprAssert(type->prototype->numProp >= basePrototype->numProp);
        if (inheritProperties(ejs, type, type->prototype, offset, basePrototype, 0, basePrototype->numProp, 0) < 0) {
            return EJS_ERR;
        }
        type->numInherited = basePrototype->numProp;
        offset += basePrototype->numProp;
    }
    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (iface->isInterface) {
                continue;
            }
            /* Only come here for implemented classes */
            if (iface->prototype == 0) {
                continue;
            }
            count = iface->prototype->numProp - iface->numInherited;
            if (inheritProperties(ejs, type, type->prototype, offset, iface->prototype, iface->numInherited, count, 1) < 0) {
                return EJS_ERR;
            }
            type->numInherited += count;
            offset += count;
        }
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
int ejsBindMethod(Ejs *ejs, EjsAny *obj, int slotNum, void *nativeProc)
{
    return ejsBindFunction(ejs, obj, slotNum, nativeProc);
}


int ejsBindAccess(Ejs *ejs, void *obj, int slotNum, void *getter, void *setter)
{
    EjsFunction     *fun;

    if (getter) {
        if (ejsBindFunction(ejs, obj, slotNum, getter) < 0) {
            return EJS_ERR;
        }
    }
    if (setter) {
        fun = ejsGetProperty(ejs, obj, slotNum);
        if (fun == 0 || !ejsIsFunction(ejs, fun) || fun->setter == 0 || !ejsIsFunction(ejs, fun->setter)) {
            ejs->hasError = 1;
            mprError("Attempt to bind non-existant setter function for slot %d in \"%s\"", slotNum, mprGetName(obj));
            return EJS_ERR;
        }
        fun = fun->setter;
        if (fun->body.code) {
            mprError("Setting a native method on a non-native function \"%@\" in \"%s\"", fun->name, mprGetName(obj));
            ejs->hasError = 1;
        }
        fun->body.proc = setter;
        fun->isNativeProc = 1;
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
int ejsBindFunction(Ejs *ejs, EjsAny *obj, int slotNum, void *nativeProc)
{
    EjsFunction     *fun;

    if (ejsGetPropertyCount(ejs, obj) < slotNum) {
        ejs->hasError = 1;
        mprError("Attempt to bind non-existant function for slot %d in \"%s\"", slotNum, mprGetName(obj));
        return EJS_ERR;
    }
    fun = ejsGetProperty(ejs, obj, slotNum);
    if (fun == 0 || !ejsIsFunction(ejs, fun)) {
        mprAssert(fun);
        ejs->hasError = 1;
        mprError("Attempt to bind non-existant function for slot %d in \"%s\"", slotNum, mprGetName(obj));
        return EJS_ERR;
    }
    if (fun->body.code) {
        mprError("Setting a native method on a non-native function \"%@\" in \"%s\"", fun->name, mprGetName(obj));
        ejs->hasError = 1;
    }
    mprAssert(fun->body.proc == 0);
    fun->body.proc = nativeProc;
    fun->isNativeProc = 1;
    return 0;
}


void ejsBindConstructor(Ejs *ejs, EjsType *type, void *nativeProc)
{
    mprAssert(type->hasConstructor);
    mprAssert(type->constructor.isConstructor);
    mprAssert(type->constructor.block.pot.isBlock);
    mprAssert(type->constructor.block.pot.isFunction);
    mprAssert(type->constructor.body.proc == 0);

    type->constructor.body.proc = nativeProc;
    type->constructor.isNativeProc = 1;
}


/*
    Define a global public function. Returns a positive slot number, otherwise a negative MPR error.
 */
int ejsDefineGlobalFunction(Ejs *ejs, EjsString *name, EjsProc fn)
{
    EjsFunction *fun;
    EjsName     qname;

    if ((fun = ejsCreateFunction(ejs, name, NULL, -1, 0, 0, 0, ST(Object), 0, NULL, NULL, 0)) == 0) {
        return MPR_ERR_MEMORY;
    }
    fun->body.proc = fn;
    fun->isNativeProc = 1;
    qname.space = ejsCreateStringFromAsc(ejs, EJS_PUBLIC_NAMESPACE);
    qname.name = name;
    return ejsSetPropertyByName(ejs, ejs->global, qname, fun);
}


/*
    Return true if target is an instance of type or a sub class of it.
 */
bool ejsIsA(Ejs *ejs, EjsAny *target, EjsType *type)
{
    mprAssert(type);

    if (!ejsIsType(ejs, type) || target == 0) {
        return 0;
    }
    return ejsIsTypeSubType(ejs, TYPE(target), type);
}


/*
    Return true if "target" is a "type", subclass of "type" or implements "type".
 */
bool ejsIsTypeSubType(Ejs *ejs, EjsType *target, EjsType *type)
{
    EjsType     *tp, *iface;
    int         next;

    mprAssert(target);
    mprAssert(type);
    
    if (!ejsIsType(ejs, target) || !ejsIsType(ejs, type)) {
        return 0;
    }
    /*
        See if target is a subtype of type
     */
    for (tp = target; tp; tp = tp->baseType) {
        /*
            All strings are interned, so this will test equality of types even across interpreters.
            This permits using code from another interpreter.
         */
        if (tp->qname.name == type->qname.name && tp->qname.space == type->qname.space) {
            return 1;
        }
    }
    /*
        See if target implements type
     */
    if (target->implements) {
        for (next = 0; (iface = mprGetNextItem(target->implements, &next)) != 0; ) {
            if (iface->qname.name == type->qname.name && iface->qname.space == type->qname.space) {
                return 1;
            }
        }
    }
    return 0;
}


/*
    This call is currently only used to update the type namespace after resolving a run-time namespace.
 */
void ejsSetTypeName(Ejs *ejs, EjsType *type, EjsName qname)
{
    type->qname = qname;
}


/*
    Define namespaces for a class. Inherit the protected and internal namespaces from all base classes.
 */
void ejsDefineTypeNamespaces(Ejs *ejs, EjsType *type)
{
    EjsNamespace        *nsp;

    if (type->baseType) {
        /*
            Inherit the base class's protected and internal namespaces
         */
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }
    //  TODO - add readonly here
    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);
}



static void manageType(EjsType *type, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManageFunction(&type->constructor, flags);
        mprMark(type->qname.name);
        mprMark(type->qname.space);
        mprMark(type->prototype);
        mprMark(type->baseType);
        if (type->mutex) {
            mprNop(NULL);
        }
        mprMark(type->mutex);
        mprMark(type->implements);
        mprMark(type->typeData);
        mprMark(type->module);
    }
}


void ejsCreateTypeType(Ejs *ejs)
{
    EjsType     *type;

    type = ST(Type);
    type->manager = (MprManager) manageType;

    ejsCloneBlockHelpers(ejs, type);

    type->helpers.clone        = (EjsCloneHelper) cloneTypeVar;
    type->helpers.create       = (EjsCreateHelper) createTypeVar;
    type->helpers.setProperty  = (EjsSetPropertyHelper) setTypeProperty;

    /*
        WARNING: read closely. This can be confusing. Fixup the helpers for the object type. We need to find
        helpers via objectType->type->helpers. So we set it to the Type type. We keep objectType->baseType == 0
        because Object has no base type. Similarly for the Type type.
     */
    SET_TYPE(ST(Object), type);
    SET_TYPE(ST(Block), type);
    SET_TYPE(ST(String), type);
    SET_TYPE(ST(Type), ST(Object));
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsType.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsUri.c"
 */
/************************************************************************/

/*
    ejsUri.c - Uri class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsUri *completeUri(Ejs *ejs, EjsUri *up, EjsObj *missing, int includeQuery);
static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact);
static HttpUri *createHttpUriFromHash(Ejs *ejs, EjsObj *arg, int complete);
static HttpUri *toHttpUri(Ejs *ejs, EjsObj *arg, int dup);
static EjsUri *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv);


#if UNUSED && KEEP
//  keep this for when the cast helper is reversed
/*
    Convert an arg to a URI. Can handle strings, paths, URIs and object hashes. Will cast all else to strings and then
    parse.
 */
static EjsUri *castToUri(Ejs *ejs, EjsObj *arg)
{
    EjsUri  *up;

    up = ejsCreateObj(ejs, ST(Uri), 0);
    if (ejsIs(ejs, arg, String)) {
        up->uri = httpCreateUri(up, ejsToMulti(ejs, arg), 0);

    } else if (ejsIs(ejs, arg, Uri)) {
        up->uri = httpCloneUri(((EjsUri*) arg)->uri, 0);

    } else if (ejsIs(ejs, arg, Path)) {
        ustr = ((EjsPath*) arg)->path;
        up->uri = httpCreateUri(up, ustr, 0);

    } else if (ejsGetPropertyCount(ejs, arg) > 0) {
        up->uri = createHttpUriFromHash(ejs, up, arg, 0);

    } else {
        arg = (EjsObj) ejsToString(ejs, arg);
        up->uri = httpCreateUri(up, ejsToMulti(ejs, arg), 0);
    }
    return up;
}
#endif


static EjsUri *cloneUri(Ejs *ejs, EjsUri *src, bool deep)
{
    EjsUri     *dest;

    if ((dest = ejsCreateObj(ejs, TYPE(src), 0)) == 0) {
        return 0;
    }
    /*  NOTE: a deep copy will complete the uri */
    dest->uri = httpCloneUri(src->uri, deep);
    return dest;
}


static EjsAny *coerceUriOperands(Ejs *ejs, EjsUri *lhs, int opcode,  EjsAny *rhs)
{
    HttpUri     *uri;
    char        *ustr;

    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        uri = lhs->uri;
        ustr = httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        }
        uri = lhs->uri;
        ustr = httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return S(true);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return S(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


static EjsAny *invokeUriOperator(Ejs *ejs, EjsUri *lhs, int opcode,  EjsUri *rhs, void *data)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceUriOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*  Types now match, both Uris
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->uri == rhs->uri)) {
            return S(true);
        }
        return ejsCreateBoolean(ejs,  same(ejs, lhs->uri, rhs->uri, 1));

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs,  !same(ejs, lhs->uri, rhs->uri, 1));

    /*  NOTE: these only compare the paths */
    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) >= 0);

    /*  
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->uri->path) ? S(true): S(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->uri->path == 0) ? S(true): S(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return S(false);

    /*  
        Binary operators
     */
    case EJS_OP_ADD:
        return uri_join(ejs, lhs, 1, (EjsObj**) &rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}



/*  
    Constructor
    function Uri(uri: Uri)
    function Uri(path: String)
    function Uri(parts: Object)
 */
static EjsUri *uri_constructor(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (argc >= 0) {
        up->uri = toHttpUri(ejs, argv[0], 1);
    }
    return up;
}


/*  
    Make an absolute reference for "this" URI.

    function absolute(base): Uri
 */
static EjsUri *uri_absolute(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *uri, *baseUri;

    if (argc >= 1) {
        baseUri = toHttpUri(ejs, argv[0], 1);
        result = cloneUri(ejs, up, 0);
        uri = result->uri;
        if (uri->path && uri->path[0] != '/') {
            httpJoinUriPath(uri, baseUri, uri);
        }
        httpCompleteUri(result->uri, baseUri);
    } else {
        result = cloneUri(ejs, up, 0);
        httpCompleteUri(result->uri, NULL);
    }
    httpNormalizeUri(result->uri);
    return result;
}


/*  
    function get basename(): Uri
 */
static EjsUri *uri_basename(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return S(empty);
    }
    len = (int) strlen(path);
    if (path[len - 1] == '/') {
        *path = '\0';
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            np->uri->path = &cp[1];
        }
    }
    return np;
}


/*  
    function complete(missing = null): Uri
 */
static EjsUri *uri_complete(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri  *result;

    result = cloneUri(ejs, up, 0);
    return completeUri(ejs, result, (argc >= 1) ? argv[0] : 0, 1);
}


/*  
    Break a uri into components
  
    function components(): Object
 */
static EjsObj *uri_components(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    HttpUri     *uri;

    uri = up->uri;
    obj = ejsCreateEmptyPot(ejs);

    if (uri->scheme) {
        ejsSetPropertyByName(ejs, obj, EN("scheme"), ejsCreateStringFromAsc(ejs, uri->scheme));
    }
    if (uri->host) {
        ejsSetPropertyByName(ejs, obj, EN("host"), ejsCreateStringFromAsc(ejs, uri->host));
    }
    if (uri->port > 0) {
        ejsSetPropertyByName(ejs, obj, EN("port"), ejsCreateNumber(ejs, uri->port));
    }
    if (uri->path) {
        ejsSetPropertyByName(ejs, obj, EN("path"), ejsCreateStringFromAsc(ejs, uri->path));
    }
    if (uri->reference) {
        ejsSetPropertyByName(ejs, obj, EN("reference"), ejsCreateStringFromAsc(ejs, uri->reference));
    }
    if (uri->query) {
        ejsSetPropertyByName(ejs, obj, EN("query"), ejsCreateStringFromAsc(ejs, uri->query));
    }
    return obj;
}


/*  
    Decode a Uri
    static function decode(str: String): String
 */
static EjsString *uri_decode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Decode a Uri component
    static function decodeComponent(str: String): String
 */
static EjsString *uri_decodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    function get dirname(): Uri
 */
static EjsUri *uri_dirname(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return S(empty);
    }
    len = (int) strlen(path);
    if (path[len - 1] == '/') {
        if (len > 1) {
            path[len - 1] = '\0';
        }
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            if (cp > path) {
                *cp = '\0';
            } else {
                cp[1] = '\0';
            }
        }
    }
    return np;
}


/*  
    Uri Encode a string
    function encode(str: String): String
 */
static EjsString *uri_encode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_URI));
}


/*  
    Encode a Uri component
    static function encodeComponent(str: String): String
 */
static EjsString *uri_encodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_URI_COMPONENT));
}


/*  
    Get the Uri extension
    static function get extension(): String
 */
static EjsString *uri_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, up->uri->ext);
}


/*  
    Set the Uri extension
    static function set extension(ext: String): Void
 */
static EjsObj *uri_set_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    uri->ext = ejsToMulti(ejs, argv[0]);
    uri->path = sjoin(mprTrimPathExtension(uri->path), uri->ext, NULL);
    return 0;
}


/*  
    Determine if the uri has an extension
    static function get hasExtension(): Boolean
 */
static EjsBoolean *uri_hasExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->ext);
}


/*  
    Determine if the uri has a host
    static function get hasHost(): Boolean
 */
static EjsBoolean *uri_hasHost(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->host);
}


/*  
    Determine if the uri has a port
    static function get hasPort(): Boolean
 */
static EjsBoolean *uri_hasPort(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->port > 0);
}


/*  
    Determine if the uri has a query
    static function get hasQuery(): Boolean
 */
static EjsBoolean *uri_hasQuery(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->query);
}


/*  
    Determine if the uri has a reference
    static function get hasReference(): Boolean
 */
static EjsBoolean *uri_hasReference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->reference);
}


/*  
    Determine if the uri has a scheme
    static function get hasScheme(): Boolean
 */
static EjsBoolean *uri_hasScheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->scheme);
}


/*  
    Get the host portion
    static function get host(): String
 */
static EjsString *uri_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->host == 0) {
        return S(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->host);
}


/*  
    Set the host portion
    static function set host(name: String): Void
 */
static EjsObj *uri_set_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->host = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get isAbsolute(): Boolean
 */
static EjsBoolean *uri_isAbsolute(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->path[0] == '/');
}


/*  
    Determine if the file name is a directory. This 
    function get isDir(): Boolean
 */
static EjsBoolean *uri_isDir(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateBoolean(ejs, uri->path[strlen(uri->path) - 1] == '/');
}


/*  
    Join uri segments
    function join(...others): Uri
 */
static EjsUri *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    EjsObj      *arg;
    EjsArray    *args;
    HttpUri     *uri, *other, *oldUri;
    int         i;

    args = (EjsArray*) argv[0];
    result = cloneUri(ejs, up, 0);
    uri = result->uri;
    for (i = 0; i < args->length; i++) {
        arg = ejsGetProperty(ejs, args, i);
        if ((other = toHttpUri(ejs, arg, 0)) == NULL) {
            return 0;
        }
        oldUri = uri;
        uri = httpJoinUri(oldUri, 1, &other);
    }
    result->uri = uri;
    return result;
}


/*  
    Join extension
    function joinExt(ext: String): Uri
 */
static EjsUri *uri_joinExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    ext = ejsToMulti(ejs, argv[0]);
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = sjoin(mprTrimPathExtension(nuri->path), ".", nuri->ext, NULL);
    return np;
}


/*  
    function local(): Uri
 */
static EjsUri *uri_local(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;

    if ((result = cloneUri(ejs, up, 0)) != 0) {
        httpMakeUriLocal(result->uri);
    }
    return result;
}


/*  
    Get the mimeType
    function mimeType(): String
 */
static EjsString *uri_mimeType(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprLookupMime(NULL, up->uri->ext));
}


/*  
    function get normalize(): Uri
 */
static EjsUri *uri_normalize(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;

    np = cloneUri(ejs, up, 0);
    np->uri->path = httpNormalizeUriPath(up->uri->path);
    return np;
}


/*  
    Get the path portion
    static function get path(): String
 */
static EjsString *uri_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, up->uri->path);
}


/*  
    Set the path portion
    static function set path(path: String): Void
 */
static EjsObj *uri_set_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->path = httpNormalizeUriPath(ejsToMulti(ejs, argv[0]));
    up->uri->ext = mprGetPathExtension(up->uri->path);
    return 0;
}


/*  
    Get the port portion
    static function get port(): Number
 */
static EjsNumber *uri_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;
    
    uri = up->uri;
    if (uri->port == 0) {
        if (uri->host == 0) {
            return S(null);
        }
        if (uri->scheme == 0 || strcmp(uri->scheme, "http") == 0) {
            return ejsCreateNumber(ejs, 80);
        } else if (uri->scheme && strcmp(uri->scheme, "https") == 0) {
            return ejsCreateNumber(ejs, 443);
        }
    }
    return ejsCreateNumber(ejs, up->uri->port);
}


/*  
    Set the port portion
    static function set port(port: Number): Void
 */
static EjsObj *uri_set_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->port = ejsGetInt(ejs, argv[0]);
    return 0;
}


/*  
    Replace the Uri extension
    static function set replaceExt(ext: String): Uri
 */
static EjsUri *uri_replaceExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->path = mprTrimPathExtension(nuri->path);
    ext = ejsToMulti(ejs, argv[0]);
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = sjoin(mprTrimPathExtension(nuri->path), ".", nuri->ext, NULL);
    return np;
}


/*  
    function resolve(target): Uri
 */
static EjsUri *uri_resolve(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *uri, *target;

#if UNUSED
    int         relative;

    relative = (argc >= 2 && argv[1] == S(false)) ? 0 : 1;
#endif

    uri = up->uri;
    target = toHttpUri(ejs, argv[0], 0);
    result = ejsCreateObj(ejs, ST(Uri), 0);
    uri = httpResolveUri(uri, 1, &target, 0);
    if (up->uri == uri) {
        uri = httpCloneUri(uri, 0);
    }
    result->uri = uri;
    return result;
}


/*  
    function relative(base): Uri
 */
static EjsUri *uri_relative(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *baseUri;

    baseUri = toHttpUri(ejs, argv[0], 0);
    result = ejsCreateObj(ejs, ST(Uri), 0);
    result->uri = httpGetRelativeUri(baseUri, up->uri, 1);
    return result;
}


/*  
    Get the scheme portion
    static function get scheme(): String
 */
static EjsString *uri_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->scheme == 0) {
        return S(null);
    }
    return ejsCreateStringFromAsc(ejs, up->uri->scheme);
}


/*  
    Set the scheme portion
    static function set scheme(scheme: String): Void
 */
static EjsObj *uri_set_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->scheme = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    Get the query portion
    static function get query(): String
 */
static EjsString *uri_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, up->uri->query);
}


/*  
    Set the query portion
    static function set query(query: String): Void
 */
static EjsObj *uri_set_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    cchar    *value;

    value = ejsIs(ejs, argv[0], Null) ? "" : ejsToMulti(ejs, argv[0]);
    up->uri->query = sclone(value);
    return 0;
}


/*  
    Get the reference portion
    static function get reference(): String
 */
static EjsString *uri_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, up->uri->reference);
}


/*  
    Set the reference portion
    static function set reference(reference: String): Void
 */
static EjsObj *uri_set_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    cchar    *value;

    value = ejsIs(ejs, argv[0], Null) ? "" : ejsToMulti(ejs, argv[0]);
    up->uri->reference = sclone(value);
    return 0;
}


/*  
    Compare two Uris
    function same(other: String, exact: Boolean = false): Boolean
 */
static EjsObj *uri_same(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri  *other;
    int     exact;

    other = (EjsUri*) argv[0];
    exact = (argc == 2 && argv[1] == S(true));
    return ejsCreateBoolean(ejs, same(ejs, up->uri, other->uri, exact));
}


/*  
    Expand a template with {word} tokens from the given options objects

    function template(pattern: String, ...options): Uri
 */
static EjsUri *uri_template(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsArray    *options;
    EjsObj      *obj, *value;
    MprBuf      *buf;
    cchar       *pattern, *cp, *ep, *str;
    char        *token;
    int         i, len;

    pattern = ejsToMulti(ejs, argv[0]);
    options = (EjsArray*) argv[1];

    buf = mprCreateBuf(-1, -1);
    for (cp = pattern; *cp; cp++) {
        if (*cp == '{' && (cp == pattern || cp[-1] != '\\')) {
            if ((ep = strchr(++cp, '}')) != 0) {
                len = (int) (ep - cp);
                token = mprMemdup(cp, len + 1);
                token[len] = '\0';
                value = 0;
                for (i = 0; i < options->length; i++) {
                    obj = options->data[i];
                    if ((value = ejsGetPropertyByName(ejs, obj, N(NULL, token))) != 0 && ejsIsDefined(ejs, value)) {
                        str = ejsToMulti(ejs, value);
                        if (str && *str) {
                            mprPutStringToBuf(buf, str);
                            break;
                        } else {
                            value = 0;
                        }
                    }
                }
                if (!ejsIsDefined(ejs, value)) {
                    if (cp >= &pattern[2] && cp[-2] == '/') {
                        mprAdjustBufEnd(buf, -1);
                    }
                }
                cp = ep;
            }
        } else {
            mprPutCharToBuf(buf, *cp);
        }
    }
    mprAddNullToBuf(buf);
    return ejsCreateUriFromMulti(ejs, mprGetBufStart(buf));
}


/* 
   function toString(): String
 */
static EjsString *uri_toString(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateStringFromAsc(ejs, httpUriToString(uri, 0));
}


/* 
   function toLocalString(): String
 */
static EjsString *uri_toLocalString(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateStringFromAsc(ejs, httpFormatUri(NULL, NULL, 0, uri->path, uri->reference, uri->query, 0));
}


/*  
    function trimExt(): Uri
 */
static EjsUri *uri_trimExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->ext = 0;
    nuri->path = mprTrimPathExtension(nuri->path);
    return np;
}


/*  
    function set uri(value: String): Void
 */
static EjsObj *uri_set_uri(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri = httpCreateUri(ejsToMulti(ejs, argv[0]), 0);
    return 0;
}


#if UNUSED && KEEP
static char *uriToString(Ejs *ejs, EjsUri *up)
{
    HttpUri     *uri;

    uri = up->uri;
    return httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
}
#endif


static EjsUri *completeUri(Ejs *ejs, EjsUri *up, EjsObj *missing, int includeQuery)
{
    EjsUri      *missingUri;

    if (!ejsIsDefined(ejs, missing)) {
        missingUri = 0;
    } else if (ejsGetPropertyCount(ejs, missing) > 0) {
        missingUri = ejsCreateObj(ejs, ST(Uri), 0);
        missingUri->uri = createHttpUriFromHash(ejs, missing, 1);
    } else {
        missingUri = ejsToUri(ejs, missing);
    }
    if (missingUri == 0) {
        if (!includeQuery) {
            up->uri->query = NULL;
        }
        httpCompleteUri(up->uri, NULL);
    } else {
        httpCompleteUri(up->uri, missingUri->uri);
    }
    return up;
}


static HttpUri *toHttpUri(Ejs *ejs, EjsObj *arg, int dup)
{
    HttpUri     *uri;

    if (ejsIs(ejs, arg, String)) {
        uri = httpCreateUri(ejsToMulti(ejs, arg), 0);

    } else if (ejsIs(ejs, arg, Uri)) {
        if (dup) {
            uri = httpCloneUri(((EjsUri*) arg)->uri, 0);
        } else {
            uri = ((EjsUri*) arg)->uri;
        }

    } else if (ejsIs(ejs, arg, Path)) {
        uri = httpCreateUri(((EjsPath*) arg)->value, 0);

    } else if (ejsGetPropertyCount(ejs, arg) > 0) {
        uri = createHttpUriFromHash(ejs, arg, 0);

    } else {
        arg = (EjsObj*) ejsToString(ejs, arg);
        uri = httpCreateUri(ejsToMulti(ejs, arg), 0);
    }
    return uri;
}


static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact)
{
    if (u1 == u2) {
        return 1;
    }
    if ((u1->scheme && !u2->scheme) || (!u1->scheme && u2->scheme)) {
        return 0;
    }
    if (u1->scheme && strcmp(u1->scheme, u2->scheme) != 0) {
        return 0;
    }
    if ((u1->host && !u2->host) || (!u1->host && u2->host)) {
        return 0;
    }
    if (u1->host && strcmp(u1->host, u2->host) != 0) {
        return 0;
    }
    if ((u1->path && !u2->path) || (!u1->path && u2->path)) {
        return 0;
    }
    if (u1->path && strcmp(u1->path, u2->path) != 0) {
        return 0;
    }
    if (u1->port != u2->port) {
        return 0;
    }
    if (exact) {
        if ((u1->reference && !u2->reference) || (!u1->reference && u2->reference)) {
            return 0;
        }
        if (u1->reference && strcmp(u1->reference, u2->reference) != 0) {
            return 0;
        }
        if ((u1->query && !u2->query) || (!u1->query && u2->query)) {
            return 0;
        }
        if (u1->query && strcmp(u1->query, u2->query) != 0) {
            return 0;
        }
    }
    return 1;
}


static HttpUri *createHttpUriFromHash(Ejs *ejs, EjsObj *arg, int complete)
{
    EjsObj      *schemeObj, *hostObj, *portObj, *pathObj, *referenceObj, *queryObj, *uriObj;
    cchar       *scheme, *host, *path, *reference, *query;
    int         port;

    /*
        This permits a uri property override. Used in ejs.web::View.getOptions()
     */
    uriObj = ejsGetPropertyByName(ejs, arg, EN("uri"));
    if (uriObj) {
        return toHttpUri(ejs, uriObj, 1);
    }
    schemeObj = ejsGetPropertyByName(ejs, arg, EN("scheme"));
    scheme = ejsIs(ejs, schemeObj, String) ? ejsToMulti(ejs, schemeObj) : 0;

    hostObj = ejsGetPropertyByName(ejs, arg, EN("host"));
    host = ejsIs(ejs, hostObj, String) ? ejsToMulti(ejs, hostObj) : 0;

    port = 0;
    if ((portObj = ejsGetPropertyByName(ejs, arg, EN("port"))) != 0) {
        if (ejsIs(ejs, portObj, Number)) {
            port = ejsGetInt(ejs, portObj);
        } else if (ejsIs(ejs, portObj, String)) {
            port = (int) stoi(ejsToMulti(ejs, portObj), 10, NULL);
        }
    }
    pathObj = ejsGetPropertyByName(ejs, arg, EN("path"));
    path = ejsIs(ejs, pathObj, String) ? ejsToMulti(ejs, pathObj) : 0;

    referenceObj = ejsGetPropertyByName(ejs, arg, EN("reference"));
    reference = ejsIs(ejs, referenceObj, String) ? ejsToMulti(ejs, referenceObj) : 0;

    queryObj = ejsGetPropertyByName(ejs, arg, EN("query"));
    query = ejsIs(ejs, queryObj, String) ? ejsToMulti(ejs, queryObj) : 0;

    return httpCreateUriFromParts(scheme, host, port, path, reference, query, complete);
}


/*  
    Decode a Uri (ECMA Standard)

    function decodeURI(str: String): String
 */
static EjsObj *decodeURI(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Decode a Uri component (ECMA Standard)
    function decodeURIComponent(str: String): String
 */
static EjsObj *decodeURIComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Uri Encode a string (ECMA Standard)
    function encodeURI(str: String): String
 */
static EjsObj *encodeURI(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_JS_URI));
}


/*  
    Encode a Uri component (ECMA Standard)
    static function encodeComponent(str: String): String
 */
static EjsObj *encodeURIComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    char    *encoded;

    encoded = mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_JS_URI_COMPONENT);
    return (EjsObj*) ejsCreateStringFromAsc(ejs, encoded);
}



EjsUri *ejsCreateUri(Ejs *ejs, EjsString *path)
{
    EjsUri      *up;

    if ((up = ejsCreateObj(ejs, ST(Uri), 0)) == NULL) {
        return 0;
    }
    uri_constructor(ejs, up, 1, (EjsObj**) &path);
    return up;
}


EjsUri *ejsCreateUriFromMulti(Ejs *ejs, cchar *path)
{
    EjsUri      *up;
    EjsObj      *arg;

    if ((up = ejsCreateObj(ejs, ST(Uri), 0)) == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    uri_constructor(ejs, up, 1, (EjsObj**) &arg);
    return up;
}


EjsUri *ejsCreateUriFromParts(Ejs *ejs, cchar *scheme, cchar *host, int port, cchar *path, cchar *query, cchar *reference, 
    int complete)
{
    EjsUri      *up;

    if ((up = ejsCreateObj(ejs, ST(Uri), 0)) == 0) {
        return 0;
    }
    up->uri = httpCreateUriFromParts(scheme, host, port, path, reference, query, complete);
    return up;
}


static void manageUri(EjsUri *up, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(up->uri);
    }
}


void ejsConfigureUriType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "Uri"), sizeof(EjsUri), manageUri, EJS_OBJ_HELPERS);
    type->mutableInstances = 1;
    ejsSetSpecialType(ejs, S_Uri, type);
    prototype = type->prototype;

    type->helpers.clone = (EjsCloneHelper) cloneUri;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeUriOperator;

    ejsBindMethod(ejs, type, ES_Uri_decode, uri_decode);
    ejsBindMethod(ejs, type, ES_Uri_decodeComponent, uri_decodeComponent);
    ejsBindMethod(ejs, type, ES_Uri_encode, uri_encode);
    ejsBindMethod(ejs, type, ES_Uri_encodeComponent, uri_encodeComponent);
    ejsBindMethod(ejs, type, ES_Uri_template, uri_template);

    ejsBindConstructor(ejs, type, uri_constructor);
    ejsBindMethod(ejs, prototype, ES_Uri_absolute, uri_absolute);
    ejsBindMethod(ejs, prototype, ES_Uri_basename, uri_basename);
    ejsBindMethod(ejs, prototype, ES_Uri_complete, uri_complete);
    ejsBindMethod(ejs, prototype, ES_Uri_components, uri_components);
    ejsBindMethod(ejs, prototype, ES_Uri_dirname, uri_dirname);
    ejsBindAccess(ejs, prototype, ES_Uri_extension, uri_extension, uri_set_extension);
    ejsBindMethod(ejs, prototype, ES_Uri_hasExtension, uri_hasExtension);
    ejsBindMethod(ejs, prototype, ES_Uri_hasHost, uri_hasHost);
    ejsBindMethod(ejs, prototype, ES_Uri_hasPort, uri_hasPort);
    ejsBindMethod(ejs, prototype, ES_Uri_hasQuery, uri_hasQuery);
    ejsBindMethod(ejs, prototype, ES_Uri_hasReference, uri_hasReference);
    ejsBindMethod(ejs, prototype, ES_Uri_hasScheme, uri_hasScheme);
    ejsBindAccess(ejs, prototype, ES_Uri_host, uri_host, uri_set_host);
    ejsBindMethod(ejs, prototype, ES_Uri_isAbsolute, uri_isAbsolute);
    ejsBindMethod(ejs, prototype, ES_Uri_isDir, uri_isDir);
    ejsBindMethod(ejs, prototype, ES_Uri_join, uri_join);
    ejsBindMethod(ejs, prototype, ES_Uri_joinExt, uri_joinExt);
    ejsBindMethod(ejs, prototype, ES_Uri_local, uri_local);
    ejsBindMethod(ejs, prototype, ES_Uri_mimeType, uri_mimeType);
    ejsBindMethod(ejs, prototype, ES_Uri_normalize, uri_normalize);
    ejsBindAccess(ejs, prototype, ES_Uri_path, uri_path, uri_set_path);
    ejsBindAccess(ejs, prototype, ES_Uri_port, uri_port, uri_set_port);
    ejsBindAccess(ejs, prototype, ES_Uri_scheme, uri_scheme, uri_set_scheme);
    ejsBindAccess(ejs, prototype, ES_Uri_query, uri_query, uri_set_query);
    ejsBindAccess(ejs, prototype, ES_Uri_reference, uri_reference, uri_set_reference);
    ejsBindMethod(ejs, prototype, ES_Uri_replaceExt, uri_replaceExtension);
    ejsBindMethod(ejs, prototype, ES_Uri_relative, uri_relative);
    ejsBindMethod(ejs, prototype, ES_Uri_resolve, uri_resolve);
    ejsBindMethod(ejs, prototype, ES_Uri_same, uri_same);
    ejsBindMethod(ejs, prototype, ES_Uri_toString, uri_toString);
    ejsBindMethod(ejs, prototype, ES_Uri_toLocalString, uri_toLocalString);
    ejsBindMethod(ejs, prototype, ES_Uri_trimExt, uri_trimExt);
    ejsBindAccess(ejs, prototype, ES_Uri_uri, uri_toString, uri_set_uri);

    ejsBindMethod(ejs, ejs->global, ES_decodeURI, decodeURI);
    ejsBindMethod(ejs, ejs->global, ES_decodeURIComponent, decodeURIComponent);
    ejsBindMethod(ejs, ejs->global, ES_encodeURI, encodeURI);
    ejsBindMethod(ejs, ejs->global, ES_encodeURIComponent, encodeURIComponent);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsUri.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsVoid.c"
 */
/************************************************************************/

/**
    ejsVoid.c - Ejscript Void class (aka undefined)

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the void operand to a primitive type
 */

static EjsAny *castVoid(Ejs *ejs, EjsVoid *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return S(false);

    case S_Number:
        return S(nan);

    case S_Object:
        return vp;

    case S_String:
        return ejsCreateStringFromAsc(ejs, "undefined");

    case S_Uri:
        return ejsCreateUriFromMulti(ejs, "undefined");
            
    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}



static EjsAny *coerceVoidOperands(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(nan), opcode, rhs);

    /*
     *  Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return S(false);

    case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, Null)) {
            return S(false);
        }
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return S(true);

    case EJS_OP_COMPARE_EQ:
        if (ejsIs(ejs, rhs, Null)) {
            return S(true);
        }
        return S(false);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return S(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}



static EjsObj *invokeVoidOperator(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceVoidOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
     *  Types match, left and right types are both "undefined"
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return S(nan);

    /*
     *  Binary operators
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return S(nan);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    iterator native function get(): Iterator
 */
static EjsIterator *getVoidIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, NULL, 0, NULL);
}


static EjsObj *getVoidProperty(Ejs *ejs, EjsVoid *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*
    We don't actually create any instances. We just use a reference to the undefined singleton instance.
 */
EjsVoid *ejsCreateUndefined(Ejs *ejs)
{
    return (EjsVoid*) S(undefined);
}


void ejsCreateVoidType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "Void"), sizeof(EjsVoid), S_Void, ES_Void_NUM_CLASS_PROP, NULL, 
        EJS_OBJ_HELPERS);

    type->helpers.cast             = (EjsCastHelper) castVoid;
    type->helpers.invokeOperator   = (EjsInvokeOperatorHelper) invokeVoidOperator;
    type->helpers.getProperty      = (EjsGetPropertyHelper) getVoidProperty;

    ejsSetSpecial(ejs, S_undefined, ejsCreateObj(ejs, type, 0));
    mprSetName(S(undefined), "undefined");
}


void ejsConfigureVoidType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(Void);
    prototype = type->prototype;

    ejsSetProperty(ejs, ejs->global, ES_void, type);
    ejsSetProperty(ejs, ejs->global, ES_undefined, S(undefined));
    ejsBindMethod(ejs, prototype, ES_Void_iterator_get, getVoidIterator);
    ejsBindMethod(ejs, prototype, ES_Void_iterator_getValues, getVoidIterator);
}



/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsVoid.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsWorker.c"
 */
/************************************************************************/

/*
    ejsWorker - VM Worker thread classes

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



typedef struct Message {
    EjsWorker   *worker;
    cchar       *callback;
    char        *data;
    EjsObj      *message;
    EjsObj      *stack;
    int         callbackSlot;
} Message;


static void addWorker(Ejs *ejs, EjsWorker *worker);
static int join(Ejs *ejs, EjsObj *workers, int timeout);
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception, int throwOutside);
static void loadFile(EjsWorker *insideWorker, cchar *filename);
static void removeWorker(EjsWorker *worker);
static int workerMain(EjsWorker *worker, MprEvent *event);
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv);


static EjsWorker *initWorker(Ejs *ejs, EjsWorker *worker, Ejs *baseVm, cchar *name, EjsArray *search, cchar *scriptFile)
{
    Ejs             *wejs;
    EjsWorker       *self;
    EjsNamespace    *ns;
    EjsName         sname;
    static int      workerSeqno = 0;

    ejsFreeze(ejs, 1);
    if (worker == 0) {
        worker = ejsCreateWorker(ejs);
    }
    worker->ejs = ejs;
    worker->state = EJS_WORKER_BEGIN;

    if (name) {
        worker->name = sclone(name);
    } else {
        lock(ejs);
        worker->name = mprAsprintf("worker-%d", workerSeqno++);
        unlock(ejs);
    }

    /*
        Create a new interpreter and an "inside" worker object and pair it with the current "outside" worker.
        The worker interpreter gets a new dispatcher
     */
    if ((wejs = ejsCreateVM(baseVm, 0, 0, 0, 0, 0, 0)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    worker->pair = self = ejsCreateWorker(wejs);
    self->state = EJS_WORKER_BEGIN;
    self->ejs = wejs;
    self->inside = 1;
    self->pair = worker;
    self->name = sjoin("inside-", worker->name, NULL);
    mprEnableDispatcher(wejs->dispatcher);
    if (search) {
        ejsSetSearchPath(ejs, (EjsArray*) search);
    }

    //  TODO - these should be don't delete
    ejsSetProperty(ejs, worker, ES_Worker_name, ejsCreateStringFromAsc(ejs, self->name));
    ejsSetProperty(wejs, self,  ES_Worker_name, ejsCreateStringFromAsc(wejs, self->name));

    sname = ejsName(wejs, EJS_WORKER_NAMESPACE, "self");
    ejsSetPropertyByName(wejs, wejs->global, sname, self);

    /*
        Workers have a dedicated namespace to enable viewing of the worker globals (self, onmessage, postMessage...)
     */
    ns = ejsDefineReservedNamespace(wejs, wejs->global, NULL, EJS_WORKER_NAMESPACE);

    if (scriptFile) {
        addWorker(ejs, worker);
        worker->scriptFile = sclone(scriptFile);
        worker->state = EJS_WORKER_STARTED;
        if (mprCreateEvent(wejs->dispatcher, "workerMain", 0, (MprEventProc) workerMain, self, 0) < 0) {
            ejsThrowStateError(ejs, "Can't create worker event");
            return 0;
        }
    }
    return worker;
}


static EjsWorker *workerConstructor(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    EjsArray    *search;
    EjsObj      *options, *value;
    cchar       *name, *scriptFile;

    ejsFreeze(ejs, 1);

    scriptFile = (argc >= 1) ? ((EjsPath*) argv[0])->value : 0;
    options = (argc == 2) ? (EjsObj*) argv[1]: NULL;
    name = 0;
    search = 0;
    if (options) {
        search = ejsGetPropertyByName(ejs, options, EN("search"));
        value = ejsGetPropertyByName(ejs, options, EN("name"));
        if (ejsIs(ejs, value, String)) {
            name = ejsToMulti(ejs, value);
        }
    }
    worker->ejs = ejs;
    worker->state = EJS_WORKER_BEGIN;
    return initWorker(ejs, worker, 0, name, search, scriptFile);
}


/*
    Add a worker object to the list of running workers for this interpreter
 */
static void addWorker(Ejs *ejs, EjsWorker *worker) 
{
    mprAssert(ejs == worker->ejs);
    mprAssert(worker);
    mprAssert(worker->state == EJS_WORKER_BEGIN);
    mprAssert(!worker->inside);

    //  OPT - locking not needed
    lock(ejs);
    mprAssert(ejs->workers->length < 10);
    mprAddItem(ejs->workers, worker);
    unlock(ejs);
}


static void removeWorker(EjsWorker *worker) 
{
    Ejs     *ejs;

    mprAssert(!worker->inside);
    mprAssert(worker);

    ejs = worker->ejs;
    if (ejs) {
        lock(ejs);
        if (ejs->workers) {
            mprRemoveItem(ejs->workers, worker);
        }
        if (ejs->joining) {
            mprSignalDispatcher(ejs->dispatcher);
        }
        /* Accelerate GC */
        if (worker->pair) {
            worker->pair->ejs->workerComplete = 1;
            worker->pair->ejs = 0;
            worker->pair->pair = 0;
            worker->pair = 0;
        }
        worker->ejs = 0;        
        unlock(ejs);
    }
}


/*
    Called when destroying ejs
 */
void ejsRemoveWorkers(Ejs *ejs)
{
    EjsWorker   *worker;
    int         next;

    for (next = 0; (worker = mprGetNextItem(ejs->workers, &next)) != NULL; ) {
        worker->ejs = 0;
    }
    ejs->workers = 0;
}


/*
    Start a worker thread. This is called by eval() and load(). Not by preload() or by Worker(). It always joins.
 */
static EjsObj *startWorker(Ejs *ejs, EjsWorker *outsideWorker, int timeout)
{
    EjsWorker   *insideWorker;
    Ejs         *inside;
    EjsString   *result;

    mprAssert(ejs);
    mprAssert(outsideWorker);
    mprAssert(!outsideWorker->inside);
    mprAssert(outsideWorker->state == EJS_WORKER_BEGIN);
    mprAssert(outsideWorker->pair);
    mprAssert(outsideWorker->pair->ejs);

    LOG(5, "Worker.startWorker");

    if (outsideWorker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = outsideWorker->pair;
    mprAssert(insideWorker->inside);
    mprAssert(insideWorker->state == EJS_WORKER_BEGIN);
    inside = insideWorker->ejs;

    addWorker(ejs, outsideWorker);
    outsideWorker->state = EJS_WORKER_STARTED;

    if (mprCreateEvent(inside->dispatcher, "workerMain", 0, (MprEventProc) workerMain, insideWorker, 0) < 0) {
        ejsThrowStateError(ejs, "Can't create worker event");
        return 0;
    }
    if (timeout == 0) {
        return S(undefined);
    } 
    if (timeout < 0) {
        timeout = MAXINT;
    }
    if (join(ejs, (EjsObj*) outsideWorker, timeout) < 0) {
        return S(undefined);
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return S(null);
    }
    return ejsDeserialize(ejs, result);
}


/*
    function clone(deep: Boolean = null): Worker
 */
static EjsWorker *workerClone(Ejs *ejs, EjsWorker *baseWorker, int argc, EjsObj **argv)
{
    return initWorker(ejs, 0, baseWorker->pair->ejs, 0, 0, 0);
}


/*
    static function cloneSelf(): Worker
 */
static EjsWorker *workerCloneSelf(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    return initWorker(ejs, 0, ejs, 0, 0, 0);
}


/*
    function eval(script: String, timeout: Boolean = -1): Obj
 */
static EjsObj *workerEval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    mprAssert(ejsIs(ejs, argv[0], String));

    worker->scriptLiteral = (EjsString*) argv[0];
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): MAXINT;
    return startWorker(ejs, worker, timeout);
}


/*
    static function exit()
 */
static EjsObj *workerExit(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    /*
        Setting exiting causes the VM to suspend processing this interpreter
     */
    ejs->exiting = 1;
    ejsAttention(ejs);
    return 0;
}


/*
    Return true if the join is successful
 */
static int reapJoins(Ejs *ejs, EjsObj *workers)
{
    EjsWorker   *worker;
    EjsArray    *set;
    int         i, completed, joined, count;

    lock(ejs);
    completed = 0;
    joined = 0;

    if (workers == 0 || ejsIs(ejs, workers, Null)) {
        /* Join all */
        count = mprGetListLength(ejs->workers);
        for (i = 0; i < count; i++) {
            worker = mprGetItem(ejs->workers, i);
            if (worker->state >= EJS_WORKER_COMPLETE) {
                completed++;
            }
        }
        if (completed == count) {
            joined = 1;
        }
    } else if (ejsIs(ejs, workers, Array)) {
        /* Join a set */
        set = (EjsArray*) workers;
        for (i = 0; i < set->length; i++) {
            worker = (EjsWorker*) set->data[i];
            if (worker->state >= EJS_WORKER_COMPLETE) {
                completed++;
            }
        }
        if (completed == set->length) {
            joined = 1;
        }
    } else if (TYPE(workers) == ST(Worker)) {
        /* Join one worker */
        worker = (EjsWorker*) workers;
        if (worker->state >= EJS_WORKER_COMPLETE) {
            joined = 1;
        }
    }
    unlock(ejs);
    return joined;
}


static int join(Ejs *ejs, EjsObj *workers, int timeout)
{
    MprTime     mark;
    int         result, remaining;

    LOG(5, "Worker.join: joining %d", ejs->joining);
    mprAssert(!MPR->marking);
    
    mark = mprGetTime();
    remaining = timeout;
    do {
        mprAssert(!MPR->marking);
        ejs->joining = !reapJoins(ejs, workers);
        mprAssert(!MPR->marking);
        if (!ejs->joining) {
            break;
        }
        if (mprShouldAbortRequests()) {
            ejsThrowStateError(ejs, "Program instructed to exit");
            break;
        }
        mprWaitForEvent(ejs->dispatcher, remaining);
        mprAssert(!MPR->marking);
        remaining = (int) mprGetRemainingTime(mark, timeout);
        mprAssert(!MPR->marking);
    } while (remaining > 0 && !ejs->exception);
    mprAssert(!MPR->marking);

    if (ejs->exception) {
        return 0;
    }
    result = (ejs->joining) ? MPR_ERR_TIMEOUT: 0;
    ejs->joining = 0;
    LOG(7, "Worker.join: result %d", result);
    return result;
}


/*
    static function join(workers: Object = null, timeout: Number = -1): Boolean
 */
static EjsObj *workerJoin(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    EjsObj      *workers;
    int         timeout;

    workers = (argc > 0) ? argv[0] : NULL;
    timeout = (argc == 2) ? ejsGetInt(ejs, argv[1]) : MAXINT;
    mprAssert(!MPR->marking);

    return (join(ejs, workers, timeout) == 0) ? S(true): S(false);
}


/*
    Load a file into the worker. This can be a script file or a module. This runs on the inside interpreter
 */
static void loadFile(EjsWorker *worker, cchar *path)
{
    Ejs         *ejs;
    EjsObj      *result;
    cchar       *cp;

    mprAssert(worker->inside);
    mprAssert(worker->pair && worker->pair->ejs);

    ejs = worker->ejs;
    result = 0;

    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
            return;
        }
        (ejs->service->loadScriptFile)(ejs, path, NULL);

    } else {
        /* Error reporting via thrown exceptions */
        ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, EJS_LOADER_RELOAD);
    }
}


/*
    function load(script: Path, timeout: Number = 0): Void
 */
static EjsObj *workerLoad(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    mprAssert(argc == 0 || ejsIs(ejs, argv[0], Path));

    worker->scriptFile = sclone(((EjsPath*) argv[0])->value);
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): 0;
    return startWorker(ejs, worker, timeout);
}


/*
    static function lookup(name: String): Worker
 */
static EjsWorker *workerLookup(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsWorker   *worker;
    cchar       *name;
    int         next;

    name = ejsToMulti(ejs, argv[0]);
    lock(ejs);
    for (next = 0; (worker = mprGetNextItem(ejs->workers, &next)) != NULL; ) {
        if (worker->name && strcmp(name, worker->name) == 0) {
            unlock(ejs);
            return worker;
        }
    }
    unlock(ejs);
    return S(null);
}


/*
    Process a message sent from postMessage. This may run inside the worker or outside in the parent depending on the
    direction of the message. But it ALWAYS runs in the appropriate thread for the interpreter.
 */
static int doMessage(Message *msg, MprEvent *mprEvent)
{
    Ejs         *ejs;
    EjsObj      *event, *frame;
    EjsWorker   *worker;
    EjsFunction *callback;
    EjsObj      *argv[1];

    worker = msg->worker;
    worker->gotMessage = 1;
    ejs = worker->ejs;
    event = 0;
    ejsFreeze(ejs, 1);

    callback = ejsGetProperty(ejs, worker, msg->callbackSlot);

    switch (msg->callbackSlot) {
    case ES_Worker_onerror:
        event = ejsCreateObj(ejs, ST(ErrorEvent), 0);
        break;
            
    case ES_Worker_onclose:
    case ES_Worker_onmessage:
        event = ejsCreateObj(ejs, ST(Event), 0);
        break;
            
    default:
        mprAssert(msg->callbackSlot == 0);
        return 0;
    }
    worker->event = event;
    if (msg->data) {
        ejsSetProperty(ejs, event, ES_Event_data, ejsCreateStringFromAsc(ejs, msg->data));
    }
    if (msg->message) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_message, msg->message);
    }
    if (msg->stack) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_stack, msg->stack);
        if ((frame = ejsGetProperty(ejs, msg->stack, 0)) != 0 && !ejsIs(ejs, frame, Void)) {
            ejsSetProperty(ejs, event, ES_ErrorEvent_filename, ejsGetPropertyByName(ejs, frame, EN("filename")));
            ejsSetProperty(ejs, event, ES_ErrorEvent_lineno, ejsGetPropertyByName(ejs, frame, EN("lineno")));
        }
    }
    if (callback == 0 || ejsIs(ejs, callback, Null)) {
        if (msg->callbackSlot == ES_Worker_onmessage) {
            mprLog(6, "Discard message as no onmessage handler defined for worker");
            
        } else if (msg->callbackSlot == ES_Worker_onerror) {
            if (ejsIs(ejs, msg->message, String)) {
                ejsThrowError(ejs, "Exception in Worker: %@", ejsToString(ejs, msg->message));
            } else {
                ejsThrowError(ejs, "Exception in Worker: %s", ejsGetErrorMsg(worker->pair->ejs, 1));
            }
        } else {
            /* Ignore onclose message */
        }

    } else if (!ejsIsFunction(ejs, callback)) {
        ejsThrowTypeError(ejs, "Worker callback %s is not a function", msg->callback);

    } else {
        argv[0] = event;
        ejsRunFunction(ejs, callback, worker, 1, argv);
    }
    if (msg->callbackSlot == ES_Worker_onclose) {
        mprAssert(!worker->inside);
        worker->state = EJS_WORKER_COMPLETE;
        LOG(5, "Worker.doMessage: complete");
        /* Worker and insider interpreter are now eligible for garbage collection */
        removeWorker(worker);
    }
    mprSignalDispatcher(ejs->dispatcher);
    worker->event = 0;
    return 0;
}


/*
    function preeval(script: String): Object
    NOTE: this blocks. 
 */
static EjsObj *workerPreeval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsString   *result;

    mprAssert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    mprAssert(insideWorker->inside);
    inside = insideWorker->ejs;

    (inside->service->loadScriptLiteral)(inside, (EjsString*) argv[0], NULL);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception, 1);
        return 0;
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return S(null);
    }
    return ejsDeserialize(ejs, result);
}


/*
    function preload(path: Path): Object
    NOTE: this blocks. 
 */
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsString   *result;

    mprAssert(argc > 0 && ejsIs(ejs, argv[0], Path));
    mprAssert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    mprAssert(insideWorker->inside);
    inside = insideWorker->ejs;

    loadFile(worker->pair, ((EjsPath*) argv[0])->value);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception, 1);
        return 0;
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return S(null);
    }
    return ejsDeserialize(ejs, result);
}


static void manageMessage(Message *msg, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(msg->data);
        mprMark(msg->message);
        mprMark(msg->stack);
    }
}


static Message *createMessage()
{ 
    return mprAllocObj(Message, manageMessage);
}


/*
    Post a message to this worker. Note: the worker is the destination worker which may be the parent.

    function postMessage(data: Object, ports: Array = null): Void
 */
static EjsObj *workerPostMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    EjsString       *data;
    EjsWorker       *target;
    MprDispatcher   *dispatcher;
    Message         *msg;

    if (worker->state >= EJS_WORKER_CLOSED) {
        ejsThrowStateError(ejs, "Worker has completed");
        return 0;
    }
    /*
        Create the event with serialized data in the originating interpreter. It owns the data.
     */
    ejsFreeze(ejs, 1);
    if ((data = ejsToJSON(ejs, argv[0], NULL)) == 0) {
        ejsThrowArgError(ejs, "Can't serialize message data");
        return 0;
    }
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    target = worker->pair;
    msg->data = ejsToMulti(ejs, data);
    msg->worker = target;
    msg->callback = "onmessage";
    msg->callbackSlot = ES_Worker_onmessage;

    dispatcher = target->ejs->dispatcher;
    mprCreateEvent(dispatcher, "postMessage", 0, doMessage, msg, 0);
    return 0;
}


/*
    Worker thread main procedure. Worker is the inside worker.
 */
static int workerMain(EjsWorker *insideWorker, MprEvent *event)
{
    Ejs             *outside, *inside;
    EjsWorker       *outsideWorker;
    MprDispatcher   *dispatcher;
    Message         *msg;

    mprAssert(insideWorker->inside);
    outsideWorker = insideWorker->pair;
    mprAssert(!outsideWorker->inside);
    mprAssert(insideWorker->state == EJS_WORKER_BEGIN);

    outside = outsideWorker->ejs;
    inside = insideWorker->ejs;
    insideWorker->state = EJS_WORKER_STARTED;
    
    /*
        Run the script or file
     */
    if (outsideWorker->scriptFile) {
        loadFile(insideWorker, outsideWorker->scriptFile);

    } else if (outsideWorker->scriptLiteral) {
        if (outside->service->loadScriptLiteral == 0) {
            ejsThrowIOError(outside, "worker: Compiling is not enabled");
            return 0;
        }
        (outside->service->loadScriptLiteral)(inside, outsideWorker->scriptLiteral, NULL);
    }
    /*
        Check for exceptions
     */
    if (inside->exception) {
        handleError(outside, outsideWorker, inside->exception, 0);
        inside->exception = 0;
    }
    ejsFreeze(inside, 1);
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(outside);
        return 0;
    }
    /*
        Post "onclose" finalization message
     */
    msg->worker = outsideWorker;
    msg->callback = "onclose";
    msg->callbackSlot = ES_Worker_onclose;

    insideWorker->state = EJS_WORKER_CLOSED;
    outsideWorker->state = EJS_WORKER_CLOSED;
    dispatcher = outside->dispatcher;
    mprCreateEvent(dispatcher, "doMessage", 0, (MprEventProc) doMessage, msg, 0);
    return 0;
}


/*
    function terminate(): Void
 */
static EjsObj *workerTerminate(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{    
    if (worker->state == EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has not yet started");
        return 0;
    }
    if (worker->state >= EJS_WORKER_COMPLETE) {
        return 0;
    }
    /*
        Switch to the inside worker if called from outside
     */
    mprAssert(worker->pair && worker->pair->ejs);
    ejs = (!worker->inside) ? worker->pair->ejs : ejs;
    ejs->exiting = 1;
    mprSignalDispatcher(ejs->dispatcher);
    return 0;
}


/*
    function waitForMessage(timeout: Number = -1): Boolean
 */
static EjsBoolean *workerWaitForMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    MprTime     mark;
    MprTime     remaining;
    int         timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]): MAXINT;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime();
    remaining = timeout;

    worker->gotMessage = 0;
    do {
        mprWaitForEvent(ejs->dispatcher, (int) remaining);
        remaining = mprGetRemainingTime(mark, timeout);
    } while (!worker->gotMessage && remaining > 0 && !ejs->exception);

    if (worker->gotMessage) {
        worker->gotMessage = 0;
        return S(true);
    } else {
        return S(true);
    }
}


/*
    WARNING: the inside interpreter owns the exception object. Must fully extract all fields
 */
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception, int throwOutside)
{
    Ejs             *inside;
    EjsString       *str;
    EjsObj          *e;
    MprDispatcher   *dispatcher;
    Message         *msg;

    mprAssert(!worker->inside);
    mprAssert(exception);
    mprAssert(ejs == worker->ejs);

    ejsFreeze(ejs, 1);
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(ejs);
        return;
    }
    msg->worker = worker;
    msg->callback = "onerror";
    msg->callbackSlot = ES_Worker_onerror;
    inside = worker->pair->ejs;
    
    inside->exception = 0;
    str = ejsSerialize(inside, exception, NULL);
    e = ejsDeserialize(ejs, ejsSerialize(inside, exception, NULL));
    inside->exception = exception;

    /*
        Inside interpreter owns the exception object, so must fully extract all exception. 
        Allocate into the outside worker's interpreter.
     */
    if (ejsIsError(inside, exception)) {
        msg->message = ejsGetPropertyByName(ejs, e, EN("message"));
        msg->stack = ejsGetPropertyByName(ejs, e, EN("stack"));
    } else {
        msg->message = e;
        msg->stack = 0;
    }
    if (throwOutside) {
        if (msg->stack) {
            ejsThrowStateError(ejs, "%@\n%@", ejsToString(ejs, msg->message), ejsToString(ejs, msg->stack));
        } else {
            ejsThrowStateError(ejs, "%@", ejsToString(ejs, msg->message));
        }
    }
    dispatcher = ejs->dispatcher;
    mprCreateEvent(dispatcher, "doMessage-error", 0, (MprEventProc) doMessage, msg, 0);
}


EjsWorker *ejsCreateWorker(Ejs *ejs)
{
    return ejsCreateObj(ejs, ST(Worker), 0);
}


static void manageWorker(EjsWorker *worker, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(worker->ejs);
        ejsManagePot(worker, flags);
        mprMark(worker->event);
        mprMark(worker->name);
        mprMark(worker->scriptFile);
        mprMark(worker->scriptLiteral);
        mprMark(worker->pair);

    } else if (flags & MPR_MANAGE_FREE) {
        if (!worker->inside) {
            removeWorker(worker);
        }
        if (worker->pair) {
            if (worker->pair->pair) {
                worker->pair->pair = 0;
            }
            worker->pair = 0;
        }
    }
}


void ejsConfigureWorkerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs", "Worker"), sizeof(EjsWorker), manageWorker, EJS_POT_HELPERS);
    type->mutableInstances = 1;
    ejsSetSpecialType(ejs, S_Worker, type);
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, workerConstructor);
    ejsBindMethod(ejs, type, ES_Worker_exit, workerExit);
    ejsBindMethod(ejs, type, ES_Worker_join, workerJoin);
    ejsBindMethod(ejs, type, ES_Worker_lookup, workerLookup);
    ejsBindMethod(ejs, type, ES_Worker_cloneSelf, workerCloneSelf);
    ejsBindMethod(ejs, prototype, ES_Worker_clone, workerClone);
    ejsBindMethod(ejs, prototype, ES_Worker_eval, workerEval);
    ejsBindMethod(ejs, prototype, ES_Worker_load, workerLoad);
    ejsBindMethod(ejs, prototype, ES_Worker_preload, workerPreload);
    ejsBindMethod(ejs, prototype, ES_Worker_preeval, workerPreeval);
    ejsBindMethod(ejs, prototype, ES_Worker_postMessage, workerPostMessage);
    ejsBindMethod(ejs, prototype, ES_Worker_terminate, workerTerminate);
    ejsBindMethod(ejs, prototype, ES_Worker_waitForMessage, workerWaitForMessage);

    ejsSetSpecial(ejs, S_Event, ejsGetTypeByName(ejs, N("ejs", "Event")));
    ejsSetSpecial(ejs, S_ErrorEvent, ejsGetTypeByName(ejs, N("ejs", "ErrorEvent")));
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsWorker.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsXML.c"
 */
/************************************************************************/

/**
    ejsXML.c - XML type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    XML methods
 */
static EjsObj *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj *xmlToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv);
static EjsObj *xml_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);

static bool allDigitsForXml(EjsString *name);
static bool deepCompare(EjsXML *lhs, EjsXML *rhs);
static ssize readStringData(MprXml *xp, void *data, char *buf, ssize size);
static ssize readFileData(MprXml *xp, void *data, char *buf, ssize size);


static EjsXML *createXml(Ejs *ejs, EjsType *type, int size)
{
    return ejsCreateXML(ejs, 0, N(NULL, NULL), NULL, NULL);
}


static EjsXML *cloneXml(Ejs *ejs, EjsXML *xml, bool deep)
{
    EjsXML  *newXML;

    newXML = ejsCreateObj(ejs, TYPE(xml), 0);
    if (newXML == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    return newXML;
}


/*
    Cast the object operand to a primitive type
 */
static EjsAny *castXml(Ejs *ejs, EjsXML *xml, EjsType *type)
{
    EjsXML      *item;
    EjsObj      *result;
    MprBuf      *buf;

    mprAssert(ejsIsXML(ejs, xml));

    if (type == ST(XMLList)) {
        return xml;
    }

    switch (type->sid) {
    case S_Object:

    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_Number:
        result = castXml(ejs, xml, ST(String));
        return ejsToNumber(ejs, result);

    case S_String:
        if (xml->kind == EJS_XML_ELEMENT) {
            if (xml->elements == 0) {
                return S(empty);
            }
            if (xml->elements && mprGetListLength(xml->elements) == 1) {
                //  TODO - what about PI and comments?
                item = mprGetFirstItem(xml->elements);
                if (item->kind == EJS_XML_TEXT) {
                    return item->value;
                }
            }
        }
        buf = mprCreateBuf(MPR_BUFSIZE, -1);
        if (ejsXMLToString(ejs, buf, xml, -1) < 0) {
            return 0;
        }
        return ejsCreateStringFromAsc(ejs, (char*) buf->start);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


static int deleteXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML      *item;
    bool        removed;
    int         next;

    removed = 0;

    if (qname.name->value[0] == '@') {
        /* @ and @* */
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprAssert(qname.name->value[0] == '@');
                if (qname.name->value[1] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    mprRemoveItemAtPos(xml->attributes, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }

    } else {
        /* name and * */
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                mprAssert(item->qname.name);
                if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                    mprRemoveItemAtPos(xml->elements, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }
    }
    return (removed) ? 0 : EJS_ERR;
}


static EjsObj *getXmlNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) xml->qname.name;
}



/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, nextXmlKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, nextXmlValue, 0, NULL);
}


static int getXmlPropertyCount(Ejs *ejs, EjsXML *xml)
{
    return mprGetListLength(xml->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML      *item, *result, *list;
    int         next, nextList;

    result = 0;

    mprAssert(xml->kind < 5);
    if (isdigit((int) qname.name->value[0]) && allDigitsForXml(qname.name)) {
        /*
            Consider xml as a list with only one entry == xml. Then return the 0'th entry
         */
        return (EjsObj*) xml;
    }

    if (qname.name->value[0] == '@') {
        /* @ and @* */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprAssert(qname.name->value[0] == '@');
                if (qname.name->value[1] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                }
            }
        }

    } else if (qname.name->value[0] == '.') {
        /* Decenders (do ..@ also) */
        result = ejsXMLDescendants(ejs, xml, qname);

    } else {
        /* name and * */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (item->kind == EJS_XML_LIST) {
                    list = item;
                    for (nextList = 0; (item = mprGetNextItem(list->elements, &nextList)) != 0; ) {
                        mprAssert(item->qname.name);
                        if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                            result = ejsAppendToXML(ejs, result, item);
                        }
                    }

                } else if (item->qname.name) {
                    mprAssert(item->qname.name);
                    if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                        result = ejsAppendToXML(ejs, result, item);
                    }
                }
            }
        }
    }
    return (EjsObj*) result;
}


static EjsObj *invokeXmlOperator(Ejs *ejs, EjsXML *lhs, int opcode,  EjsXML *rhs)
{
    EjsObj      *result;

    if ((result = ejsCoerceOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
        return result;
    }
    switch (opcode) {
    case EJS_OP_COMPARE_EQ:
        return (EjsObj*) ejsCreateBoolean(ejs, deepCompare(lhs, rhs));

    case EJS_OP_COMPARE_NE:
        return (EjsObj*) ejsCreateBoolean(ejs, !deepCompare(lhs, rhs));

    default:
        return ejsInvokeOperatorDefault(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs);
    }
}


/*
    Set a property attribute by name.
 */
static int setXmlPropertyAttributeByName(Ejs *ejs, EjsXML *xml, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *attribute, *rp, *xvalue, *lastElt;
    EjsString   *sv;
    EjsName     qn;
    MprChar     *str;
    int         index, last, next;

    /*
        Attribute. If the value is an XML list, convert to a space separated string
     */
    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue) && xvalue->kind == EJS_XML_LIST) {
        str = 0;
        for (next = 0; (elt = mprGetNextItem(xvalue->elements, &next)) != 0; ) {
            sv = (EjsString*) ejsCast(ejs, (EjsObj*) elt, String);
            str = mrejoin(str, NULL, " ", sv->value, NULL);
        }
        value = (EjsObj*) ejsCreateString(ejs, str, -1);

    } else {
        value = ejsCast(ejs, value, String);
    }
    mprAssert(ejsIs(ejs, value, String));

    /*
        Find the first attribute that matches. Delete all other attributes of the same name.
     */
    index = 0;
    if (xml->attributes) {
        lastElt = 0;
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->attributes, &index)) != 0; ) {
            mprAssert(qname.name->value[0] == '@');
            if (wcmp(elt->qname.name->value, &qname.name->value[1]) == 0) {
                if (last >= 0) {
                    rp = mprGetItem(xml->attributes, last);
                    mprRemoveItemAtPos(xml->attributes, last);
                }
                last = index;
                lastElt = elt;
            }
        }
        if (lastElt) {
            /*
                Found a match. So replace its value
             */
            lastElt->value = (EjsString*) value;
            return last;

        } else {
            index = mprGetListLength(xml->attributes);
        }
    }
    //  TODO - namespace work to do here

    /*
        Not found. Create a new attribute node
     */
    mprAssert(ejsIs(ejs, value, String));
    qn.space = NULL;
    qn.name = ejsSubstring(ejs, qname.name, 1, -1);
    attribute = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, qn, xml, (EjsString*) value);
    if (xml->attributes == 0) {
        xml->attributes = mprCreateList(-1, 0);
    }
    mprSetItem(xml->attributes, index, attribute);
    return index;
}


/*
    Create a value node. If the value is an XML node already, we are done. Otherwise, cast the value to a string
    and create a text child node containing the string value.
 */
static EjsXML *createValueNode(Ejs *ejs, EjsXML *elt, EjsObj *value)
{
    EjsXML      *text;
    EjsString   *str;

    if (ejsIsXML(ejs, value)) {
        return (EjsXML*) value;
    }
    if ((str = (EjsString*) ejsCast(ejs, value, String)) == NULL) {
        return 0;
    }
    if (mprGetListLength(elt->elements) == 1) {
        /*
            Update an existing text element
         */
        text = mprGetFirstItem(elt->elements);
        if (text->kind == EJS_XML_TEXT) {
            text->value = str;
            return elt;
        }
    }

    /*
        Create a new text element
     */
    if (str->value && str->value[0] != '\0') {
        text = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, NULL), elt, str);
        elt = ejsAppendToXML(ejs, elt, text);
    }
    return elt;
}


/*
    Set a property by name
    There are 7 kinds of qname's: prop, @att, [prop], *, @*, .name, .@name
 */
static int setXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *xvalue, *rp, *lastElt;
    EjsObj      *originalValue;
    int         index, last;

    last = 0;
    lastElt = 0;

    mprLog(9, "XMLSet %@.%@ = \"%@\"", xml->qname.name, qname.name, ejsCast(ejs, value, String));

    if (isdigit((int) qname.name->value[0]) && allDigitsForXml(qname.name)) {
        ejsThrowTypeError(ejs, "Integer indicies for set are not allowed");
        return EJS_ERR;
    }

    if (xml->kind != EJS_XML_ELEMENT) {
        //  TODO spec requires this -- but why? -- surely throw?
        return 0;
    }

    /*
        Massage the value type.
     */
    originalValue = value;

    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue)) {
        if (xvalue->kind == EJS_XML_LIST) {
            value = (EjsObj*) ejsDeepCopyXML(ejs, xvalue);

        } else if (xvalue->kind == EJS_XML_TEXT || xvalue->kind == EJS_XML_ATTRIBUTE) {
            value = ejsCast(ejs, originalValue, String);

        } else {
            value = (EjsObj*) ejsDeepCopyXML(ejs, xvalue);
        }
    } else {
        value = ejsCast(ejs, value, String);
    }
    if (qname.name->value[0] == '@') {
        return setXmlPropertyAttributeByName(ejs, xml, qname, value);
    }
    /*
        Delete redundant elements by the same name.
     */
    if (xml->elements) {
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->elements, &index)) != 0; ) {
            if (qname.name->value[0] == '*' || (elt->kind == EJS_XML_ELEMENT && elt->qname.name == qname.name)) {
                /*
                    Must remove all redundant elements of the same name except the first one
                 */
                if (last >= 0) {
                    rp = mprGetItem(xml->elements, last);
                    rp->parent = 0;
                    mprRemoveItemAtPos(xml->elements, last);
                }
                last = index;
                lastElt = elt;
            }
        }
    }
    if (xml->elements == 0) {
        //  TODO - need routine to do this centrally so we can control the default number of elements in the list?
        xml->elements = mprCreateList(-1, 0);
    }
    elt = lastElt;
    index = last;

    if (qname.name->value[0] == '*') {
        /*
            Special case when called from XMLList to update the value of an element
         */
        xml = createValueNode(ejs, xml, value);

    } else if (elt == 0) {
        /*
            Not found. New node required.
         */
        elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, qname, xml, NULL);
        if (elt == 0) {
            return 0;
        }
        index = mprGetListLength(xml->elements);
        xml = ejsAppendToXML(ejs, xml, createValueNode(ejs, elt, value));

    } else {
        /*
            Update existing element.
         */
        xml = ejsSetXML(ejs, xml, index, createValueNode(ejs, elt, value));
    }

    if (xml == 0) {
        return EJS_ERR;
    }
    return index;
}


/*
    Deep compare
 */
static bool deepCompare(EjsXML *lhs, EjsXML *rhs)
{
    EjsXML      *l, *r;
    int         i;

    if (lhs == rhs) {
        return 1;
    }
    //  TODO - must compare all the namespaces?
    if (lhs->kind != rhs->kind) {
        return 0;

    } else  if (lhs->qname.name != rhs->qname.name) {
        return 0;

    } else if (mprGetListLength(lhs->attributes) != mprGetListLength(rhs->attributes)) {
        //  TODO - must compare all the attributes
        return 0;

    } else if (mprGetListLength(lhs->elements) != mprGetListLength(rhs->elements)) {
        //  TODO - must compare all the children
        return 0;

    } else if (lhs->value != rhs->value) {
        return 0;

    } else {
        for (i = 0; i < mprGetListLength(lhs->elements); i++) {
            l = mprGetItem(lhs->elements, i);
            r = mprGetItem(rhs->elements, i);
            if (! deepCompare(l, r)) {
                return 0;
            }
        }
    }
    return 1;
}


//  TODO - rename ejsGetXMLDescendants. Check all other names.

EjsXML *ejsXMLDescendants(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML          *item, *result;
    int             next;

    result = ejsCreateXMLList(ejs, xml, qname);
    if (result == 0) {
        return 0;
    }
    if (qname.name->value[0] == '.' && qname.name->value[1] == '@') {
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                if (qname.name->value[2] == '*' || wcmp(item->qname.name->value, &qname.name->value[2]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
#if UNUSED
                } else {
                    result = ejsAppendToXML(ejs, result, ejsXMLDescendants(ejs, item, qname));
#endif
                }
            }
        }
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                result = ejsAppendToXML(ejs, result, ejsXMLDescendants(ejs, item, qname));
            }
        }

    } else {
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (qname.name->value[0] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                } else {
                    result = ejsAppendToXML(ejs, result, ejsXMLDescendants(ejs, item, qname));
                }
            }
        }
    }
    return result;
}


EjsXML *ejsDeepCopyXML(Ejs *ejs, EjsXML *xml)
{
    EjsXML      *root, *elt;
    int         next;

    if (xml == 0) {
        return 0;
    }
    if (xml->kind == EJS_XML_LIST) {
        root = ejsCreateXMLList(ejs, xml->targetObject, xml->targetProperty);
    } else {
        root = ejsCreateXML(ejs, xml->kind, xml->qname, NULL, xml->value);
    }
    if (root == 0) {
        return 0;
    }
    //  TODO - must copy inScopeNamespaces?

    if (xml->attributes) {
        root->attributes = mprCreateList(-1, 0);
        for (next = 0; (elt = (EjsXML*) mprGetNextItem(xml->attributes, &next)) != 0; ) {
            elt = ejsDeepCopyXML(ejs, elt);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->attributes, elt);
            }
        }
    }
    if (xml->elements) {
        root->elements = mprCreateList(-1, 0);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            mprAssert(ejsIsXML(ejs, elt));
            elt = ejsDeepCopyXML(ejs, elt);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->elements, elt);
            }
        }
    }
    if (mprHasMemError(ejs)) {
        return 0;
    }
    return root;
}

/*
    native function XML(value: Object = null)
 */
static EjsObj *xmlConstructor(Ejs *ejs, EjsXML *thisObj, int argc, EjsObj **argv)
{
    EjsObj      *arg, *vp;
    MprChar     *str;

    //  TODO - should be also able to handle a File object

    if (thisObj == 0) {
        /*
            Called as a function - cast the arg
         */
        if (argc > 0){
            if ((arg = ejsCast(ejs, argv[0], String)) == 0) {
                return 0;
            }
        }
        thisObj = ejsCreateXML(ejs, 0, N(NULL, NULL), NULL, NULL);
    }
    if (argc == 0) {
        return (EjsObj*) thisObj;
    }

    arg = argv[0];
    mprAssert(arg);

    if (!ejsIsDefined(ejs, arg)) {
        return (EjsObj*) thisObj;
    }
    arg = ejsCast(ejs, argv[0], String);
    if (arg && ejsIs(ejs, arg, String)) {
        str = ((EjsString*) arg)->value;
        if (str == 0) {
            return 0;
        }
        while (isspace((int) *str)) str++;
        if (*str == '<') {
            /* XML Literal */
            ejsLoadXMLString(ejs, thisObj, (EjsString*) arg);

        } else {
            /* Load from file */
            loadXml(ejs, thisObj, argc, argv);
        }
    } else if (arg && ejsIsXML(ejs, arg)) {
        if ((vp = xmlToString(ejs, argv[0], 0, NULL)) != 0) {
            ejsLoadXMLString(ejs, thisObj, (EjsString*) vp);
        }

    } else {
        ejsThrowArgError(ejs, "Bad type passed to XML constructor");
        return 0;
    }
    return (EjsObj*) thisObj;
}


static EjsObj *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprXml      *xp;
    cchar       *filename;

    mprAssert(argc == 1 && ejsIs(ejs, argv[0], String));

    filename = ejsToMulti(ejs, argv[0]);
    file = mprOpenFile(filename, O_RDONLY, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open: %s", filename);
        return 0;
    }
    //  TODO - convert to open/close
    xp = ejsCreateXmlParser(ejs, xml, filename);
    if (xp == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }
    mprXmlSetInputStream(xp, readFileData, (void*) file);

    if (mprXmlParse(xp) < 0 && !ejsHasException(ejs)) {
        ejsThrowIOError(ejs, "Can't parse XML file: %s\nDetails %s",  filename, mprXmlGetErrorMsg(xp));
    }
    mprCloseFile(file);
    return 0;
}


static EjsObj *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprBuf      *buf;
    MprFile     *file;
    char        *filename;
    ssize       bytes, len;

    if (argc != 1 || !ejsIs(ejs, argv[0], String)) {
        ejsThrowArgError(ejs, "Bad args. Usage: save(filename);");
        return 0;
    }
    filename = awtom(((EjsString*) argv[0])->value, NULL);

    /*
        Create a buffer to hold the output. All in memory.
     */
    buf = mprCreateBuf(MPR_BUFSIZE, -1);
    mprPutStringToBuf(buf, "<?xml version=\"1.0\"?>\n");

    /*
       Convert XML to a string
     */
    if (ejsXMLToString(ejs, buf, xml, 0) < 0) {
        return 0;
    }
    file = mprOpenFile(filename,  O_CREAT | O_TRUNC | O_WRONLY | O_TEXT, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open: %s, %d", filename, mprGetOsError(ejs));
        return 0;
    }
    len = mprGetBufLength(buf);
    bytes = mprWriteFile(file, buf->start, len);
    if (bytes != len) {
        ejsThrowIOError(ejs, "Can't write to: %s", filename);
        mprCloseFile(file);
        return 0;
    }
    mprWriteFile(file, "\n", 1);
    mprCloseFile(file);
    return 0;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsString *xmlToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(-1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsToMulti(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the XML object to a string.

    function toString() : String
 */
static EjsObj *xmlToString(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return (TYPE(obj)->helpers.cast)(ejs, obj, ST(String));
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    public override function get length(): int
 */
static EjsObj *xmlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListLength(xml->elements));
}


#if KEEP
/*
    Set the length. TODO - what does this do?
    public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    int         length;

    mprAssert(ejsIsXML(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, ap, i, S(undefined)) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, ap, length - 1, S(undefined)) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
    return 0;
}
#endif


/*
    function parent(): XML
 */
static EjsObj *xml_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (xml->parent && xml != xml->parent) ? (EjsObj*) xml->parent : (EjsObj*) S(null);
}

/*
    Set an indexed element to an XML value
 */
EjsXML *ejsSetXML(Ejs *ejs, EjsXML *xml, int index, EjsXML *node)
{
    EjsXML      *old;

    if (xml == 0 || node == 0) {
        return 0;
    }
    if (xml->elements == 0) {
        xml->elements = mprCreateList(-1, 0);

    } else {
        old = (EjsXML*) mprGetItem(xml->elements, index);
        if (old && old != node) {
            old->parent = 0;
        }
    }

    if (xml->kind != EJS_XML_LIST) {
        node->parent = xml;
    }
    mprSetItem(xml->elements, index, node);
    return xml;
}


EjsXML *ejsAppendToXML(Ejs *ejs, EjsXML *xml, EjsXML *node)
{
    EjsXML      *elt;
    int         next;

    if (xml == 0 || node == 0) {
        return 0;
    }
    if (xml->elements == 0) {
        xml->elements = mprCreateList(-1, 0);
    }
    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            if (xml->kind != EJS_XML_LIST) {
                elt->parent = xml;
            }
            mprAddItem(xml->elements, elt);
        }
        xml->targetObject = node->targetObject;
        xml->targetProperty = node->targetProperty;

    } else {
        if (xml->kind != EJS_XML_LIST) {
            node->parent = xml;
        }
        mprAddItem(xml->elements, node);
    }
    return xml;
}


int ejsAppendAttributeToXML(Ejs *ejs, EjsXML *parent, EjsXML *node)
{
    if (parent->attributes == 0) {
        parent->attributes = mprCreateList(-1, 0);
    }
    node->parent = parent;
    return mprAddItem(parent->attributes, node);
}


static ssize readFileData(MprXml *xp, void *data, char *buf, ssize size)
{
    mprAssert(xp);
    mprAssert(data);
    mprAssert(buf);
    mprAssert(size > 0);

    return mprReadFile((MprFile*) data, buf, size);
}


static ssize readStringData(MprXml *xp, void *data, char *buf, ssize size)
{
    EjsXmlState *parser;
    ssize       len, rc;

    mprAssert(xp);
    mprAssert(buf);
    mprAssert(size > 0);

    parser = (EjsXmlState*) xp->parseArg;

    if (parser->inputPos < parser->inputSize) {
        len = min(size, (parser->inputSize - parser->inputPos));
        rc = mprMemcpy(buf, size, &parser->inputBuf[parser->inputPos], len);
        parser->inputPos += len;
        return rc;
    }
    return 0;
}


static bool allDigitsForXml(EjsString *name)
{
    MprChar     *cp;

    for (cp = name->value; *cp; cp++) {
        if (!isdigit((int) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}



EjsXML *ejsCreateXML(Ejs *ejs, int kind, EjsName qname, EjsXML *parent, EjsString *value)
{
    EjsXML      *xml;

    if ((xml = (EjsXML*) ejsAlloc(ejs, ST(XML), 0)) == NULL) {
        return 0;
    }
    if (qname.name) {
        xml->qname = qname;
    }
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        xml->value = value;
    }
    return xml;
}


EjsXML *ejsConfigureXML(Ejs *ejs, EjsXML *xml, int kind, EjsString *name, EjsXML *parent, EjsString *value)
{
    xml->qname.name = name;
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        xml->value = value;
    }
    return xml;
}


/*
    Support routine. Not an class method
 */
void ejsLoadXMLString(Ejs *ejs, EjsXML *xml, EjsString *xmlString)
{
    EjsXmlState *parser;
    MprXml      *xp;

    xp = ejsCreateXmlParser(ejs, xml, "string");
    parser = mprXmlGetParseArg(xp);
    parser->inputBuf = ejsToMulti(ejs, xmlString);
    parser->inputSize = slen(parser->inputBuf);
    mprXmlSetInputStream(xp, readStringData, (void*) 0);

    if (mprXmlParse(xp) < 0 && !ejsHasException(ejs)) {
        ejsThrowSyntaxError(ejs, "Can't parse XML string: %s", mprXmlGetErrorMsg(xp));
    }
}


void ejsLoadXMLCString(Ejs *ejs, EjsXML *xml, cchar *xmlString)
{
    ejsLoadXMLString(ejs, xml, ejsCreateStringFromAsc(ejs, xmlString));
}


void ejsManageXML(EjsXML *xml, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(xml->parent);
        mprMark(xml->targetObject);
        mprMark(xml->attributes);
        mprMark(xml->elements);
        mprMark(xml->namespaces);
        mprMark(xml->qname.name);
        mprMark(xml->qname.space);
        mprMark(xml->value);
    }
}


void ejsCreateXMLType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "XML"), sizeof(EjsXML), S_XML, ES_XML_NUM_CLASS_PROP, 
        ejsManageXML, EJS_OBJ_HELPERS);

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->constructor.block.nobind = 1;

    type->helpers.clone = (EjsCloneHelper) cloneXml;
    type->helpers.cast = (EjsCastHelper) castXml;
    type->helpers.create = (EjsCreateHelper) createXml;
    type->helpers.getPropertyByName = (EjsGetPropertyByNameHelper) getXmlPropertyByName;
    type->helpers.getPropertyCount = (EjsGetPropertyCountHelper) getXmlPropertyCount;
    type->helpers.deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlPropertyByName;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeXmlOperator;
    type->helpers.setPropertyByName = (EjsSetPropertyByNameHelper) setXmlPropertyByName;
}


void ejsConfigureXMLType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(XML);
    type->mutableInstances = 1;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, xmlConstructor);
    ejsBindMethod(ejs, prototype, ES_XML_length, xmlLength);
    ejsBindMethod(ejs, prototype, ES_XML_load, loadXml);
    ejsBindMethod(ejs, prototype, ES_XML_save, saveXml);
    ejsBindMethod(ejs, prototype, ES_XML_name, getXmlNodeName);

    ejsBindMethod(ejs, prototype, ES_XML_parent, (EjsNativeFunction) xml_parent);

    /*
        Override these methods
     */
    ejsBindMethod(ejs, prototype, ES_XML_toString, xmlToString);
    ejsBindMethod(ejs, prototype, ES_XML_toJSON, xmlToJson);
    ejsBindMethod(ejs, prototype, ES_XML_iterator_get, getXmlIterator);
    ejsBindMethod(ejs, prototype, ES_XML_iterator_getValues, getXmlValues);
#if FUTURE
    ejsBindMethod(ejs, prototype, ES_XML_parent, parent);
    ejsBindMethod(ejs, prototype, "valueOf", valueOf, NULL);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsXML.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsXMLList.c"
 */
/************************************************************************/

/**
    ejsXMLList.c - XMLList type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    XMLList methods
 */

#if KEEP
static EjsObj   *valueOf(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *xlLength(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *toXmlString(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *appendChild(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *attributes(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *child(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *comments(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *decendants(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildAfter(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildBefore(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *replace(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *setName(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *text(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
#endif

static bool allDigitsForXmlList(EjsString *name);
static EjsXML *resolve(Ejs *ejs, EjsXML *obj);
static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml);


static EjsXML *createXmlListVar(Ejs *ejs, EjsType *type, int size)
{
    return (EjsXML*) ejsCreateXMLList(ejs, NULL, N(NULL, NULL));
}


static EjsObj *cloneXmlList(Ejs *ejs, EjsXML *list, bool deep)
{
    EjsXML  *newList;

    //  TODO - implement deep copy
    newList = ejsCreateObj(ejs, TYPE(list), 0);
    if (newList == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    //  TODO incomplete
    return (EjsObj*) newList;
}


/*
    Cast the object operand to a primitive type
 */
static EjsObj *xlCast(Ejs *ejs, EjsXML *vp, EjsType *type)
{
    MprBuf      *buf;
    EjsObj      *result;
    EjsXML      *elt, *item;
    int         next;

    if (type == ST(XML)) {
        return (EjsObj*) vp;
    }
    switch (type->sid) {
    case S_Object:

    case S_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case S_Number:
        result = xlCast(ejs, vp, ST(String));
        result = (EjsObj*) ejsToNumber(ejs, result);
        return result;

    case S_String:
        buf = mprCreateBuf(MPR_BUFSIZE, -1);
        if (mprGetListLength(vp->elements) == 1) {
            elt = mprGetFirstItem(vp->elements);
            if (elt->kind == EJS_XML_ELEMENT) {
                if (elt->elements == 0) {
                    return (EjsObj*) S(empty);
                }
                if (elt->elements && mprGetListLength(elt->elements) == 1) {
                    //  TODO - what about PI and comments?
                    item = mprGetFirstItem(elt->elements);
                    if (item->kind == EJS_XML_TEXT) {
                        return (EjsObj*) item->value;
                    }
                }
            }
        }
        for (next = 0; (elt = mprGetNextItem(vp->elements, &next)) != 0; ) {
            if (ejsXMLToString(ejs, buf, elt, -1) < 0) {
                return 0;
            }
            if (next < vp->elements->length) {
                mprPutStringToBuf(buf, " ");
            }
        }
        return (EjsObj*) ejsCreateStringFromAsc(ejs, (char*) buf->start);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


//  TODO - seems the return code for delete should be boolean?

static int deleteXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname)
{
    EjsXML      *elt;
    int         index, next;

    if (isdigit((int) qname.name->value[0]) && allDigitsForXmlList(qname.name)) {
        index = ejsAtoi(ejs, qname.name, 10);

        elt = (EjsXML*) mprGetItem(list->elements, index);
        if (elt) {
            if (elt->parent) {
                if (elt->kind == EJS_XML_ATTRIBUTE) {
                    ejsDeletePropertyByName(ejs, (EjsObj*) elt->parent, elt->qname);
                } else {
                    //  TODO - let q be the property of parent where parent[q] == x[i]
                    mprRemoveItem(elt->parent->elements, elt);
                    elt->parent = 0;
                }
            }
        }
        //  Spec says return true even if index is out of range. We return 0 for true and < 0 for false.
        //  TODO - should ejs throw?
        return 0;
    }

    for (next = 0; (elt = mprGetNextItem(list->elements, &next)) != 0; ) {
        if (elt->kind == EJS_XML_ELEMENT /* && elt->parent */) {
            ejsDeletePropertyByName(ejs, (EjsObj*) elt /* TODO was elt->parent */, qname);
        }
    }
    return 0;
}


static int getXmlListPropertyCount(Ejs *ejs, EjsXML *list)
{
    return mprGetListLength(list->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname)
{
    EjsXML      *result, *subList, *item;
    int         nextItem;

    /*
        Get the n'th item in the list
     */
    if (isdigit((int) qname.name->value[0]) && allDigitsForXmlList(qname.name)) {
        return mprGetItem(list->elements, ejsAtoi(ejs, qname.name, 10));
    }

    result = ejsCreateXMLList(ejs, list, qname);

    /*
        Build a list of all the elements that themselves have a property qname
     */
    for (nextItem = 0; (item = mprGetNextItem(list->elements, &nextItem)) != 0; ) {
        if (item->kind == EJS_XML_ELEMENT) {
            subList = ejsGetPropertyByName(ejs, (EjsObj*) item, qname);
            mprAssert(ejsIsXML(ejs, subList));
            ejsAppendToXML(ejs, result, subList);

        } else {
            //  TODO - do we ever get a list in a list?
            mprAssert(0);
        }
    }
    return (EjsObj*) result;
}


static EjsObj *getXmlListNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    if (xml->targetProperty.name) {
        return (EjsObj*) xml->targetProperty.name;
    } else if (xml->targetObject) {
        return (EjsObj*) xml->targetObject->qname.name;
    } else {
        return S(null);
    }
}



/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlListIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, nextXmlListKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlListValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, nextXmlListValue, 0, NULL);
}


#if OLD
/*
    Handle all core operators. We currenly handle only === and !==
    TODO. Must implement: +, -, <, >, <=, >=, ==, ===, !=, !==, &, |
 */
static EjsObj *invokeOperator(Ejs *ejs, EjsXML *lhs, int opCode,  EjsXML *rhs)
{
    EjsObj      *l, *r;
    bool        boolResult;

    mprAssert(ejsIsXML(ejs, lhs));
    mprAssert(ejsIsXML(ejs, rhs));

    //  TODO - Complete
    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = (lhs == rhs);
        break;

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        /*
            Cast to strings and re-invoke
         */
        l = ejsCast(ejs, lhs, String);
        r = ejsCast(ejs, rhs, String);
        return ejsInvokeOperator(ejs, l, opCode, r);
    }
    return (EjsObj*) ejsCreateBoolean(ejs, boolResult);
}
#endif


/*
    Set an alpha property by name.
 */
static int setAlphaPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         count;

    targetObject = 0;

    count = ejsGetPropertyCount(ejs, (EjsObj*) list);
    if (count > 1) {
        //  TODO - why no error in spec?
        mprAssert(0);
        return 0;
    }

    if (count == 0) {
        /*
            Empty list so resolve the real target object and append it to the list.
         */
        targetObject = resolve(ejs, list);
        if (targetObject == 0) {
            return 0;
        }
        if (ejsGetPropertyCount(ejs, (EjsObj*) targetObject) != 1) {
            return 0;
        }
        ejsAppendToXML(ejs, list, targetObject);
    }

    /*
        Update the element
     */
    mprAssert(ejsGetPropertyCount(ejs, (EjsObj*) list) == 1);
    elt = mprGetItem(list->elements, 0);                        //  TODO OPT - GetFirstItem
    mprAssert(elt);
    ejsSetPropertyByName(ejs, elt, qname, value);
    return 0;
}


static EjsXML *createElement(Ejs *ejs, EjsXML *list, EjsXML *targetObject, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *last, *attList;
    int         index;
    int         j;

    if (targetObject && ejsIsXML(ejs, targetObject) && targetObject->kind == EJS_XML_LIST) {

        /*
            If the target is a list it must have 1 element. So switch to it.
            TODO - could we get resolve to do this?
         */
        if (mprGetListLength(targetObject->elements) != 1) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
        targetObject = mprGetFirstItem(targetObject->elements);
    }

    /*
        Return if the target object is not an XML element
     */
    if (!ejsIsXML(ejs, targetObject) || targetObject->kind != EJS_XML_ELEMENT) {
            /* Spec says so - TODO why no error? */
        return 0;
    }

    elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, list->targetProperty, targetObject, NULL);

    if (list->targetProperty.name && list->targetProperty.name->value[0] == '@') {
        elt->kind = EJS_XML_ATTRIBUTE;
        attList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, list->targetProperty);
        if (attList && mprGetListLength(attList->elements) > 0) {
            /* Spec says so. But this surely means you can't update an attribute? */
            return 0;
        }
    } else if (list->targetProperty.name == NULL || qname.name->value[0] == '*') {
        elt->kind = EJS_XML_TEXT;
        elt->qname.name = 0;
    }

    index = mprGetListLength(list->elements);

    if (elt->kind != EJS_XML_ATTRIBUTE) {
        if (targetObject) {
            if (index > 0) {
                /*
                    Find the place of the last list item in the resolved target object.
                 */
                last = mprGetItem(list->elements, index - 1);
                j = mprLookupItem(targetObject->elements, last);
            } else {
                j = -1;
            } 
            if (j < 0) {
                j = mprGetListLength(targetObject->elements) - 1;
            }
            //  TODO - really need to wrap this ejsInsertXML(EjsXML *xml, int index, EjsXML *node)
            if (targetObject->elements == 0) {
                targetObject->elements = mprCreateList(-1, 0);
            }
            /*
                Insert into the target object
             */
            mprInsertItemAtPos(targetObject->elements, j + 1, elt);
        }

        if (ejsIsXML(ejs, value)) {
            if (((EjsXML*) value)->kind == EJS_XML_LIST) {
                elt->qname = ((EjsXML*) value)->targetProperty;
            } else {
                elt->qname = ((EjsXML*) value)->qname;
            }
        }

        /*
            Insert into the XML list
         */
        mprSetItem(list->elements, index, elt);
    }
    return (EjsXML*) mprGetItem(list->elements, index);
}


/*
    Update an existing element
 */
static int updateElement(Ejs *ejs, EjsXML *list, EjsXML *elt, int index, EjsObj *value)
{
    EjsXML      *node;
    int         i, j;

    if (!ejsIsXML(ejs, value)) {
        /* Not XML or XMLList -- convert to string */
        value = ejsCast(ejs, value, String);                //  TODO - seem to be doing this in too many places
    }
    mprSetItem(list->elements, index, value);

    if (elt->kind == EJS_XML_ATTRIBUTE) {
        mprAssert(ejsIs(ejs, value, String));
        i = mprLookupItem(elt->parent->elements, elt);
        mprAssert(i >= 0);
        ejsSetXML(ejs, elt->parent, i, elt);
        //  TODO - why do this. Doesn't above do this?
        ejsSetPropertyByName(ejs, elt->parent, elt->qname, value);
        elt->value = (EjsString*) value;
    }

    if (ejsIsXML(ejs, value) && ((EjsXML*) value)->kind == EJS_XML_LIST) {
        value = (EjsObj*) shallowCopy(ejs, (EjsXML*) value);
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            mprAssert(index >= 0);
            for (j = 0; j < mprGetListLength(((EjsXML*) value)->elements); j++) {
                mprInsertItemAtPos(elt->parent->elements, index, value);
            }
        }

    } else if (ejsIsXML(ejs, value) || elt->kind != EJS_XML_ELEMENT) {
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            mprAssert(index >= 0);
            mprSetItem(elt->parent->elements, index, value);
            ((EjsXML*) value)->parent = elt->parent;
            if (ejsIs(ejs, value, String)) {
                node = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, NULL), list, (EjsString*) value);
                mprSetItem(list->elements, index, node);
            } else {
                mprSetItem(list->elements, index, value);
            }
        }

    } else {
        ejsSetPropertyByName(ejs, elt, N(NULL, "*"), value);
    }
    return index;
}


/*
    Set a property by name.
 */
static int setXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         index;

    if (!isdigit((int) qname.name->value[0])) {
        return setAlphaPropertyByName(ejs, list, qname, value);
    }

    /*
        Numeric property
     */
    targetObject = 0;
    if (list->targetObject) {
        /*
            Find the real underlying target object. May be an XML object or XMLList if it contains multiple elements.
         */
        targetObject = resolve(ejs, list->targetObject);
        if (targetObject == 0) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index >= mprGetListLength(list->elements)) {
        /*
            Create, then fall through to update
         */
        elt = createElement(ejs, list, targetObject, qname, value);
        if (elt == 0) {
            return 0;
        }

    } else {
        elt = mprGetItem(list->elements, index);
    }
    mprAssert(elt);
    updateElement(ejs, list, elt, index, value);
    return index;
}


/*
    function parent(): XML
 */
static EjsObj *xl_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return xml->targetObject ? (EjsObj*) xml->targetObject : (EjsObj*) S(null);
}


static bool allDigitsForXmlList(EjsString *name)
{
    MprChar     *cp;

    for (cp = name->value; *cp; cp++) {
        if (!isdigit((int) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}


static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml)
{
    EjsXML      *root, *elt;
    int         next;

    mprAssert(xml->kind == EJS_XML_LIST);

    if (xml == 0) {
        return 0;
    }
    if ((root = ejsCreateXMLList(ejs, xml->targetObject, xml->targetProperty)) == NULL) {
        return 0;
    }
    if (xml->elements) {
        root->elements = mprCreateList(-1, 0);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            mprAssert(ejsIsXML(ejs, elt));
            if (elt) {
                mprAddItem(root->elements, elt);
            }
        }
    }
    if (mprHasMemError(ejs)) {
        return 0;
    }
    return root;
}


/*
    Resolve empty XML list objects to an actual XML object. This is used by SetPropertyByName to find the actual 
    object to update. This method resolves the value of empty XMLLists. If the XMLList is not empty, the list will 
    be returned. If list is empty, this method attempts to create an element based on the list targetObject and 
    targetProperty.
 */
static EjsXML *resolve(Ejs *ejs, EjsXML *xml)
{
    EjsXML  *targetObject, *targetPropertyList;

    if (!ejsIsXML(ejs, xml) || xml->kind != EJS_XML_LIST) {
        /* Resolved to an XML object */
        return xml;
    }
    if (mprGetListLength(xml->elements) > 0) {
        /* Resolved to a list of items */
        return xml;
    }
    if (xml->targetObject == 0 || xml->targetProperty.name == NULL || xml->targetProperty.name->value[0] == '*') {
        /* End of chain an no more target objects */
        return 0;
    }
    targetObject = resolve(ejs, xml->targetObject);
    if (targetObject == 0) {
        return 0;
    }
    //  TODO - OPT. targetPropertyList is also being created below.
    targetPropertyList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, xml->targetProperty);
    if (targetPropertyList == 0) {
        return 0;
    }
    if (ejsGetPropertyCount(ejs, (EjsObj*) targetPropertyList) == 0) {
        /*
            Property does not exist in the target.
         */
        if (targetObject->kind == EJS_XML_LIST && ejsGetPropertyCount(ejs, (EjsObj*) targetObject) > 1) {
            return 0;
        }
        /*
            Create the property as an element (The text value will be optimized away).
         */
        ejsSetPropertyByName(ejs, targetObject, xml->targetProperty, S(empty));
        targetPropertyList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, xml->targetProperty);
    }
    return targetPropertyList;
}



static EjsObj *xmlListConstructor(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
#if FUTURE
    EjsObj      *vp;
    cchar       *str;

    if (argc == 1) {
        vp = argv[0];

        if (ejsIsObject(vp)) {
            /* Convert DOM to XML. Not implemented */;

        } else if (ejsIs(ejs, vp, String)) {
            str = ((EjsString*) vp)->value;
            if (str == 0) {
                return 0;
            }
            if (*str == '<') {
                /* XML Literal */
                return loadXmlString(ejs, (EjsXML*) thisObj, str);

            } else {
                /* Load from file */
                return load(ejs, (EjsXML*) thisObj, argc, argv);
            }
        } else {
            ejsThrowArgError(ejs, "Bad type passed to XML constructor");
            return 0;
        }
    }
#endif
    return (EjsObj*) thisObj;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsObj *xmlListToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(-1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsToMulti(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the XML object to a string.

    function toString() : String
 */
static EjsObj *xmlListToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (TYPE(vp)->helpers.cast)(ejs, vp, ST(String));
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    public override function get length(): int
 */

static EjsObj *xlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListLength(xml->elements));
}


#if FUTURE
/*
    Set the length. TODO - what does this do?
    public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXMLList *xml, int argc, EjsObj **argv)
{
    int         length;

    mprAssert(ejsIsXMLList(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

#if KEEP
    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, ap, i, S(undefined)) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, ap, length - 1, S(undefined)) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
#endif
    return 0;
}
#endif



EjsXML *ejsCreateXMLList(Ejs *ejs, EjsXML *targetObject, EjsName targetProperty)
{
    EjsXML      *list;

    if ((list = (EjsXML*) ejsAlloc(ejs, ST(XMLList), 0)) == NULL) {
        return 0;
    }
    list->kind = EJS_XML_LIST;
    list->elements = mprCreateList(-1, 0);
    list->targetObject = targetObject;

    if (targetProperty.name) {
        list->targetProperty.name = targetProperty.name;
    }
    return list;
}


void ejsCreateXMLListType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, N("ejs", "XMLList"), sizeof(EjsXML), S_XMLList, ES_XMLList_NUM_CLASS_PROP, 
        ejsManageXML, EJS_OBJ_HELPERS);

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->constructor.block.nobind = 1;

    type->helpers.clone = (EjsCloneHelper) cloneXmlList;
    type->helpers.cast = (EjsCastHelper) xlCast;
    type->helpers.create = (EjsCreateHelper) createXmlListVar;
    type->helpers.getPropertyByName = (EjsGetPropertyByNameHelper) getXmlListPropertyByName;
    type->helpers.getPropertyCount = (EjsGetPropertyCountHelper) getXmlListPropertyCount;
    type->helpers.deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlListPropertyByName;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) ejsInvokeOperatorDefault;
    type->helpers.setPropertyByName = (EjsSetPropertyByNameHelper) setXmlListPropertyByName;
}


void ejsConfigureXMLListType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ST(XMLList);
    type->mutableInstances = 1;
    prototype = type->prototype;

    ejsBindConstructor(ejs, type, xmlListConstructor);
    ejsBindMethod(ejs, prototype, ES_XMLList_length, xlLength);
    ejsBindMethod(ejs, prototype, ES_XMLList_name, getXmlListNodeName);
    ejsBindMethod(ejs, prototype, ES_XMLList_parent, (EjsNativeFunction) xl_parent);
#if FUTURE
    ejsBindMethod(ejs, prototype, "name", name, NULL);
    ejsBindMethod(ejs, prototype, "valueOf", valueOf, NULL);
#endif
    ejsBindMethod(ejs, prototype, ES_XMLList_toJSON, xmlListToJson);
    ejsBindMethod(ejs, prototype, ES_XMLList_toString, xmlListToString);
    ejsBindMethod(ejs, prototype, ES_XMLList_iterator_get, getXmlListIterator);
    ejsBindMethod(ejs, prototype, ES_XMLList_iterator_getValues, getXmlListValues);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsXMLList.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/core/src/ejsXMLLoader.c"
 */
/************************************************************************/

/**
    ejsXMLLoader.c - Load and save XML data.
 *
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void indent(MprBuf *bp, int level);
static int  parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *value);


static void manageXmlParser(EjsXmlState *parser, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(parser->inputBuf);
        mprMark(parser->filename);

    } else if (flags & MPR_MANAGE_FREE) {
    }
}


MprXml *ejsCreateXmlParser(Ejs *ejs, EjsXML *xml, cchar *filename)
{
    EjsXmlState *parser;
    MprXml      *xp;
    
    xp = mprXmlOpen(MPR_BUFSIZE, EJS_XML_BUF_MAX);
    mprAssert(xp);

    /*
        Create the parser stack
     */
    if ((parser = mprAllocObj(EjsXmlState, manageXmlParser)) == 0) {
        return 0;
    }
    parser->ejs = ejs;
    parser->nodeStack[0].obj = xml;
    
    //  TODO - these 2 are not really needed. Can use ejs->
    parser->xmlType = ST(XML);
    parser->xmlListType = ST(XMLList);
    parser->filename = filename;

    mprXmlSetParseArg(xp, parser);
    mprXmlSetParserHandler(xp, parserHandler);
    return xp;
}


/*
    XML parsing callback. Called for each elt and attribute/value pair. 
    For speed, we handcraft the object model here rather than calling 
    putXmlProperty.
 *
    "<!-- txt -->"      parserHandler(, , MPR_XML_COMMENT);
    "<elt"              parserHandler(, , MPR_XML_NEW_ELT);
    "...att=value"      parserHandler(, , MPR_XML_NEW_ATT);
    "<elt ...>"         parserHandler(, , MPR_XML_ELT_DEFINED);
    "<elt/>"            parserHandler(, , MPR_XML_SOLO_ELT_DEFINED);
    "<elt> ...<"        parserHandler(, , MPR_XML_ELT_DATA);
    "...</elt>"         parserHandler(, , MPR_XML_END_ELT);
 *
    Note: we recurse on every new nested elt.
 */

static int parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *str)
{
    Ejs             *ejs;
    EjsXmlState     *parser;
    EjsXmlTagState  *tos;
    EjsString       *value;
    EjsXML          *xml, *node, *parent;

    parser = (EjsXmlState*) xp->parseArg;
    ejs = parser->ejs;
    tos = &parser->nodeStack[parser->topOfStack];
    xml = tos->obj;
    value = ejsCreateStringFromAsc(ejs, str);
    
    mprAssert(xml);

    mprAssert(state >= 0);
    mprAssert(tagName && *tagName);

    switch (state) {
    case MPR_XML_PI:
        node = ejsCreateXML(ejs, EJS_XML_PROCESSING, N(NULL, NULL), xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_COMMENT:
        node = ejsCreateXML(ejs, EJS_XML_COMMENT, N(NULL, NULL), xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_NEW_ELT:
        if (parser->topOfStack > EJS_XML_MAX_NODE_DEPTH) {
            ejsThrowSyntaxError(ejs,  "XML nodes nested too deeply in %s at line %d", parser->filename, 
                mprXmlGetLineNumber(xp));
            return MPR_ERR_BAD_SYNTAX;
        }
        if (xml->kind <= 0) {
            ejsConfigureXML(ejs, xml, EJS_XML_ELEMENT, ejsCreateStringFromAsc(ejs, tagName), xml, NULL);
        } else {
            xml = ejsCreateXML(ejs, EJS_XML_ELEMENT, N(NULL, tagName), xml, NULL);
            tos = &parser->nodeStack[++(parser->topOfStack)];
            tos->obj = (EjsXML*) xml;
            tos->attributes = 0;
            tos->comments = 0;
        }
        break;

    case MPR_XML_NEW_ATT:
        node = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, N(NULL, attName), xml, value);
        //  TODO - rc
        ejsAppendAttributeToXML(ejs, xml, node);
        //  TODO RC
        break;

    case MPR_XML_SOLO_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
            parser->topOfStack--;
            mprAssert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    case MPR_XML_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
        }
        break;

    case MPR_XML_ELT_DATA:
    case MPR_XML_CDATA:
        node = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, attName), xml, value);
        //  TODO - rc
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_END_ELT:
        /*
            This is the closing element in a pair "<x>...</x>".
            Pop the stack frame off the elt stack
         */
        if (parser->topOfStack > 0) {
            parser->topOfStack--;
            mprAssert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    default:
        ejsThrowSyntaxError(ejs, "XML error in %s at %d\nDetails %s", parser->filename, mprXmlGetLineNumber(xp), 
            mprXmlGetErrorMsg(xp));
        mprAssert(0);
        return MPR_ERR_BAD_SYNTAX;
    }
    return 0;
}


#if KEEP
static bool checkTagName(char *name)
{
    char    *cp;

    for (cp = name; *cp; cp++) {
        if (!isalnum(*cp) && *cp != '_' && *cp != '$' && *cp != '@') {
            return 0;
        }
    }
    return 1;
}
#endif


int ejsXMLToString(Ejs *ejs, MprBuf *buf, EjsXML *node, int indentLevel)
{
    EjsXML      *xml, *child, *attribute, *elt;
    int         sawElements, next;
    
    if (VISITED(node)) {
        return 0;
    }
    SET_VISITED(node, 1);

    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            ejsXMLToString(ejs, buf, elt, indentLevel);
        }
        return 0;
    }
    mprAssert(ejsIsXML(ejs, node));
    xml = (EjsXML*) node;
    
    switch (xml->kind) {
    case EJS_XML_ELEMENT:
        /*
            XML object is complex (has elements) so return full XML content.
         */
        if (indentLevel > 0) {
            mprPutCharToBuf(buf, '\n');
        }
        indent(buf, indentLevel);

        mprPutFmtToBuf(buf, "<%@", xml->qname.name);
        if (xml->attributes) {
            for (next = 0; (attribute = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprPutFmtToBuf(buf, " %@=\"%@\"",  attribute->qname.name, attribute->value);
            }
        }
        
        sawElements = 0;
        if (xml->elements) {
            mprPutStringToBuf(buf, ">"); 
            for (next = 0; (child = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (child->kind != EJS_XML_TEXT) {
                    sawElements++;
                }
    
                /* Recurse */
                if (ejsXMLToString(ejs, buf, child, indentLevel < 0 ? -1 : indentLevel + 1) < 0) {
                    return -1;
                }
            }
            if (sawElements && indentLevel >= 0) {
                mprPutCharToBuf(buf, '\n');
                indent(buf, indentLevel);
            }
            mprPutFmtToBuf(buf, "</%@>", xml->qname.name);
            
        } else {
            /* Solo */
            mprPutStringToBuf(buf, "/>");
        }
        break;
        
    case EJS_XML_COMMENT:
        mprPutCharToBuf(buf, '\n');
        indent(buf, indentLevel);
        mprPutFmtToBuf(buf, "<!--%@ -->", xml->value);
        break;
        
    case EJS_XML_ATTRIBUTE:
        /*
            Only here when converting solo attributes to a string
         */
        mprPutStringToBuf(buf, ejsToMulti(ejs, xml->value));
        break;
        
    case EJS_XML_TEXT:
        mprPutStringToBuf(buf, ejsToMulti(ejs, xml->value));
        break;
    }
    SET_VISITED(node, 0);
    return 0;
}


static void indent(MprBuf *bp, int level)
{
    int     i;

    for (i = 0; i < level; i++) {
        mprPutCharToBuf(bp, '\t');
    }
}


/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/core/src/ejsXMLLoader.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsByteCode.c"
 */
/************************************************************************/

/**
    ejsByteCode.c - Definition of the byte code table.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/*
    This will define an instance of the EjsOptable which is defined in ejsByteCodeTable.h
 */
#define EJS_DEFINE_OPTABLE 1


EjsOptable *ejsGetOptable()
{
    return ejsOptable;
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsByteCode.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsException.c"
 */
/************************************************************************/

/**
    ejsException.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



static uchar trapByteCode[] = { EJS_OP_ATTENTION };

/*
    Redirect the VM to the ATTENTION op code
 */
void ejsAttention(Ejs *ejs)
{
    EjsFrame    *frame;
    uchar       *pc;

    frame = ejs->state->fp;
    if (frame && frame->attentionPc == 0) {
        /*
            Order matters. Setting the pc to the trap byte code will redirect the VM to the ATTENTION op code which
            will call mprLock(ejs->mutex) preventing a race here.
         */
        pc = frame->pc;
        frame->pc = trapByteCode;
        frame->attentionPc = pc;
    }
}


void ejsClearAttention(Ejs *ejs)
{
    EjsFrame    *frame;

    frame = ejs->state->fp;

    if (ejs->exception == 0 && frame && frame->attentionPc) {
        frame->pc = frame->attentionPc;
        frame->attentionPc = 0;
        mprAssert(frame->pc);
    }
}


EjsAny *ejsThrowException(Ejs *ejs, EjsAny *error)
{
    mprAssert(error);

    ejs->exception = error;
    ejsAttention(ejs);
    return error;
}


void ejsClearException(Ejs *ejs)
{
    ejs->exception = 0;
    if (ejs->state->fp) {
        ejsClearAttention(ejs);
    }
}


static EjsAny *createException(Ejs *ejs, EjsType *type, cchar* fmt, va_list fmtArgs)
{
    EjsError    *error;
    EjsAny      *argv[1];
    char        *msg;

    mprAssert(type);

    msg = mprAsprintfv(fmt, fmtArgs);
    argv[0] = ejsCreateStringFromAsc(ejs, msg);
    if (argv[0] == 0) {
        mprAssert(argv[0]);
        return 0;
    }
    if (ST(Error)->constructor.body.proc) {
        error = (EjsError*) ejsCreateInstance(ejs, type, 1, argv);
    } else {
        error = ejsCreatePot(ejs, type, 0);
        ejsSetProperty(ejs, error, ES_Error_message, ejsCreateStringFromAsc(ejs, msg));
    }
    return error;
}


EjsAny *ejsCreateException(Ejs *ejs, int slot, cchar *fmt, va_list fmtArgs)
{
    EjsType     *type;
    EjsAny      *error;

    if (ejs->exception) {
        mprError("Double exception: %s", mprAsprintfv(fmt, fmtArgs));
        return ejs->exception;
    }
    type = (ejs->initialized) ? ejsGetProperty(ejs, ejs->global, slot) : NULL;
    if (type == 0) {
        type = ST(Error);
    }
    error = createException(ejs, type, fmt, fmtArgs);
    if (error) {
        ejsThrowException(ejs, error);
    }
    return error;
}


EjsError *ejsThrowArgError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArgError, fmt, fmtArgs);
}


EjsError *ejsThrowArithmeticError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArithmeticError, fmt, fmtArgs);
}


EjsError *ejsThrowAssertError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_AssertError, fmt, fmtArgs);
}


EjsError *ejsThrowInstructionError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InstructionError, fmt, fmtArgs);
}


EjsError *ejsThrowError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_Error, fmt, fmtArgs);
}


EjsError *ejsThrowIOError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_IOError, fmt, fmtArgs);
}


EjsError *ejsThrowInternalError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InternalError, fmt, fmtArgs);
}


EjsError *ejsThrowMemoryError(Ejs *ejs)
{
    /*
        Don't do double exceptions for memory errors
     */
    if (ejs->exception == 0) {
        va_list dummy = NULL_INIT;
        return ejsCreateException(ejs, ES_MemoryError, "Memory Error", dummy);
    }
    return (EjsError*) ejs->exception;
}


EjsError *ejsThrowOutOfBoundsError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_OutOfBoundsError, fmt, fmtArgs);
}


EjsError *ejsThrowReferenceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ReferenceError, fmt, fmtArgs);
}


EjsError *ejsThrowResourceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ResourceError, fmt, fmtArgs);
}


EjsString *ejsThrowString(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;
    char        *msg;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    msg = mprAsprintfv(fmt, fmtArgs);
    va_end(fmtArgs);

    /*
        Throwing a string will not create a stack frame
     */
    ejs->exception = ejsCreateStringFromAsc(ejs, msg);
    ejsAttention(ejs);
    return ejs->exception;
}


EjsError *ejsThrowStateError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_StateError, fmt, fmtArgs);
}


EjsError *ejsThrowSyntaxError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_SyntaxError, fmt, fmtArgs);
}


EjsError *ejsThrowTypeError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_TypeError, fmt, fmtArgs);
}


EjsArray *ejsCaptureStack(Ejs *ejs, int uplevels)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsArray        *stack;
    MprChar         *source;
    EjsObj          *frame;
    char            *filename;
    int             index, lineNumber;

    mprAssert(ejs);

    stack = ejsCreateArray(ejs, 0);
    index = 0;
    for (state = ejs->state; state; state = state->prev) {
        for (fp = state->fp; fp; fp = fp->caller) {
            if (uplevels-- <= 0) {
                frame = ejsCreateEmptyPot(ejs);
                if (ejsGetDebugInfo(ejs, (EjsFunction*) fp, fp->pc, &filename, &lineNumber, &source) >= 0) {
                    ejsSetPropertyByName(ejs, frame, EN("filename"), ejsCreatePathFromAsc(ejs, filename));
                    ejsSetPropertyByName(ejs, frame, EN("lineno"), ejsCreateNumber(ejs, lineNumber));
                    ejsSetPropertyByName(ejs, frame, EN("code"), ejsCreateString(ejs, source, wlen(source)));
                } else {
                    ejsSetPropertyByName(ejs, frame, EN("filename"), ST(undefined));
                }
                ejsSetPropertyByName(ejs, frame, EN("func"), fp->function.name);
                ejsSetProperty(ejs, stack, index++, frame);
            }
        }
    }
    return stack;
}


/*
    Get the current exception error. May be an Error object or may be any other object that is thrown.
    Caller must NOT free.
 */
cchar *ejsGetErrorMsg(Ejs *ejs, int withStack)
{
    EjsString   *str, *tag, *msg, *message;
    EjsAny      *stack, *error, *saveException;
    char        *buf, *stackStr;

    error = ejs->exception;
    message = 0;
    stack = 0;
    tag = NULL;

    if (error) {
        tag = TYPE(error)->qname.name;
        if (ejsIs(ejs, error, Error)) {
            message = ejsGetProperty(ejs, error, ES_Error_message);
            if (withStack && ejs->initialized) {
                saveException = ejs->exception;
                ejsClearException(ejs);
                stack = ejsRunFunctionBySlot(ejs, error, ES_Error_formatStack, 0, NULL);
                ejs->exception = saveException;
            }

        } else if (ejsIs(ejs, error, String)) {
            tag = ejsCreateStringFromAsc(ejs, "Error");
            message = (EjsString*) error;

        } else if (ejsIs(ejs, error, Number)) {
            tag = ejsCreateStringFromAsc(ejs, "Error");
            message = (EjsString*) error;
            
        } else if (error == ST(StopIteration)) {
            message = ejsCreateStringFromAsc(ejs, "Uncaught StopIteration exception");
        }
    }
    if (message == S(null) || message == 0) {
        msg = ejsCreateStringFromAsc(ejs, "Exception");
    } else{
        msg = ejsToString(ejs, message);
    }
    if (ejsIs(ejs, error, Error)) {
        stackStr = (stack) ? ejsToMulti(ejs, stack) : 0;
        if (stackStr && *stackStr) {
            buf = mprAsprintf("%@: %@\nStack:\n%s", tag, msg, (stack) ? ejsToMulti(ejs, stack) : "");
        } else {
            buf = mprAsprintf("%@: %@", tag, msg);
        }

    } else if (message && ejsIs(ejs, message, String)){
        buf = mprAsprintf("%@: %@", tag, msg);

    } else if (message && ejsIs(ejs, message, Number)){
        buf = mprAsprintf("%@: %g", tag, ((EjsNumber*) msg)->value);
        
    } else if (error) {
        EjsObj *saveException = ejs->exception;
        ejs->exception = 0;
        str = ejsToString(ejs, error);
        buf = sclone(ejsToMulti(ejs, str));
        ejs->exception = saveException;

    } else {
        buf = sclone("");
    }
    ejs->errorMsg = buf;
    return buf;
}


bool ejsHasException(Ejs *ejs)
{
    return ejs->exception != 0;
}


EjsObj *ejsGetException(Ejs *ejs)
{
    return ejs->exception;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsException.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsHelper.c"
 */
/************************************************************************/

/**
    ejsHelper.c - Helper methods for types.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static MprNumber parseNumber(Ejs *ejs, MprChar *str);
static bool      parseBoolean(Ejs *ejs, MprChar *s);


static int acount;

EjsAny *ejsAlloc(Ejs *ejs, EjsType *type, ssize extra)
{
    EjsObj      *vp;

    mprAssert(type);
    mprAssert(extra >= 0);

    //  OPT could have dedicated ejsAlloc as a macro when assign is zero
    if ((vp = mprAllocBlock(type->instanceSize + extra, MPR_ALLOC_MANAGER | MPR_ALLOC_ZERO)) == NULL) {
        return NULL;
    }
    //  OPT can do direct assign
    SET_TYPE(vp, type);
    ejsSetMemRef(vp);
    mprAssert(type->manager);
    //  OPT inline here
    mprSetManager(vp, type->manager);
    acount++;
    return vp;
}


/**
    Cast the variable to a given target type.
    @return Returns a variable with the result of the cast or null if an exception is thrown.
 */
EjsAny *ejsCastType(Ejs *ejs, EjsAny *vp, EjsType *targetType)
{
    EjsType     *type;

    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(targetType);

    type = TYPE(vp);
    if (type == targetType) {
        return vp;
    }
    if (type->helpers.cast) {
        return (type->helpers.cast)(ejs, vp, targetType);
    }
    ejsThrowInternalError(ejs, "Cast helper not defined for type \"%@\"", type->qname.name);
    return 0;
}


/*
    Create a new instance of an object. Delegate to the type specific create.
 */
EjsAny *ejsCreateObj(Ejs *ejs, EjsType *type, int numSlots)
{
#if VXWORKS
    /*
     *  The VxWorks cc386 invoked linker crashes without this test. Ugh!
     */
    if (type == 0) {
        return 0;
    }
#endif
    mprAssert(type->helpers.create);
    return (type->helpers.create)(ejs, type, numSlots);
}

int cloneCopy = 0;
int cloneRef = 0;

/**
    Copy a variable by copying all properties. If a property is a reference  type, just copy the reference.
    See ejsDeepClone for a complete recursive copy of all reference contents.
    @return Returns a variable or null if an exception is thrown.
 */
EjsAny *ejsClone(Ejs *ejs, EjsAny *src, bool deep)
{
    EjsAny      *dest;
    EjsType     *type;
    
    if (src == 0) {
        return 0;
    }
cloneCopy++;
    mprAssert(TYPE(src)->helpers.clone);
    if (VISITED(src) == 0) {
        type = TYPE(src);
        SET_VISITED(src, 1);
        dest = (TYPE(src)->helpers.clone)(ejs, src, deep);
        SET_VISITED(src, 0);
        SET_VISITED(dest, 0);
    } else {
        dest = src;
    }
    return dest;
}


/*
    Define a property and its traits.
    @return Return the slot number allocated for the property.
 */
int ejsDefineProperty(Ejs *ejs, EjsAny *vp, int slotNum, EjsName name, EjsType *propType, int64 attributes, EjsAny *value)
{
    mprAssert(name.name);
    mprAssert(name.space);

    return (TYPE(vp)->helpers.defineProperty)(ejs, vp, slotNum, name, propType, attributes, value);
}


/**
    Delete a property in a value
    @return Returns a status code.
 */
int ejsDeleteProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    mprAssert(slotNum >= 0);
    
    type = TYPE(vp);
    mprAssert(type->helpers.deleteProperty);
    return (type->helpers.deleteProperty)(ejs, vp, slotNum);
}


/**
    Delete a property
    @return Returns a status code.
 */
int ejsDeletePropertyByName(Ejs *ejs, EjsAny *vp, EjsName qname)
{
    EjsLookup   lookup;
    int         slotNum;

    mprAssert(qname.name);
    mprAssert(qname.space);
    
    if (TYPE(vp)->helpers.deletePropertyByName) {
        return (TYPE(vp)->helpers.deletePropertyByName)(ejs, vp, qname);
    } else {
        slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
        if (slotNum < 0) {
            ejsThrowReferenceError(ejs, "Property \"%@\" does not exist", qname.name);
            return 0;
        }
        return ejsDeleteProperty(ejs, vp, slotNum);
    }
}


/**
    Get a property at a given slot in a variable.
    @return Returns the requested property varaible.
 */
void *ejsGetProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    mprAssert(ejs);
    mprAssert(vp);

    type = TYPE(vp);
    mprAssert(type->helpers.getProperty);
    return (type->helpers.getProperty)(ejs, vp, slotNum);
}


void *ejsGetPropertyByName(Ejs *ejs, EjsAny *vp, EjsName name)
{
    EjsType     *type;
    int         slotNum;

    mprAssert(ejs);
    mprAssert(vp);

    type = TYPE(vp);

    /*
        WARNING: this is not implemented by most types
     */
    if (type->helpers.getPropertyByName) {
        return (type->helpers.getPropertyByName)(ejs, vp, name);
    }

    /*
        Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, name);
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, vp, slotNum);
}


EjsTrait *ejsGetPropertyTraits(Ejs *ejs, EjsAny *vp, int slotNum)
{
    mprAssert(TYPE(vp)->helpers.getPropertyTraits);
    return (TYPE(vp)->helpers.getPropertyTraits)(ejs, vp, slotNum);
}


/**
    Return the number of properties in the variable.
    @return Returns the number of properties.
 */
int ejsGetLength(Ejs *ejs, EjsAny *vp)
{
    mprAssert(TYPE(vp)->helpers.getPropertyCount);
    return (TYPE(vp)->helpers.getPropertyCount)(ejs, vp);
}


/**
    Return the name of a property indexed by slotNum.
    @return Returns the property name.
 */
EjsName ejsGetPropertyName(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    type = TYPE(vp);
    mprAssert(type->helpers.getPropertyName);
    return (type->helpers.getPropertyName)(ejs, vp, slotNum);
}


int ejsPropertyHasTrait(Ejs *ejs, EjsAny *vp, int slotNum, int attributes)
{
    EjsTrait    *trait;

    mprAssert((attributes & EJS_TRAIT_MASK) == attributes);

    if ((trait = ejsGetPropertyTraits(ejs, vp, slotNum)) != 0) {
        return trait->attributes & attributes;
    }
    return 0;
}


/**
    Get a property slot. Lookup a property name and return the slot reference. If a namespace is supplied, the property
    must be defined with the same namespace.
    @return Returns the slot number or -1 if it does not exist.
 */
int ejsLookupProperty(Ejs *ejs, EjsAny *vp, EjsName name)
{
    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(name.name);

    mprAssert(TYPE(vp)->helpers.lookupProperty);
    return (TYPE(vp)->helpers.lookupProperty)(ejs, vp, name);
}


/*
    Invoke an operator.
    vp is left-hand-side
    @return Return a variable with the result or null if an exception is thrown.
 */
EjsAny *ejsInvokeOperator(Ejs *ejs, EjsAny *vp, int opCode, EjsAny *rhs)
{
    mprAssert(vp);

    mprAssert(TYPE(vp)->helpers.invokeOperator);
    return (TYPE(vp)->helpers.invokeOperator)(ejs, vp, opCode, rhs);
}


/*
    Set a property and return the slot number. Incoming slot may be -1 to allocate a new slot.
 */
int ejsSetProperty(Ejs *ejs, EjsAny *vp, int slotNum, EjsAny *value)
{
    mprAssert(vp);

    mprAssert(TYPE(vp)->helpers.setProperty);
    return (TYPE(vp)->helpers.setProperty)(ejs, vp, slotNum, value);
}


/*
    Set a property given a name.
 */
int ejsSetPropertyByName(Ejs *ejs, EjsAny *vp, EjsName qname, EjsAny *value)
{
    int     slotNum;

    mprAssert(ejs);
    mprAssert(vp);

    /*
        WARNING: Not all types implement this
     */
    if (TYPE(vp)->helpers.setPropertyByName) {
        return (TYPE(vp)->helpers.setPropertyByName)(ejs, vp, qname, value);
    }

    /*
        Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, qname);
    if (slotNum < 0) {
        slotNum = ejsSetProperty(ejs, vp, -1, value);
        if (slotNum < 0) {
            return EJS_ERR;
        }
        if (ejsSetPropertyName(ejs, vp, slotNum, qname) < 0) {
            return EJS_ERR;
        }
        //  UNICODE
#if BLD_DEBUG
        if (((EjsObj*) value)->mem == 0) {
            mprSetName(value, qname.name->value);
        }
#endif
        return slotNum;
    }
    return ejsSetProperty(ejs, vp, slotNum, value);
}


/*
    Set the property name and return the slot number. Slot may be -1 to allocate a new slot.
 */
int ejsSetPropertyName(Ejs *ejs, EjsAny *vp, int slot, EjsName qname)
{
    mprAssert(TYPE(vp)->helpers.setPropertyName);
    return (TYPE(vp)->helpers.setPropertyName)(ejs, vp, slot, qname);
}


int ejsSetPropertyTraits(Ejs *ejs, EjsAny *vp, int slot, EjsType *type, int attributes)
{
    mprAssert(TYPE(vp)->helpers.setPropertyTraits);
    return (TYPE(vp)->helpers.setPropertyTraits)(ejs, vp, slot, type, attributes);
}


/**
    Get a string representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsString *ejsToString(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, String)) {
        return (EjsString*) vp;
    }
    return ejsCast(ejs, vp, String);
}


/**
    Get a numeric representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsNumber *ejsToNumber(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Number)) {
        return (EjsNumber*) vp;
    }
    if (TYPE(vp)->helpers.cast) {
        return (TYPE(vp)->helpers.cast)(ejs, vp, ST(Number));
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%@\"", TYPE(vp)->qname.name);
    return 0;
}


/**
    Get a boolean representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsBoolean *ejsToBoolean(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Boolean)) {
        return (EjsBoolean*) vp;
    }
    if (TYPE(vp)->helpers.cast) {
        return (TYPE(vp)->helpers.cast)(ejs, vp, ST(Boolean));
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%@\"", TYPE(vp)->qname.name);
    return 0;
}


/**
    Get a Path representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsPath *ejsToPath(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Path)) {
        return (EjsPath*) vp;
    }
    return ejsCast(ejs, vp, Path);
}


/**
    Get a Uri representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsUri *ejsToUri(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Uri)) {
        return (EjsUri*) vp;
    }
    return ejsCast(ejs, vp, Uri);
}


/*
    Fully construct a new object. We create a new instance and call all required constructors.
 */
EjsAny *ejsCreateInstance(Ejs *ejs, EjsType *type, int argc, void *argv)
{
    EjsAny  *vp;

    mprAssert(type);

    vp = ejsCreateObj(ejs, type, 0);
    if (vp == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (type->constructor.block.pot.isFunction) {
        ejsRunFunction(ejs, (EjsFunction*) type, vp, argc, argv);
    }
    return vp;
}



static void missingHelper(Ejs *ejs, EjsObj *obj, cchar *helper) 
{
    EjsType     *type;

    type = TYPE(obj);
    ejsThrowInternalError(ejs, "The \"%s\" helper is not defined for this type \"%@\"", helper, type->qname.name);
}


static EjsAny *castObj(Ejs *ejs, EjsObj *obj, EjsType *type)
{
    EjsString       *str;
    EjsFunction     *fun;
    EjsObj          *result;
    EjsLookup       lookup;
    
    mprAssert(ejsIsType(ejs, type));

    if (type->hasMeta) {
        return ejsRunFunctionByName(ejs, type, N(EJS_META_NAMESPACE, "cast"), type, 1, &obj);
    }
    switch (type->sid) {
    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_Number:
        str = ejsToString(ejs, obj);
        if (str == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        return ejsParse(ejs, str->value, S_Number);

    case S_String:
        if (!ejsIsType(ejs, obj) && !ejsIsPrototype(ejs, obj)) {
            if (ejsLookupVar(ejs, obj, EN("toString"), &lookup) >= 0 && lookup.obj != ST(Object)->prototype) {
                fun = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
                if (fun && ejsIsFunction(ejs, fun) && fun->body.proc != (EjsFun) ejsObjToString) {
                    result = ejsRunFunction(ejs, fun, obj, 0, NULL);
                    return result;
                }
            }
        }
        if (obj == ejs->global) {
            return ejsCreateStringFromAsc(ejs, "[object global]");
        } else {
            if (TYPE(obj)->helpers.cast && TYPE(obj)->helpers.cast != (EjsCastHelper) castObj) {
                return (TYPE(obj)->helpers.cast)(ejs, obj, type);
            }
            return ejsSprintf(ejs, "[object %@]", TYPE(obj)->qname.name);
        }

    default:
        if (ejsIsA(ejs, obj, type)) {
            return obj;
        }
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsObj *cloneObj(Ejs *ejs, EjsObj *obj, bool deep)
{
    return obj;
}


/*
    Cast the operands depending on the operation code
 */
EjsAny *ejsCoerceOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, S(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ:  case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? S(false): S(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return S(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    /* Unary operators */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return S(undefined);
    }
    return 0;
}


EjsAny *ejsInvokeOperatorDefault(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = ejsCoerceOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }
    /* Types now match */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /* Unary operators */

    case EJS_OP_COMPARE_NOT_ZERO:
        return S(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return S(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return S(one);

    /* Binary operators */

    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL:
    case EJS_OP_REM: case EJS_OP_OR: case EJS_OP_SHL: case EJS_OP_SHR:
    case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, ejsToNumber(ejs, rhs));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    mprAssert(0);
}


static int defineProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsName qname, EjsType *propType, int64 attributes, 
    EjsObj *value)
{
    missingHelper(ejs, obj, "defineProperty");
    return MPR_ERR_BAD_STATE;
}


static int deleteProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    missingHelper(ejs, obj, "deleteProperty");
    return MPR_ERR_BAD_STATE;
}


static int deletePropertyByName(Ejs *ejs, EjsObj *obj, EjsName qname)
{
    missingHelper(ejs, obj, "deletePropertyByName");
    return MPR_ERR_BAD_STATE;
}


static EjsObj *getProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    if (obj == 0 || obj == S(null) || obj == S(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return NULL;
    }
    return NULL;
}


static int getPropertyCount(Ejs *ejs, EjsObj *obj)
{
    return 0;
}


static EjsName getPropertyName(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsName     qname;

    qname.name = 0;
    qname.space = 0;
    return qname;
}


static EjsTrait *getPropertyTraits(Ejs *ejs, EjsAny *vp, int slotNum)
{
    return 0;
}


static int lookupProperty(struct Ejs *ejs, EjsObj *obj, EjsName qname)
{
    return -1;
}


static int setProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsObj *value)
{
    if (obj == 0 || obj == S(null) || obj == S(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setProperty");
    return MPR_ERR_BAD_STATE;
}


static int setPropertyName(Ejs *ejs, EjsObj *obj, int slotNum, EjsName qname)
{
    if (obj == 0 || obj == S(null) || obj == S(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setPropertyName");
    return MPR_ERR_BAD_STATE;
}


static int setPropertyTraits(Ejs *ejs, EjsObj *obj, int slot, EjsType *type, int attributes)
{
    if (obj == 0 || obj == S(null) || obj == S(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setPropertyTraits");
    return MPR_ERR_BAD_STATE;
}


void ejsCreateObjHelpers(Ejs *ejs)
{
    EjsHelpers      *helpers;

    helpers = &ejs->objHelpers;
    helpers->cast                   = (EjsCastHelper) castObj;
    helpers->clone                  = (EjsCloneHelper) cloneObj;
    helpers->create                 = (EjsCreateHelper) ejsAlloc;
    helpers->defineProperty         = (EjsDefinePropertyHelper) defineProperty;
    helpers->deleteProperty         = (EjsDeletePropertyHelper) deleteProperty;
    helpers->deletePropertyByName   = (EjsDeletePropertyByNameHelper) deletePropertyByName;
    helpers->getProperty            = (EjsGetPropertyHelper) getProperty;
    helpers->getPropertyCount       = (EjsGetPropertyCountHelper) getPropertyCount;
    helpers->getPropertyName        = (EjsGetPropertyNameHelper) getPropertyName;
    helpers->getPropertyTraits      = (EjsGetPropertyTraitsHelper) getPropertyTraits;
    helpers->lookupProperty         = (EjsLookupPropertyHelper) lookupProperty;
    helpers->invokeOperator         = (EjsInvokeOperatorHelper) ejsInvokeOperatorDefault;
    helpers->setProperty            = (EjsSetPropertyHelper) setProperty;
    helpers->setPropertyName        = (EjsSetPropertyNameHelper) setPropertyName;
    helpers->setPropertyTraits      = (EjsSetPropertyTraitsHelper) setPropertyTraits;
}



EjsName ejsEmptyName(Ejs *ejs, cchar *name)
{
    EjsName     n;

    n.name = ejsCreateStringFromAsc(ejs, name);
    n.space = S(empty);
    return n;
}


EjsName ejsEmptyWideName(Ejs *ejs, MprChar *name)
{
    EjsName     n;

    n.name = ejsCreateString(ejs, name, strlen(name));
    n.space = S(empty);
    return n;
}


EjsName ejsName(Ejs *ejs, cchar *space, cchar *name)
{
    EjsName     n;

    n.name = ejsCreateStringFromAsc(ejs, name);
    n.space = (space) ? ejsCreateStringFromAsc(ejs, space) : NULL;
    return n;
}


EjsName ejsWideName(Ejs *ejs, MprChar *space, MprChar *name)
{
    EjsName     n;

    n.name = ejsCreateString(ejs, name, wlen(name));
    n.space = ejsCreateString(ejs, space, wlen(space));
    return n;
}


/*
    Parse a string based on formatting instructions and intelligently create a variable.
    Number formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
        [+|-][DIGITS][.][DIGITS][(e|E)[+|-]DIGITS]
 */
EjsAny *ejsParse(Ejs *ejs, MprChar *str, int preferredType)
{
    MprChar     *buf;
    int         sid;

    mprAssert(str);

    buf = str;
    sid = preferredType;

    //  TODO unicode
    while (isspace((int) *buf)) {
        buf++;
    }    
    if (preferredType == S_Void || preferredType < 0) {
        if (*buf == '-' || *buf == '+') {
            sid = S_Number;

        } else if (*buf == '/') {
            sid = S_RegExp;

        } else if (!isdigit((int) *buf) && *buf != '.') {
            if (mcmp(buf, "true") == 0) {
                return S(true);

            } else if (mcmp(buf, "false") == 0) {
                return S(false);
            }
            sid = S_String;

            if (mcmp(buf, "true") == 0 || mcmp(buf, "false") == 0) {
                sid = S_Boolean;
            } else {
                sid = S_String;
            }

        } else {
            sid = S_Number;
        }
    }
    switch (sid) {
    case S_Object:
    case S_Void:
    case S_Null:
    default:
        break;

    case S_Number:
        return ejsCreateNumber(ejs, parseNumber(ejs, buf));

    case S_Boolean:
        return ejsCreateBoolean(ejs, parseBoolean(ejs, buf));

#if BLD_FEATURE_PCRE
    case S_RegExp:
        return ejsCreateRegExp(ejs, ejsCreateString(ejs, buf, -1));
#endif

    case S_String:
        if (mcmp(buf, "null") == 0) {
            return ejsCreateNull(ejs);

        } else if (mcmp(buf, "undefined") == 0) {
            return ejsCreateUndefined(ejs);
        }
        return ejsCreateString(ejs, buf, wlen(buf));
    }
    return ejsCreateUndefined(ejs);
}


/*
    Convert the variable to a number type. Only works for primitive types.
 */
static bool parseBoolean(Ejs *ejs, MprChar *s)
{
    if (s == 0 || *s == '\0') {
        return 0;
    }
    if (mcmp(s, "false") == 0 || mcmp(s, "FALSE") == 0) {
        return 0;
    }
    return 1;
}


/*
    Convert the string buffer to a Number.
 */
static MprNumber parseNumber(Ejs *ejs, MprChar *str)
{
    MprNumber   n;
    MprChar     *cp, *sp;
    int64       num;
    char        nbuf[32], *dp;
    int         radix, c, negative;

    mprAssert(str);

    num = 0;
    negative = 0;

    if (*str == '-') {
        str++;
        negative = 1;
    } else if (*str == '+') {
        str++;
    }
    if (*str != '.' && !isdigit((int) *str)) {
        return ((EjsNumber*) S(nan))->value;
    }
    /*
        Floatng format: [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
     */
    if (!(*str == '0' && tolower((int) str[1]) == 'x')) {
        for (cp = str; *cp; cp++) {
            if (*cp == '.' || tolower((int) *cp) == 'e') {
                // OPT
                for (sp = str, dp = nbuf; *str && dp < &nbuf[sizeof(nbuf) - 1]; ) {
                    *dp++ = *sp++;
                }
                *dp = '\0';
                n = atof(nbuf);
                if (negative) {
                    n = (0.0 - n);
                }
                return n;
            }
        }
    }

    /*
        Parse an integer. Observe hex and octal prefixes (0x, 0).
     */
    if (*str != '0') {
        /*
         *  Normal numbers (Radix 10)
         */
        while (isdigit((int) *str)) {
            num = (*str - '0') + (num * 10);
            str++;
        }
    } else {
        str++;
        if (tolower((int) *str) == 'x') {
            str++;
            radix = 16;
            while (*str) {
                c = tolower((int) *str);
                if (isdigit(c)) {
                    num = (c - '0') + (num * radix);
                } else if (c >= 'a' && c <= 'f') {
                    num = (c - 'a' + 10) + (num * radix);
                } else {
                    break;
                }
                str++;
            }

        } else{
            radix = 8;
            while (*str) {
                c = tolower((int) *str);
                if (isdigit(c) && c < '8') {
                    num = (c - '0') + (num * radix);
                } else {
                    break;
                }
                str++;
            }
        }
    }

    if (negative) {
        return (MprNumber) (0 - num);
    }
    return (MprNumber) num;
}


MprNumber ejsGetNumber(Ejs *ejs, EjsAny *vp)
{
    mprAssert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIs(ejs, vp, Number));
    return (vp) ? ((EjsNumber*) (vp))->value: 0;
}


bool ejsGetBoolean(Ejs *ejs, EjsAny *vp)
{
    mprAssert(vp);
    if (!ejsIs(ejs, vp, Boolean)) {
        if ((vp = ejsCast(ejs, vp, Boolean)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIs(ejs, vp, Boolean));
    return (vp) ? ((EjsBoolean*) (vp))->value: 0;
}


int ejsGetInt(Ejs *ejs, EjsAny *vp)
{
    mprAssert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIs(ejs, vp, Number));
    return (vp) ? ((int) (((EjsNumber*) (vp))->value)): 0;
}


int64 ejsGetInt64(Ejs *ejs, EjsAny *vp)
{
    mprAssert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIs(ejs, vp, Number));
    return (vp) ? ((int64) (((EjsNumber*) (vp))->value)): 0;
}


double ejsGetDouble(Ejs *ejs, EjsAny *vp)
{
    mprAssert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIs(ejs, vp, Number));
    return (vp) ? ((double) (((EjsNumber*) (vp))->value)): 0;
}


void ejsMarkName(EjsName *qname)
{
    mprMark(qname->name);
    mprMark(qname->space);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsHelper.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsInterp.c"
 */
/************************************************************************/

/*
    ejsInterp.c - Virtual Machine Interpreter for Ejscript.

    Copyright (c) All Rights Reserved. See details at the end of the file.

    NEXT
        - Optimize and cache stack.top
        - Fix BAD BINDING
 */



/*
    The stack is a stack of pointers to values. The top of stack (stack.top) always points to the current top item 
    on the stack. To push a new value, top is incremented then the value is stored. To pop, simply copy the value at 
    top and decrement top ptr.
 */
#define top                     (*state->stack)
#define pop(ejs)                (*state->stack--)

#define push(value)             (*(++(state->stack))) = ((EjsObj*) (value))
#define popString(ejs)          ((EjsString*) pop(ejs))
#define popOutside(ejs)         *(ejs->state->stack)--
#define pushOutside(ejs, value) (*(++(ejs->state->stack))) = ((EjsObj*) (value))

#define FRAME                   state->fp
#define FUNCTION                state->fp.function
#define BLOCK                   state->bp

#define SWAP if (1) { \
        EjsObj *swap = state->stack[0]; \
        state->stack[0] = state->stack[-1]; \
        state->stack[-1] = swap; \
    }

static void callFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, int stackAdjust);

static MPR_INLINE void getPropertyFromSlot(Ejs *ejs, EjsAny *thisObj, EjsAny *obj, int slotNum) 
{
    EjsFunction     *fun, *value;

    if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_GETTER)) {
        fun = ejsGetProperty(ejs, obj, slotNum);
        callFunction(ejs, fun, thisObj, 0, 0);
        if (ejsIsNativeFunction(ejs, fun)) {
            pushOutside(ejs, ejs->result);
        } else {
            ejs->state->fp->getter = 1;
        }
        return;
    }
    value = ejsGetProperty(ejs, obj, slotNum);
    if (ejsIsFunction(ejs, value)) {
        fun = (EjsFunction*) value;
        if (!fun->boundThis && thisObj) {
            /* Function extraction. Bind the "thisObj" into a clone of the function */
            fun = ejsCloneFunction(ejs, fun, 0);
            fun->boundThis = thisObj;
            mprAssert(fun->boundThis != ejs->global);
        }
    }
    pushOutside(ejs, value);
}

#define GET_SLOT(thisObj, obj, slotNum) getPropertyFromSlot(ejs, thisObj, obj, slotNum)

static MPR_INLINE void checkGetter(Ejs *ejs, EjsAny *value, EjsAny *thisObj, EjsAny *obj, int slotNum) 
{
    EjsFunction     *fun;

    if (ejsIsFunction(ejs, value) && !ejsIsType(ejs, value)) {
        fun = (EjsFunction*) value;
        if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_GETTER)) {
            if (fun->staticMethod) {
                thisObj = obj;
            }
            callFunction(ejs, fun, thisObj, 0, 0);
            if (ejsIsNativeFunction(ejs, fun)) {
                pushOutside(ejs, ejs->result);
            } else {
                ejs->state->fp->getter = 1;
            }
            return;
        } else {
            if (!fun->boundThis && thisObj && thisObj != ejs->global) {
                /* Function extraction. Bind the "thisObj" into a clone of the function */
                /* OPT - this is slow in the a case: a.b.fn */
                fun = ejsCloneFunction(ejs, fun, 0);
                fun->boundThis = thisObj;
                mprAssert(fun->boundThis != ejs->global);
                value = fun;
            }
        }
    } else if (value == 0) {
        value = S(undefined);
    }
    pushOutside(ejs, value);
}

#define CHECK_VALUE(value, thisObj, obj, slotNum) checkGetter(ejs, value, thisObj, obj, slotNum)

#define CHECK_GC() if (MPR->heap.mustYield && !(ejs->state->frozen)) { mprYield(0); } else 

/*
    Set a slot value when we don't know if the object is an EjsObj
 */
#define SET_SLOT(thisObj, obj, slotNum, value) storePropertyToSlot(ejs, thisObj, obj, slotNum, value)

/*
    Must clear attentionPc when changing the PC. Otherwise the next instruction will jump to a bad (stale) location.
 */
//  TODO -- should not need to clear attentionPc
#define SET_PC(fp, value) \
    if (1) { \
        (fp)->pc = (uchar*) (value); \
        (fp)->attentionPc = 0; \
    } else 

#define GET_BYTE()      *(FRAME)->pc++
#define GET_DOUBLE()    ejsDecodeDouble(ejs, &(FRAME)->pc)
#define GET_INT()       ((int) GET_NUM())

//  TODO OPT - returns 64 bits, but most cases only need 32 bits
#define GET_NUM()       ejsDecodeNum(ejs, &(FRAME)->pc)
#define GET_NAME()      getNameArg(ejs, FRAME)
#define GET_STRING()    getStringArg(ejs, FRAME)
#define GET_TYPE()      ((EjsType*) getGlobalArg(ejs, FRAME))
#define GET_WORD()      ejsDecodeInt32(ejs, &(FRAME)->pc)
#undef THIS
#if UNUSED
#define THIS            FRAME->thisObj
#else
#define THIS            FRAME->function.boundThis
#endif
#define FILL(mark)      while (mark < FRAME->pc) { *mark++ = EJS_OP_NOP; }

#if DEBUG_IDE
    static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode);
    static int opcount[256];
#else
    #define traceCode(ejs, opcode) opcode
#endif

#if BLD_UNIX_LIKE || (VXWORKS && !BLD_CC_DIAB)
    #define CASE(opcode) opcode
    #define BREAK goto *opcodeJump[opcode = traceCode(ejs, GET_BYTE())]
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    #define BREAK break
    #define CASE(opcode) case opcode
#endif


static void callInterfaceInitializers(Ejs *ejs, EjsType *type);
static void callProperty(Ejs *ejs, EjsAny *obj, int slotNum, EjsAny *thisObj, int argc, int stackAdjust);
static void checkExceptionHandlers(Ejs *ejs);
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags);
static EjsAny *evalBinaryExpr(Ejs *ejs, EjsAny *lhs, EjsOpCode opcode, EjsAny *rhs);
static uint findEndException(Ejs *ejs);
static EjsEx *findExceptionHandler(Ejs *ejs, int kind);
static EjsName getNameArg(Ejs *ejs, EjsFrame *fp);
static EjsAny *getNthBase(Ejs *ejs, EjsAny *obj, int nthBase);
static EjsAny *getNthBaseFromBottom(Ejs *ejs, EjsAny *obj, int nthBase);
static EjsAny *getNthBlock(Ejs *ejs, int nth);
static EjsString *getString(Ejs *ejs, EjsFrame *fp, int num);
static EjsString *getStringArg(Ejs *ejs, EjsFrame *fp);
static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp);
static EjsBlock *popExceptionBlock(Ejs *ejs);
static bool processException(Ejs *ejs);
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, EjsName name, EjsObj *value);
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, int slotNum, EjsObj *value);
static void storePropertyToScope(Ejs *ejs, EjsName qname, EjsObj *value);
static void throwNull(Ejs *ejs);

/*
    Virtual Machine byte code evaluation
 */
static void VM(Ejs *ejs, EjsFunction *fun, EjsAny *otherThis, int argc, int stackAdjust)
{
    EjsName     qname;
    EjsObj      *result, *vp, *v1, *v2, *obj, *value;
    int         slotNum, nthBase;
    EjsState    *state;
    EjsBlock    *blk;
    EjsObj      *global;
    EjsObj      *vobj, *thisObj;
    EjsString   *nameVar, *spaceVar;
    EjsNumber   *indexVar;
    EjsType     *type;
    EjsLookup   lookup;
    EjsEx       *ex;
    EjsFrame    *newFrame;
    EjsFunction *f1, *f2;
    EjsNamespace *nsp;
    EjsString   *str;
    uchar       *mark;
    int         i, offset, count, opcode, attributes, frozen;

#if BLD_UNIX_LIKE || (VXWORKS && !BLD_CC_DIAB)
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
static void *opcodeJump[] = {
    &&EJS_OP_ADD,
    &&EJS_OP_ADD_NAMESPACE,
    &&EJS_OP_ADD_NAMESPACE_REF,
    &&EJS_OP_AND,
    &&EJS_OP_ATTENTION,
    &&EJS_OP_BRANCH_EQ,
    &&EJS_OP_BRANCH_STRICTLY_EQ,
    &&EJS_OP_BRANCH_FALSE,
    &&EJS_OP_BRANCH_GE,
    &&EJS_OP_BRANCH_GT,
    &&EJS_OP_BRANCH_LE,
    &&EJS_OP_BRANCH_LT,
    &&EJS_OP_BRANCH_NE,
    &&EJS_OP_BRANCH_STRICTLY_NE,
    &&EJS_OP_BRANCH_NULL,
    &&EJS_OP_BRANCH_NOT_ZERO,
    &&EJS_OP_BRANCH_TRUE,
    &&EJS_OP_BRANCH_UNDEFINED,
    &&EJS_OP_BRANCH_ZERO,
    &&EJS_OP_BRANCH_FALSE_8,
    &&EJS_OP_BRANCH_TRUE_8,
    &&EJS_OP_BREAKPOINT,
    &&EJS_OP_CALL,
    &&EJS_OP_CALL_GLOBAL_SLOT,
    &&EJS_OP_CALL_OBJ_SLOT,
    &&EJS_OP_CALL_THIS_SLOT,
    &&EJS_OP_CALL_BLOCK_SLOT,
    &&EJS_OP_CALL_OBJ_INSTANCE_SLOT,
    &&EJS_OP_CALL_OBJ_STATIC_SLOT,
    &&EJS_OP_CALL_THIS_STATIC_SLOT,
    &&EJS_OP_CALL_OBJ_NAME,
    &&EJS_OP_CALL_SCOPED_NAME,
    &&EJS_OP_CALL_CONSTRUCTOR,
    &&EJS_OP_CALL_NEXT_CONSTRUCTOR,
    &&EJS_OP_CAST,
    &&EJS_OP_CAST_BOOLEAN,
    &&EJS_OP_CLOSE_BLOCK,
    &&EJS_OP_COMPARE_EQ,
    &&EJS_OP_COMPARE_STRICTLY_EQ,
    &&EJS_OP_COMPARE_FALSE,
    &&EJS_OP_COMPARE_GE,
    &&EJS_OP_COMPARE_GT,
    &&EJS_OP_COMPARE_LE,
    &&EJS_OP_COMPARE_LT,
    &&EJS_OP_COMPARE_NE,
    &&EJS_OP_COMPARE_STRICTLY_NE,
    &&EJS_OP_COMPARE_NULL,
    &&EJS_OP_COMPARE_NOT_ZERO,
    &&EJS_OP_COMPARE_TRUE,
    &&EJS_OP_COMPARE_UNDEFINED,
    &&EJS_OP_COMPARE_ZERO,
    &&EJS_OP_DEFINE_CLASS,
    &&EJS_OP_DEFINE_FUNCTION,
    &&EJS_OP_DELETE_NAME_EXPR,
    &&EJS_OP_DELETE_SCOPED_NAME_EXPR,
    &&EJS_OP_DIV,
    &&EJS_OP_DUP,
    &&EJS_OP_DUP2,
    &&EJS_OP_DUP_STACK,
    &&EJS_OP_END_CODE,
    &&EJS_OP_END_EXCEPTION,
    &&EJS_OP_GOTO,
    &&EJS_OP_GOTO_8,
    &&EJS_OP_INC,
    &&EJS_OP_INIT_DEFAULT_ARGS,
    &&EJS_OP_INIT_DEFAULT_ARGS_8,
    &&EJS_OP_INST_OF,
    &&EJS_OP_IS_A,
    &&EJS_OP_LOAD_0,
    &&EJS_OP_LOAD_1,
    &&EJS_OP_LOAD_2,
    &&EJS_OP_LOAD_3,
    &&EJS_OP_LOAD_4,
    &&EJS_OP_LOAD_5,
    &&EJS_OP_LOAD_6,
    &&EJS_OP_LOAD_7,
    &&EJS_OP_LOAD_8,
    &&EJS_OP_LOAD_9,
    &&EJS_OP_LOAD_DOUBLE,
    &&EJS_OP_LOAD_FALSE,
    &&EJS_OP_LOAD_GLOBAL,
    &&EJS_OP_LOAD_INT,
    &&EJS_OP_LOAD_M1,
    &&EJS_OP_LOAD_NAMESPACE,
    &&EJS_OP_LOAD_NULL,
    &&EJS_OP_LOAD_REGEXP,
    &&EJS_OP_LOAD_STRING,
    &&EJS_OP_LOAD_THIS,
    &&EJS_OP_LOAD_THIS_LOOKUP,
    &&EJS_OP_LOAD_THIS_BASE,
    &&EJS_OP_LOAD_TRUE,
    &&EJS_OP_LOAD_UNDEFINED,
    &&EJS_OP_LOAD_XML,
    &&EJS_OP_GET_LOCAL_SLOT_0,
    &&EJS_OP_GET_LOCAL_SLOT_1,
    &&EJS_OP_GET_LOCAL_SLOT_2,
    &&EJS_OP_GET_LOCAL_SLOT_3,
    &&EJS_OP_GET_LOCAL_SLOT_4,
    &&EJS_OP_GET_LOCAL_SLOT_5,
    &&EJS_OP_GET_LOCAL_SLOT_6,
    &&EJS_OP_GET_LOCAL_SLOT_7,
    &&EJS_OP_GET_LOCAL_SLOT_8,
    &&EJS_OP_GET_LOCAL_SLOT_9,
    &&EJS_OP_GET_OBJ_SLOT_0,
    &&EJS_OP_GET_OBJ_SLOT_1,
    &&EJS_OP_GET_OBJ_SLOT_2,
    &&EJS_OP_GET_OBJ_SLOT_3,
    &&EJS_OP_GET_OBJ_SLOT_4,
    &&EJS_OP_GET_OBJ_SLOT_5,
    &&EJS_OP_GET_OBJ_SLOT_6,
    &&EJS_OP_GET_OBJ_SLOT_7,
    &&EJS_OP_GET_OBJ_SLOT_8,
    &&EJS_OP_GET_OBJ_SLOT_9,
    &&EJS_OP_GET_THIS_SLOT_0,
    &&EJS_OP_GET_THIS_SLOT_1,
    &&EJS_OP_GET_THIS_SLOT_2,
    &&EJS_OP_GET_THIS_SLOT_3,
    &&EJS_OP_GET_THIS_SLOT_4,
    &&EJS_OP_GET_THIS_SLOT_5,
    &&EJS_OP_GET_THIS_SLOT_6,
    &&EJS_OP_GET_THIS_SLOT_7,
    &&EJS_OP_GET_THIS_SLOT_8,
    &&EJS_OP_GET_THIS_SLOT_9,
    &&EJS_OP_GET_SCOPED_NAME,
    &&EJS_OP_GET_SCOPED_NAME_EXPR,
    &&EJS_OP_GET_OBJ_NAME,
    &&EJS_OP_GET_OBJ_NAME_EXPR,
    &&EJS_OP_GET_BLOCK_SLOT,
    &&EJS_OP_GET_GLOBAL_SLOT,
    &&EJS_OP_GET_LOCAL_SLOT,
    &&EJS_OP_GET_OBJ_SLOT,
    &&EJS_OP_GET_THIS_SLOT,
    &&EJS_OP_GET_TYPE_SLOT,
    &&EJS_OP_GET_THIS_TYPE_SLOT,
    &&EJS_OP_IN,
    &&EJS_OP_LIKE,
    &&EJS_OP_LOGICAL_NOT,
    &&EJS_OP_MUL,
    &&EJS_OP_NEG,
    &&EJS_OP_NEW,
    &&EJS_OP_NEW_ARRAY,
    &&EJS_OP_NEW_OBJECT,
    &&EJS_OP_NOP,
    &&EJS_OP_NOT,
    &&EJS_OP_OPEN_BLOCK,
    &&EJS_OP_OPEN_WITH,
    &&EJS_OP_OR,
    &&EJS_OP_POP,
    &&EJS_OP_POP_ITEMS,
    &&EJS_OP_PUSH_CATCH_ARG,
    &&EJS_OP_PUSH_RESULT,
    &&EJS_OP_PUT_LOCAL_SLOT_0,
    &&EJS_OP_PUT_LOCAL_SLOT_1,
    &&EJS_OP_PUT_LOCAL_SLOT_2,
    &&EJS_OP_PUT_LOCAL_SLOT_3,
    &&EJS_OP_PUT_LOCAL_SLOT_4,
    &&EJS_OP_PUT_LOCAL_SLOT_5,
    &&EJS_OP_PUT_LOCAL_SLOT_6,
    &&EJS_OP_PUT_LOCAL_SLOT_7,
    &&EJS_OP_PUT_LOCAL_SLOT_8,
    &&EJS_OP_PUT_LOCAL_SLOT_9,
    &&EJS_OP_PUT_OBJ_SLOT_0,
    &&EJS_OP_PUT_OBJ_SLOT_1,
    &&EJS_OP_PUT_OBJ_SLOT_2,
    &&EJS_OP_PUT_OBJ_SLOT_3,
    &&EJS_OP_PUT_OBJ_SLOT_4,
    &&EJS_OP_PUT_OBJ_SLOT_5,
    &&EJS_OP_PUT_OBJ_SLOT_6,
    &&EJS_OP_PUT_OBJ_SLOT_7,
    &&EJS_OP_PUT_OBJ_SLOT_8,
    &&EJS_OP_PUT_OBJ_SLOT_9,
    &&EJS_OP_PUT_THIS_SLOT_0,
    &&EJS_OP_PUT_THIS_SLOT_1,
    &&EJS_OP_PUT_THIS_SLOT_2,
    &&EJS_OP_PUT_THIS_SLOT_3,
    &&EJS_OP_PUT_THIS_SLOT_4,
    &&EJS_OP_PUT_THIS_SLOT_5,
    &&EJS_OP_PUT_THIS_SLOT_6,
    &&EJS_OP_PUT_THIS_SLOT_7,
    &&EJS_OP_PUT_THIS_SLOT_8,
    &&EJS_OP_PUT_THIS_SLOT_9,
    &&EJS_OP_PUT_OBJ_NAME_EXPR,
    &&EJS_OP_PUT_OBJ_NAME,
    &&EJS_OP_PUT_SCOPED_NAME,
    &&EJS_OP_PUT_SCOPED_NAME_EXPR,
    &&EJS_OP_PUT_BLOCK_SLOT,
    &&EJS_OP_PUT_GLOBAL_SLOT,
    &&EJS_OP_PUT_LOCAL_SLOT,
    &&EJS_OP_PUT_OBJ_SLOT,
    &&EJS_OP_PUT_THIS_SLOT,
    &&EJS_OP_PUT_TYPE_SLOT,
    &&EJS_OP_PUT_THIS_TYPE_SLOT,
    &&EJS_OP_REM,
    &&EJS_OP_RETURN,
    &&EJS_OP_RETURN_VALUE,
    &&EJS_OP_SAVE_RESULT,
    &&EJS_OP_SHL,
    &&EJS_OP_SHR,
    &&EJS_OP_SPREAD,
    &&EJS_OP_SUB,
    &&EJS_OP_SUPER,
    &&EJS_OP_SWAP,
    &&EJS_OP_THROW,
    &&EJS_OP_TYPE_OF,
    &&EJS_OP_USHR,
    &&EJS_OP_XOR,
    &&EJS_OP_FINALLY,
};
#endif
    mprAssert(ejs);
    mprAssert(!mprHasMemError(ejs));
    mprAssert(!ejs->exception);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    MPR_VERIFY_MEM();

    vp = 0;
    slotNum = -1;
    global = ejs->global;

    state = mprAlloc(sizeof(EjsState));
    *state = *ejs->state;
    state->prev = ejs->state;
    state->frozen = ejs->state->frozen;
    ejs->state = state;

    callFunction(ejs, fun, otherThis, argc, stackAdjust);
    mprAssert(state->fp);
    FRAME->caller = 0;

#if BLD_UNIX_LIKE || (VXWORKS && !BLD_CC_DIAB)
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
    BREAK;
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    while (1) {
        opcode = (EjsOpCode) GET_BYTE();
        traceCode(ejs, opcode);
        switch (opcode) {
#endif
        /*
            End of a code block. Used to mark the end of a script. Saves testing end of code block in VM loop.
                EndCode
         */
        CASE (EJS_OP_END_CODE):
            /*
                The "ejs" command needs to preserve the current ejs->result for interactive sessions.
             */
            if (ejs->result == 0) {
                // OPT - remove this
                ejs->result = S(undefined);
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            FRAME = 0;
            goto done;

        /*
            Return from a function with a result
                ReturnValue
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_RETURN_VALUE):
            ejs->result = pop(ejs);
            if (FRAME->caller == 0) {
                goto done;
            }
            state->stack = FRAME->stackReturn;
            if (ejs->result) {
                f1 = &FRAME->function;
                if (FRAME->function.resultType) {
                    type = FRAME->function.resultType;
                    //  TODO remove this voidType
                    if (type != ST(Void) && !ejsIsA(ejs, ejs->result, type)) {
                        if (ejs->result == S(null) || ejs->result == S(undefined)) {
                            if (FRAME->function.throwNulls) {
                                ejsThrowTypeError(ejs, "Unacceptable null or undefined return value");
                                BREAK;
                            } else if (FRAME->function.castNulls) {
                                ejs->result = ejsCastType(ejs, ejs->result, type);
                                if (ejs->exception) {
                                    BREAK;
                                }
                            }
                        } else {
                            ejs->result = ejsCastType(ejs, ejs->result, type);
                            if (ejs->exception) {
                                BREAK;
                            }
                        }
                    }
                }
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            state->bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            CHECK_GC();
            BREAK;

        /*
            Return from a function without a result
                Return
         */
        CASE (EJS_OP_RETURN):
            ejs->result = S(undefined);
            if (FRAME->caller == 0) {
                goto done;
            }
            state->stack = FRAME->stackReturn;
            state->bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            CHECK_GC();
            BREAK;

        /*
            Load the catch argument
                PushCatchArg
                Stack before (top)  []
                Stack after         [catchArg]
         */
        CASE (EJS_OP_PUSH_CATCH_ARG):
            push(ejs->exceptionArg);
            ejs->exceptionArg = 0;
            BREAK;

        /*
            Push the function call result
                 PushResult
                Stack before (top)  []
                Stack after         [result]
         */
        CASE (EJS_OP_PUSH_RESULT):
            push(ejs->result);
            BREAK;

        /*
            Save the top of stack and store in the interpreter result register
                SaveResult
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_SAVE_RESULT):
            ejs->result = pop(ejs);
            BREAK;

        /* Load Constants ----------------------------------------------- */

        /*
            Load a float constant
                LoadDouble          <double>
                Stack before (top)  []
                Stack after         [Double]
         */
        CASE (EJS_OP_LOAD_DOUBLE):
            push(ejsCreateNumber(ejs, GET_DOUBLE()));
            BREAK;

        /*
            Load a signed integer constant (up to 55 bits worth of data)
                LoadInt.64          <int64>
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_INT):
            push(ejsCreateNumber(ejs, (MprNumber) GET_NUM()));
            BREAK;

        /*
            Load integer constant between 0 and 9
                Load0, Load1, ... Load9
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_0):
        CASE (EJS_OP_LOAD_1):
        CASE (EJS_OP_LOAD_2):
        CASE (EJS_OP_LOAD_3):
        CASE (EJS_OP_LOAD_4):
        CASE (EJS_OP_LOAD_5):
        CASE (EJS_OP_LOAD_6):
        CASE (EJS_OP_LOAD_7):
        CASE (EJS_OP_LOAD_8):
        CASE (EJS_OP_LOAD_9):
            push(ejsCreateNumber(ejs, opcode - EJS_OP_LOAD_0));
            BREAK;

        /*
            Load the -1 integer constant
                LoadMinusOne
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_M1):
            push(ejsCreateNumber(ejs, -1));
            BREAK;

        /*
            Load a string constant
                LoadString          <string>
                Stack before (top)  []
                Stack after         [String]
         */
        CASE (EJS_OP_LOAD_STRING):
            push(GET_STRING());
            BREAK;

        /*
            Load a namespace constant
                LoadNamespace       <UriString>
                Stack before (top)  []
                Stack after         [Namespace]
         */
        CASE (EJS_OP_LOAD_NAMESPACE):
            str = GET_STRING();
            push(ejsCreateNamespace(ejs, str));
            BREAK;

        /*
            Load an XML constant
                LoadXML             <xmlString>
                Stack before (top)  []
                Stack after         [XML]
         */
        CASE (EJS_OP_LOAD_XML):
            v1 = ejsCreateObj(ejs, ST(XML), 0);
            str = GET_STRING();
            ejsLoadXMLString(ejs, (EjsXML*) v1, str);
            push(v1);
            BREAK;

        /*
            Load a Regexp constant
                LoadRegExp
                Stack before (top)  []
                Stack after         [RegExp]
         */
        CASE (EJS_OP_LOAD_REGEXP):
#if BLD_FEATURE_PCRE
            str = GET_STRING();
            v1 = (EjsObj*) ejsCreateRegExp(ejs, str);
            push(v1);
#else
            ejsThrowReferenceError(ejs, "RegularExpression support was not included in the build");
#endif
            BREAK;

        /*
            Load a null constant
                LoadNull
                Stack before (top)  []
                Stack after         [Null]
         */
        CASE (EJS_OP_LOAD_NULL):
            push(S(null));
            BREAK;

        /*
            Load a void / undefined constant
                LoadUndefined
                Stack before (top)  []
                Stack after         [undefined]
         */
        CASE (EJS_OP_LOAD_UNDEFINED):
            push(S(undefined));
            BREAK;

        CASE (EJS_OP_LOAD_THIS):
            push(THIS);
            BREAK;

        CASE (EJS_OP_LOAD_THIS_LOOKUP):
            if (lookup.originalObj) {
                push(lookup.originalObj);
            } else {
                obj = FRAME->function.moduleInitializer ? ejs->global : (EjsObj*) FRAME;
                push(obj);
            }
            BREAK;

        /*
            Load the nth base class of "this"
                LoadThis
                Stack before (top)  []
                Stack after         [baseClass]
         */
        CASE (EJS_OP_LOAD_THIS_BASE):
            vp = getNthBase(ejs, THIS, GET_INT());
            push(vp);
            BREAK;

        /*
            Load the "global" value
                LoadGlobal
                Stack before (tp (op)  []
                Stack after         [global]
         */
        CASE (EJS_OP_LOAD_GLOBAL):
            push(ejs->global);
            BREAK;

        /*
            Load the "true" value
                LoadTrue
                Stack before (top)  []
                Stack after         [true]
         */
        CASE (EJS_OP_LOAD_TRUE):
            push(S(true));
            BREAK;

        /*
            Load the "false" value
                LoadFalse
                Stack before (top)  []
                Stack after         [false]
         */
        CASE (EJS_OP_LOAD_FALSE):
            push(S(false));
            BREAK;

        /*
            Load a global variable by slot number
                GetGlobalSlot       <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_GLOBAL_SLOT):
            GET_SLOT(NULL, global, GET_INT());
            BREAK;

        /*
            Load a local variable by slot number
                GetLocalSlot        <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT):
            GET_SLOT(NULL, FRAME, GET_INT());
            BREAK;

        /*
            Load a local variable in slot 0-9
                GetLocalSlot0, GetLocalSlot1, ... GetLocalSlot9
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT_0):
        CASE (EJS_OP_GET_LOCAL_SLOT_1):
        CASE (EJS_OP_GET_LOCAL_SLOT_2):
        CASE (EJS_OP_GET_LOCAL_SLOT_3):
        CASE (EJS_OP_GET_LOCAL_SLOT_4):
        CASE (EJS_OP_GET_LOCAL_SLOT_5):
        CASE (EJS_OP_GET_LOCAL_SLOT_6):
        CASE (EJS_OP_GET_LOCAL_SLOT_7):
        CASE (EJS_OP_GET_LOCAL_SLOT_8):
        CASE (EJS_OP_GET_LOCAL_SLOT_9):
            GET_SLOT(NULL, FRAME, opcode - EJS_OP_GET_LOCAL_SLOT_0);
            BREAK;

        /*
            Load a block scoped variable by slot number
                GetBlockSlot        <slot> <nthBlock>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            GET_SLOT(NULL, obj, slotNum);
            BREAK;

        /*
            Load a property in thisObj by slot number
                GetThisSlot         <slot>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT):
            GET_SLOT(THIS, THIS, GET_INT());
            BREAK;

        /*
            Load a property in slot 0-9
                GetThisSlot0, GetThisSlot1,  ... GetThisSlot9
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT_0):
        CASE (EJS_OP_GET_THIS_SLOT_1):
        CASE (EJS_OP_GET_THIS_SLOT_2):
        CASE (EJS_OP_GET_THIS_SLOT_3):
        CASE (EJS_OP_GET_THIS_SLOT_4):
        CASE (EJS_OP_GET_THIS_SLOT_5):
        CASE (EJS_OP_GET_THIS_SLOT_6):
        CASE (EJS_OP_GET_THIS_SLOT_7):
        CASE (EJS_OP_GET_THIS_SLOT_8):
        CASE (EJS_OP_GET_THIS_SLOT_9):
            GET_SLOT(THIS, THIS, opcode - EJS_OP_GET_THIS_SLOT_0);
            BREAK;

        /*
            Load a property in an object by slot number
                GetObjSlot          <slot>
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT):
            vp = pop(ejs);
            GET_SLOT(vp, vp, GET_INT());
            BREAK;

        /*
            Load a property in an object from slot 0-9
                GetObjSlot0, GetObjSlot1, ... GetObjSlot9
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT_0):
        CASE (EJS_OP_GET_OBJ_SLOT_1):
        CASE (EJS_OP_GET_OBJ_SLOT_2):
        CASE (EJS_OP_GET_OBJ_SLOT_3):
        CASE (EJS_OP_GET_OBJ_SLOT_4):
        CASE (EJS_OP_GET_OBJ_SLOT_5):
        CASE (EJS_OP_GET_OBJ_SLOT_6):
        CASE (EJS_OP_GET_OBJ_SLOT_7):
        CASE (EJS_OP_GET_OBJ_SLOT_8):
        CASE (EJS_OP_GET_OBJ_SLOT_9):
            vp = pop(ejs);
            GET_SLOT(vp, vp, opcode - EJS_OP_GET_OBJ_SLOT_0);
            BREAK;

        /*
            Load a variable from a type by slot number
                GetTypeSlot         <slot> <nthBase>
                Stack before (top)  [objRef]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_TYPE_SLOT):
            slotNum = GET_INT();
            thisObj = pop(ejs);
            vp = getNthBase(ejs, thisObj, GET_INT());
            GET_SLOT(thisObj, vp, slotNum);
            BREAK;

        /*
            Load a type variable by slot number from this. NthBase counts from Object up rather than "this" down.
                GetThisTypeSlot     <slot> <nthBaseFromBottom>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                GET_SLOT(THIS, type, slotNum);
            }
            BREAK;

        /*
            Load a variable by an unqualified name
                GetScopedName       <qname>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME):
            mark = FRAME->pc - 1;
            qname = GET_NAME();
            vp = ejsGetVarByName(ejs, NULL, qname, &lookup);
            if (unlikely(vp == 0)) {
                ejsThrowReferenceError(ejs, "%@ is not defined", qname.name);
            } else {
//  XXX
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
            BREAK;
                
        /*
            Load a variable by an unqualified name expression
                GetScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME_EXPR):
            mark = FRAME->pc - 1;
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            vp = ejsGetVarByName(ejs, NULL, qname, &lookup);
            if (unlikely(vp == 0)) {
                push(S(undefined));
            } else {
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
#if DYNAMIC_BINDING
            if (ejs->flags & EJS_FLAG_COMPILER || TYPE(lookup.obj) == ST(Object) || lookup.slotNum >= 4096) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_BLOCK_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock);

            } else {
                BREAK;
            }
            FILL(mark);
#endif
            BREAK;
                
        /*
            Load a property by property name
                GetObjName          <qname>
                Stack before (top)  [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_GET_OBJ_NAME):
#if DYNAMIC_BINDING
            mark = FRAME->pc - 1;
#endif
            qname = GET_NAME();
            vp = pop(ejs);
            if (vp == S(null) || vp == S(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
            CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);
#if DYNAMIC_BINDING
            if (lookup.slotNum < 0 || lookup.slotNum > 4096 || ejs->flags & EJS_FLAG_COMPILER) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == (EjsObj*) state.fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == state.fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                
            } else if (ejsIsType(ejs, lookup.obj) && ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock + 1);

            } else if ((EjsObj*) TYPE(vp) == lookup.obj) {
                *mark++  = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBase);

            } else {
                *mark++  = EJS_OP_GET_OBJ_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
            }
            FILL(mark);
#endif
            BREAK;

#if XXXX
        CASE (EJS_OP_GET_POLY_SLOT):
            vp = pop(ejs);
            slotNum = GET_UINT32();
            type = GET_PTR();
            if (TYPE(vp) != type) {
                GET_SLOT(thisObj, vp, slotNum);
            } else {
                v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
                CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);
            }

        /*
            Load a property by property name
                GetObjName          <qname>
                Stack before (top)  [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_GET_OBJ_NAME):
            mark = FRAME->pc - 1;
            qname = GET_NAME();
            vp = pop(ejs);
            if (vp == S(null) || vp == S(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
            CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);

            if (v1 && lookup.obj == vp) {
                *mark++ = EJS_OP_GET_POLY_SLOT;
                *mark++ = lookup.slotNum;
                uint *ui = (uint*) mark;
                *ui++ = lookup.
                uint *ui = (uint*) FRAME->pc;
                *ui = ejsEncodeUint(mark, lookup.slotNum);
            }
            FILL(mark);
            BREAK;
#endif

        /*
            Load a property by property a qualified name expression
                GetObjNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            vp = pop(ejs);
            if (vp == 0 || vp == S(null) || vp == S(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            if (TYPE(vp)->numericIndicies && ejsIs(ejs, v1, Number)) {
                vp = ejsGetProperty(ejs, vp, ejsGetInt(ejs, v1));
                push(vp == 0 ? S(null) : vp);
                BREAK;
            } else {
                qname.name = ejsToString(ejs, v1);
                if (ejsIs(ejs, v2, Namespace)) {
                    qname.space = ((EjsNamespace*) v2)->value;
                } else {
                    qname.space = ejsToString(ejs, v2);
                }
                v2 = ejsGetVarByName(ejs, vp, qname, &lookup);
                CHECK_VALUE(v2, NULL, lookup.obj, lookup.slotNum);
                BREAK;
            }


        /* Store ------------------------------- */

        /*
            Store a global variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutGlobalSlot       <slot>
         */
        CASE (EJS_OP_PUT_GLOBAL_SLOT):
            SET_SLOT(NULL, global, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutLocalSlot        <slot>
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT):
            SET_SLOT(NULL, FRAME, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable from slot 0-9
                PutLocalSlot0, PutLocalSlot1, ... PutLocalSlot9
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT_0):
        CASE (EJS_OP_PUT_LOCAL_SLOT_1):
        CASE (EJS_OP_PUT_LOCAL_SLOT_2):
        CASE (EJS_OP_PUT_LOCAL_SLOT_3):
        CASE (EJS_OP_PUT_LOCAL_SLOT_4):
        CASE (EJS_OP_PUT_LOCAL_SLOT_5):
        CASE (EJS_OP_PUT_LOCAL_SLOT_6):
        CASE (EJS_OP_PUT_LOCAL_SLOT_7):
        CASE (EJS_OP_PUT_LOCAL_SLOT_8):
        CASE (EJS_OP_PUT_LOCAL_SLOT_9):
            SET_SLOT(NULL, FRAME, opcode - EJS_OP_PUT_LOCAL_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a block variable by slot number
                PutBlockSlot        <slot> <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;

#if FUTURE
        /*
            Store a block variable from slot 0-9
                PutBlockSlot0, PutBlockSlot1, ... PutBlockSlot9 <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT_0):
        CASE (EJS_OP_PUT_BLOCK_SLOT_1):
        CASE (EJS_OP_PUT_BLOCK_SLOT_2):
        CASE (EJS_OP_PUT_BLOCK_SLOT_3):
        CASE (EJS_OP_PUT_BLOCK_SLOT_4):
        CASE (EJS_OP_PUT_BLOCK_SLOT_5):
        CASE (EJS_OP_PUT_BLOCK_SLOT_6):
        CASE (EJS_OP_PUT_BLOCK_SLOT_7):
        CASE (EJS_OP_PUT_BLOCK_SLOT_8):
        CASE (EJS_OP_PUT_BLOCK_SLOT_9):
            slotNum = opcode - EJS_OP_PUT_BLOCK_SLOT_0;
            obj = getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;
#endif

        /*
            Store a property by slot number
                PutThisSlot         <slot>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT):
            slotNum = GET_INT();
            SET_SLOT(THIS, THIS, slotNum, pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutThisSlot0, PutThisSlot1, ... PutThisSlot9,
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT_0):
        CASE (EJS_OP_PUT_THIS_SLOT_1):
        CASE (EJS_OP_PUT_THIS_SLOT_2):
        CASE (EJS_OP_PUT_THIS_SLOT_3):
        CASE (EJS_OP_PUT_THIS_SLOT_4):
        CASE (EJS_OP_PUT_THIS_SLOT_5):
        CASE (EJS_OP_PUT_THIS_SLOT_6):
        CASE (EJS_OP_PUT_THIS_SLOT_7):
        CASE (EJS_OP_PUT_THIS_SLOT_8):
        CASE (EJS_OP_PUT_THIS_SLOT_9):
            SET_SLOT(THIS, THIS, opcode - EJS_OP_PUT_THIS_SLOT_0, pop(ejs));
            BREAK;

        /* 
            Store a property by slot number
                PutObjSlot          <slot>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutObjSlot0, PutObjSlot1, ... PutObjSlot9
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT_0):
        CASE (EJS_OP_PUT_OBJ_SLOT_1):
        CASE (EJS_OP_PUT_OBJ_SLOT_2):
        CASE (EJS_OP_PUT_OBJ_SLOT_3):
        CASE (EJS_OP_PUT_OBJ_SLOT_4):
        CASE (EJS_OP_PUT_OBJ_SLOT_5):
        CASE (EJS_OP_PUT_OBJ_SLOT_6):
        CASE (EJS_OP_PUT_OBJ_SLOT_7):
        CASE (EJS_OP_PUT_OBJ_SLOT_8):
        CASE (EJS_OP_PUT_OBJ_SLOT_9):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, opcode - EJS_OP_PUT_OBJ_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a variable by an unqualified name
                PutScopedName       <qname>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME):
            qname = GET_NAME();
            value = pop(ejs);
            storePropertyToScope(ejs, qname, value);
            BREAK;

        /*
            Store a variable by an unqualified name expression
                PutScopedName 
                Stack before (top)  [name]
                                    [space]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME_EXPR):
            //  MOB -- all these toStrings can cause a function to run which can cause a GC???
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            value = pop(ejs);
            storePropertyToScope(ejs, qname, value);
            BREAK;

        /*
            Store a property by property name to an object
                PutObjName
                MOB - is this right order?
                Stack before (top)  [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME):
            qname = GET_NAME();
            obj = pop(ejs);
            value = pop(ejs);
            storeProperty(ejs, obj, obj, qname, value);
            BREAK;

        /*
            Store a property by a qualified property name expression to an object
                PutObjNameExpr
                Stack before (top)  [nameExpr]
                                    [spaceExpr]
                                    [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            obj = pop(ejs);
            value = pop(ejs);
            //  MOB -- cleanup this too - push into storeProperty
            if (TYPE(obj)->numericIndicies && ejsIs(ejs, v1, Number)) {
                ejsSetProperty(ejs, obj, ejsGetInt(ejs, v1), value);
            } else {
                //  MOB -- all these toStrings can cause a function to run which can cause a GC???
                qname.name = ejsToString(ejs, v1);
                if (ejsIs(ejs, v2, Namespace)) {
                    qname.space = ((EjsNamespace*) v2)->value;
                } else {
                    qname.space = ejsToString(ejs, v2);
                }
                if (qname.name && qname.space) {
                    storeProperty(ejs, obj, obj, qname, value);
                }
            }
            BREAK;

        /*
            Store a type variable by slot number
                PutTypeSlot         <slot> <nthBase>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_TYPE_SLOT):
            slotNum = GET_INT();
            vobj = pop(ejs);
            vp = getNthBase(ejs, vobj, GET_INT());
            SET_SLOT(vobj, vp, slotNum, pop(ejs));
            BREAK;

        /*
            Store a variable to a slot in the nthBase class of the current "this" object
                PutThisTypeSlot     <slot> <nthBase>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                SET_SLOT(THIS, type, slotNum, pop(ejs));
            }
            BREAK;


        /* Function calling and return */

        /*
            Call a function by reference
                Stack before (top)  [args]
                                    [function]
                                    [thisObj]
                Stack after         []
         */
        CASE (EJS_OP_CALL):
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc - 1];
            callFunction(ejs, (EjsFunction*) state->stack[-argc], vp, argc, 2);
            BREAK;

        /*
            Call a global function by slot on the given type
                CallGlobalSlot      <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_GLOBAL_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            callProperty(ejs, global, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the pushed object
                CallObjSlot         <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == S(null) || vp == S(undefined)) {
                //  MOB -- refactor
                if (vp && (slotNum == ES_Object_iterator_get || slotNum == ES_Object_iterator_getValues)) {
                    callProperty(ejs, TYPE(vp), slotNum, vp, argc, 1);
                } else {
                    ejsThrowReferenceError(ejs, "Object reference is null or undefined");
                }
            } else {
                //  MOB -- need a function to invoke 
                callProperty(ejs, TYPE(vp)->prototype, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by slot number on the current this object.
                CallThisSlot        <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            obj = (EjsObj*) TYPE(THIS)->prototype;
            callProperty(ejs, obj, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the nth enclosing block
                CallBlockSlot        <slot> <nthBlock> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            callProperty(ejs, obj, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on an object.
                CallObjInstanceSlot <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_INSTANCE_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0 || vp == S(null) || vp == S(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
            } else {
                callProperty(ejs, vp, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the pushed object
                CallObjStaticSlot   <slot> <nthBase> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == S(null) || vp == S(undefined)) {
                throwNull(ejs);
            } else {
                type = (EjsType*) getNthBase(ejs, vp, nthBase);
                callProperty(ejs, type, slotNum, type, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the nth base class of the current "this" object
                CallThisStaticSlot  <slot> <nthBase> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            type = (EjsType*) getNthBase(ejs, THIS, nthBase);
            if (type == ST(Object)) {
                //  TODO - remove
                ejsThrowReferenceError(ejs, "Bad type reference");
                BREAK;
            }
            callProperty(ejs, type, slotNum, type, argc, 0);
            BREAK;

        /*
            Call a function by name on the pushed object
                CallObjName         <qname> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0) {
                ejsThrowReferenceError(ejs, "%@ is not defined", qname.name);
                throwNull(ejs);
                BREAK;
            }
            slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Can't find function \"%@\"", qname.name);
            } else {
                EjsTrait *trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
                if (trait && trait->attributes & EJS_PROP_STATIC) {
                    vp = lookup.obj;
                }
                callProperty(ejs, lookup.obj, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by name in the current scope. Use existing "this" object if defined.
                CallName            <qname> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_SCOPED_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            slotNum = ejsLookupScope(ejs, qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Can't find function %@", qname.name);
                BREAK;
            }
            fun = ejsGetProperty(ejs, lookup.obj, slotNum);
            if (ejsIsType(ejs, fun)) {
                type = (EjsType*) fun;
                callFunction(ejs, fun, NULL, argc, 0);

            } else if (!ejsIsFunction(ejs, fun)) {
                if (!ejs->exception) {
                    if ((EjsObj*) vp == (EjsObj*) S(undefined)) {
                        ejsThrowReferenceError(ejs, "Function is undefined");
                    } else {
                        ejsThrowReferenceError(ejs, "Reference is not a function");
                    }
                }
            } else {
                /*
                    Calculate the "this" to use for the function. If required function is a method in the current 
                    "this" object use the current thisObj. If the lookup.obj is a type, then use it. Otherwise global.
                 */
                //  MOB
                if ((vp = fun->boundThis) == 0) {
                    if (lookup.obj == THIS) {
                        vp = THIS;
                    } else if (ejsIsPrototype(ejs, lookup.obj) && ejsIsA(ejs, THIS, lookup.type)) {
                        vp = THIS;
                    } else if (ejsIsType(ejs, lookup.obj)) {
                        vp = lookup.obj;
                    } else {
                        vp = /* lookup.obj */ ejs->global;
                    } 
                }
                callProperty(ejs, lookup.obj, slotNum, vp, argc, 0);
            }
            BREAK;

        /*
            Call a constructor
                CallConstructor     <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         [obj]
         */
        CASE (EJS_OP_CALL_CONSTRUCTOR):
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0 || vp == S(null) || vp == S(undefined)) {
                throwNull(ejs);
                BREAK;
            }
            type = TYPE(vp);
            mprAssert(type);
            if (type && type->constructor.block.pot.isFunction) {
                mprAssert(type->prototype);
                callFunction(ejs, (EjsFunction*) type, vp, argc, 0);
                //  MOB -- must update pushed object
                state->stack[0] = ejs->result;
            }
            BREAK;

        /*
            Call the next constructor
                CallNextConstructor <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_NEXT_CONSTRUCTOR):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            type = ejsGetPropertyByName(ejs, ejs->global, qname);
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Can't find constructor %@", qname.name);
            } else {
                mprAssert(type->constructor.block.pot.isFunction);
                callFunction(ejs, (EjsFunction*) type, THIS, argc, 0);
            }
            BREAK;

        /*
            Add a literal namespace to the set of open namespaces for the current block
                AddNamespace <string>
         */
        CASE (EJS_OP_ADD_NAMESPACE):
            str = GET_STRING();
            nsp = ejsCreateNamespace(ejs, str);
            ejsAddNamespaceToBlock(ejs, state->bp, nsp);
            //  MOB - opt
            if (ejsContainsMulti(ejs, str, "internal-")) {
                state->internal = nsp;
            }
            BREAK;

        /*
            Add a namespace expression (reference) to the set of open namespaces for the current block. (use namespace).
                Stack before (top)  [namespace]
                Stack after         []
                AddNamespaceRef
         */
        CASE (EJS_OP_ADD_NAMESPACE_REF):
            MPR_VERIFY_MEM();
            ejsAddNamespaceToBlock(ejs, state->bp, (EjsNamespace*) pop(ejs));
            MPR_VERIFY_MEM();
            BREAK;

        /*
            Push a new scope block on the scope chain
                OpenBlock <slotNum> <nthBlock>
         */
        CASE (EJS_OP_OPEN_BLOCK):
            slotNum = GET_INT();
            vp = getNthBlock(ejs, GET_INT());
            v1 = ejsGetProperty(ejs, vp, slotNum);
            if (!ejsIsBlock(ejs, v1)) {
                ejsThrowReferenceError(ejs, "Reference is not a block");
                BREAK;
            }
            //  OPT
            blk = ejsCloneBlock(ejs, (EjsBlock*) v1, 0);
            blk->prev = blk->scope = state->bp;
            state->bp = blk;
            blk->stackBase = state->stack;
            mprCopyName(state->bp, v1);
            ejsSetBlockLocation(blk, FRAME->line);
            BREAK;

        /*
            Add a new scope block from the stack onto on the scope chain
                OpenWith
         */
        CASE (EJS_OP_OPEN_WITH):
            vp = pop(ejs);
            blk = ejsCreateBlock(ejs, 0);
            //  MOB -- looks bugged. Can overwrite block.
            memcpy((void*) blk, vp, TYPE(vp)->instanceSize);
            blk->prev = blk->scope = state->bp;
            state->bp = blk;
            BREAK;

        /*
            Store the top scope block off the scope chain
                CloseBlock
                CloseWith
         */
        CASE (EJS_OP_CLOSE_BLOCK):
            state->bp = state->bp->prev;
            BREAK;

        /*
            Define a class and initialize by calling any static initializer.
                DefineClass <type>
         */
        CASE (EJS_OP_DEFINE_CLASS):
            MPR_VERIFY_MEM();
            type = GET_TYPE();
            if (type == 0 || !ejsIsType(ejs, type)) {
                ejsThrowReferenceError(ejs, "Reference is not a class");
            } else {
                type->constructor.block.scope = state->bp;
                if (type && type->hasInitializer) {
                    fun = ejsGetProperty(ejs, type, 0);
                    MPR_VERIFY_MEM();
                    callFunction(ejs, fun, type, 0, 0);
                    MPR_VERIFY_MEM();
                    if (type->implements && !ejs->exception) {
                        callInterfaceInitializers(ejs, type);
                    }
                    state->bp = &FRAME->function.block;
                    MPR_VERIFY_MEM();
                }
            }
            ejs->result = type;
            BREAK;

        /*
            Define a function. This is used only for non-method functions to capture the scope chain.
                DefineFunction <slot> <nthBlock>
         */
        CASE (EJS_OP_DEFINE_FUNCTION):
            qname = GET_NAME();
            if ((slotNum = ejsLookupScope(ejs, qname, &lookup)) >= 0) {
                f1 = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
            }
            if (slotNum < 0 || !ejsIsFunction(ejs, f1)) {
                ejsThrowReferenceError(ejs, "Reference is not a function");
            } else {
                //  MOB -- fullScope is always true if DEFINE_FUNCTION is emitted
                mprAssert(f1->fullScope);
                if (f1->fullScope) {
                    //  MOB - why exception for global
                    if (lookup.obj != ejs->global) {
                        f2 = ejsCloneFunction(ejs, f1, 0);
                    } else {
                        f2 = f1;
                    }
                    f2->block.scope = state->bp;
                    if (FRAME->function.boundThis != ejs->global) {
                        f2->boundThis = FRAME->function.boundThis;
                    }
                    mprAssert(f2->boundThis != ejs->global);
                    mprAssert(!ejsIsPrototype(ejs, lookup.obj));
                    //  OPT - don't do this for global functions (if f2 == f1 and boundThis not updated (== global))
                    ejsSetProperty(ejs, lookup.obj, lookup.slotNum, f2);
                }
            }
            BREAK;


        /* Exception Handling -------------------------------------------- */

        /*
            Invoke finally blocks before acting on: return, returnValue and break (goto) opcodes.
            Injected by the compiler prior to break, continue and return statements. Also at the end of a try block
            if there is a finally block.
        
                finally
         */
        CASE (EJS_OP_FINALLY):
            if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
                if (FRAME->function.inCatch) {
                    popExceptionBlock(ejs);
                    push(FRAME->pc);
                    createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
                    BLOCK->breakCatch = 1;
                } else {
                    createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
                }
            }
            BREAK;

        /*
            End of an exception block. Put at the end of the last catch/finally block
                EndException
         */
        CASE (EJS_OP_END_EXCEPTION):
            if (FRAME->function.inException) {
                FRAME->function.inCatch = 0;
                FRAME->function.inException = 0;
                if (BLOCK->breakCatch) {
                    /* Restart the original instruction (return, break, continue) */
                    popExceptionBlock(ejs);
                    SET_PC(FRAME, pop(ejs));
                } else {
                    offset = findEndException(ejs);
                    SET_PC(FRAME, &FRAME->function.body.code->byteCode[offset]);
                    popExceptionBlock(ejs);
                }
            }
            BREAK;

        /*
            Throw an exception
                Stack before (top)  [exceptionObj]
                Stack after         []
                Throw
         */
        CASE (EJS_OP_THROW):
            ejs->exception = pop(ejs);
            ejsAttention(ejs);
            BREAK;

        /*
            Special circumstances need attention. Exceptions, exiting and garbage collection.
         */
        CASE (EJS_OP_ATTENTION):
            CHECK_GC();
            mprAssert(FRAME->attentionPc);
            if (FRAME->attentionPc) {
                FRAME->pc = FRAME->attentionPc;
                mprAssert(FRAME->pc);
                FRAME->attentionPc = 0;
            }
            if (mprHasMemError(ejs) && !ejs->exception) {
                mprResetMemError(ejs);
                ejsThrowMemoryError(ejs);
            }
            if (ejs->exiting || mprIsStopping(ejs)) {
                goto done;
            }
            if (ejs->exception && !processException(ejs)) {
                goto done;
            }
            BREAK;


        /* Stack management ---------------------------------------------- */

        /*
            Pop one item off the stack
                Pop
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_POP):
            ejs->result = pop(ejs);
            mprAssert(ejs->exception || ejs->result);
            BREAK;

        /*
            Pop N items off the stack
                PopItems            <count>
                Stack before (top)  [value]
                                    [...]
                Stack after         []
         */
        CASE (EJS_OP_POP_ITEMS):
            state->stack -= GET_BYTE();
            BREAK;

        /*
            Duplicate one item on the stack
                Stack before (top)  [value]
                Stack after         [value]
                                    [value]
         */
        CASE (EJS_OP_DUP):
            vp = state->stack[0];
            push(vp);
            BREAK;

        /*
            Duplicate two items on the stack
                Dup2
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value1]
                                    [value2]
                                    [value1]
                                    [value2]
         */
        CASE (EJS_OP_DUP2):
            v1 = state->stack[-1];
            push(v1);
            v1 = state->stack[0];
            push(v1);
            BREAK;

        /*
            Duplicate one item on the stack
                Stack before (top)  [value]
                Stack after         [value]
                                    [value]
         */
        CASE (EJS_OP_DUP_STACK):
            i = GET_BYTE();
            if (i < 0 || i > 32) {
                ejsThrowTypeError(ejs, "Bad stack index");
            } else {
                vp = state->stack[-i];
                push(vp);
            }
            BREAK;

        /*
            Swap the top two items on the stack
                Swap
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value2]
                                    [value1]
         */
        CASE (EJS_OP_SWAP):
            SWAP; BREAK;


        /* Branching */

        /*
            Default function argument initialization. Computed goto for functions with more than 256 parameters.
                InitDefault         <tableSize>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS): {
            int tableSize, numNonDefault;
            /*
                Use the argc value for the current function. Compare with the number of default args.
             */
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += ((uint*) FRAME->pc)[offset];
            BREAK;
        }

        /*
            Default function argument initialization. Computed goto for functions with less than 256 parameters.
                InitDefault.8       <tableSize.8>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS_8): {
            int tableSize, numNonDefault;
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault - FRAME->function.rest;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += FRAME->pc[offset];
            BREAK;
        }

        /*
            Spread array/object as individual args
                Pop
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_SPREAD):
            vp = *state->stack;
            count = ejsGetPropertyCount(ejs, vp);
            if (count > 0) {
                vp = pop(ejs);
                for (i = 0; i < count; i++) {
                    push(ejsGetProperty(ejs, vp, i));
                }
                ejs->spreadArgs = count - 1;
            }
            BREAK;

        /*
            Unconditional branch to a new location
                Goto                <offset.32>
         */
        CASE (EJS_OP_GOTO):
            offset = GET_WORD();
            SET_PC(FRAME, &FRAME->pc[offset]);
            CHECK_GC();
            BREAK;

        /*
            Unconditional branch to a new location (8 bit)
                Goto.8              <offset.8>
         */
        CASE (EJS_OP_GOTO_8):
            offset = (schar) GET_BYTE();
            SET_PC(FRAME, &FRAME->pc[offset]);
            CHECK_GC();
            BREAK;

        /*
            Branch to offset if false
                BranchFalse
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true
                BranchTrue
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if false (8 bit)
                BranchFalse.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE_8):
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true (8 bit)
                BranchTrue.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE_8):
            /* We want sign extension here */
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();

        /*
            Common boolean branch code
         */
        commonBoolBranchCode:
            v1 = pop(ejs);
            if (v1 == 0 || !ejsIs(ejs, v1, Boolean)) {
                v1 = ejsCast(ejs, v1, Boolean);
                if (ejs->exception) {
                    BREAK;
                }
            }
            if (!ejsIs(ejs, v1, Boolean)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
                BREAK;
            }
            if (opcode == EJS_OP_BRANCH_TRUE) {
                if (((EjsBoolean*) v1)->value) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            } else {
                if (((EjsBoolean*) v1)->value == 0) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            }
            CHECK_GC();
            BREAK;

        /*
            Branch to offset if [value1] == null
                BranchNull
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NULL):
            push(S(null));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == undefined
                BranchUndefined
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_UNDEFINED):
            push(S(undefined));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [tos] value is zero
                BranchZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_ZERO):
            /* Fall through */

        /*
            Branch to offset if [tos] value is not zero
                BranchNotZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NOT_ZERO):
            push(S(zero));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == [value2]
                BranchEQ
                Stack before (top)  [value1]
                Stack before (top)  [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_EQ):

        /*
            Branch to offset if [value1] === [value2]
                BranchStrictlyEQ
                Stack before (top)  [value1]
                Stack after         [value2]
         */
        CASE (EJS_OP_BRANCH_STRICTLY_EQ):

        /*
            Branch to offset if [value1] != [value2]
                BranchNotEqual
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NE):

        /*
            Branch to offset if [value1] !== [value2]
                BranchStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_STRICTLY_NE):

        /*
            Branch to offset if [value1] <= [value2]
                BranchLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LE):

        /*
            Branch to offset if [value1] < [value2]
                BranchLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LT):

        /*
            Branch to offset if [value1] >= [value2]
                BranchGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GE):

        /*
            Branch to offset if [value1] > [value2]
                BranchGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GT):
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Handle all branches here. We convert to a compare opcode and pass to the type to handle.
         */
        commonBranchCode:
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_EQ + EJS_OP_COMPARE_EQ);
            v2 = pop(ejs);
            v1 = pop(ejs);
            result = evalBinaryExpr(ejs, v1, opcode, v2);
            if (!ejsIs(ejs, result, Boolean)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
            } else if (((EjsBoolean*) result)->value) {
                SET_PC(FRAME, &FRAME->pc[offset]);
            }
            BREAK;

        /*
            Compare if [value1] == true
                CompareTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_TRUE):

        /*
            Compare if ![value1]
                CompareNotTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_FALSE):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Compare if [value1] == NULL
                CompareNull
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NULL):
            push(S(null));
            goto binaryExpression;

        /*
            Compare if [item] == undefined
                CompareUndefined
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_UNDEFINED):
            push(S(undefined));
            goto binaryExpression;

        /*
            Compare if [item] value is zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [tos] value is not zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NOT_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [value1] == [item2]
                CompareEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_EQ):

        /*
            Compare if [value1] === [item2]
                CompareStrictlyEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_EQ):

        /*
            Compare if [value1] != [item2]
                CompareNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NE):

        /*
            Compare if [value1] !== [item2]
                CompareStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_NE):

        /*
            Compare if [value1] <= [item2]
                CompareLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LE):

        /*
            Compare if [value1] < [item2]
                CompareStrictlyLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LT):

        /*
            Compare if [value1] >= [item2]
                CompareGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GE):

        /*
            Compare if [value1] > [item2]
                CompareGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GT):

        /*
            Binary expressions
                Stack before (top)  [right]
                                    [left]
                Stack after         [boolean]
         */
        CASE (EJS_OP_ADD):
        CASE (EJS_OP_SUB):
        CASE (EJS_OP_MUL):
        CASE (EJS_OP_DIV):
        CASE (EJS_OP_REM):
        CASE (EJS_OP_SHL):
        CASE (EJS_OP_SHR):
        CASE (EJS_OP_USHR):
        CASE (EJS_OP_AND):
        CASE (EJS_OP_OR):
        CASE (EJS_OP_XOR):
        binaryExpression:
            v2 = pop(ejs);
            v1 = pop(ejs);
            mprAssert(v1);
            ejs->result = evalBinaryExpr(ejs, v1, opcode, v2);
            push(ejs->result);
            BREAK;


        /* Unary operators */

        /*
            Negate a value
                Neg
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NEG):
            v1 = pop(ejs);
            //  TODO - should this assign to ejs->result
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Logical not (~value)
                LogicalNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_LOGICAL_NOT):
            v1 = pop(ejs);
            if ((v1 = ejsCast(ejs, v1, Boolean)) != 0) {
                result = ejsInvokeOperator(ejs, v1, opcode, 0);
                push(result);
            }
            BREAK;

        /*
            Bitwise not (!value)
                BitwiseNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NOT):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Increment a stack variable
                Inc                 <increment>
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_INC):
            v1 = pop(ejs);
            count = (schar) GET_BYTE();
            result = evalBinaryExpr(ejs, v1, EJS_OP_ADD, ejsCreateNumber(ejs, count));
            push(result);
            BREAK;


        /* Object creation */

        /*
            Create a new object
                New
                Stack before (top)  [type]
                Stack after         [obj]
         */
        CASE (EJS_OP_NEW):
            v1 = pop(ejs);
            if (!ejsIsType(ejs, v1)) {
                if (ejsIsFunction(ejs, v1)) {
                    fun = (EjsFunction*) v1;
                    if (fun->archetype == 0) {
                        if ((fun->archetype = ejsCreateArchetype(ejs, fun, NULL)) == 0) {
                            BREAK;
                        }
                    }
                    obj = ejsCreateObj(ejs, fun->archetype, 0);
                } else {
                    ejsThrowReferenceError(ejs, "Can't locate type");
                    BREAK;
                }
            } else {
                obj = ejsCreateObj(ejs, (EjsType*) v1, 0);
            }
            push(obj);
            ejs->result = obj;
            BREAK;
                
            /*
             Create a new array literal
             NewArray            <type> <argc>
             Stack before (top)  [<index><value>]
             [<index><value>]
             Stack after         []
             */
        CASE (EJS_OP_NEW_ARRAY):
frozen = ejsFreeze(ejs, 1);
            type = GET_TYPE();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            state->t1 = vp = ejsCreateObj(ejs, type, 0);
            for (i = 1 - (argc * 2); i <= 0; ) {
                indexVar = ejsToNumber(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                v1 = state->stack[i++];
                if (v1 && indexVar) {
                    ejsSetProperty(ejs, vp, ejsGetInt(ejs, indexVar), v1);
                }
            }
            state->stack -= (argc * 2);
            push(vp);
            state->t1 = 0;
ejsFreeze(ejs, frozen);
            BREAK;

        /*
            Create a new object literal
                NewObject           <type> <argc> [<attributes> ...]
                Stack before (top)  [<space><name><value>]
                                    [<space><name><value>]
                Stack after         []
         */
        CASE (EJS_OP_NEW_OBJECT):
frozen = ejsFreeze(ejs, 1);
            type = GET_TYPE();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            state->t1 = vp = ejsCreateObj(ejs, type, 0);
            for (i = 1 - (argc * 3); i <= 0; ) {
                spaceVar = ejsToString(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                nameVar = ejsToString(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                v1 = state->stack[i++];
                attributes = GET_INT();
                if (v1 && nameVar && spaceVar) {
                    EjsName qname = { nameVar, spaceVar };
                    ejsDefineProperty(ejs, vp, -1, qname, NULL, attributes, v1);
                }
            } 
            MPR_VERIFY_MEM();
            state->stack -= (argc * 3);
            push(vp);
            state->t1 = 0;
ejsFreeze(ejs, frozen);
            BREAK;


        /*
            Reference the super class
                Super
                Stack before (top)  [obj]
                Stack after         [type]
         */
        CASE (EJS_OP_SUPER):
            push(TYPE(FRAME->function.boundThis));
            BREAK;

        /*
            Delete an object property by name expression
                DeleteNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         [true|false]
         */
        CASE (EJS_OP_DELETE_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            vp = pop(ejs);
            slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
            if (slotNum < 0) {
                push(S(true));
            } else {
                if (/* MOB !DYNAMIC(lookup.obj) || */ ejsPropertyHasTrait(ejs, lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    push(S(false));
                } else {
                    ejsDeletePropertyByName(ejs, lookup.obj, lookup.name);
                    push(S(true));
                }
            }
            BREAK;

        /*
            Delete an object property from the current scope
                DeleteScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         [true|false]
         */
        CASE (EJS_OP_DELETE_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            slotNum = ejsLookupScope(ejs, qname, &lookup);
            if (slotNum < 0) {
                push(S(true));
            } else {
                if (/* MOB - !DYNAMIC(lookup.obj) || */ ejsPropertyHasTrait(ejs, lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    push(S(false));
                } else {
                    ejsDeletePropertyByName(ejs, lookup.obj, lookup.name);
                    push(S(true));
                }
            }
            BREAK;

        /*
            No operation. Does nothing.
                Nop
         */
        CASE (EJS_OP_NOP):
            BREAK;

        /*
            Check if object is a given type
                IsA, Like, InstanceOf
                Stack before (top)  [type]
                                    [obj]
                Stack after         [boolean]
         */
        CASE (EJS_OP_INST_OF):
        CASE (EJS_OP_IS_A):
        CASE (EJS_OP_LIKE):
            type = (EjsType*) pop(ejs);
            v1 = pop(ejs);
            push(ejsCreateBoolean(ejs, ejsIsA(ejs, v1, type)));
            BREAK;

        /*
            Get the type of an object.
                TypeOf              <obj>
                Stack before (top)  [obj]
                Stack after         [string]
         */
        CASE (EJS_OP_TYPE_OF):
            v1 = pop(ejs);
            push(ejsGetTypeOf(ejs, v1));
            BREAK;

        /*
            Cast an object to the given the type. Throw if not castable.
                Cast
                Stack before (top)  [type]
                                    [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST):
            type = (EjsType*) pop(ejs);
            if (!ejsIsType(ejs, type)) {
                ejsThrowTypeError(ejs, "Not a type");
            } else {
                v1 = pop(ejs);
                push(ejsCastType(ejs, v1, type));
            }
            BREAK;

        /*
            Cast to a boolean type
                CastBoolean
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST_BOOLEAN):
            v1 = ejsCast(ejs, pop(ejs), Boolean);
            push(v1);
            BREAK;

        /*
            Test if a given name is the name of a property "in" an object
                Cast
                Stack before (top)  [obj]
                                    [name]
                Stack after         [result]
         */
        CASE (EJS_OP_IN):
            v1 = pop(ejs);
            nameVar = ejsToString(ejs, pop(ejs));
            if (nameVar == 0) {
                ejsThrowTypeError(ejs, "Can't convert to a name");
            } else {
                EjsName n = { nameVar, NULL };
                slotNum = ejsLookupProperty(ejs, v1, n);
                if (slotNum < 0) {
                    n.space = S(empty);
                    slotNum = ejsLookupVar(ejs, v1, n, &lookup);
                    if (slotNum < 0 && ejsIsType(ejs, v1)) {
                        slotNum = ejsLookupVar(ejs, ((EjsType*) v1)->prototype, n, &lookup);
                    }
                }
                push(ejsCreateBoolean(ejs, slotNum >= 0));
            }
            BREAK;

        /*
            Unimplemented op codes
         */
        CASE (EJS_OP_BREAKPOINT):
            mprAssert(0);
            BREAK;

#if !BLD_UNIX_LIKE && !(VXWORKS && !BLD_CC_DIAB)
        }
    }
#endif
    
done:
#if BLD_DEBUG && FUTURE
    if (ejs->initialized) {
        ejsShowOpFrequency(ejs);
    }
#endif
    mprAssert(FRAME == 0 || FRAME->attentionPc == 0);
    ejs->state = ejs->state->prev;
    if (ejs->exception) {
        ejsAttention(ejs);
    }
}


/*
    WARNING: this may not complete the store. It may setup a setter function which then requires the VM to execute.
 */
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, int slotNum, EjsObj *value)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    EjsTrait        *trait;

    mprAssert(value);

    if (slotNum < 0 && !DYNAMIC(obj)) {
        ejsThrowTypeError(ejs, "Object is not extendable");
        return;
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    if (trait) {
        if (trait->attributes & EJS_TRAIT_SETTER) {
            pushOutside(ejs, value);
            fun = ejsGetProperty(ejs, obj, slotNum);
            mprAssert(fun);
            fun = fun->setter;
            mprAssert(fun);
            callFunction(ejs, fun, thisObj, 1, 0);
            return;
        }
        if (trait->type) {
            if (!ejsIsA(ejs, value, trait->type)) {
                if (value == S(null) || value == S(undefined)) {
                    if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                        ejsThrowTypeError(ejs, "Unacceptable null or undefined value");
                        return;
                    } else if (trait->attributes & EJS_TRAIT_CAST_NULLS) {
                        value = ejsCastType(ejs, value, trait->type);
                        if (ejs->exception) {
                            return;
                        }
                    }
                } else {
                    value = ejsCastType(ejs, value, trait->type);
                    if (ejs->exception) {
                        return;
                    }
                }
            }
        }
        if (trait->attributes & EJS_TRAIT_READONLY) {
            EjsName  qname;
            vp = ejsGetProperty(ejs, obj, slotNum);
            if (vp != value && vp != S(null) && vp != S(undefined)) {
                qname = ejsGetPropertyName(ejs, obj, slotNum);
                ejsThrowReferenceError(ejs, "Property \"%@\" is not writable", qname.name);
                return;
            }
        }
    }
    ejsSetProperty(ejs, obj, slotNum, value);
    ejs->result = value;
}


/*
    Store a property by name in the given object. Will create if the property does not already exist.
 */
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsAny *vp, EjsName qname, EjsObj *value)
{
    EjsLookup       lookup;
    EjsTrait        *trait;
    EjsPot          *pot;
    int             slotNum;

    mprAssert(qname.name);
    mprAssert(vp);

    //  MOB -- ONLY XML requires this.  NOTE: this bypasses ES5 traits
    //  Alternatively push this whole function down into ejsObject and have all go via setPropertyByName
    
    if (TYPE(vp)->helpers.setPropertyByName) {
        slotNum = (*TYPE(vp)->helpers.setPropertyByName)(ejs, vp, qname, value);
        if (slotNum >= 0) {
            return;
        }
    }
    if ((slotNum = ejsLookupVar(ejs, vp, qname, &lookup)) >= 0) {
        if (lookup.obj != vp) {
            trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
            if (trait->attributes & EJS_TRAIT_SETTER) {
                vp = lookup.obj;
                
                //  MOB - REFACTOR. Just for prototype() getter in Object.prototype
            } else if (ejsIsPrototype(ejs, lookup.obj) || trait->attributes & EJS_TRAIT_GETTER) {
                if (TYPE(vp)->hasInstanceVars) {
                    /* The prototype properties have been inherited */
                    mprAssert(ejsIsPot(ejs, vp));
                    slotNum = ejsGetSlot(ejs, vp, slotNum);
                    pot = (EjsPot*) vp;
                    //MOB - BUG what if not a POT
                    pot->properties->slots[slotNum].trait = ((EjsPot*) lookup.obj)->properties->slots[slotNum].trait;
                    pot->properties->slots[slotNum].value = ((EjsPot*) lookup.obj)->properties->slots[slotNum].value;
                    slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
                } else  {
                    slotNum = -1;
                }
            } else {
                /*
                    This is the fundamental asymetry between load/store. We allow loading properties from static base 
                    types, but do not allow stores. This is essential to stop bleeding of Object static properties into
                    all objects. E.g. Object.create.
                 */
                slotNum = -1;
            }
        }
    }
    if (slotNum < 0) {
        slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
        //  UNICODE
        mprSetName(value, qname.name->value);
    }
    if (!ejs->exception) {
        storePropertyToSlot(ejs, thisObj, vp, slotNum, value);
    }
}


/*
    Store a property by name in the scope chain. Will create properties if the given name does not already exist.
 */
static void storePropertyToScope(Ejs *ejs, EjsName qname, EjsObj *value)
{
    EjsFrame        *fp;
    EjsObj          *vp, *thisObj;
    EjsPot          *obj;
    EjsLookup       lookup;
    EjsTrait        *trait;
    int             slotNum;

    fp = ejs->state->fp;

    if ((slotNum = ejsLookupScope(ejs, qname, &lookup)) >= 0) {
        if (ejsIsPrototype(ejs, lookup.obj)) {
            thisObj = vp = (EjsObj*) fp->function.boundThis;
            trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
            if (trait->attributes & EJS_TRAIT_SETTER) {
                vp = lookup.obj;

            } else if (TYPE(vp)->hasInstanceVars && ejsIsPot(ejs, vp)) {
                /* The prototype properties have been inherited */
                mprAssert(ejsIsPot(ejs, vp));
                slotNum = ejsGetSlot(ejs, (EjsPot*) vp, slotNum);
                obj = (EjsPot*) vp;
                mprAssert(slotNum < obj->numProp);
                mprAssert(slotNum < ((EjsPot*) lookup.obj)->numProp);
                obj->properties->slots[slotNum].trait = ((EjsPot*) lookup.obj)->properties->slots[slotNum].trait;
                obj->properties->slots[slotNum].value = ((EjsPot*) lookup.obj)->properties->slots[slotNum].value;
                slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
            } else {
                slotNum = -1;
            }
        } else {
            thisObj = vp = lookup.obj;
        }
    } else {
        thisObj = vp = fp->function.moduleInitializer ? ejs->global : (EjsObj*) fp;
        slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
        //  UNICODE
        mprSetName(value, qname.name->value);
    }
    storePropertyToSlot(ejs, thisObj, vp, slotNum, value);
}


/*
    Run the module initializer
 */
EjsObj *ejsRunInitializer(Ejs *ejs, EjsModule *mp)
{
    EjsModule   *dp;
    EjsAny      *result;
    int         next;
    
    if (mp->initialized || !mp->hasInitializer) {
        mp->initialized = 1;
        result = S(null);
    } else {
        mp->initialized = 1;
        if (mp->dependencies) {
            for (next = 0; (dp = mprGetNextItem(mp->dependencies, &next)) != 0;) {
                if (dp->hasInitializer && !dp->initialized) {
                    if (ejsRunInitializer(ejs, dp) == 0) {
                        return 0;
                    }
                }
            }
        }
        mprLog(6, "Running initializer for module %@", mp->name);
        result = ejsRunFunction(ejs, mp->initializer, ejs->global, 0, NULL);
    }
    return result;
}


/*
    Run all initializers for all modules
 */
int ejsRun(Ejs *ejs)
{
    EjsModule   *mp;
    int         next;

    for (next = 0; (mp = mprGetNextItem(ejs->modules, &next)) != 0;) {
        if (!mp->initialized) {
            ejsRunInitializer(ejs, mp);
        }
        if (ejsCompareMulti(ejs, mp->name, EJS_DEFAULT_MODULE) == 0) {
            ejsRemoveModule(ejs, mp);
            next--;
        }
        if (ejs->exception) {
            return EJS_ERR;
        }
    }
    return 0;
}


EjsAny *ejsRunFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, void *argv)
{
    int     i;
    
    mprAssert(ejs);
    mprAssert(fun);
    mprAssert(ejsIsFunction(ejs, fun));
    mprAssert(ejs->exception == 0);
    MPR_VERIFY_MEM();

    if (ejs->exception) {
        return 0;
    }
#if TEST
    //  MOB -is this required 
    mprAssert(ejs->state->fp->attentionPc == 0);
#endif
    ejsClearAttention(ejs);
    
#if UNUSED
    if (thisObj == 0) {
        //  MOB - simplify
        if ((thisObj = fun->boundThis) == 0) {
            thisObj = ejs->state->fp->function.boundThis;
        }
    }    
#else
    if (thisObj == 0) {
        thisObj = fun->boundThis ? fun->boundThis : ejs->global;
    }
#endif
    if (ejsIsNativeFunction(ejs, fun)) {
        if (fun->body.proc == 0) {
            ejsThrowArgError(ejs, "Native function is not defined");
            return 0;
        }
//  MOB - need faster solution
//  MOB -- just so that all args get marked
for (i = 0; i < argc; i++) {
    pushOutside(ejs, ((EjsAny**) argv)[i]);
}
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
        ejs->state->stack -= argc;
        if (ejs->result == 0) {
            ejs->result = S(null);
        }

    } else {
        for (i = 0; i < argc; i++) {
            pushOutside(ejs, ((EjsAny**) argv)[i]);
        }
        VM(ejs, fun, thisObj, argc, 0);
        ejs->state->stack -= argc;
        if (ejs->exiting || mprIsStopping(ejs)) {
            ejsAttention(ejs);
        }
    }
    return (ejs->exception) ? 0 : ejs->result;
}


//  MOB - can only be used to run instance methods -- rename to clarify

EjsAny *ejsRunFunctionBySlot(Ejs *ejs, EjsAny *thisObj, int slotNum, int argc, void *argv)
{
    EjsFunction     *fun;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if (thisObj == ejs->global) {
        fun = ejsGetProperty(ejs, thisObj, slotNum);
    } else if (ejsIsType(ejs, thisObj)) {
        fun = ejsGetProperty(ejs, thisObj, slotNum);
    } else {
        fun = ejsGetProperty(ejs, TYPE(thisObj)->prototype, slotNum);
    }
    if (fun == 0) {
        ejsThrowReferenceError(ejs, "Can't find function at slot %d in %N", slotNum, &TYPE(thisObj)->qname);
        return 0;
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}


EjsAny *ejsRunFunctionByName(Ejs *ejs, EjsAny *container, EjsName qname, EjsAny *thisObj, int argc, void *argv)
{
    EjsFunction     *fun;
    EjsLookup       lookup;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if (container) {
        if ((fun = ejsGetPropertyByName(ejs, container, qname)) == 0) {
            ejsThrowReferenceError(ejs, "Can't find function %N", qname);
            return 0;
        }
    } else {
        if (ejsLookupScope(ejs, qname, &lookup) == 0) {
            ejsThrowReferenceError(ejs, "Can't find function %N", qname);
            return 0;
        }
        fun = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}



static void badArgType(Ejs *ejs, EjsPot *activation, EjsTrait *trait, int index)
{
    EjsName     qname;

    qname = ejsGetPropertyName(ejs, activation, index);
    ejsThrowTypeError(ejs, "Unacceptable null or undefined value for arg \"%@\" (pos: %d)", qname.name, index);
}


/*
    Validate the args. This routine handles ...rest args and parameter type checking and casts. Returns the new argc 
    or < 0 on errors.
 */
static int validateArgs(Ejs *ejs, EjsFunction *fun, int argc, void *args)
{
    EjsType     *type;
    EjsTrait    *trait;
    EjsArray    *rest;
    EjsPot      *activation;
    EjsObj      *newArg, **argv;
    int         nonDefault, i, limit, numRest;

    mprAssert(ejs->exception == 0);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    argv = (EjsObj**) args;
    activation = fun->activation;
    nonDefault = fun->numArgs - fun->numDefault - fun->rest;

    if (argc < nonDefault) {
        if (!fun->rest || argc != (fun->numArgs - 1)) {
            if (fun->strict || (ejsIsNativeFunction(ejs, fun) && !fun->allowMissingArgs)) {
                ejsThrowArgError(ejs, "Insufficient actual parameters %d. Call requires %d parameter(s).", argc, nonDefault);
                return EJS_ERR;
            } else {
                /* Create undefined values for missing args for script functions */
                for (i = argc; i < nonDefault; i++) {
                    pushOutside(ejs, S(undefined));
                }
                argc = nonDefault;
            }
        }
    }
    if ((uint) argc > fun->numArgs && !fun->rest) {
        /*
            Discard excess arguments for scripted functions. No need to discard for native procs. This allows
            ejsDefineGlobalFunction to not have to bother with specifying the number of args for native procs.
         */
        if (!ejsIsNativeFunction(ejs, fun)) {
            ejs->state->stack -=  (argc - fun->numArgs);
            argc = fun->numArgs;
        }
    }

    /*
        Handle rest "..." args
     */
    if (fun->rest && (argc > nonDefault || fun->numDefault == 0)) {
        numRest = argc - fun->numArgs + 1;
        rest = ejsCreateArray(ejs, numRest);
        if (rest == 0) {
            return EJS_ERR;
        }
        for (i = numRest - 1; i >= 0; i--) {
            ejsSetProperty(ejs, rest, i, popOutside(ejs));
        }
        argc = argc - numRest + 1;
        pushOutside(ejs, rest);
    }

    /*
        Cast args to the right types
     */
    limit = min((uint) argc, fun->numArgs);
    for (i = 0; i < limit; i++) {
        if ((trait = ejsGetPropertyTraits(ejs, activation, i)) == 0 || trait->type == 0) {
            /* No trait - all to pass */
            continue;
        }
        type = trait->type;
        if (!ejsIsA(ejs, argv[i], type)) {
            if ((argv[i] == S(null) || argv[i] == S(undefined))) {
                if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                    badArgType(ejs, activation, trait, i);
                    return EJS_ERR;
                }
                if (!(trait->attributes & EJS_TRAIT_CAST_NULLS)) {
                    continue;
                }
            }
            newArg = ejsCastType(ejs, argv[i], trait->type);
            if (ejs->exception) {
                ejsClearException(ejs);
                badArgType(ejs, activation, trait, i);
                return EJS_ERR;
            }
            argv[i] = newArg;
        }
    }
    return argc;
}


static void callInterfaceInitializers(Ejs *ejs, EjsType *type)
{
    EjsType         *iface;
    EjsFunction     *fun;
    EjsName         qname;
    int             next;

    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (iface->hasInitializer) {
            qname = ejsGetPropertyName(ejs, iface, 0);
            //  TODO OPT. Could run all 
            fun = ejsGetPropertyByName(ejs, type, qname);
            if (fun && ejsIsFunction(ejs, fun)) {
                callFunction(ejs, fun, type, 0, 0);
            }
        }
    }
}


/*
    Push a block. Used by compiler.
    MOB -- move back to the compiler
 */
EjsBlock *ejsPushBlock(Ejs *ejs, EjsBlock *original)
{
    EjsBlock    *block;

    mprAssert(!ejsIsFunction(ejs, original));

    block = ejsCloneBlock(ejs, original, 0);
    block->scope = ejs->state->bp;
    block->prev = ejs->state->bp;
    block->stackBase = ejs->state->stack;
    ejs->state->bp = block;
    return block;
}


/*
    Pop a block frame and return to the previous frame.  This pops functions and/or lexical blocks.
 */
EjsBlock *ejsPopBlock(Ejs *ejs)
{
    EjsBlock    *bp;

    bp = ejs->state->bp;
    ejs->state->stack = bp->stackBase;
    return ejs->state->bp = bp->prev;
}


/*
    Pop an exception block.
 */
static EjsBlock *popExceptionBlock(Ejs *ejs)
{
    EjsBlock     *prev;

    if ((prev = ejs->state->bp->prev) != 0) {
        if (ejs->exception == 0) {
            ejs->exception = prev->prevException;
            prev->prevException = 0;
            if (ejs->exception) {
                /* Advance by one as checkExceptionHandlers expects the PC to be advanced after parsing the opcode */
                ejs->state->fp->pc++;
                ejsAttention(ejs);
            }
        }
    }
    ejs->state->bp = prev;
    return prev;
}


/*
    Manage exceptions. Bubble up the exception until we find an exception handler for it.
 */
static bool processException(Ejs *ejs)
{
    EjsState        *state;

    state = ejs->state;

    /*
        Check at each function level for a handler to process the exception.
     */
    while (state->fp) {
        checkExceptionHandlers(ejs);
        if (ejs->exception == 0) {
            return 1;
        }
        state->stack = state->fp->stackReturn;
        state->bp = state->fp->function.block.prev;
        state->fp = state->fp->caller;
        ejsClearAttention(ejs);
    }
    return 0;
}


static EjsEx *findExceptionHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);

    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->tryStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            if (ejsIsType(ejs, ejs->exception) && ((EjsType*) ejs->exception)->sid == S_StopIteration) {
                return ex;
            }
            mprAssert(ex->catchType);
            if (kind == EJS_EX_FINALLY || ex->catchType->sid == S_Void) {
                return ex;
            }
            if (ejsIsA(ejs, ejs->exception, ex->catchType)) {
                return ex;
            }
        }
    }
    return 0;
}


static EjsEx *inHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;
    
    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    
    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->handlerStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            return ex;
        }
    }
    return 0;
}


/*
    Find the end of the last catch/finally handler.
 */
static uint findEndException(Ejs *ejs)
{
    EjsFrame    *fp;
    EjsEx       *best, *ex;
    EjsCode     *code;
    uint        offset, pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    offset = 0;

    for (best = 0, i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        /*
            Comparison must include try and all catch handlers, incase there are multiple catch handlers
         */
        if (ex->tryStart <= pc && pc < ex->handlerEnd) {
            offset = ex->handlerEnd;
            for (++i; i < code->numHandlers; i++) {
                /* Find the last handler of this try block. Use tryEnd as nested try blocks can start at the same location */
                if (ex->tryEnd == code->handlers[i]->tryEnd) {
                    offset = code->handlers[i]->handlerEnd;
                }
            }
        }
    }
    mprAssert(offset);
    return offset;
}


/*
    Search for an exception handler at this level to process the exception. Return true if the exception is handled.
 */
static void checkExceptionHandlers(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsCode         *code;
    EjsEx           *ex;
    uint            pc;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;

    if (code->numHandlers == 0) {
        return;
    }

    /*
        The PC is always one advanced from the throwing instruction. ie. the PC has advanced past the offending 
        instruction so reverse by one.
     */
    pc = (uint) (fp->pc - code->byteCode - 1);
    mprAssert(pc >= 0);

rescan:
    if (!fp->function.inException || (ejs->exception == ST(StopIteration))) {
        /*
            Normal exception in a try block. NOTE: the catch will jump or fall through to the finally block code.
            ie. We won't come here again for the finally code unless there is an exception in the catch block.
            Otherwise, No catch handler at this level and need to bubble up.
         */
        if ((ex = findExceptionHandler(ejs, EJS_EX_CATCH)) != 0) {
            createExceptionBlock(ejs, ex, ex->flags);
            return;
        }

    } else {
        /*
            Exception in a catch or finally block. If in a catch block, must first run the finally
            block before bubbling up. If in a finally block, we are done and upper levels will handle. We can be
            in a finally block and inException == 0. This happens because try blocks jump through directly
            into finally blocks (fast). But we need to check here if we are in the finally block explicitly.
         */
        if ((ex = inHandler(ejs, EJS_EX_FINALLY)) != 0) {
            /*
                If in a finally block, must advance the outer blocks's pc to be outside [tryStart .. finallyStart]
                This prevents this try block from handling this exception again.
             */
            SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerEnd + 1]);
            fp->function.inCatch = fp->function.inException = 0;
            goto rescan;            
        }
    }

    /*
        Exception without a catch block or exception in a catch block. 
     */
    if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
        if (fp->function.inCatch) {
            popExceptionBlock(ejs);
        }
        createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
    } else {
        fp->function.inCatch = fp->function.inException = 0;
    }
    ejsClearAttention(ejs);
}


/*
    Called for catch and finally blocks
 */
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags)
{
    EjsBlock        *block;
    EjsFrame        *fp;
    EjsState        *state;
    EjsCode         *code;
    int             i, count;

    state = ejs->state;
    fp = state->fp;
    code = state->fp->function.body.code;
    mprAssert(ex);

    ejsClearAttention(ejs);

    if (flags & EJS_EX_ITERATION) {
        /*
            Empty handler is a special case for iteration. We simply do a break to the handler location
            which targets the end of the for/in loop.
         */
        SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerStart]);
        ejs->exception = 0;
        return;
    }

    /*
        Discard all lexical blocks defined inside the try block
     */
    if (!fp->function.inCatch) {
        for (count = 0, block = state->bp; block != (EjsBlock*) state->fp; block = block->prev) {
            count++;
        }
        count -= ex->numBlocks;
        mprAssert(count >= 0);
        for (i = 0; i < count && count > 0; i++) {
            ejsPopBlock(ejs);
        }
        count = (int) (state->stack - fp->stackBase);
        state->stack -= (count - ex->numStack);
        mprAssert(state->stack >= fp->stackReturn);
    }
    
    /*
        Allocate a new frame in which to execute the handler
     */
    block = ejsCreateBlock(ejs, 0);
    if (block == 0) {
        /*  Exception will continue to bubble up */
        return;
    }
    block->prev = block->scope = state->bp;
    block->stackBase = state->stack;
    state->bp = block;

    /*
        Move the PC outside of the try region. If this is a catch block, this allows the finally block to still
        be found. But if this is processing a finally block, the scanning for a matching handler will be forced
        to bubble up.
     */
    SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerStart]);

    if (flags & EJS_EX_CATCH) {
        ejs->exceptionArg = ejs->exception;
        fp->function.inCatch = 1;

    } else {
        /*
            Mask the exception while processing the finally block
         */
        block->prev->prevException = ejs->exception;
        fp->function.inCatch = 0;
        ejsAttention(ejs);
    }
    ejs->exception = 0;
    fp->function.inException = 1;
}


typedef struct OperMap {
    int         opcode;
    cchar       *name;
} OperMap;

static OperMap operMap[] = {
        { EJS_OP_MUL,           "*"     },
        { EJS_OP_DIV,           "/"     },
        { EJS_OP_REM,           "%"     },
        { EJS_OP_COMPARE_LT,    "<"     },
        { EJS_OP_COMPARE_GT,    ">"     },
        { EJS_OP_COMPARE_LE,    "<="    },
        { EJS_OP_COMPARE_GE,    ">="    },
        { 0,                    0       },
};


static int lookupOverloadedOperator(Ejs *ejs, EjsOpCode opcode, EjsAny *lhs)
{
    EjsName     qname;
    int         i;

    for (i = 0; operMap[i].opcode; i++) {
        if (operMap[i].opcode == opcode) {
            qname = ejsName(ejs, "", operMap[i].name);
            break;
        }
    }
    return ejsLookupProperty(ejs, TYPE(lhs), qname);
}


/*
    Evaluate a binary expression.
    OPT -- simplify and move back inline into eval loop.
 */
static EjsAny *evalBinaryExpr(Ejs *ejs, EjsAny *lhs, EjsOpCode opcode, EjsAny *rhs)
{
    EjsAny      *result;
    int         slotNum;

    if (lhs == 0) {
        lhs = S(undefined);
    }
    if (rhs == 0) {
        rhs = S(undefined);
    }
    result = ejsInvokeOperator(ejs, lhs, opcode, rhs);

    if (result == 0 && ejs->exception == 0) {
        slotNum = lookupOverloadedOperator(ejs, opcode, lhs);
        if (slotNum >= 0) {
            result = ejsRunFunctionBySlot(ejs, lhs, slotNum, 1, &rhs);
        }
    }
    return result;
}


int ejsInitStack(Ejs *ejs)
{
    EjsState    *state;

    state = ejs->state;
    mprAssert(state);

    /*
        Allocate the stack
        This will allocate memory virtually for systems with virutal memory. Otherwise, it will just use malloc.
        TODO - create a guard page
     */
    state->stackSize = MPR_PAGE_ALIGN(EJS_STACK_MAX, mprGetPageSize(ejs));
    if ((state->stackBase = mprVirtAlloc(state->stackSize, MPR_MAP_READ | MPR_MAP_WRITE)) == 0) {
        mprSetMemError(ejs);
        return EJS_ERR;
    }
    state->stack = &state->stackBase[-1];
    return 0;
}


#if FUTURE
/*
    Grow the operand evaluation stack.
    Return a negative error code on memory allocation errors or if the stack grows too big.
 */
int ejsGrowStack(Ejs *ejs, int incr)
{
    EjsStack    *sp;
    EjsFrame    *frame;
    EjsObj      **bottom;
    int         i, size, moveBy;

    sp = ejs->stack;
    sp->ejs = ejs;

    incr = max(incr, EJS_STACK_INC);

    if (sp->bottom) {
        /*
            Grow an existing stack
         */
        size = sp->size + (sizeof(EjsObj*) * incr);
        bottom = (EjsObj**) mprRealloc(sp, sp->bottom, size);
        //  OPT - don't zeroed?
        memset(&bottom[sp->size], 0, (size - sp->size) * sizeof(EjsObj*));
        moveBy = (int) ((char*) bottom - (char*) sp->bottom);
        sp->top = (EjsObj**) ((char*) sp->top + moveBy);
        sp->bottom = bottom;

        /*
            Adjust all the argv pointers.
         */
        for (frame = ejs->frame; frame; frame = frame->prev) {
            if (frame->argv) {
                frame->argv = (EjsObj**) ((char*) frame->argv + moveBy);
            }
            frame->prevStackTop = (EjsObj**) ((char*) frame->prevStackTop + moveBy);
        }

    } else {
        /*
            Allocate a stack
         */
        if (sp->top >= &sp->bottom[EJS_STACK_MAX]) {
            return MPR_ERR_MEMORY;
        }
        size = (sizeof(EjsObj*) * incr);
        sp->bottom = (EjsObj**) mprAlloc(size);
        /*
            Push always begins with an increment of sp->top. Initially, sp_bottom points to the first (future) element.
         */
        sp->top = &sp->bottom[-1];
    }

    if (sp->bottom == 0) {
        return MPR_ERR_MEMORY;
    }

    sp->end = &sp->bottom[size / sizeof(EjsObj*)];
    sp->size = size;

    for (i = 1; i <= incr; i++) {
        sp->top[i] = 0;
    }
    return 0;
}
#endif


/*
    Exit the script
 */
void ejsExit(Ejs *ejs, int status)
{
    //  TODO - should pass status back
    //  MOB -- what about graceful exiting 
    ejs->exiting = 1;
    mprSignalDispatcher(ejs->dispatcher);
}


static EjsName getNameArg(Ejs *ejs, EjsFrame *fp)
{
    EjsName     qname;

    qname.name = getStringArg(ejs, fp);
    qname.space = getStringArg(ejs, fp);
    return qname;
}


static EjsString *getString(Ejs *ejs, EjsFrame *fp, int num)
{
    return ejsCreateStringFromConst(ejs, fp->function.body.code->module, num);
}


static EjsString *getStringArg(Ejs *ejs, EjsFrame *fp)
{
    return getString(ejs, fp, (int) ejsDecodeNum(ejs, &fp->pc));
}


static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp)
{
    EjsObj      *obj;
    EjsName     qname;
    int         t, slotNum;

    t = (int) ejsDecodeNum(ejs, &fp->pc);
    if (t < 0) {
        return 0;
    }
    slotNum = -1;
    qname.name = 0;
    qname.space = 0;
    obj = 0;

    /*
        OPT. Could this encoding be optimized?
     */
    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        mprAssert(0);
        return 0;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        slotNum = t >> 2;
        if (0 <= slotNum && slotNum < ejsGetPropertyCount(ejs, ejs->global)) {
            obj = ejsGetProperty(ejs, ejs->global, slotNum);
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        qname.name = getString(ejs, fp, t >> 2);
        if (qname.name == 0) {
            mprAssert(0);
            return 0;
        }
        qname.space = getStringArg(ejs, fp);
        if (qname.space == 0) {
            return 0;
        }
        if (qname.name) {
            obj = ejsGetPropertyByName(ejs, ejs->global, qname);
        }
        break;
    }
    return obj;
}


static void callProperty(Ejs *ejs, EjsAny *obj, int slotNum, EjsAny *thisObj, int argc, int stackAdjust)
{
    EjsTrait    *trait;
    EjsFunction *fun;

    //  MOB -- rethink this.
    fun = ejsGetProperty(ejs, obj, slotNum);
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    if (trait && trait->attributes & EJS_TRAIT_GETTER) {
        fun = (EjsFunction*) ejsRunFunction(ejs, fun, thisObj, 0, NULL);
        if (ejs->exception) {
            return;
        }
    }
    callFunction(ejs, fun, thisObj, argc, stackAdjust);
}


/*
    Call a function. Supports both native and scripted functions. If native, the function is fully 
    invoked here. If scripted, a new frame is created and the pc adjusted to point to the new function.
 */
static void callFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, int stackAdjust)
{
    EjsState        *state;
    EjsFrame        *fp;
    EjsType         *type;
    EjsObj          **argv;
    EjsObj          **sp;
    int             count, i, fstate;

    mprAssert(fun);
    mprAssert(ejs->exception == 0);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);  

    state = ejs->state;

    if (unlikely(ejsIsType(ejs, fun))) {
        type = (EjsType*) fun;
        if (thisObj == NULL) {
            thisObj = ejsCreateObj(ejs, type, 0);
        }
        ejs->result = thisObj;
        if (!type->hasConstructor) {
            ejs->state->stack -= (argc + stackAdjust);
            if (ejs->exiting || mprIsStopping(ejs)) {
                ejsAttention(ejs);
            }
            return;
        }
        
    } else if (!ejsIsFunction(ejs, fun)) {
        if (fun == S(undefined)) {
            ejsThrowReferenceError(ejs, "Function is undefined");
            return;
        } else {
            ejsThrowReferenceError(ejs, "Reference is not a function");
            return;
        }
    }
//  XXX
#if UNUSED || 1
    if (thisObj == 0) {
        if ((thisObj = fun->boundThis) == 0) {
            thisObj = state->fp->function.boundThis;
        } 
    } 
#else
    if (thisObj == 0) {
        thisObj = fun->boundThis ? fun->boundThis : ejs->global;
    }
#endif
    if (fun->boundArgs) {
        mprAssert(ejsIs(ejs, fun->boundArgs, Array));
        count = fun->boundArgs->length;
        sp = &state->stack[1 - argc];
        for (i = argc - 1; i >= 0; i--) {
            sp[i + count] = sp[i];
        }
        for (i = 0; i < count; i++) {
            *sp++ = fun->boundArgs->data[i];
        }
        state->stack += count;
        argc += count;
    }
    
    //  MOB -- should already be factored in.
    mprAssert(ejs->spreadArgs == 0);
    argc += ejs->spreadArgs;
    ejs->spreadArgs = 0;
    
    /*
        Validate the args. Cast to the right type, handle rest args and return with argc adjusted.
     */
    argv = NULL;
    if (argc > 0 || fun->numArgs || fun->rest) {
        argv = &(state->stack[1 - argc]);
        if ((argc = validateArgs(ejs, fun, argc, argv)) < 0) {
            return;
        }
    }
    if (ejs->exception) {
        return;
    }
    if (ejsIsNativeFunction(ejs, fun)) {
        if (fun->body.proc == 0) {
            ejsThrowInternalError(ejs, "Native function is not defined: %@", fun->name);
            return;
        }
        ejsClearAttention(ejs);
fstate = state->frozen;
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
state->frozen = fstate;
        if (ejs->result == 0) {
            ejs->result = S(null);
        }
        state->stack -= (argc + stackAdjust);

    } else {
        mprAssert(thisObj);
        if ((fp = ejsCreateFrame(ejs, fun, thisObj, argc, argv)) == 0) {
            return;
        }
        fp->function.block.prev = state->bp;
        fp->caller = state->fp;
        fp->stackBase = state->stack;
        fp->stackReturn = state->stack - argc - stackAdjust;
        state->fp = fp;
        state->bp = (EjsBlock*) fp;
        ejsClearAttention(ejs);
    }
    //  MOB - is this the best place for this?
    mprAssert(ejs->state->fp);
    // mprAssert(!state->frozen);
}


static void throwNull(Ejs *ejs)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
}


/*
    Object can be an instance or a type. If an instance, then step to the immediate base type to begin the count.
 */
static EjsAny *getNthBase(Ejs *ejs, EjsAny *vp, int nthBase)
{
    EjsType     *type;

    if (vp) {
        if (ejsIsType(ejs, vp) || vp == ejs->global) {
            type = (EjsType*) vp;
        } else {
            type = TYPE(vp);
            nthBase--;
        }
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        if (nthBase > 0) {
            ejsThrowReferenceError(ejs, "Can't find correct base class");
            return 0;
        }
        vp = type;
    }
    return vp;
}


static EjsAny *getNthBaseFromBottom(Ejs *ejs, EjsAny *vp, int nthBase)
{
    EjsType     *type, *tp;
    int         count;

    if (vp) {
        if (ejsIsType(ejs, vp) || vp == ejs->global) {
            type = (EjsType*) vp;
        } else {
            type = TYPE(vp);
        }
        for (count = 0, tp = type->baseType; tp; tp = tp->baseType) {
            count++;
        }
        nthBase = count - nthBase;
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        vp = type;
    }
    return vp;
}


static EjsAny *getNthBlock(Ejs *ejs, int nth)
{
    EjsBlock    *block;

    mprAssert(ejs);
    mprAssert(nth >= 0);

    for (block = ejs->state->bp; block && --nth >= 0; ) {
        /* TODO - this is done for loading scripts into ejs. Really the compiler should remove these blocks */
        block = block->scope;
    }
    return block;
}


/*
    Enter a mesage into the log file
 */
void ejsLog(Ejs *ejs, const char *fmt, ...)
{
    va_list     args;
    char        buf[MPR_MAX_LOG_STRING];

    va_start(args, fmt);
    mprSprintfv(buf, sizeof(buf) - 1, fmt, args);
    va_end(args);
    mprLog(0, "%s", buf);
}


#if FUTURE

- Separate file

//  MOB - move into the mpr
#if BLD_CC_EDITLINE
static History  *cmdHistory;
static EditLine *eh; 
static cchar    *prompt;

static cchar *issuePrompt(EditLine *e) {
    return prompt;
}

static EditLine *initEditLine()
{
    EditLine    *e;
    HistEvent   ev; 

    cmdHistory = history_init(); 
    history(cmdHistory, &ev, H_SETSIZE, 100); 
    e = el_init("ejs", stdin, stdout, stderr); 
    el_set(e, EL_EDITOR, "vi");
    el_set(e, EL_HIST, history, cmdHistory);
    el_source(e, NULL);
    return e;
}


/*  
    Prompt for input with the level of current nest (block nest depth)
 */
static char *readline(cchar *msg) 
{ 
    HistEvent   ev; 
    cchar       *str; 
    char        *result;
    int         len, count; 
 
    if (eh == NULL) { 
        eh = initEditLine();
    }
    prompt = msg;
    el_set(eh, EL_PROMPT, issuePrompt);
    str = el_gets(eh, &count); 
    if (str && count > 0) { 
        result = strdup(str); 
        len = strlen(result);
        if (result[len - 1] == '\n') {
            result[len - 1] = '\0'; 
        }
        count = history(cmdHistory, &ev, H_ENTER, result); 
        return result; 
    }  
    return NULL; 
} 

#else

static char *readline(cchar *msg)
{
    char    buf[MPR_MAX_STRING];

    printf("%s", msg);
    if (fgets(buf, sizeof(buf) - 1, stdin) == 0) {
        return NULL;
    }
    return strdup(buf);
}
#endif


typedef struct EjsBreakpoint {
    cchar   *filename;
    int     lineNumber;
    int     opcode;    
} EjsBreakpoint;


static void bkpt(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsBreakpoints  *breakpoints;
    EjsOptable      *optable;
    int             len;
    uint            offset;
    static int      once = 0;
    static int      stop = 1;

    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;

    breakpoints = ejs->breakpoints;

    offset = (uint) (fp->pc - fp->function.body.code.byteCode) - 1;
    if (offset < 0) {
        offset = 0;
    }
    str = readline("edb> ");

    Display source with current line highlighted

    optable = ejsGetOptable();
    if (mprGetLogLevel(ejs) > 7) {
        mprPrintf(ejs, "%0s %04d: [%d] %02x: %-35s # %s:%d %@",
            mprGetCurrentThreadName(fp), offset, (int) (state->stack - fp->stackReturn),
            (uchar) opcode, optable[opcode].name, fp->filename, fp->lineNumber, fp->currentLine);
    if (stop && once++ == 0) {
        mprSleep(ejs, 0);
    }
    mprAssert(state->stack >= fp->stackReturn);
}
#endif


#if DEBUG_IDE
/*
    This code is only active when building in debug mode and debugging in an IDE
 */
static int ejsOpCount = 0;
static int doDebug = 1;

static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsOptable      *optable;
    int             offset;
#if UNUSED
    static int      showFrequency = 1;
#endif

    MPR_VERIFY_MEM();
    mprAssert(!MPR->marking);
    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;

    if (ejs->initialized && doDebug) {
        offset = (int) (fp->pc - fp->function.body.code->byteCode) - 1;
        if (offset < 0) {
            offset = 0;
        }
        optable = ejsGetOptable();
        fp->line = ejsGetDebugLine(ejs, (EjsFunction*) fp, fp->pc);
#if UNUSED
        if (showFrequency && ((once % 1000) == 999)) {
            ejsShowOpFrequency(ejs);
        }
#endif
        mprAssert(state->stack >= fp->stackReturn);
    }
    ejsOpCount++;
    return opcode;
}


#if UNUSED
void ejsShowOpFrequency(Ejs *ejs)
{
    EjsOptable      *optable;
    int             i;

    if (mprGetLogLevel(ejs) < 6) {
        return;
    }
    optable = ejsGetOptable();
    mprLog(0, "Opcode Frequency");
    for (i = 0; i < 256 && optable[i].name; i++) {
        mprLog(6, "%4d %24s %8d", (uchar) i, optable[i].name, opcount[i]);
    }
}
#endif

#endif /* BLD_DEBUG */


/*
    Cleanup defines for combo builds
 */
#undef top
#undef pop
#undef push
#undef popString
#undef popOutside
#undef pushOutside
#undef FRAME
#undef FUNCTION
#undef BLOCK
#undef SWAP
#undef GET_SLOT
#undef SET_SLOT
#undef GET_BYTE
#undef GET_DOUBLE
#undef GET_INT
#undef GET_NUM
#undef GET_NAME
#undef GET_STRING
#undef GET_TYPE
#undef GET_WORD
#undef THIS
#undef FILL
#undef CASE
#undef BREAK

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsInterp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsLoader.c"
 */
/************************************************************************/

/**
    ejsLoader.c - Ejscript module file file loader

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int  addFixup(Ejs *ejs, EjsModule *mp, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup);
static int  alreadyLoaded(Ejs *ejs, EjsString *name, int minVersion, int maxVersion);
static EjsLoadState *createLoadState(Ejs *ejs, int flags);
static EjsTypeFixup *createFixup(Ejs *ejs, EjsModule *mp, EjsName qname, int slotNum);
static int  fixupTypes(Ejs *ejs, MprList *list);
static EjsObj *getCurrentBlock(EjsModule *mp);
static int  getVersion(cchar *name);
static int  initializeModule(Ejs *ejs, EjsModule *mp);
static int  loadBlockSection(Ejs *ejs, EjsModule *mp);
static int  loadClassSection(Ejs *ejs, EjsModule *mp);
static int  loadDependencySection(Ejs *ejs, EjsModule *mp);
static int  loadDocSection(Ejs *ejs, EjsModule *mp);
static int  loadEndBlockSection(Ejs *ejs, EjsModule *mp);
static int  loadEndFunctionSection(Ejs *ejs, EjsModule *mp);
static int  loadEndClassSection(Ejs *ejs, EjsModule *mp);
static int  loadEndModuleSection(Ejs *ejs, EjsModule *mp);
static int  loadDebugSection(Ejs *ejs, EjsModule *mp);
static int  loadExceptionSection(Ejs *ejs, EjsModule *mp);
static int  loadFunctionSection(Ejs *ejs, EjsModule *mp);
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags);
static int  loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *path);
static int  loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags);
static int  loadPropertySection(Ejs *ejs, EjsModule *mp, int sectionType);
static int  loadScriptModule(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags);
static char *makeModuleName(cchar *name);
static void popScope(EjsModule *mp, int keepScope);
static void pushScope(EjsModule *mp, EjsAny *block, EjsAny *obj);
static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion);
static int  trimModule(Ejs *ejs, char *name);
static void setDoc(Ejs *ejs, EjsModule *mp, cchar *tag, void *vp, int slotNum);

/**
    Load a module file and return a list of the loaded modules. This is used to load scripted module files with
    optional native (shared / DLL) implementations. If loading a scripted module that has native declarations, a
    search for the corresponding native DLL will be performed and both scripted and native module files will be loaded.
    NOTE: this may recursively call itself as it loads dependent modules.

    @param ejs Ejs handle
    @param path Module name or path to load. May be "." separated path. May include or omit the ".mod" extension.
    @param minVersion Minimum acceptable version (inclusive). Set to zero for unversioned.
    @param maxVersion Maximum acceptable version (inclusive). Set to -1 for all versions.
    @param flags Reserved. Must be set to zero.
    @param modulesArg List of modules loaded. Will only return a list if successful and doing a top level load. 
        When ejsLoadModule is called to load dependant modules, not list of modules will be returned.
        The final list of modules aggregates all modules loaded including those from dependant modules.
    @return Returns the last loaded module.
 */
int ejsLoadModule(Ejs *ejs, EjsString *path, int minVersion, int maxVersion, int flags)
{
    char    *trimmedPath, *name;
    int     status, version;

    mprAssert(path);

    /*
        Note the cannonical name for a module is the basename of the module without extension
     */
    trimmedPath = sclone(ejsToMulti(ejs, path));
    if ((version = trimModule(ejs, trimmedPath)) != 0) {
        minVersion = maxVersion = version;
    }
    name = mprGetPathBase(trimmedPath);

    if (flags & EJS_LOADER_RELOAD ||
            (status = alreadyLoaded(ejs, ejsCreateStringFromAsc(ejs, name), minVersion, maxVersion)) == 0) {
        status = loadScriptModule(ejs, trimmedPath, minVersion, maxVersion, flags);
    }
    return status;
}


static int initializeModule(Ejs *ejs, EjsModule *mp)
{
    EjsNativeModule     *nativeModule;
    int                 priorGen, old;

    priorGen = 0;

    if (mp->hasNative && !mp->configured) {
        /*
            See if a native module initialization routine has been registered. If so, use that. Otherwise, look
            for a backing shared library.
         */
        if ((nativeModule = ejsLookupNativeModule(ejs, ejsToMulti(ejs, mp->name))) == 0) {
            loadNativeLibrary(ejs, mp, mp->path);
            nativeModule = ejsLookupNativeModule(ejs, ejsToMulti(ejs, mp->name));
            if (nativeModule == NULL) {
                if (ejs->exception == 0) {
                    ejsThrowIOError(ejs, "Can't load or initialize the native module file \"%s\"", mp->path);
                }
                return MPR_ERR_CANT_INITIALIZE;
            }
            if (!(ejs->flags & EJS_FLAG_NO_INIT)) {
                if (nativeModule->checksum != mp->checksum) {
                    ejsThrowIOError(ejs, "Module \"%s\" does not match native code (%d, %d)", mp->path, 
                            nativeModule->checksum, mp->checksum);
                    return MPR_ERR_BAD_STATE;
                }
            }
        }
        if (nativeModule && (nativeModule->callback)(ejs) < 0) {
            return MPR_ERR_CANT_INITIALIZE;
        }
        if (ejs->hasError || ST(Error) == 0 || mprHasMemError(ejs)) {
            if (!ejs->exception) {
                ejsThrowIOError(ejs, "Initialization error for %s (%d, %d)", mp->path, ejs->hasError, mprHasMemError(ejs));
            }
            return MPR_ERR_CANT_INITIALIZE;
        }
    }
    mp->configured = 1;
    old = ejsFreeze(ejs, 1);
    if (ejsRunInitializer(ejs, mp) == 0) {
        ejsFreeze(ejs, old);
        return MPR_ERR_CANT_INITIALIZE;
    }
    ejsFreeze(ejs, old);
    return 0;
}


static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion) 
{
    char        *path;

    mprAssert(filename && *filename);

    if ((path = ejsSearchForModule(ejs, filename, minVersion, maxVersion)) == 0) {
        mprLog(2, "Can't find module file \"%s\"", filename);
        if (minVersion <= 0 && maxVersion <= 0) {
            ejsThrowReferenceError(ejs,  "Can't find module file \"%s\"", filename);
        } else if (minVersion == 0 && maxVersion == EJS_MAX_VERSION) {
            ejsThrowReferenceError(ejs,  "Can't find module file \"%s\"", filename);
        } else {
            ejsThrowReferenceError(ejs,  "Can't find module file \"%s\", min version %d.%d.%d, max version %d.%d.%d", 
                filename, 
                EJS_MAJOR(minVersion), EJS_MINOR(minVersion), EJS_PATCH(minVersion),
                EJS_MAJOR(maxVersion), EJS_MINOR(maxVersion), EJS_PATCH(maxVersion));
        }
        return 0;
    }
    return path;
}


/*
    Load the sections: modules, classes, properties and functions from a module file. May load muliple logical modules.
 */
static int loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags)
{
    EjsModule   *mp;
    int         next, rc, sectionType, created, firstModule, status;

    created = 0;
    mp = 0;
    firstModule = mprGetListLength(ejs->modules);

    while ((sectionType = mprGetFileChar(file)) >= 0) {
        if (sectionType < 0 || sectionType >= EJS_SECT_MAX) {
            mprError("Bad section type %d in %@", sectionType, mp->name);
            return MPR_ERR_CANT_LOAD;
        }
        mprLog(9, "Load section type %d", sectionType);
        mprAssert(mp == NULL || mp->scope == NULL || mp->scope != mp->scope->scope);

        rc = 0;
        switch (sectionType) {

        case EJS_SECT_BLOCK:
            rc = loadBlockSection(ejs, mp);
            break;

        case EJS_SECT_BLOCK_END:
            rc = loadEndBlockSection(ejs, mp);
            break;

        case EJS_SECT_CLASS:
            rc = loadClassSection(ejs, mp);
            break;

        case EJS_SECT_CLASS_END:
            rc = loadEndClassSection(ejs, mp);
            break;

        case EJS_SECT_DEBUG:
            rc = loadDebugSection(ejs, mp);
            break;

        case EJS_SECT_DEPENDENCY:
            rc = loadDependencySection(ejs, mp);
            mp->firstGlobal = ejsGetPropertyCount(ejs, ejs->global);
            break;

        case EJS_SECT_EXCEPTION:
            rc = loadExceptionSection(ejs, mp);
            break;

        case EJS_SECT_FUNCTION:
            rc = loadFunctionSection(ejs, mp);
            break;

        case EJS_SECT_FUNCTION_END:
            rc = loadEndFunctionSection(ejs, mp);
            break;

        case EJS_SECT_MODULE:
            if ((mp = loadModuleSection(ejs, file, hdr, &created, flags)) == 0) {
                return MPR_ERR_CANT_LOAD;
            }
            ejsAddModule(ejs, mp);
            mp->path = sclone(path);
            mp->file = file;
            mp->firstGlobal = (ejs->initialized) ? ejsGetPropertyCount(ejs, ejs->global) : 0;
            break;

        case EJS_SECT_MODULE_END:
            rc = loadEndModuleSection(ejs, mp);
            mp->lastGlobal = ejsGetPropertyCount(ejs, ejs->global);
            break;

        case EJS_SECT_PROPERTY:
            rc = loadPropertySection(ejs, mp, sectionType);
            break;

        case EJS_SECT_DOC:
            rc = loadDocSection(ejs, mp);
            break;

        default:
            return MPR_ERR_CANT_LOAD;
        }
        if (rc < 0) {
            if (mp && mp->name && created) {
                ejsRemoveModule(ejs, mp);
            }
            return rc;
        }
    }
    status = 0;
    for (next = firstModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
        if (mp->loadState) {
            if (fixupTypes(ejs, mp->loadState->typeFixups) < 0) {
                return MPR_ERR_CANT_LOAD;
            }
            mp->loadState = 0;
        }
        //  TODO rationalize down to just ejs flag
        if (!ejs->empty && !(flags & EJS_LOADER_NO_INIT) && !(ejs->flags & EJS_FLAG_NO_INIT)) {
            if (!mp->initialized) {
                if ((status = initializeModule(ejs, mp)) < 0) {
                    break;
                }
            }
        }
    }
    if (ejs->loaderCallback && !ejs->exception) {
        (ejs->loaderCallback)(ejs, EJS_SECT_END, ejs->modules, firstModule);
    }
    return status;
}


/*
    Load a module section and constant pool.
    poolCount is the number of strings. poolSize is the size of the entire pool in bytes.
 */
static EjsConstants *loadConstants(Ejs *ejs, MprFile *file, int poolCount, int poolSize)
{
    EjsConstants    *constants;
    char            *pp;
    int             i;

    if ((constants = ejsCreateConstants(ejs, poolCount, poolSize)) == 0) {
        return 0;
    }
    if (mprReadFile(file, constants->pool, poolSize) != poolSize) {
        return 0;
    }
    constants->poolLength = poolSize;
    constants->indexCount = poolCount;
    for (pp = constants->pool, i = 1; pp < &constants->pool[constants->poolLength]; i++) {
        constants->index[i] = (void*) (((pp - constants->pool) << 1) | 0x1);
        pp += slen(pp) + 1;
    }
    return constants;
}


/*
    Load a module section and constant pool.
 */
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags)
{
    EjsModule       *mp, tmod;
    EjsConstants    *constants;
    EjsString       *name;
    int             version, checksum, poolSize, poolCount, nameToken;

    mprAssert(created);

    *created = 0;
    checksum = 0;

    /*
        We don't have the constant pool yet so we cant resolve the nameToken yet.
     */
    mp = &tmod;
    memset(&tmod, 0, sizeof(tmod));
    mp->file = file;
    nameToken = ejsModuleReadInt(ejs, mp);
    version   = ejsModuleReadInt(ejs, mp);
    checksum  = ejsModuleReadInt32(ejs, mp);
    poolSize  = ejsModuleReadInt(ejs, mp);
    poolCount = ejsModuleReadInt(ejs, mp);

    if (mp->hasError || poolSize <= 0 || poolSize > EJS_MAX_POOL) {
        return 0;
    }
    if (nameToken < 0 || nameToken >= poolSize) {
        mprAssert(0);
        return 0;
    }
    if ((constants = loadConstants(ejs, file, poolCount, poolSize)) == 0) {
        return 0;
    }
    mp->constants = constants;
    name = ejsCreateStringFromConst(ejs, mp, nameToken);
    if ((mp = ejsCreateModule(ejs, name, version, constants)) == NULL) {
        return 0;
    }
    mp->current = mprCreateList(-1, 0);
#if UNUSED
    pushScope(mp, ejs->global, ejs->global);
#else
    pushScope(mp, 0, ejs->global);
#endif
    mp->checksum = checksum;
    *created = 1;

    mp->file = file;
    mp->flags = flags;
    mp->loadState = createLoadState(ejs, flags);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE, mp);
    }
    mprLog(9, "Load module section %@", name);
    return mp;
}


static int loadEndModuleSection(Ejs *ejs, EjsModule *mp)
{
    mprLog(9, "End module section %@", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE_END, mp);
    }
    mprAssert(mprGetListLength(mp->current) == 1);
    mp->current = 0;
    mp->file = 0;
    return 0;
}


static int loadDependencySection(Ejs *ejs, EjsModule *mp)
{
    EjsModule   *module;
    EjsString   *name;
    void        *saveCallback;
    int         next, rc, minVersion, maxVersion, checksum, nextModule;

    mprAssert(ejs);
    mprAssert(mp);

    name = ejsModuleReadConst(ejs, mp);
    checksum  = ejsModuleReadInt(ejs, mp);
    minVersion = ejsModuleReadInt(ejs, mp);
    maxVersion = ejsModuleReadInt(ejs, mp);
    
    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (ejsLookupModule(ejs, name, minVersion, maxVersion) == 0) {
        saveCallback = ejs->loaderCallback;
        nextModule = mprGetListLength(ejs->modules);
        ejs->loaderCallback = NULL;

        mprLog(6, "    Load dependency section %@", name);
        rc = loadScriptModule(ejs, ejsToMulti(ejs, name), minVersion, maxVersion, mp->flags | EJS_LOADER_DEP);
        ejs->loaderCallback = saveCallback;
        if (rc < 0) {
            return rc;
        }
        if (mp->dependencies == 0) {
            mp->dependencies = mprCreateList(-1, 0);
        }
        for (next = nextModule; (module = mprGetNextItem(ejs->modules, &next)) != 0; ) {
            mprAddItem(mp->dependencies, module);
            if (ejs->loaderCallback) {
                (ejs->loaderCallback)(ejs, EJS_SECT_DEPENDENCY, mp, module);
            }
        }
    }
    if ((module = ejsLookupModule(ejs, name, minVersion, maxVersion)) != 0) {
        if (checksum != module->checksum) {
            ejsThrowIOError(ejs, "Can't load module \"%@\" due to checksum mismatch.\n"
                "The program was compiled depending on a different version of module \"%@\".", mp->name, name);
            return MPR_ERR_BAD_STATE;
        }
    }
    return 0;
}


static int loadBlockSection(Ejs *ejs, EjsModule *mp)
{
    EjsBlock    *bp;
    EjsObj      *current;
    EjsName     qname;
    int         slotNum, numSlot;

    qname.space = ejsCreateStringFromAsc(ejs, EJS_BLOCK_NAMESPACE);
    qname.name = ejsModuleReadConst(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    numSlot = ejsModuleReadInt(ejs, mp);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    bp = ejsCreateBlock(ejs, numSlot);
    mprSetName(bp, MPR_NAME("block"));
    current = getCurrentBlock(mp);

    /*
        TODO - replace this strict mode with dont-delete on a per property basis. Redefinition is then okay if the
        property to be replaced is !dont-delete
     */
    if (mp->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, qname) >= 0) {
            ejsThrowReferenceError(ejs, "Block \"%@\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    slotNum = ejsDefineProperty(ejs, current, slotNum, qname, ST(Block), 0, bp);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK, mp, current, slotNum, qname.name, numSlot, bp);
    }
    pushScope(mp, bp, bp);
    return 0;
}


static int loadEndBlockSection(Ejs *ejs, EjsModule *mp)
{
    mprLog(9, "    End block section %@", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK_END, mp);
    }
    popScope(mp, 0);
    return 0;
}


static int loadClassSection(Ejs *ejs, EjsModule *mp)
{
    EjsType         *type, *baseType, *iface;
    EjsTypeFixup    *fixup, *ifixup;
    EjsName         qname, baseClassName, ifaceClassName;
    int             attributes, numTypeProp, numInstanceProp, numInterfaces, i, slotNum;

    fixup = 0;
    ifixup = 0;
    
    qname = ejsModuleReadName(ejs, mp);
    attributes = ejsModuleReadInt(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    ejsModuleReadType(ejs, mp, &baseType, &fixup, &baseClassName, 0);
    numTypeProp = ejsModuleReadInt(ejs, mp);
    numInstanceProp = ejsModuleReadInt(ejs, mp);
    numInterfaces = ejsModuleReadInt(ejs, mp);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (mp->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, ejs->global, qname) >= 0) {
            ejsThrowReferenceError(ejs, "Class \"%@\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    if (fixup || (baseType && baseType->needFixup)) {
        attributes |= EJS_TYPE_FIXUP;
    }
    type = ejsGetPropertyByName(ejs, ejs->service->foundation, qname);

    if (attributes & EJS_TYPE_FIXUP) {
        baseType = 0;
        if (fixup == 0) {
            fixup = createFixup(ejs, mp, (baseType) ? baseType->qname : ST(Object)->qname, -1);
        }
    }
    mprLog(9, "    Load %@ class %@ for module %@ at slotNum %d", qname.space, qname.name, mp->name, slotNum);

    if (type == 0) {
        type = ejsCreateType(ejs, qname, mp, baseType, NULL, sizeof(EjsPot), -1, numTypeProp, numInstanceProp, 
            attributes);
        if (type == 0) {
            ejsThrowInternalError(ejs, "Can't create class %@", qname.name);
            return MPR_ERR_BAD_STATE;
        }
        ejsClonePotHelpers(ejs, type);

    } else {
        if (ejsConfigureType(ejs, type, mp, baseType, numTypeProp, numInstanceProp, attributes) < 0) {
            ejsThrowInternalError(ejs, "Can't configure class %@", qname.name);
            return MPR_ERR_BAD_STATE;
        }
        mp->hasNative = 1;
#if FUTURE
        /*
            Currently errors on Namespace
         */
        if (attributes & EJS_TYPE_HAS_CONSTRUCTOR && !type->hasConstructor) {
            mprError("WARNING: module indicates a constructor required but none exists for \"%@\"", type->qname.name);
        }
#endif
#if UNUSED && KEEP
        if (!type->native) {
            mprError("WARNING: type not defined as native: \"%@\"", type->qname.name);
        }
#endif
    }
    
    /*
        Read implemented interfaces. Add to type->implements. Create fixup record if the interface type is not yet known.
     */
    if (numInterfaces > 0) {
        type->implements = mprCreateList(numInterfaces, 0);
        for (i = 0; i < numInterfaces; i++) {
            if (ejsModuleReadType(ejs, mp, &iface, &ifixup, &ifaceClassName, 0) < 0) {
                return MPR_ERR_CANT_READ;
            }
            if (iface) {
                mprAddItem(type->implements, iface);
            } else if (addFixup(ejs, mp, EJS_FIXUP_INTERFACE_TYPE, (EjsObj*) type, -1, ifixup) < 0) {
                ejsThrowMemoryError(ejs);
                return MPR_ERR_MEMORY;
            }
        }
    }
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, qname, ST(Type), attributes, (EjsObj*) type);
    if (slotNum < 0) {
        ejsThrowMemoryError(ejs);
        return MPR_ERR_MEMORY;
    }
    type->module = mp;

    if (fixup) {
        if (addFixup(ejs, mp, EJS_FIXUP_BASE_TYPE, (EjsObj*) type, -1, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_MEMORY;
        }
    }
    setDoc(ejs, mp, "class", ejs->global, slotNum);
    pushScope(mp, type, type);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS, mp, slotNum, qname, type, attributes);
    }
    return 0;
}


static int loadEndClassSection(Ejs *ejs, EjsModule *mp)
{
    EjsType     *type;

    mprLog(9, "    End class section");

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS_END, mp, mp->scope);
    }
    type = (EjsType*) mp->scope;
    if (type->hasScriptFunctions) {
        type->hasScriptFunctions = 1;
    }
    if (type->hasScriptFunctions && type->baseType) {
        ejsDefineTypeNamespaces(ejs, type);
    }
    popScope(mp, 0);
    if (type->dynamicInstances) {
        type->mutableInstances = 1;
    }
#if UNUSED && KEEP
    mprLog(0, "Type %N is %s and has %s instances", type->qname, (type->mutable) ? "mutable" : "immutable", type->mutableInstances ? "mutable" : "immutable");
#endif
    return 0;
}


static int loadFunctionSection(Ejs *ejs, EjsModule *mp)
{
    EjsType         *returnType, *currentType;
    EjsTypeFixup    *fixup;
    EjsFunction     *fun;
    EjsName         qname, returnTypeName;
    EjsPot          *block;
    uchar           *code;
    int             slotNum, numProp, numArgs, numDefault, codeLen, numExceptions, attributes, strict, sn;

    strict = 0;
    qname = ejsModuleReadName(ejs, mp);
    attributes = ejsModuleReadInt(ejs, mp);
    strict = ejsModuleReadByte(ejs, mp);
    ejsModuleReadType(ejs, mp, &returnType, &fixup, &returnTypeName, 0);
    slotNum = ejsModuleReadInt(ejs, mp);
    numProp = ejsModuleReadInt(ejs, mp);
    numArgs = ejsModuleReadInt(ejs, mp);
    numDefault = ejsModuleReadInt(ejs, mp);
    numExceptions = ejsModuleReadInt(ejs, mp);
    codeLen = ejsModuleReadInt(ejs, mp);
    
    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    block = (EjsPot*) getCurrentBlock(mp);
    currentType = 0;
    if (ejsIsType(ejs, block)) {
        currentType = (EjsType*) block;
        if (!(attributes & (EJS_FUN_CONSTRUCTOR | EJS_PROP_STATIC))) {
            block = ((EjsType*) currentType)->prototype;
        }
    }
    mprAssert(block);
    mprAssert(numArgs >= 0 && numArgs < EJS_MAX_ARGS);
    mprAssert(numExceptions >= 0 && numExceptions < EJS_MAX_EXCEPTIONS);

    mprLog(9, "Loading function %N at slot %d", qname, slotNum);

    /*
        Read the code
     */
    if (codeLen > 0) {
        if ((code = mprAlloc(codeLen)) == 0) {
            return MPR_ERR_MEMORY;
        }
        if (mprReadFile(mp->file, code, codeLen) != codeLen) {
            return MPR_ERR_CANT_READ;
        }
        if (currentType) {
            currentType->hasScriptFunctions = 1;
        }
    } else {
        code = 0;
    }
    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
    if (attributes & EJS_FUN_MODULE_INITIALIZER) {
        mp->hasInitializer = 1;
    }
    if (attributes & EJS_FUN_CONSTRUCTOR) {
        fun = (EjsFunction*) block;
        ejsInitFunction(ejs, fun, qname.name, code, codeLen, numArgs, numDefault, numExceptions, returnType, 
            attributes, mp, NULL, strict);
        mprAssert(fun->isConstructor);

    } else {
        if (mp->loadState->flags & EJS_LOADER_STRICT) {
            if ((sn = ejsLookupProperty(ejs, block, qname)) >= 0 && !(attributes & EJS_FUN_OVERRIDE)) {
                if (!(attributes & EJS_TRAIT_SETTER && ejsPropertyHasTrait(ejs, block, sn, EJS_TRAIT_GETTER))) {
                    if (ejsIsType(ejs, block)) {
                        ejsThrowReferenceError(ejs,
                            "function \"%@\" already defined in type \"%@\". Add \"override\" to the function declaration.", 
                            qname.name, ((EjsType*) block)->qname.name);
                    } else {
                        ejsThrowReferenceError(ejs,
                            "function \"%@\" already defined. Try adding \"override\" to the function declaration.", 
                            qname.name);
                    }
                    return MPR_ERR_CANT_CREATE;
                }
            }
        }
        fun = ejsCreateFunction(ejs, qname.name, code, codeLen, numArgs, numDefault, numExceptions, returnType, attributes, 
            mp, mp->scope, strict);
        if (fun == 0) {
            return MPR_ERR_MEMORY;
        }
    }
    mprAssert(fun->block.pot.isBlock);
    mprAssert(fun->block.pot.isFunction);

    if (numProp > 0) {
        fun->activation = ejsCreateActivation(ejs, fun, numProp);
    }
    if (block == ejs->global && slotNum < 0) {
        if (attributes & EJS_FUN_OVERRIDE) {
            slotNum = ejsLookupProperty(ejs, block, qname);
            if (slotNum < 0) {
                mprError("Can't find method \"%@\" to override", qname.name);
                return MPR_ERR_MEMORY;
            }

        } else {
            slotNum = -1;
        }
    }
    if (!(attributes & EJS_FUN_CONSTRUCTOR)) {
        if (attributes & EJS_FUN_MODULE_INITIALIZER && block == ejs->global) {
            mp->initializer = fun;
            slotNum = -1;
        } else {
            slotNum = ejsDefineProperty(ejs, block, slotNum, qname, ST(Function), attributes, fun);
            if (slotNum < 0) {
                return MPR_ERR_MEMORY;
            }
        }
    }
    if (fixup) {
        mprAssert(returnType == 0);
        if (addFixup(ejs, mp, EJS_FIXUP_RETURN_TYPE, (EjsObj*) fun, -1, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_MEMORY;
        }
    }
    if (currentType && attributes & EJS_FUN_CONSTRUCTOR) {
        setDoc(ejs, mp, "fun", ejs->global, ejsLookupProperty(ejs, ejs->global, currentType->qname));
    } else {
        setDoc(ejs, mp, "fun", block, slotNum);
    }

    mp->currentMethod = fun;
    pushScope(mp, ejsIsType(ejs, fun) ? NULL : fun, fun->activation);
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION, mp, block, slotNum, qname, fun, attributes);
    }
    return 0;
}


static int loadEndFunctionSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;

    mprLog(9, "    End function section");

    fun = (EjsFunction*) mp->scope;
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION_END, mp, fun);
    }
    popScope(mp, ejsIsType(ejs, fun));
    return 0;
}


static int loadDebugSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;
    int             size;

    fun = mp->currentMethod;
    mprAssert(fun);

    /* 
        Note the location in the file and skip over
     */
    mprAssert(!fun->isNativeProc);
    size = ejsModuleReadInt32(ejs, mp);
    fun->body.code->debugOffset = (int) mprGetFilePosition(mp->file);
    mprSeekFile(mp->file, SEEK_CUR, size);
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_DEBUG, mp, fun);
    }
    return 0;
}


static int loadExceptionSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;
    EjsType         *catchType;
    EjsTypeFixup    *fixup;
    EjsCode         *code;
    EjsEx           *ex;
    int             tryStart, tryEnd, handlerStart, handlerEnd, numBlocks, numStack, flags, i;

    fun = mp->currentMethod;
    mprAssert(fun);

    flags = 0;
    code = fun->body.code;

    for (i = 0; i < code->numHandlers; i++) {
        flags        = ejsModuleReadByte(ejs, mp);
        tryStart     = ejsModuleReadInt(ejs, mp);
        tryEnd       = ejsModuleReadInt(ejs, mp);
        handlerStart = ejsModuleReadInt(ejs, mp);
        handlerEnd   = ejsModuleReadInt(ejs, mp);
        numBlocks    = ejsModuleReadInt(ejs, mp);
        numStack     = ejsModuleReadInt(ejs, mp);
        ejsModuleReadType(ejs, mp, &catchType, &fixup, 0, 0);
        if (mp->hasError) {
            return MPR_ERR_CANT_READ;
        }
        ex = ejsAddException(ejs, fun, tryStart, tryEnd, catchType, handlerStart, handlerEnd, numBlocks, numStack, flags, i);
        if (fixup) {
            mprAssert(catchType == 0);
            if (addFixup(ejs, mp, EJS_FIXUP_EXCEPTION, (EjsObj*) ex, 0, fixup) < 0) {
                mprAssert(0);
                return MPR_ERR_MEMORY;
            }
        }
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_EXCEPTION, mp, fun);
    }
    return 0;
}


static int loadPropertySection(Ejs *ejs, EjsModule *mp, int sectionType)
{
    EjsType         *type, *ctype;
    EjsTypeFixup    *fixup;
    EjsName         qname, propTypeName;
    EjsObj          *current, *value;
    int             slotNum, attributes, fixupKind;

    value = 0;
    current = getCurrentBlock(mp);
    qname = ejsModuleReadName(ejs, mp);
    
    attributes = ejsModuleReadInt(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    ejsModuleReadType(ejs, mp, &type, &fixup, &propTypeName, 0);

    /*
        This is used for namespace values. It is required when compiling (only) and thus module init code is not 
        being run -- but we still need the value of the namespace if a script wants to declare a variable qualified
        by the namespace that is defined in the module.
     */
    if (attributes & EJS_PROP_HAS_VALUE) {
        EjsString  *str;
        if ((str = ejsModuleReadConst(ejs, mp)) == 0) {
            return MPR_ERR_CANT_READ;
        }
        /*  Only doing for namespaces currently */
        value = (EjsObj*) ejsCreateNamespace(ejs, str);
    }
    mprLog(9, "Loading property %N at slot %d", qname, slotNum);

    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
    if (mp->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, qname) >= 0) {
            ejsThrowReferenceError(ejs, "property \"%@\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    if (ejsIsType(ejs, current)) {
        ctype = (EjsType*) current;
        if (!(attributes & EJS_TRAIT_READONLY)) {
            if (attributes & EJS_PROP_STATIC) {
                ctype->mutable = 1;
            } else {
                ctype->mutableInstances = 1;
            }
        }
        if (!(attributes & EJS_PROP_STATIC) && current != ejs->global && ctype->prototype) {
            current = (EjsObj*) ((EjsType*) current)->prototype;
        }
    }
    slotNum = ejsDefineProperty(ejs, current, slotNum, qname, type, attributes, value);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (fixup) {
        if (ejsIsFunction(ejs, current)) {
            fixupKind = EJS_FIXUP_LOCAL;
        } else if (ejsIsType(ejs, current) && !(attributes & EJS_PROP_STATIC) && current != ejs->global) {
            mprAssert(((EjsType*) current)->prototype);
            current = (EjsObj*) ((EjsType*) current)->prototype;
            fixupKind = EJS_FIXUP_INSTANCE_PROPERTY;
        } else {
            fixupKind = EJS_FIXUP_TYPE_PROPERTY;
        }
        mprAssert(type == 0);
        if (addFixup(ejs, mp, fixupKind, current, slotNum, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_MEMORY;
        }
    }
    setDoc(ejs, mp, "var", current, slotNum);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_PROPERTY, mp, current, slotNum, qname, attributes, propTypeName);
    }
    return 0;
}


static int loadDocSection(Ejs *ejs, EjsModule *mp)
{
    EjsString   *doc;

    mprLog(9, "    Documentation section");

    doc = ejsModuleReadConst(ejs, mp);

    if (ejs->flags & EJS_FLAG_DOC) {
        mp->doc = doc;
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_DOC, doc);
        }
    }
    return 0;
}


/*
    Check if a native module exists at the given path. If so, load it. If the path is a scripted module
    but has a corresponding native module, then load that.
 */
static int loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *modPath)
{
    MprModule   *native;
    char        *bare, *path, *moduleName, initName[MPR_MAX_PATH], *cp;

    /*
        Replace ".mod" with ".so", ".dll" or ".dylib"
     */
    bare = sclone(modPath);
    if ((cp = strrchr(bare, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    path = sjoin(bare, BLD_SHOBJ, NULL);

    if (! mprPathExists(path, R_OK)) {
        mprError("Native module not found %s", path);
        return MPR_ERR_CANT_ACCESS;
    }

    /*
        Build the DSO entry point name. Format is "Name_ModuleInit" where Name has "." converted to "_"
        Typical name: ejs_io_Init or com_acme_rockets_Init
     */
    moduleName = (char*) ejsToMulti(ejs, mp->name);
    moduleName[0] = tolower((int) moduleName[0]);
    mprSprintf(initName, sizeof(initName), "%s_Init", moduleName);
    for (cp = initName; *cp; cp++) {
        if (*cp == '.') {
            *cp = '_';
        }
    }
    mprLog(5, "Loading native module %s", path);
    native = mprCreateModule(mp->name->value, path, initName, ejs);
    if (mprLoadModule(native) < 0) {
        return MPR_ERR_CANT_READ;
    }
    return 0;
}


static int loadScriptModule(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags)
{
    EjsModuleHdr    hdr;
    EjsModule       *mp;
    MprFile         *file;
    char            *path;
    int             next, status, firstModule;

    mprAssert(filename && *filename);
    mprAssert(ejs->exception == 0);

    if ((path = search(ejs, filename, minVersion, maxVersion)) == 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    if ((file = mprOpenFile(path, O_RDONLY | O_BINARY, 0666)) == NULL) {
        ejsThrowIOError(ejs, "Can't open module file %s", path);
        return MPR_ERR_CANT_OPEN;
    }
    mprLog(5, "Loading module %s", path);
    mprEnableFileBuffering(file, 0, 0);
    firstModule = mprGetListLength(ejs->modules);

    /*
        Read module file header
     */
    status = 0;
    if ((mprReadFile(file, &hdr, sizeof(hdr))) != sizeof(hdr)) {
        ejsThrowIOError(ejs, "Can't read module file %s, corrupt header", path);
        status = MPR_ERR_CANT_LOAD;

    } else if ((int) ejsSwapInt32(ejs, hdr.magic) != EJS_MODULE_MAGIC) {
        ejsThrowIOError(ejs, "Bad module file format in %s", path);
        status = MPR_ERR_CANT_LOAD;

    } else if (ejsSwapInt32(ejs, hdr.fileVersion) != EJS_MODULE_VERSION) {
        ejsThrowIOError(ejs, "Incompatible module file format in %s", path);
        status = MPR_ERR_CANT_LOAD;

    } else {
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_START, path, &hdr);
        }
        if ((status = loadSections(ejs, file, path, &hdr, flags)) < 0) {
            if (ejs->exception == 0) {
                ejsThrowReferenceError(ejs, "Can't load module file %s", path);
                status = MPR_ERR_CANT_LOAD;
            }
        }
    }
    if (status) {
        for (next = firstModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
            ejsRemoveModule(ejs, mp);
        }
    }
    mprCloseFile(file);
    return status;
}


static int fixupTypes(Ejs *ejs, MprList *list)
{
    EjsTypeFixup    *fixup;
    EjsModule       *mp;
    EjsType         *type, *targetType;
    EjsTrait        *trait;
    EjsFunction     *targetFunction;
    EjsEx           *targetException;
    int             next;

    for (next = 0; (fixup = (EjsTypeFixup*) mprGetNextItem(list, &next)) != 0; ) {
        mp = 0;
        type = 0;
        if (fixup->typeSlotNum >= 0) {
            type = ejsGetProperty(ejs, ejs->global, fixup->typeSlotNum);
        } else if (fixup->typeName.name) {
            mprAssert(fixup->typeSlotNum < 0);
            type = ejsGetPropertyByName(ejs, ejs->global, fixup->typeName);
        } else {
            continue;
        }
        if (type == 0) {
            if (fixup->typeName.name) {
                ejsThrowReferenceError(ejs, "Can't fixup forward type reference for \"%@\". Fixup kind %d", 
                    fixup->typeName.name, fixup->kind);
            }
            return MPR_ERR_CANT_LOAD;
        }
        switch (fixup->kind) {
        case EJS_FIXUP_BASE_TYPE:
            mprAssert(fixup->target);
            targetType = (EjsType*) fixup->target;
            targetType->needFixup = 1;
            ejsFixupType(ejs, targetType, type, 0);
            if (targetType->constructor.block.namespaces.length == 0 && type->hasScriptFunctions) {
                ejsDefineTypeNamespaces(ejs, targetType);
            }
            break;

        case EJS_FIXUP_INTERFACE_TYPE:
            targetType = (EjsType*) fixup->target;
            mprAddItem(targetType->implements, type);
            break;

        case EJS_FIXUP_RETURN_TYPE:
            mprAssert(fixup->target);
            targetFunction = (EjsFunction*) fixup->target;
            targetFunction->resultType = type;
            break;

        case EJS_FIXUP_TYPE_PROPERTY:
            mprAssert(fixup->target);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_INSTANCE_PROPERTY:
            mprAssert(fixup->target);
            mprAssert(ejsIsBlock(ejs, fixup->target));
            mprAssert(((EjsPot*) fixup->target)->isPrototype);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_LOCAL:
            mprAssert(fixup->target);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_EXCEPTION:
            mprAssert(fixup->target);
            targetException = (EjsEx*) fixup->target;
            targetException->catchType = type;
            break;

        default:
            mprAssert(0);
        }
    }
    return 0;
}


/*
    Parse a major.minor.version string
 */
int ejsParseModuleVersion(cchar *name)
{
    char    *tok;
    int     major, minor, patch;

    minor = patch = 0;
    major = (int) stoi(name, 10, NULL);
    if ((tok = strchr(name, '.')) != 0) {
        minor = (int) stoi(++tok, 10, NULL);
    }
    if ((tok = strchr(tok, '.')) != 0) {
        patch = (int) stoi(++tok, 10, NULL);
    }
    return EJS_MAKE_VERSION(major, minor, patch);
}


/*
    Remove "-version" and ".mod"
 */
static int trimModule(Ejs *ejs, char *name)
{
    cchar   *lastSlash;
    char    *cp, *vp;

    if ((cp = strrchr(name, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    lastSlash = mprGetLastPathSeparator(name);
    if (lastSlash && lastSlash > vp) {
        /* There is a "-" but it is in the directory portion of the name and not in the module name */
        return 0;
    }
    *vp++ = '\0';
    return ejsParseModuleVersion(vp);
}


/*
    Extract the version from a module name
 */
static int getVersion(cchar *name)
{
    char    *vp;

    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    return ejsParseModuleVersion(++vp);
}


/*
    Search for a file. If found, Return the path where the file was located. Otherwise return null.
 */
static char *probe(Ejs *ejs, cchar *path, int minVersion, int maxVersion)
{
    MprDirEntry     *dp, *best;
    MprList         *files;
    char            *dir, *base, *ext;
    int             next, nameLen, version, bestVersion;

    mprAssert(ejs);
    mprAssert(path);

    mprLog(7, "Probe for file %s", path);

    if (maxVersion == 0) {
        if (mprPathExists(path, R_OK)) {
            return sclone(path);
        }
        return 0;
    }
    dir = mprGetPathDir(path);
    base = mprGetPathBase(path);
    if ((ext = strrchr(base, '.')) != 0) {
        *ext++ = '\0';
    }
    files = mprGetPathFiles(dir, 0);
    nameLen = (int) strlen(base);
    bestVersion = -1;
    best = 0;

    for (next = 0; (dp = mprGetNextItem(files, &next)) != 0; ) {
        if (strncmp(dp->name, base, nameLen) != 0) {
            continue;
        }
        if ((ext = strrchr(dp->name, '.')) == 0 || strcmp(ext, EJS_MODULE_EXT) != 0) {
            continue;
        }
        if (dp->name[nameLen] == '-') {
            version = getVersion(dp->name);
        } else if (&dp->name[nameLen] == ext) {
            version = 0;
        } else {
            continue;
        }
        if (version == 0 || (minVersion <= version && version <= maxVersion)) {
            if (best == 0 || bestVersion < version) {
                bestVersion = version;
                best = dp;
            }
        }
    }
    return (best == 0) ? 0 : mprJoinPath(dir, best->name);
}


/*
    Search for a module. moduleName is a filename or path name. It MUST have a ".mod" extension.

    The search strategy is: Given a name "a.b.c", scan for:

        1. File named a.b.c
        2. File named a/b/c
        3. File named a.b.c in EJSPATH
        4. File named a/b/c in EJSPATH
        5. File named c in EJSPATH
 */
static char *searchForModule(Ejs *ejs, cchar *moduleName, int minVersion, int maxVersion)
{
    EjsPath     *dir;
    char        *withDotMod, *path, *filename, *basename, *cp, *slash, *name, *bootSearch, *tok, *searchDir, *dp;
    int         i;

    mprAssert(moduleName && *moduleName);

    slash = 0;
    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    withDotMod = makeModuleName(moduleName);
    name = mprGetNormalizedPath(withDotMod);

    mprLog(6, "Search for module \"%s\"", name);

    /*
        1. Search for path directly
     */
    if ((path = probe(ejs, name, minVersion, maxVersion)) != 0) {
        return path;
    }

    /*
        2. Search for "a/b/c"
     */
    slash = sclone(name);
    for (cp = slash; *cp; cp++) {
        if (*cp == '.') {
            *cp = mprGetPathSeparators(name)[0];
        }
    }
    if ((path = probe(ejs, slash, minVersion, maxVersion)) != 0) {
        return path;
    }

    if (ejs->search) {
        /*
            3. Search for "a.b.c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, name);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            4. Search for "a/b/c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, slash);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            5. Search for "c" in EJSPATH
         */
        basename = mprGetPathBase(slash);
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

    } else {
        /*
            Used when bootstrapping the VM
         */
        basename = mprGetPathBase(name);
        if (ejs->bootSearch) {
            bootSearch = sclone(ejs->bootSearch);
            searchDir = stok(bootSearch, MPR_SEARCH_SEP, &tok);
            while (searchDir && *searchDir) {
                filename = mprJoinPath(searchDir, basename);
                if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                    return path;
                }
                searchDir = stok(NULL, MPR_SEARCH_SEP, &tok);
            }

        } else {
            /* Search bin/../modules */
            dp = mprGetAppDir();
            dp = mprGetPathParent(dp);
            dp = mprJoinPath(dp, BLD_MOD_NAME);
            filename = mprJoinPath(dp, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
            /* Search bin */
            filename = mprJoinPath(mprGetAppDir(), basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
            /* Search "." */
            path = mprGetCurrentPath();
            filename = mprJoinPath(path, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }
    }
    return 0;
}


char *ejsSearchForModule(Ejs *ejs, cchar *moduleName, int minVersion, int maxVersion)
{
    char        *path, *withDotMod, *name;

    mprAssert(moduleName && *moduleName);

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    withDotMod = makeModuleName(moduleName);
    name = mprGetNormalizedPath(withDotMod);

    mprLog(6, "Search for module \"%s\"", name);
    path = searchForModule(ejs, name, minVersion, maxVersion);
    if (path) {
        mprLog(6, "Found %s at %s", name, path);
    }
    return path;
}


/*
    Ensure name has a ".mod" extension
 */
static char *makeModuleName(cchar *name)
{
    char    *cp;

    if ((cp = strrchr(name, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) == 0) {
        return sclone(name);
    }
    return sjoin(name, EJS_MODULE_EXT, NULL);
}


static int alreadyLoaded(Ejs *ejs, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp;

    if ((mp = ejsLookupModule(ejs, name, minVersion, maxVersion)) == 0) {
        return 0;
    }
    if (mp->compiling && ejsCompareMulti(ejs, name, EJS_DEFAULT_MODULE) != 0) {
        ejsThrowStateError(ejs, "Attempt to load module \"%@\" that is currently being compiled.", name);
        return MPR_ERR_ALREADY_EXISTS;
    }
    return 1;
}


void manageLoadState(EjsLoadState *ls, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ls->typeFixups);
    }
}


static EjsLoadState *createLoadState(Ejs *ejs, int flags)
{
    EjsLoadState    *ls;

    ls = mprAllocObj(EjsLoadState, manageLoadState);
    ls->typeFixups = mprCreateList(-1, 0);
    ls->firstModule = mprGetListLength(ejs->modules);
    ls->flags = flags;
    return ls;
}


/*
    Read a type reference. Types are stored as either global property slot numbers or as strings (token offsets into the 
    constant pool). The lowest bit is set if the reference is a string. The type and name arguments are optional and may 
    be set to null. Return the 0 if successful, otherwise return < 0. If the type could not be resolved, allocate a 
    fixup record and return in *fixup. The caller should then call addFixup.
 */
int ejsModuleReadType(Ejs *ejs, EjsModule *mp, EjsType **typeRef, EjsTypeFixup **fixup, EjsName *typeName, int *slotNum)
{
    EjsType         *type;
    EjsName         qname;
    int             t, slot;

    mprAssert(mp);
    mprAssert(typeRef);
    mprAssert(fixup);

    *typeRef = 0;
    *fixup = 0;

    if (typeName) {
        typeName->name = 0;
        typeName->space = 0;
    }
    t = ejsModuleReadInt(ejs, mp);
    slot = -1;
    qname.name = 0;
    qname.space = 0;
    type = 0;

    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        mp->hasError = 1;
        return MPR_ERR_CANT_LOAD;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        /*
            Type is a builtin primitive type or we are binding globals.
         */
        slot = t >> 2;
        if (0 <= slot && slot < ejsGetPropertyCount(ejs, ejs->global)) {
            type = ejsGetProperty(ejs, ejs->global, slot);
            if (type && (EjsObj*) type != S(null)) {
                qname = type->qname;
            }
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        /*
            Type was unbound at compile time
         */
        qname.name = ejsCreateStringFromConst(ejs, mp, t >> 2);
        if (qname.name == 0) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        if ((qname.space = ejsModuleReadConst(ejs, mp)) == 0) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        if (qname.name) {
            slot = ejsLookupProperty(ejs, ejs->global, qname);
            if (slot >= 0) {
                type = ejsGetProperty(ejs, ejs->global, slot);
            }
        }
        break;
    }
    if (type == S(null)) {
        type = 0;
    }
    if (type) {
        if (!ejsIsType(ejs, type)) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        *typeRef = type;

    } else if (type == 0 && fixup) {
        *fixup = createFixup(ejs, mp, qname, slot);
    }
    if (typeName) {
        *typeName = qname;
    }
    if (slotNum) {
        *slotNum = slot;
    }
    return 0;
}


static EjsTypeFixup *createFixup(Ejs *ejs, EjsModule *mp, EjsName qname, int slotNum)
{
    EjsTypeFixup    *fixup;

    mprAssert(mp->loadState->typeFixups);

    /*
        Managed by manageLoadState
     */
    if ((fixup = mprAllocZeroed(sizeof(EjsTypeFixup))) == 0) {
        return 0;
    }
    fixup->typeName = qname;
    fixup->typeSlotNum = slotNum;
    return fixup;
}


static int addFixup(Ejs *ejs, EjsModule *mp, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup)
{
    int     index;

    mprAssert(ejs);
    mprAssert(fixup);
    mprAssert(mp->loadState->typeFixups);

    fixup->kind = kind;
    fixup->target = target;
    fixup->slotNum = slotNum;

    index = mprAddItem(mp->loadState->typeFixups, fixup);
    if (index < 0) {
        return MPR_ERR_CANT_LOAD;
    }
    return 0;
}


static void setDoc(Ejs *ejs, EjsModule *mp, cchar *tag, void *vp, int slotNum)
{
    if (mp->doc) {
        ejsCreateDoc(ejs, tag, vp, slotNum, mp->doc);
        mp->doc = 0;
    }
}


static void manageDoc(EjsDoc *doc, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(doc->docString);
        mprMark(doc->brief);
        mprMark(doc->description);
        mprMark(doc->example);
        mprMark(doc->requires);
        mprMark(doc->returns);
        mprMark(doc->stability);
        mprMark(doc->spec);
        mprMark(doc->duplicate);
        mprMark(doc->defaults);
        mprMark(doc->params);
        mprMark(doc->options);
        mprMark(doc->events);
        mprMark(doc->see);
        mprMark(doc->throws);
    }
}


EjsDoc *ejsCreateDoc(Ejs *ejs, cchar *tag, void *vp, int slotNum, EjsString *docString)
{
    EjsDoc      *doc;
    char        key[32];

    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(EJS_DOC_HASH_SIZE, 0);
    }
    mprSprintf(key, sizeof(key), "%s %Lx %d", tag, PTOL(vp), slotNum);
    if ((doc = mprLookupHash(ejs->doc, key)) != 0) {
        return doc;
    }
    if ((doc = mprAllocObj(EjsDoc, manageDoc)) == 0) {
        return 0;
    }
    doc->docString = docString;
    mprAddKey(ejs->doc, key, doc);
    return doc;
}


static EjsObj *getCurrentBlock(EjsModule *mp)
{
    return mprGetLastItem(mp->current);
}


static void pushScope(EjsModule *mp, EjsAny *block, EjsAny *obj)
{
    if (block) {
        mprAssert(block != mp->scope);
        ((EjsBlock*) block)->scope = mp->scope;
        mp->scope = block;
        mprAssert(mp->scope != mp->scope->scope);
    }
    mprPushItem(mp->current, obj);
}


static void popScope(EjsModule *mp, int keepScope)
{
    mprPopItem(mp->current);
    if (!keepScope) {
        mprAssert(mp->scope != mp->scope->scope);
        mp->scope = mp->scope->scope;
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsLoader.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsModule.c"
 */
/************************************************************************/

/**
    ejsModule.c - Ejscript module management

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void manageConstants(EjsConstants *constants, int flags);
static void manageDebug(EjsDebug *debug, int flags);
static void manageModule(EjsModule *module, int flags);


EjsModule *ejsCreateModule(Ejs *ejs, EjsString *name, int version, EjsConstants *constants)
{
    EjsModule   *mp;

    mprAssert(version >= 0);

    if ((mp = mprAllocObj(EjsModule, manageModule)) == NULL) {
        mprAssert(mp);
        return 0;
    }
    mp->name = name;
    mp->version = version;
    mp->vname = (version) ? ejsSprintf(ejs, "%@-%d", name, version) : mp->name;
    if (constants) {
        mp->constants = constants;
    } else if ((mp->constants = ejsCreateConstants(ejs, EJS_INDEX_INCR, EC_BUFSIZE)) == NULL) {
        return 0;
    }
    mp->constants->mp = mp;
    mprAssert(mp->checksum == 0);
    return mp;
}


#if UNUSED
EjsModule *ejsCloneModule(Ejs *ejs, EjsModule *mp)
{
    return ejsCreateModule(ejs, mp->name, mp->version, mp->constants);
}
#endif


static void manageModule(EjsModule *mp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(mp->name);
        mprMark(mp->vname);
        mprMark(mp->path);
        mprMark(mp->loadState);
        mprMark(mp->dependencies);
        mprMark(mp->file);
        mprMark(mp->code);
        mprMark(mp->initializer);
        mprMark(mp->constants);
        mprMark(mp->doc);
        mprMark(mp->scope);
        mprMark(mp->currentMethod);
        mprMark(mp->current);
        mprMark(mp->vms);

    } else if (flags & MPR_MANAGE_FREE) {
        mprCloseFile(mp->file);
        ejsRemoveModuleFromAll(mp);
    }
}


static void manageNativeModule(EjsNativeModule *nm, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(nm->name);
    }
}


/*
    Register a native module callback to be invoked when it it time to configure the module. This is used by loadable modules
    when they are built statically.
 */
int ejsAddNativeModule(Ejs *ejs, cchar *name, EjsNativeCallback callback, int checksum, int flags)
{
    EjsService          *sp;
    EjsNativeModule     *nm;

    sp = ejs->service;
    if (ejsLookupNativeModule(ejs, name)) {
        return 0;
    }
    if ((nm = mprAllocObj(EjsNativeModule, manageNativeModule)) == NULL) {
        return MPR_ERR_MEMORY;
    }
    nm->name = sclone(name);
    nm->callback = callback;
    nm->checksum = checksum;
    nm->flags = flags;

    if (mprAddKey(sp->nativeModules, nm->name, nm) == 0) {
        return EJS_ERR;
    }
    return 0;
}


EjsNativeModule *ejsLookupNativeModule(Ejs *ejs, cchar *name) 
{
    return mprLookupHash(ejs->service->nativeModules, name);
}


int ejsSetModuleConstants(Ejs *ejs, EjsModule *mp, EjsConstants *constants)
{
    mp->constants = constants;
    return 0;
}


/*
    Lookup a module name in the set of loaded modules
    If minVersion is <= 0, then any version up to, but not including maxVersion is acceptable.
    If maxVersion is < 0, then any version greater than minVersion is acceptable.
    If both are zero, then match the name itself and ignore minVersion and maxVersion
    If both are -1, then any version is acceptable.
    If both are equal, then only that version is acceptable.
 */
EjsModule *ejsLookupModule(Ejs *ejs, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion < 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0; ) {
        if ((minVersion == 0 && maxVersion == 0) || (minVersion <= mp->version && mp->version <= maxVersion)) {
            if (mp->name == name) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


int ejsAddModule(Ejs *ejs, EjsModule *mp)
{
    mprAssert(ejs->modules);
    if (mp->vms == 0) {
        mp->vms = mprCreateList(-1, 0);
        mprAddItem(mp->vms, ejs);
    }
    return mprAddItem(ejs->modules, mp);
}


void ejsRemoveModule(Ejs *ejs, EjsModule *mp)
{
    mprLog(6, "Remove module: %@", mp->name); 
    mprRemoveItem(mp->vms, ejs);
    mprRemoveItem(ejs->modules, mp);
}


void ejsRemoveModuleFromAll(EjsModule *mp)
{
    Ejs     *ejs;
    int     next;

    if (mp->vms) {
        mprLog(6, "Remove module from all vms: %@", mp->name); 
        for (next = 0; (ejs = mprGetNextItem(mp->vms, &next)) != 0; ) {
            if (ejs->modules) {
                mprRemoveItem(ejs->modules, mp);
            }
        }
    }
}



static void manageConstants(EjsConstants *cp, int flags)
{
    int     i;
    
    if (flags & MPR_MANAGE_MARK) {
        mprMark(cp->pool);
        mprMark(cp->table);
        mprMark(cp->index);
        /*
            Racing here, but okay. May miss a few new elements, but they will be picked up on the next sweep.
         */
        for (i = 0; i < cp->indexCount; i++) {
            if (!(PTOI(cp->index[i]) & 0x1)) {
                mprMark(cp->index[i]);
            }
        }
    }
}


EjsConstants *ejsCreateConstants(Ejs *ejs, int count, ssize size)
{
    EjsConstants    *constants;

    mprAssert(ejs);

    if ((constants = mprAllocObj(EjsConstants, manageConstants)) == 0) {
        return NULL;
    }
    if (ejs->compiling) {
        if ((constants->table = mprCreateHash(EJS_DOC_HASH_SIZE, MPR_HASH_STATIC_VALUES)) == 0) {
            return 0;
        }
    }
    if ((constants->pool = mprAlloc(size)) == 0) {
        return 0;
    }
    constants->poolSize = size;
    constants->poolLength = 0;

    if ((constants->index = mprAlloc(count * sizeof(EjsString*))) == NULL) {
        return 0;
    }
    constants->index[0] = S(empty);
    constants->indexCount = 1;
    return constants;
}


int ejsGrowConstants(Ejs *ejs, EjsConstants *constants, ssize len)
{
    int     indexSize;

    if ((constants->poolLength + len) >= constants->poolSize) {
        constants->poolSize = ((constants->poolSize + len) + EC_BUFSIZE - 1) / EC_BUFSIZE * EC_BUFSIZE;
        if ((constants->pool = mprRealloc(constants->pool, constants->poolSize)) == 0) {
            return MPR_ERR_MEMORY;
        }
    }
    if (constants->indexCount >= constants->indexSize) {
        indexSize = (constants->indexCount + EJS_INDEX_INCR - 1) / EJS_INDEX_INCR * EJS_INDEX_INCR;
        if ((constants->index = mprRealloc(constants->index, indexSize * sizeof(EjsString*))) == NULL) {
            return MPR_ERR_MEMORY;
        }
        constants->indexSize = indexSize;
    }
    return 0;
}


int ejsAddConstant(Ejs *ejs, EjsConstants *constants, cchar *str)
{
    ssize       len, oldLen;

    if (constants->locked) {
        mprError("Constant pool for module is locked. Can't add constant \"%s\".",  str);
        return MPR_ERR_CANT_WRITE;
    }
    len = slen(str) + 1;
    if (ejsGrowConstants(ejs, constants, len) < 0) {
        return MPR_ERR_MEMORY;
    }
    memcpy(&constants->pool[constants->poolLength], str, len);
    oldLen = constants->poolLength;
    constants->poolLength += len;

    mprAddKey(constants->table, str, ITOP(constants->indexCount));
    constants->index[constants->indexCount] = ITOP(oldLen << 1 | 1);
    return constants->indexCount++;
}


EjsString *ejsCreateStringFromConst(Ejs *ejs, EjsModule *mp, int index)
{
    EjsConstants    *constants;
    EjsString       *sp;
    cchar           *str;
    int             value;

    constants = mp->constants;
    if (index < 0 || index >= constants->indexCount) {
        mprAssert(!(index < 0 || index >= constants->indexCount));
        return 0;
    }
    value = PTOI(constants->index[index]);
    if (value & 0x1) {
        str = &constants->pool[value >> 1];
        constants->index[index] = sp = ejsInternMulti(ejs, str, slen(str));
    }
    mprAssert(constants->index[index]);
    return constants->index[index];
}



EjsDebug *ejsCreateDebug(Ejs *ejs, int length)
{
    EjsDebug    *debug;
    ssize       size;
    int         count;

    count = (length > 0) ? length : EJS_DEBUG_INCR;
    size = sizeof(EjsDebug) + (count * sizeof(EjsLine));
    if ((debug = mprAllocBlock(size, MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(debug, manageDebug);
    debug->size = count;
    debug->numLines = length;
    debug->magic = EJS_DEBUG_MAGIC;
    return debug;
}


int ejsAddDebugLine(Ejs *ejs, EjsDebug **debugp, int offset, MprChar *source)
{
    EjsDebug    *debug;
    EjsLine     *line;
    ssize       len;
    int         numLines;

    mprAssert(debugp);
    
    if (*debugp == 0) {
        *debugp = ejsCreateDebug(ejs, 0);
    }
    debug = *debugp;
    mprAssert(debug->magic == EJS_DEBUG_MAGIC);
    if (debug->numLines >= debug->size) {
        debug->size += EJS_DEBUG_INCR;
        len = sizeof(EjsDebug) + (debug->size * sizeof(EjsLine));
        if ((debug = mprRealloc(debug, len)) == 0) {
            return MPR_ERR_MEMORY;
        }
        *debugp = debug;
    }
    if (debug->numLines > 0 && offset == debug->lines[debug->numLines - 1].offset) {
        line = &debug->lines[debug->numLines - 1];
        numLines = debug->numLines;
    } else {
        line = &debug->lines[debug->numLines];
        numLines = debug->numLines + 1;
    }
    line->source = source;
    line->offset = offset;
    debug->numLines = numLines;
    return 0;
}


static void manageDebug(EjsDebug *debug, int flags)
{
    int     i;

    mprAssert(debug->magic == EJS_DEBUG_MAGIC);

    if (flags & MPR_MANAGE_MARK) {
        for (i = 0; i < debug->numLines; i++) {
            mprMark(debug->lines[i].source);
        }
    } else if (flags & MPR_MANAGE_FREE) {
        debug->magic = 7;
    }
}


/*
    Demand load debug information for a function
 */
static EjsDebug *loadDebug(Ejs *ejs, EjsFunction *fun)
{
    EjsModule   *mp;
    EjsDebug    *debug;
    EjsLine     *line;
    EjsCode     *code;
    MprOff      prior;
    int         i, length;

    mp = fun->body.code->module;
    code = fun->body.code;
    prior = 0;
    debug = NULL;

    if (mp->file == 0) {
        if ((mp->file = mprOpenFile(mp->path, O_RDONLY | O_BINARY, 0666)) == NULL) {
            mprLog(5, "Can't open module file %s", mp->path);
            return NULL;
        }
        mprEnableFileBuffering(mp->file, 0, 0);
    } else {
        prior = mprGetFilePosition(mp->file);
    }
    if (mprSeekFile(mp->file, SEEK_SET, code->debugOffset) != code->debugOffset) {
        mprSeekFile(mp->file, SEEK_SET, prior);
        mprAssert(0);
        return 0;
    }
    length = ejsModuleReadInt(ejs, mp);
    if (!mp->hasError) {
        if ((debug = ejsCreateDebug(ejs, length)) != 0) {
            mprAssert(debug->numLines == length);
            for (i = 0; i < debug->numLines; i++) {
                line = &debug->lines[i];
                line->offset = ejsModuleReadInt(ejs, mp);
                line->source = ejsModuleReadMultiAsWide(ejs, mp);
            }
        }
    }
    if (prior) {
        mprSeekFile(mp->file, SEEK_SET, prior);
    } else {
        mprCloseFile(mp->file);
        mp->file = 0;
    }
    if (mp->hasError) {
        return NULL;
    }
    return debug;
}


EjsLine *ejsGetDebugLine(Ejs *ejs, EjsFunction *fun, uchar *pc)
{
    EjsCode     *code;
    EjsDebug    *debug;
    int         i, offset;

    code = fun->body.code;
    if (code == 0) {
        return NULL;
    }
    offset = (int) (pc - code->byteCode) - 1;
    debug = code->debug;
    if (debug == 0) {
        if (code->debugOffset == 0) {
            return NULL;
        }
        if (debug == 0 && code->debugOffset) {
            if ((debug = loadDebug(ejs, fun)) == 0) {
                return NULL;
            }
            code->debug = debug;
        }
    }
    /*
        Source format is:  path|line| code
     */
    if (debug->numLines > 0) {
        for (i = 0; i < debug->numLines; i++) {
            if (offset < debug->lines[i].offset) {
                break;
            }
        }
        if (i > 0) {
            i--;
        }
        return &debug->lines[i];
    }
    return NULL;
}


int ejsGetDebugInfo(Ejs *ejs, EjsFunction *fun, uchar *pc, char **pathp, int *linep, MprChar **sourcep)
{
    EjsLine     *line;
    MprChar     *str, *tok, *path, *lineno, *source;

    if ((line = ejsGetDebugLine(ejs, fun, pc)) == 0) {
        return MPR_ERR_CANT_FIND;
    }
    str = wclone(line->source);
    path = wtok(str, "|", &tok);
    lineno = wtok(NULL, "|", &tok);
    source = tok;
    if (pathp) {
        *pathp = wclone(path);
    }
    if (linep) {
        *linep = (int) wtoi(lineno, 10, NULL);
    }
    if (sourcep) {
        *sourcep = wclone(source);
    }
    return 0;
}


/*
    Decode a 32 bit integer. The maximum encoded value is EJS_ENCODE_MAX_WORD as the value is number encoded
 */
int ejsDecodeInt32(Ejs *ejs, uchar **pp)
{
    uchar   *start;
    int     value;

    start = *pp;
    value = (int) ejsDecodeNum(ejs, pp);
    *pp = start + 4;
    return value;
}


int64 ejsDecodeNum(Ejs *ejs, uchar **pp)
{
    uchar   *pos;
    uint64  t;
    uint    c;
    int     sign, shift;

    pos = *pp;
    c = (uint) *pos++;

    /*
        Map sign bit (0,1) to 1,-1
     */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;

    while (c & 0x80) {
        c = *pos++;
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    *pp = pos;
    return t * sign;
}


/*
    Decode a double using swapping
 */
double ejsDecodeDouble(Ejs *ejs, uchar **pp)
{
    double   value;

    memcpy(&value, *pp, sizeof(double));
    value = ejsSwapDouble(ejs, value);
    *pp += sizeof(double);
    return value;
}


/*
    Encode a number in a RLL encoding. Encoding is:
        Bit     0:  Sign
        Bits  1-6:  Low 6 bits (0-64)
        Bit     7:  Extension bit
        Bits 8-15:  Next 7 bits
        Bits   16:  Extension bit
        ...
 */
int ejsEncodeNum(Ejs *ejs, uchar *pos, int64 number)
{
    uchar       *start;
    uint        encoded;
    uint64      unumber;

    mprAssert(pos);

    start = pos;
    if (number < 0) {
        unumber = -number;
        encoded = (uint) (((unumber & 0x3F) << 1) | 1);
    } else {
        encoded = (uint) (((number & 0x3F) << 1));
        unumber = number;
    }
    unumber >>= 6;

    while (unumber) {
        *pos++ = encoded | 0x80;
        encoded = (int) (unumber & 0x7f);
        unumber >>= 7;
    }
    *pos++ = encoded;
    mprAssert((pos - start) < 11);
    return (int) (pos - start);
}


#if UNUSED && KEEP
int ejsEncodeUint(Ejs *ejs, uchar *pos, uint number)
{
    uchar       *start;
    uint        encoded;

    mprAssert(pos);

    start = pos;
    encoded = (uint) (((number & 0x3F) << 1));
    number >>= 6;

    while (number) {
        *pos++ = encoded | 0x80;
        encoded = (int) (number & 0x7f);
        number >>= 7;
    }
    *pos++ = encoded;
    mprAssert((pos - start) < 11);
    return (int) (pos - start);
}
#endif


/*
    Encode a 32 bit integer. The maximum encoded value is EJS_ENCODE_MAX_WORD as the value is number encoded
 */
int ejsEncodeInt32(Ejs *ejs, uchar *pos, int number)
{
    int         len;

    mprAssert(pos);
    if (abs(number) > EJS_ENCODE_MAX_WORD) {
        mprAssert("Code generation error. Word exceeds maximum");
        return 0;
    }
    len = ejsEncodeNum(ejs, pos, (int64) number);
    mprAssert(len <= 4);
    return 4;
}


/*
    Encode a double using swapping
 */
int ejsEncodeDouble(Ejs *ejs, uchar *pos, double number)
{
    number = ejsSwapDouble(ejs, number);
    memcpy(pos, &number, sizeof(double));
    return sizeof(double);
}


int ejsEncodeByteAtPos(Ejs *ejs, uchar *pos, int value)
{
    mprAssert(pos);
    *pos = value;
    return 0;
}


int ejsEncodeInt32AtPos(Ejs *ejs, uchar *pos, int value)
{
    return ejsEncodeInt32(ejs, pos, value);
}



void ejsModuleReadBlock(Ejs *ejs, EjsModule *mp, char *buf, int len)
{
    mprAssert(mp);

    if (mprReadFile(mp->file, buf, len) != len) {
        mp->hasError = 1;
    }
}


int ejsModuleReadByte(Ejs *ejs, EjsModule *mp)
{
    int     c;

    mprAssert(mp);

    if ((c = mprGetFileChar(mp->file)) < 0) {
        mp->hasError = 1;
        return 0;
    }
    return c;
}


/*
    Read a string constant. String constants are stored as token offsets into
    the constant pool. The pool contains null terminated UTF-8 strings.
 */
EjsString *ejsModuleReadConst(Ejs *ejs, EjsModule *mp)
{
    int     t;

    t = ejsModuleReadInt(ejs, mp);
    return ejsCreateStringFromConst(ejs, mp, t);
}


/*
    Decode a 4 byte number from a file
 */
int ejsModuleReadInt32(Ejs *ejs, EjsModule *mp)
{
    uchar   buf[4], *pp;

    mprAssert(mp);

    if (mprReadFile(mp->file, buf, 4) != 4) {
        mp->hasError = 1;
        return 0;
    }
    pp = buf;
    return ejsDecodeInt32(ejs, &pp);
}



/*
    Read a multibyte string. The length is encoded first, followed by a string of bytes.
 */
char *ejsModuleReadMulti(Ejs *ejs, EjsModule *mp)
{
    char    *buf;
    int     len;

    mprAssert(mp);

    len = ejsModuleReadInt(ejs, mp);
    if (mp->hasError || (buf = mprAlloc(len)) == 0) {
        return NULL;
    }
    if (mprReadFile(mp->file, buf, len) != len) {
        mp->hasError = 1;
        return NULL;
    }
    return buf;
}


/*
    Read a multibyte string. The length is encoded first, followed by a string of bytes.
 */
MprChar *ejsModuleReadMultiAsWide(Ejs *ejs, EjsModule *mp)
{
    mprAssert(mp);

    //  OPT - need direct multi to wide without the double copy
    return amtow(ejsModuleReadMulti(ejs, mp), NULL);
}


int ejsModuleReadInt(Ejs *ejs, EjsModule *mp)
{
    return (int) ejsModuleReadNum(ejs, mp);
}


/*
    Read an encoded number. Numbers are variable-length and little-endian encoded in 7 bits with the 0x80 
    bit of each byte being a continuation bit.
 */
int64 ejsModuleReadNum(Ejs *ejs, EjsModule *mp)
{
    int64   t;
    int     c, sign, shift;

    mprAssert(ejs);
    mprAssert(mp);
    mprAssert(mp->file);

    if ((c = mprGetFileChar(mp->file)) < 0) {
        mp->hasError = 1;
        return 0;
    }
    /* Map sign bit (0,1) to 1,-1 */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;
    
    while (c & 0x80) {
        if ((c = mprGetFileChar(mp->file)) < 0) {
            mp->hasError = 1;
            return 0;
        }
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    return (t * sign);
}


/*
    Read a constant qname. String constants are stored as token offsets into
    the constant pool. The pool contains null terminated UTF-8 strings.
 */
EjsName ejsModuleReadName(Ejs *ejs, EjsModule *mp)
{
    EjsName     qname;
    int         t;

    t = ejsModuleReadInt(ejs, mp);
    qname.name = ejsCreateStringFromConst(ejs, mp, t);
    t = ejsModuleReadInt(ejs, mp);
    qname.space = ejsCreateStringFromConst(ejs, mp, t);
    return qname;
}


#if UNUSED && KEEP
int ejsSwapInt16(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}
#endif


int ejsSwapInt32(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}


int64 ejsSwapInt64(Ejs *ejs, int64 a)
{
    int64   low, high;

    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return a;
    }
    low = a & 0xFFFFFFFF;
    high = (a >> 32) & 0xFFFFFFFF;
    return (int64) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}


double ejsSwapDouble(Ejs *ejs, double a)
{
    union {
        int64   i;
        double  d;
    } alias;
    
    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return a;
    }
    alias.d = a;
    return (double) ejsSwapInt64(ejs, alias.i);
}


#if UNUSED && KEEP
double ejsSwapDouble(Ejs *ejs, double a)
{
    int64   low, high;

    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return a;
    }
    low = ((int64) a) & 0xFFFFFFFF;
    high = (((int64) a) >> 32) & 0xFFFFFFFF;
    return  (double) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}
#endif

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsModule.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsScope.c"
 */
/************************************************************************/

/**
    ejsScope.c - Lookup variables in the scope chain.
  
    This modules provides variable lookup and scope chain management.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int lookupVarInBlock(Ejs *ejs, EjsBlock *bp, EjsName name, EjsLookup *lookup);

/*
    Look for a variable by name in the scope chain and return the location in "lookup" and a positive slot number if found. 
    If the name.space is non-empty, then only the given namespace will be used. Otherwise the set of open namespaces will 
    be used. The lookup structure will contain details about the location of the variable.
 */
int ejsLookupScope(Ejs *ejs, EjsName name, EjsLookup *lookup)
{
    EjsBlock        *bp;
    int             slotNum;

    mprAssert(ejs);
    mprAssert(name.name);
    mprAssert(name.space);
    mprAssert(lookup);

    memset(lookup, 0, sizeof(*lookup));

    //  OPT -- remove nthBlock. Not needed if not binding
    for (lookup->nthBlock = 0, bp = ejs->state->bp; bp; bp = bp->scope, lookup->nthBlock++) {
        if ((slotNum = lookupVarInBlock(ejs, bp, name, lookup)) >= 0) {
            return slotNum;
        }
    }
    return lookupVarInBlock(ejs, ejs->global, name, lookup);
}


/*
    Look for a variable by name in the scope chain and return the location in "lookup" and a positive slot number if found. 
    If the name.space is non-empty, then only the given namespace will be used. Otherwise the set of open namespaces will 
    be used. The lookup structure will contain details about the location of the variable.
 */
static int lookupVarInBlock(Ejs *ejs, EjsBlock *bp, EjsName name, EjsLookup *lookup)
{
    EjsFrame        *frame;
    EjsState        *state;
    EjsType         *type;
    EjsObj          *thisObj;
    EjsPot          *prototype;
    int             slotNum, nthBase;

    mprAssert(ejs);
    mprAssert(name.name);
    mprAssert(name.space);
    mprAssert(lookup);

    state = ejs->state;
    slotNum = -1;
    thisObj = state->fp->function.boundThis;

    /* Search simple block */
    lookup->originalObj = bp;
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, bp, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Optimized lookup for frames and types. Simple blocks don't need prototype lookup - so examine the type of block */
    if (ejsIsFrame(ejs, bp)) {
        frame = (EjsFrame*) bp;
        if (thisObj && frame->function.boundThis == thisObj && 
                thisObj != ejs->global && !frame->function.staticMethod && 
                !frame->function.isInitializer) {
            lookup->originalObj = thisObj;
            /* Instance method only */
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, thisObj, name, lookup)) >= 0) {
                return slotNum;
            }
            /* Search prototype chain */
            for (nthBase = 1, type = TYPE(thisObj); type; type = type->baseType, nthBase++) {
                if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                    break;
                }
                if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                    lookup->nthBase = nthBase;
                    lookup->type = type;
                    return slotNum;
                }
            }
            if (frame->function.isConstructor) {
                for (nthBase = 1, type = (EjsType*) TYPE(thisObj); type; type = type->baseType, nthBase++) {
                    if (type->constructor.block.pot.shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
            thisObj = 0;
        }
    } else if (ejsIsType(ejs, bp)) {
#if UNUSED
        //  TODO should this be searching the prototype chain here?
        /* Lookup prototype chain */
        //  OPT -- remove nthBase. Not needed if not binding.
        for (nthBase = 1, type = (EjsType*) bp; type; type = type->baseType, nthBase++) {
            if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                break;
            }
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                lookup->nthBase = nthBase;
                return slotNum;
            }
        }
#endif
        /* Search base class chain */
        //  OPT -- remove nthBase. Not needed if not binding.
        for (nthBase = 1, type = (EjsType*) bp; type; type = type->baseType, nthBase++) {
            if (type->constructor.block.pot.shortScope) {
                break;
            }
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                lookup->nthBase = nthBase;
                return slotNum;
            }
        }
    }
    return -1;
}


/*
    Find a property in an object or its prototype and base classes.
 */
int ejsLookupVar(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsType     *type;
    EjsPot      *prototype;
    int         slotNum, nthBase;

    mprAssert(obj);
    mprAssert(lookup);

    memset(lookup, 0, sizeof(*lookup));

    /* Lookup simple object */
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Lookup prototype chain */
    for (nthBase = 1, type = TYPE(obj); type; type = type->baseType, nthBase++) {
        if ((prototype = type->prototype) == 0 || prototype->shortScope) {
            break;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    /* Lookup base-class chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj)->baseType : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if (type->constructor.block.pot.shortScope) {
            continue;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    return -1;
}


/*
    Find a variable in an object considering namespaces. If the space is "", then search for the property name using
    the set of open namespaces.
 */
int ejsLookupVarWithNamespaces(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsNamespace    *nsp;
    EjsName         qname, target;
    EjsString       *space;
    EjsBlock        *b;
    MprList         *globalSpaces;
    int             next, slotNum;

    mprAssert(obj);
    mprAssert(name.name);
    mprAssert(name.space);
    mprAssert(lookup);

    b = (EjsBlock*) ejs->global;
    globalSpaces = &b->namespaces;

    if (name.space->value[0]) {
        /* Lookup with an explicit namespace */
        slotNum = ejsLookupProperty(ejs, obj, name);
        lookup->name = name;

    } else {
        /* 
            Lookup with the set of open namespaces in the current scope 
            Special lookup with space == NULL. Means lookup only match if there is only one property of this name 
         */
        qname.space = NULL;
        qname.name = name.name;
        if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
            if (TYPE(obj)->virtualSlots) {
                lookup->name = name;
            } else {
                target = ejsGetPropertyName(ejs, obj, slotNum);
                lookup->name = target;
                space = name.space;
                if (space->value[0] && space != target.space) {
                    /* Unique name match. Name matches, but namespace does not */
                    slotNum = -1;
                } else if (target.space && target.space->value[0]) {
                    /* OPT - Look at global spaces first */
                    for (next = -1; (nsp = mprGetPrevItem(globalSpaces, &next)) != 0; ) {
                        if (nsp->value == target.space) {
                            goto done;
                        }
                    }
                    //  OPT -- need a fast way to know if the space is a standard reserved namespace or not */
                    /* Verify namespace is open */
                    for (b = ejs->state->bp; b; b = b->scope) {
                        //  OPT. Doing some namespaces multiple times. Fix in compiler.
                        for (next = -1; (nsp = mprGetPrevItem(&b->namespaces, &next)) != 0; ) {
                            if (nsp->value == target.space) {
                                goto done;
                            }
                        }
                    }
                    slotNum = -1;
                }
            }

        } else {
            qname = name;
            for (b = ejs->state->bp; b; b = b->scope) {
                for (next = -1; (nsp = (EjsNamespace*) mprGetPrevItem(&b->namespaces, &next)) != 0; ) {
                    qname.space = nsp->value;
                    if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
                        // mprLog(5, "WARNING: Object has multiple properties of the same name \"%@\"", name.name); 
                        goto done;
                    }
                }
            }
            for (next = -1; (nsp = mprGetPrevItem(globalSpaces, &next)) != 0; ) {
                qname.space = nsp->value;
                if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
                    // mprLog(5, "WARNING: Object has multiple properties of the same name \"%@\"", name.name); 
                    goto done;
                }
            }
        }
    }
done:
    if (slotNum >= 0) {
        //  OPT MUST GET RID OF THIS. Means that every store does a get
        lookup->ref = ejsGetProperty(ejs, obj, slotNum);
        if (ejs->exception) {
            slotNum = -1;
        } else {
            lookup->obj = obj;
            lookup->slotNum = slotNum;
            lookup->trait = ejsGetPropertyTraits(ejs, lookup->obj, lookup->slotNum);
        }
    }
    return slotNum;
}


/*
    Get a variable by name. If obj is specified, it contains an explicit object in which to search for the variable name. 
    Otherwise, the full execution scope is consulted. The lookup fields will be set as residuals.
 */
EjsAny *ejsGetVarByName(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsObj  *result;
    int     slotNum;

    mprAssert(ejs);

    //  OPT - really nice to remove this
    //  OPT -- perhaps delegate the logic below down into a getPropertyByName?
    if (obj && TYPE(obj)->helpers.getPropertyByName) {
        if ((result = (TYPE(obj)->helpers.getPropertyByName)(ejs, obj, name)) != 0) {
            return result;
        }
    }
    if (obj) {
        slotNum = ejsLookupVar(ejs, obj, name, lookup);
    } else {
        slotNum = ejsLookupScope(ejs, name, lookup);
    }
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, lookup->obj, slotNum);
}


void ejsShowBlockScope(Ejs *ejs, EjsBlock *block)
{
#if BLD_DEBUG
    EjsNamespace    *nsp;
    MprList         *namespaces;
    int             nextNsp;

    mprLog(6, "\n  Block scope");
    for (; block; block = block->scope) {
        mprLog(6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprLog(6, "        \"%@\"", nsp->value);
            }
        }
    }
#endif
}


void ejsShowCurrentScope(Ejs *ejs)
{
#if BLD_DEBUG
    EjsNamespace    *nsp;
    MprList         *namespaces;
    EjsBlock        *block;
    int             nextNsp;

    mprLog(6, "\n  Current scope");
    for (block = ejs->state->bp; block; block = block->scope) {
        mprLog(6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprLog(6, "        \"%@\"", nsp->value);
            }
        }
    }
#endif
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsScope.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/vm/ejsService.c"
 */
/************************************************************************/

/**
    ejsService.c - Ejscript interpreter factory

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int allocNotifier(int flags, ssize size);
static int cloneVM(Ejs *ejs, Ejs *master);
static int  configureEjs(Ejs *ejs);
static int  defineTypes(Ejs *ejs);
static void initSearchPath(Ejs *ejs, cchar *search);
static int  loadStandardModules(Ejs *ejs, MprList *require);
static void logHandler(int flags, int level, cchar *msg);
static void manageEjs(Ejs *ejs, int flags);
static void manageEjsService(EjsService *service, int flags);
static void markValues(Ejs *ejs);
static void poolTimer(EjsPool *pool, MprEvent *event);
static int  runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName);
static int  searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn);


static EjsService *createService()
{
    EjsService  *sp;

    if ((sp = mprAllocObj(EjsService, manageEjsService)) == NULL) {
        return 0;
    }
    MPR->ejsService = sp;
    mprSetMemNotifier((MprMemNotifier) allocNotifier);
    if (mprUsingDefaultLogHandler()) {
        ejsRedirectLogging(0);
    }
    sp->nativeModules = mprCreateHash(-1, MPR_HASH_STATIC_KEYS);
    sp->mutex = mprCreateLock();
    sp->vmlist = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    sp->vmpool = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    sp->intern = ejsCreateIntern(sp);
    ejsInitCompiler(sp);
    return sp;
}


static void manageEjsService(EjsService *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(sp->http);
        mprMark(sp->mutex);
        mprMark(sp->vmlist);
        mprMark(sp->vmpool);
        mprMark(sp->nativeModules);
        mprMark(sp->intern);
        mprMark(sp->foundation);

    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyIntern(sp->intern);
        sp->mutex = NULL;
    }
}


static void managePool(EjsPool *pool, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(pool->list);
        mprMark(pool->template);
        mprMark(pool->mutex);
        mprMark(pool->templateScript);
        mprMark(pool->startScriptPath);
    }
}


EjsPool *ejsCreatePool(int poolMax, cchar *templateScript, cchar *startScriptPath)
{
    EjsPool     *pool;

    if ((pool = mprAllocObj(EjsPool, managePool)) == 0) {
        return 0;
    }
    pool->mutex = mprCreateLock();
    if ((pool->list = mprCreateList(-1, 0)) == 0) {
        return 0;
    }
    pool->max = poolMax <= 0 ? MAXINT : poolMax;
    if (templateScript) {
        pool->templateScript = sclone(templateScript);
    }
    if (startScriptPath) {
        pool->startScriptPath = sclone(startScriptPath);
    }
    return pool;
}


Ejs *ejsAllocPoolVM(EjsPool *pool, int flags)
{
    Ejs         *ejs;
    EjsString   *script;

    mprAssert(pool);

    lock(pool);
    if ((ejs = mprPopItem(pool->list)) == 0) {
        if (pool->count >= pool->max) {
            mprError("Too many ejs VMS: %d max %d", pool->count, pool->max);
            unlock(pool);
            return 0;
        }
        if (pool->template == 0) {
            if ((pool->template = ejsCreateVM(0, 0, 0, 0, 0, 0, flags)) == 0) {
                return 0;
            }
            if (pool->templateScript) {
                script = ejsCreateStringFromAsc(pool->template, pool->templateScript);
                if (ejsLoadScriptLiteral(pool->template, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_BIND) < 0) {
                    mprError("Can't execute \"%s\"\n%s", script, ejsGetErrorMsg(pool->template, 1));
                    return 0;
                }
            }
        }
        if ((ejs = ejsCreateVM(pool->template, 0, 0, 0, 0, 0, flags)) == 0) {
            mprMemoryError("Can't alloc ejs VM");
            unlock(pool);
            return 0;
        }
        mprAddRoot(ejs);
        if (pool->startScriptPath) {
            if (ejsLoadScriptFile(ejs, pool->startScriptPath, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_BIND) < 0) {
                mprError("Can't load \"%s\"\n%s", pool->startScriptPath, ejsGetErrorMsg(ejs, 1));
                mprRemoveRoot(ejs);
                return 0;
            }
        }
        pool->count++;
    }
    pool->lastActivity = mprGetTime();
    mprLog(0, "ejs: Alloc VM active %d, allocated %d, max %d", pool->count - mprGetListLength(pool->list), 
        pool->count, pool->max);

    if (!mprGetDebugMode()) {
        pool->timer = mprCreateTimerEvent(NULL, "ejsPoolTimer", HTTP_TIMER_PERIOD, poolTimer, pool,
            MPR_EVENT_CONTINUOUS | MPR_EVENT_QUICK);
    }
    mprRemoveRoot(ejs);
    unlock(pool);
    return ejs;
}


void ejsFreePoolVM(EjsPool *pool, Ejs *ejs)
{
    mprAssert(pool);
    mprAssert(ejs);

    pool->lastActivity = mprGetTime();
    lock(pool);
    mprPushItem(pool->list, ejs);
    mprLog(0, "ejs: Free VM, active %d, allocated %d, max %d", pool->count - mprGetListLength(pool->list), pool->count,
        pool->max);
    unlock(pool);
}


static void poolTimer(EjsPool *pool, MprEvent *event)
{
    lock(pool);
    if (mprGetElapsedTime(pool->lastActivity) > EJS_POOL_INACTIVITY_TIMEOUT && !mprGetDebugMode()) {
        pool->template = 0;
        mprClearList(pool->list);
    }
    unlock(pool);
}


//  MOB - need timer to free unused VMs


#if FUTURE
//  MOB - add flag to suppress loading ejs.mod
Ejs *ejsCreateVM(cchar *search, int argc, cchar **argv, int flags)
Ejs *ejsCloneVM(Ejs *ejs)
void ejsSetDispatcher(Ejs *ejs, MprDispatcher *dispatcher);
int ejsLoadModules(Ejs *ejs, MprList *require);
#endif

//  MOB - refactor args
Ejs *ejsCreateVM(Ejs *master, MprDispatcher *dispatcher, cchar *search, MprList *require, int argc, cchar **argv, int flags)
{
    EjsService  *sp;
    Ejs         *ejs;
    static int  seqno = 0;

    if ((ejs = mprAllocObj(Ejs, manageEjs)) == NULL) {
        return 0;
    }
    mprAddRoot(ejs);

    if ((sp = MPR->ejsService) == 0) {
        sp = createService();
    }
    ejs->service = sp;
    mprAddItem(sp->vmlist, ejs);
    ejs->master = master;

    if ((ejs->state = mprAllocZeroed(sizeof(EjsState))) == 0) {
        return 0;
    }
    ejs->empty = require && mprGetListLength(require) == 0;
    ejs->mutex = mprCreateLock(ejs);
    ejs->argc = argc;
    ejs->argv = argv;
    ejs->dontExit = sp->dontExit;
    ejs->flags |= (flags & (EJS_FLAG_NO_INIT | EJS_FLAG_DOC | EJS_FLAG_HOSTED));
    ejs->hosted = (flags & EJS_FLAG_HOSTED) ? 1 : 0;

    /*
        Modules are not marked in the modules list. This way, modules are collected when not referenced.
        Workers are marked. This way workers are preserved to run in the background until they exit.
     */
    ejs->modules = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    ejs->workers = mprCreateList(0, 0);

    lock(sp);
    if (dispatcher == 0) {
        ejs->name = mprAsprintf("ejs-%d", seqno++);
        ejs->dispatcher = mprCreateDispatcher(ejs->name, 1);
    } else {
        ejs->dispatcher = dispatcher;
    }
    unlock(sp);

    if (ejsInitStack(ejs) < 0) {
        ejsDestroyVM(ejs);
        mprRemoveRoot(ejs);
        return 0;
    }
    ejs->state->frozen = 1;

    if (master) {
        if (cloneVM(ejs, master) < 0) {
            return 0;
        }
    } else {
        if (defineTypes(ejs) < 0 || loadStandardModules(ejs, require) < 0) {
            if (ejs->exception) {
                ejsReportError(ejs, "Can't initialize interpreter");
            }
            ejsDestroyVM(ejs);
            mprRemoveRoot(ejs);
            return 0;
        }
        ejsFreezeGlobal(ejs);
    }
    if (mprHasMemError(ejs)) {
        mprError("Memory allocation error during initialization");
        ejsDestroyVM(ejs);
        mprRemoveRoot(ejs);
        return 0;
    }
    initSearchPath(ejs, search);
    mprRemoveRoot(ejs);
    ejs->state->frozen = 0;
#if DEBUG_IDE
    mprLog(5, "CREATE %s, length %d", ejs->name, sp->vmlist->length);
#endif
    mprAssert(!ejs->exception);
    return ejs;
}


void ejsDestroyVM(Ejs *ejs)
{
    EjsService  *sp;
    EjsState    *state;

#if DEBUG_IDE && 0
    if (ejs->service) {
        mprLog(5, "DESTROY %s, length %d", ejs->name, ejs->service->vmlist->length);
    }
#endif
    ejs->destroying = 1;
    sp = ejs->service;
    if (sp) {
#if UNUSED
        ejsRemoveModules(ejs);
#endif
        ejsRemoveWorkers(ejs);
        state = ejs->state;
        if (state->stackBase) {
            mprVirtFree(state->stackBase, state->stackSize);
            state->stackBase = 0;
            ejs->state = 0;
        }
        mprRemoveItem(sp->vmlist, ejs);
        ejs->service = 0;
        ejs->result = 0;
        mprDestroyDispatcher(ejs->dispatcher);
    }
}


static void manageEjs(Ejs *ejs, int flags)
{
    EjsState    *start, *state;
    EjsObj      *vp, **vpp, **top;
    EjsModule   *mp;
    int         next;

    if (flags & MPR_MANAGE_MARK) {
#if DEBUG_IDE && 0
        if (ejs->service) {
            printf("MARK EJS %s, length %d", ejs->name, ejs->service->vmlist->length);
        }
#endif
        mprMark(ejs->global);
        mprMark(ejs->name);
        mprMark(ejs->doc);
        mprMark(ejs->errorMsg);
        mprMark(ejs->exception);
        mprMark(ejs->exceptionArg);
        mprMark(ejs->mutex);
        mprMark(ejs->result);
        mprMark(ejs->search);
        mprMark(ejs->dispatcher);
        mprMark(ejs->httpServers);
        mprMark(ejs->workers);

        for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0;) {
            if (!mp->initialized) {
                mprMark(mp);
            }
        }
        mprMark(ejs->modules);

        /*
            Mark active call stack
         */
        start = ejs->state;
        if (start) {
            for (state = start; state; state = state->prev) {
                mprMark(state);
                mprMark(state->fp);
                mprMark(state->bp);
                mprMark(state->internal);
                mprMark(state->t1);
            }

            /*
                Mark the evaluation stack. Stack itself is virtually allocated and immune from GC.
             */
            top = start->stack;
            for (vpp = start->stackBase; vpp <= top; vpp++) {
                if ((vp = *vpp) != NULL) {
                    mprMark(vp);
                }
            }
        }
        markValues(ejs);
    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyVM(ejs);
    }
}


static void markValues(Ejs *ejs)
{
    int     i;

    for (i = 0; i < EJS_MAX_SPECIAL; i++) {
        mprMark(ejs->values[i]);
    }
}


void ejsCloneObjHelpers(Ejs *ejs, EjsType *type)
{
    type->helpers = ejs->objHelpers;
}


void ejsClonePotHelpers(Ejs *ejs, EjsType *type)
{
    type->helpers = ejs->potHelpers;
    type->isPot = 1;
}


void ejsCloneBlockHelpers(Ejs *ejs, EjsType *type)
{
    type->helpers = ST(Block)->helpers;
    type->isPot = 1;
}


static void cloneTypes(Ejs *ejs)
{
    Ejs     *master;
    
    master = (ejs->master) ? ejs->master : mprGetFirstItem(ejs->service->vmlist);
    if (master) {
        ejs->values[S_Iterator] = master->values[S_Iterator];
        ejs->values[S_StopIteration] = master->values[S_StopIteration];
    }
}


static int cloneVM(Ejs *ejs, Ejs *master)
{
    EjsAny      *vp;
    EjsModule   *mp;
    int         i, next;

    for (i = 0; i < EJS_MAX_SPECIAL; i++) {
        vp = master->values[i];
        if (vp == 0) {
            continue;
        }
#if UNUSED
        mprAssert(!((ejsIsType(ejs, vp) && ((EjsType*) vp)->mutable) ||(!ejsIsType(ejs, vp) && TYPE(vp)->mutableInstances)));
#endif
        ejs->values[i] = master->values[i];
    }
    ejs->global = master->global;

// extern int cloneCopy;
// MOB extern int cloneRef;

    ejs->global = ejsClone(ejs, master->global, 1);
// print("Copied %d, ref %d\n", cloneCopy, cloneRef);


    ejs->potHelpers = master->potHelpers;
    ejs->objHelpers = master->objHelpers;
    ejs->sqlite = master->sqlite;
    ejs->http = master->http;

    ejs->modules = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(master->modules, &next)) != 0;) {
        ejsAddModule(ejs, mp);
    }
    ejsSetPropertyByName(ejs, ejs->global, N("ejs", "global"), ejs->global);
    ejs->initialized = 1;
    return 0;
}

/*  
    Create the core language types. These are native types and are created prior to loading ejs.mod.
    The loader then matches these types to the loaded definitions.
 */
static int defineTypes(Ejs *ejs)
{
    /*  
        Create the essential bootstrap types: Object, Type and the global object, these are the foundation.
        All types are instances of Type. Order matters here.
     */
    cloneTypes(ejs);
    ejsBootstrapTypes(ejs);
    ejsCreateArrayType(ejs);
    ejsCreateBlockType(ejs);
    ejsCreateTypeType(ejs);
    ejsCreateNullType(ejs);
    ejsCreateNamespaceType(ejs);
    ejsCreateFunctionType(ejs);
    ejsCreateFrameType(ejs);
    ejsCreateGlobalBlock(ejs);

    /*
        These types are used by the compiler. Must work with an empty interpreter. Order does not matter.
     */
    ejsCreateBooleanType(ejs);
    ejsCreateErrorType(ejs);
    ejsCreateIteratorType(ejs);
    ejsCreateVoidType(ejs);
    ejsCreateNumberType(ejs);
    ejsCreatePathType(ejs);
    ejsCreateRegExpType(ejs);
    ejsCreateXMLType(ejs);
    ejsCreateXMLListType(ejs);
    ejsCreateConfigType(ejs);

    /*  
        Define the native module configuration routines.
     */
    ejsAddNativeModule(ejs, "ejs", configureEjs, _ES_CHECKSUM_ejs, 0);

#if BLD_FEATURE_EJS_ALL_IN_ONE
#if BLD_FEATURE_SQLITE
    ejs_db_sqlite_Init(ejs, NULL);
#endif
    ejs_web_Init(ejs, NULL);
#endif
    if (ejs->hasError || mprHasMemError(ejs)) {
        mprError("Can't create core types");
        return EJS_ERR;
    }
    return 0;
}


/*  
    This will configure all the core types by defining native methods and properties
 */
static int configureEjs(Ejs *ejs)
{
    /* 
        Order matters
     */
    ejsConfigureGlobalBlock(ejs);
    ejsConfigureObjectType(ejs);
    ejsConfigureIteratorType(ejs);
    ejsConfigureErrorType(ejs);
    ejsConfigureNullType(ejs);
    ejsConfigureBooleanType(ejs);
    ejsConfigureVoidType(ejs);
    ejsConfigureNumberType(ejs);

    ejsConfigurePathType(ejs);
    ejsConfigureFileSystemType(ejs);
    ejsConfigureFileType(ejs);
    ejsConfigureAppType(ejs);
    ejsConfigureArrayType(ejs);
    ejsConfigureByteArrayType(ejs);
    ejsConfigureCmdType(ejs);
    ejsConfigureDateType(ejs);
    ejsConfigureDebugType(ejs);
    ejsConfigureFunctionType(ejs);
    ejsConfigureGCType(ejs);
    ejsConfigureHttpType(ejs);
    ejsConfigureJSONType(ejs);
    ejsConfigureLogFileType(ejs);
    ejsConfigureMathType(ejs);
    ejsConfigureMemoryType(ejs);
    ejsConfigureNamespaceType(ejs);
    ejsConfigureRegExpType(ejs);
    ejsConfigureSocketType(ejs);
    ejsConfigureStringType(ejs);
    ejsConfigureSystemType(ejs);
    ejsConfigureTimerType(ejs);
    ejsConfigureUriType(ejs);
    ejsConfigureWorkerType(ejs);
    ejsConfigureXMLType(ejs);
    ejsConfigureXMLListType(ejs);

    ejsDefineConfigProperties(ejs);
    ejs->initialized = 1;
    return 0;
}


/*  
    Preload standard modules. If require is NULL, then load the standard set.
    Otherwise only load those specified in require.
 */
static int loadStandardModules(Ejs *ejs, MprList *require)
{
    char    *name;
    int     rc, next, ver, flags;

    rc = 0;
    ver = 0;
    if (require) {
        for (next = 0; rc == 0 && (name = mprGetNextItem(require, &next)) != 0; ) {
            flags = EJS_LOADER_STRICT;
            rc += ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, name), ver, ver, flags);
        }
    } else {
        rc += ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, "ejs"), ver, ver, EJS_LOADER_STRICT);
    }
    return rc;
}


static void initSearchPath(Ejs *ejs, cchar *search)
{
    if ((ejs->bootSearch = search) == 0) {
        ejs->bootSearch = getenv("EJSPATH");
    }
    if (ejs->bootSearch) {
        ejs->search = ejsCreateSearchPath(ejs, ejs->bootSearch);
    } else {
        ejs->search = ejsCreateSearchPath(ejs, NULL);
    }
}


void ejsSetSearchPath(Ejs *ejs, EjsArray *paths)
{
    mprAssert(ejs);
    mprAssert(paths && paths);
    mprAssert(ejsIs(ejs, paths, Array));

    ejs->search = paths;
}


EjsArray *ejsCreateSearchPath(Ejs *ejs, cchar *search)
{
    EjsArray    *ap;
    char        *relModDir, *dir, *next, *tok;

    ap = ejsCreateArray(ejs, 0);

    if (search) {
        next = sclone(search);
        dir = stok(next, MPR_SEARCH_SEP, &tok);
        while (dir && *dir) {
            ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, dir));
            dir = stok(NULL, MPR_SEARCH_SEP, &tok);
        }
        return (EjsArray*) ap;
    }
    relModDir = 0;
#if VXWORKS
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, mprGetCurrentPath(ejs)));
#else
    /*
        Create a default search path
        "." : APP_EXE_DIR/../modules : /usr/lib/ejs/1.0.0/modules
     */
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, "."));
    relModDir = mprAsprintf("%s/../%s", mprGetAppDir(ejs), BLD_MOD_NAME);
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, mprGetAppDir(ejs)));
    relModDir = mprAsprintf("%s/../%s", mprGetAppDir(ejs), BLD_MOD_NAME);
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, mprGetAbsPath(relModDir)));
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, BLD_MOD_PREFIX));
#endif
    return (EjsArray*) ap;
}


EjsObj *ejsGetGlobalObject(Ejs *ejs)
{
    return ejs->global;
}


#if FUTURE
void ejsSetServiceLocks(EjsService *sp, EjsLockFn lock, EjsUnlockFn unlock, void *data)
{
    mprAssert(sp);

    sp->lock = lock;
    sp->unlock = unlock;
    sp->lockData = data;
    return 0;
}
#endif


int ejsEvalModule(cchar *path)
{
    Ejs             *ejs;
    Mpr             *mpr;
    int             status;

    status = 0;

    if ((mpr = mprCreate(0, NULL, 0)) != 0) {
        status = MPR_ERR_MEMORY;

    } else if ((ejs = ejsCreateVM(0, 0, 0, 0, 0, 0, 0)) == 0) {
        status = MPR_ERR_MEMORY;

    } else if (ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, 0) < 0) {
        status = MPR_ERR_CANT_READ;

    } else if (ejsRun(ejs) < 0) {
        status = EJS_ERR;
    }
    mprDestroy(MPR_EXIT_DEFAULT);
    return status;
}


static int runProgram(Ejs *ejs, MprEvent *event)
{
    /*
        Run all module initialization code. This includes plain old scripts.
     */
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    if (ejs->className || ejs->methodName) {
        if (runSpecificMethod(ejs, ejs->className, ejs->methodName) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


int ejsRunProgram(Ejs *ejs, cchar *className, cchar *methodName)
{
    mprAssert(ejs->result == 0 || (MPR_GET_GEN(MPR_GET_MEM(ejs->result)) != MPR->heap.dead));

    ejs->className = className;
    ejs->methodName = methodName;
    mprRelayEvent(ejs->dispatcher, (MprEventProc) runProgram, ejs, NULL);

#if UNUSED
    if (ejs->flags & EJS_FLAG_NOEXIT) {
        /*
            If the script calls App.noexit(), this will service events until App.exit() is called.
            TODO - should deprecate noexit()
         */
        mprServiceEvents(-1, 0);
    }
#endif
    if (ejs->exception) {
        return EJS_ERR;
    }
    return 0;
}


/*  
    Run the specified method in the named class. If methodName is null, default to "main".
    If className is null, search for the first class containing the method name.
 */
static int runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName)
{
    EjsType         *type;
    EjsFunction     *fun;
    EjsArray        *args;
    int             i, slotNum;

    type = 0;
    if (className == 0 && methodName == 0) {
        return 0;
    }
    if (methodName == 0) {
        methodName = "main";
    }

    /*  
        Search for the first class with the given name
     */
    if (className == 0) {
        if (searchForMethod(ejs, methodName, &type) < 0) {
            return EJS_ERR;
        }
    } else {
        type = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, N(EJS_PUBLIC_NAMESPACE, className));
    }
    if (type == 0 || !ejsIsType(ejs, type)) {
        mprError("Can't find class \"%s\"", className);
        return EJS_ERR;
    }
    slotNum = ejsLookupProperty(ejs, type, N(EJS_PUBLIC_NAMESPACE, methodName));
    if (slotNum < 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    fun = (EjsFunction*) ejsGetProperty(ejs, type, slotNum);
    if (! ejsIsFunction(ejs, fun)) {
        mprError("Property is not a function");
        return MPR_ERR_BAD_STATE;
    }
    if (!ejsPropertyHasTrait(ejs, type, slotNum, EJS_PROP_STATIC)) {
        mprError("Method is not declared static");
        return EJS_ERR;
    }
    args = ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, args, i, ejsCreateStringFromAsc(ejs, ejs->argv[i]));
    }
    if (ejsRunFunction(ejs, fun, NULL, 1, &args) == 0) {
        return EJS_ERR;
    }
    return 0;
}


int ejsAddObserver(Ejs *ejs, EjsObj **emitterPtr, EjsObj *name, EjsFunction *observer)
{
    EjsAny      *argv[2];
    EjsObj      *emitter;
    EjsArray    *list;
    int         i;

    if (*emitterPtr == 0) {
        *emitterPtr = ejsCreateInstance(ejs, ejsGetTypeByName(ejs, N("ejs", "Emitter")), 0, NULL);
    }
    emitter = *emitterPtr;

    argv[1] = observer;
    if (ejsIs(ejs, name, Array)) {
        list = (EjsArray*) name;
        for (i = 0; i < list->length; i++) {
            name = ejsGetProperty(ejs, list, i);
            if (!ejsIs(ejs, name, Null)) {
                argv[0] = name;
                ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_on, 2, argv);
            }
        }
    } else {
        argv[0] = name;
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_on, 2, argv);
    }
    return 0;
}


#if ES_Emitter_hasObservers
int ejsHasObservers(Ejs *ejs, EjsObj *emitter)
{
    if (emitter) {
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_hasObservers, 0, NULL);
    }
    return 0;
}
#endif


int ejsRemoveObserver(Ejs *ejs, EjsObj *emitter, EjsObj *name, EjsFunction *observer)
{
    EjsAny      *argv[2];
    EjsArray    *list;
    int         i;

    if (emitter) {
        argv[1] = observer;
        if (ejsIs(ejs, name, Array)) {
            list = (EjsArray*) name;
            for (i = 0; i < list->length; i++) {
                name = ejsGetProperty(ejs, list, i);
                if (!ejsIs(ejs, name, Null)) {
                    argv[0] = name;
                    ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_off, 2, argv);
                }
            }
        } else {
            argv[0] = name;
            ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_off, 2, argv);
        }
    }
    return 0;
}


int ejsSendEventv(Ejs *ejs, EjsObj *emitter, cchar *name, EjsAny *thisObj, int argc, void *args)
{
    EjsObj  **av, **argv;
    int     i;

    if (emitter) {
        argv = args;
        av = mprAlloc((argc + 2) * sizeof(EjsObj*));
        av[0] = (EjsObj*) ejsCreateStringFromAsc(ejs, name);
        av[1] = thisObj ? thisObj : S(null);
        for (i = 0; i < argc; i++) {
            av[i + 2] = argv[i];
        }
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_fireThis, argc + 2, av);
    }
    return 0;
}


int ejsSendEvent(Ejs *ejs, EjsObj *emitter, cchar *name, EjsAny *thisObj, EjsAny *arg)
{
    EjsObj  **argv;

    argv = (EjsObj**) &arg;
    return ejsSendEventv(ejs, emitter, name, thisObj, 1, argv);
}


/*  
    Search for the named method in all types.
 */
static int searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn)
{
    EjsFunction *method;
    EjsType     *type;
    EjsName     qname;
    EjsObj      *global, *vp;
    int         globalCount, slotNum, methodCount;
    int         methodSlot;

    mprAssert(methodName && *methodName);
    mprAssert(typeReturn);

    global = ejs->global;
    globalCount = ejsGetPropertyCount(ejs, global);

    /*  
        Search for the named method in all types
     */
    for (slotNum = 0; slotNum < globalCount; slotNum++) {
        vp = ejsGetProperty(ejs, global, slotNum);
        if (vp == 0 || !ejsIsType(ejs, vp)) {
            continue;
        }
        type = (EjsType*) vp;

        methodCount = ejsGetPropertyCount(ejs, type);

        for (methodSlot = 0; methodSlot < methodCount; methodSlot++) {
            method = (EjsFunction*) ejsGetProperty(ejs, type, methodSlot);
            if (method == 0) {
                continue;
            }

            qname = ejsGetPropertyName(ejs, type, methodSlot);
            if (qname.name && qname.name == ejsCreateStringFromAsc(ejs, methodName)) {
                *typeReturn = type;
            }
        }
    }
    return 0;
}


static void logHandler(int flags, int level, cchar *msg)
{
    char        *prefix, *tag, *amsg, lbuf[16], buf[MPR_MAX_STRING];
    static int  solo = 0;

    if (solo > 0) {
        return;
    }
    solo = 1;
    prefix = MPR->name;
    amsg = NULL;

    if (flags & MPR_WARN_SRC) {
        tag = "Warning";
    } else if (flags & MPR_ERROR_SRC) {
        tag = "Error";
    } else if (flags & MPR_FATAL_SRC) {
        tag = "Fatal";
    } else if (flags & MPR_RAW) {
        tag = NULL;
    } else {
        tag = itos(lbuf, sizeof(lbuf), level, 10);
    }
    if (tag) {
        if (strlen(msg) < (MPR_MAX_STRING - 32)) {
            /* Avoid allocation if possible */
            mprSprintf(buf, sizeof(buf), "%s: %s: %s\n", prefix, tag, msg);
            msg = buf;
        } else {
            msg = amsg = mprAsprintf("%s: %s: %s\n", prefix, tag, msg);
        }
    }
    if (MPR->logFile) {
        mprFprintf(MPR->logFile, "%s", msg);
    } else {
        mprPrintfError("%s", msg);
    }
    solo = 0;
}

int ejsRedirectLogging(cchar *logSpec)
{
    MprFile     *file;
    char        *spec, *levelSpec;
    int         level;

    level = 0;
    if (logSpec == 0) {
        logSpec = "stdout:1";
    } else {
        MPR->logging = 1;
    }
    spec = sclone(logSpec);

    if ((levelSpec = strchr(spec, ':')) != 0) {
        *levelSpec++ = '\0';
        level = atoi(levelSpec);
    }
    if (strcmp(spec, "stdout") == 0) {
        file = MPR->fileSystem->stdOutput;

    } else if (strcmp(spec, "stderr") == 0) {
        file = MPR->fileSystem->stdError;

    } else {
        if ((file = mprOpenFile(spec, O_CREAT | O_WRONLY | O_TRUNC | O_TEXT, 0664)) == 0) {
            mprPrintfError("Can't open log file %s\n", spec);
            return EJS_ERR;
        }
    }
    mprSetLogLevel(level);
    mprSetLogHandler(logHandler);
    mprSetLogFile(file);
    return 0;
}


void ejsRedirectLoggingToFile(MprFile *file, int level)
{
    if (level >= 0) {
        mprSetLogLevel(level);
    }
    if (file) {
        mprSetLogFile(file);
    }
}


//  MOB - rename to ejsPauseGC / ejsResumeGC

int ejsFreeze(Ejs *ejs, int freeze)
{
    int     old;

    old = ejs->state->frozen;
    if (freeze != -1) {
        ejs->state->frozen = freeze;
    }
    return old;
}


/*  
    Global memory allocation handler. This is invoked when there is no notifier to handle an allocation failure.
    The interpreter has an allocNotifier (see ejsService: allocNotifier) and it will handle allocation errors.
 */
static int allocNotifier(int flags, ssize size)
{
    if (flags & MPR_MEM_DEPLETED) {
        mprPrintfError("Can't allocate memory block of size %d\n", size);
        mprPrintfError("Total memory used %d\n", (int) mprGetMem());
        exit(255);

    } else if (flags & MPR_MEM_LOW) {
        mprPrintfError("Memory request for %d bytes exceeds memory red-line\n", size);
        mprPrintfError("Total memory used %d\n", (int) mprGetMem());
#if UNUSED
    } else if (flags & MPR_MEM_ATTENTION) {
        EjsService  *sp;
        Ejs         *ejs;
        int         next;
        sp = MPR->ejsService;
        lock(sp);
        for (next = 0; (ejs = mprGetNextItem(sp->vmlist, &next)) != 0; ) {
            ejs->gc = 1;
        }
        unlock(sp);
#endif
    }
    return 0;
}


#if FUTURE && KEEP
/*  
    Notifier callback function. Invoked by mprAlloc on allocation errors. This will prevent the allocation error
    bubbling up to the global memory failure handler.
 */
static void allocNotifier(int flags, uint size)
{
    /*
        This has problems. Now many interpreters and need locking to implement this.
        Possible soln - use ejsAttention.
     */
    MprAllocStats   *alloc;
    EjsObj          *argv[2], *thisObj;
    char            msg[MPR_MAX_STRING];
    va_list         dummy = NULL_INIT;

    alloc = mprGetAllocStats(ejs);
    if (granted) {
        if (ejs->memoryCallback) {
            argv[0] = ejsCreateNumber(ejs, size);
            argv[1] = ejsCreateNumber(ejs, total);
            thisObj = ejs->memoryCallback->boundThis ? ejs->memoryCallback->boundThis : ejs->global; 
            ejsRunFunction(ejs, ejs->memoryCallback, thisObj, 2, argv);
        }
        if (!ejs->exception) {
            mprSprintf(msg, sizeof(msg), "Low memory condition. Total mem: %d. Request for %d bytes granted.", 
                total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    } else {
        if (!ejs->exception) {
            mprSprintf(msg, sizeof(msg), "Memory depleted. Total mem: %d. Request for %d bytes denied.", total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    }
}
#endif




void ejsReportError(Ejs *ejs, char *fmt, ...)
{
    va_list     arg;
    cchar       *emsg;
    char        *msg, *buf;

    va_start(arg, fmt);
    
    /*  
        Compiler error format is:
        program:SEVERITY:line:errorCode:message
        Where program is either "ejsc" or "ejs"
        Where SEVERITY is either "error" or "warn"
     */
    if ((emsg = ejsGetErrorMsg(ejs, 1)) != 0) {
        msg = (char*) emsg;
        buf = 0;
    } else {
        msg = buf = mprAsprintfv(fmt, arg);
    }
    if (ejs->exception) {
        char *name = MPR->name;
        mprRawLog(0, "%s: %s\n", name, msg);
    } else {
        mprError("%s", msg);
    }
    va_end(arg);
}


void ejsLockVm(Ejs *ejs)
{
    mprLock(ejs->mutex);
}


void ejsUnlockVm(Ejs *ejs)
{
    mprUnlock(ejs->mutex);
}


void ejsLockService(Ejs *ejs)
{
    mprLock(ejs->service->mutex);
}


void ejsUnlockService(Ejs *ejs)
{
    mprUnlock(ejs->service->mutex);
}


void ejsLoadHttpService(Ejs *ejs)
{
    ejsLockService(ejs);
    if (mprGetMpr()->httpService == 0) {
        httpCreate();
    }
    ejs->http = ejs->service->http = mprGetMpr()->httpService;
    if (ejs->http == 0) {
        mprError("Can't load Http Service");
    }
    ejsUnlockService(ejs);
}


void ejsSetSpecial(Ejs *ejs, int sid, EjsAny *value)
{
    mprAssert(sid < EJS_MAX_SPECIAL);
    
    if (0 <= sid && sid < EJS_MAX_SPECIAL) {
        mprAssert(ejs->values[sid] == 0);
        ejs->values[sid] = value;
    }
}


EjsAny *ejsGetSpecial(Ejs *ejs, int sid)
{
    mprAssert(0 <= sid && sid < EJS_MAX_SPECIAL);
    return ejs->values[sid];
}


void ejsSetSpecialType(Ejs *ejs, int sid, EjsType *type)
{
    mprAssert(0 <= sid && sid < EJS_MAX_SPECIAL);
    type->sid = sid;
    ejs->values[sid] = type;
}


void ejsDisableExit(Ejs *ejs)
{
    EjsService  *sp;

    sp = MPR->ejsService;
    if (sp) {
        sp->dontExit = 1;
    }
}

/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/vm/ejsService.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.db.sqlite/src/ejsSqlite.c"
 */
/************************************************************************/

/*
    ejsSqlite.c -- SQLite Database class

    Copyright (c) All Rights Reserved. See details at the end of the file.

    Todo:
        - should handle SQLITE_BUSY for multiuser access. Need to set the default timeout
        Useful: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
 */


#if BLD_FEATURE_SQLITE

#include    "sqlite3.h"


#define THREAD_STYLE SQLITE_CONFIG_MULTITHREAD
//#define THREAD_STYLE SQLITE_CONFIG_SERIALIZED

/*
    Map allocation and mutex routines. Can't use this (yet) as allocated memory must be marked
 */
#define MAP_ALLOC   1
#define MAP_MUTEXES 1

/*
    Ejscript Sqlite class object
 */
typedef struct EjsSqlite {
    EjsPot          pot;            /* Extends Object */
    sqlite3         *sdb;           /* Sqlite handle */
    Ejs             *ejs;           /* Interp reference */
    int             memory;         /* In-memory database */
} EjsSqlite;

/*
    DB Constructor and also used for constructor for sub classes.

    function Sqlite(options: Object)

    Options forms:
        string
            file://name
        path
            filename
        { name: path }
 */
static EjsObj *sqliteConstructor(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    sqlite3         *sdb;
    EjsObj          *options;
    cchar           *path;

    sdb = 0;
    db->ejs = ejs;
    options = argv[0];
    
    /*
        TODO - this will create a database if it doesn't exist. Should have more control over creating databases.
     */
    if (ejsIs(ejs, options, Path) || ejsIs(ejs, options, String)) {
        path = ejsToMulti(ejs, ejsToString(ejs, options));
    } else {
        path = ejsToMulti(ejs, ejsToString(ejs, ejsGetPropertyByName(ejs, options, EN("name"))));
    }
#if SECURITY_RISK
    if (strncmp(path, "memory://", 9) == 0) {
        sdb = (sqlite3*) (size_t) stoi(&path[9], 10, NULL);

    } else {
#endif
        db->memory = 0;
        if (strncmp(path, "file://", 7) == 0) {
            path += 7;
        }
        if (strstr(path, "://") == NULL) {
            if (sqlite3_open(path, &sdb) != SQLITE_OK) {
                ejsThrowIOError(ejs, "Can't open database %s", path);
                return 0;
            }
            //  TODO - should be configurable somewhere
            sqlite3_soft_heap_limit(20 * 1024 * 1024);
            sqlite3_busy_timeout(sdb, EJS_SQLITE_TIMEOUT);

        } else {
            ejsThrowArgError(ejs, "Unknown SQLite database URI %s", path);
            return 0;
        }
#if SECURITY_RISK
    }
#endif
    db->sdb = sdb;
    return (EjsObj*) db;
}


/*
    function close(): Void
 */
static int sqliteClose(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    mprAssert(ejs);
    mprAssert(db);

    if (db->sdb && !db->memory) {
        sqlite3_close(db->sdb);
        db->sdb = 0;
    }
    return 0;
}


/*
    function sql(cmd: String): Array

    Will support multiple sql cmds but will only return one result table.
 */
static EjsObj *sqliteSql(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    sqlite3         *sdb;
    sqlite3_stmt    *stmt;
    EjsArray        *result;
    EjsObj          *row;
    EjsObj          *svalue;
    EjsName         qname;
    char            *tableName;
    cchar           *tail, *colName, *cmd, *value, *defaultTableName;
    int             i, ncol, rc, retries, rowNum, len;

    mprAssert(ejs);
    mprAssert(db);

    cmd = ejsToMulti(ejs, argv[0]);
    retries = 0;
    sdb = db->sdb;
    if (sdb == 0) {
        ejsThrowIOError(ejs, "Database is closed");
        return 0;
    }
    mprAssert(sdb);

    result = ejsCreateArray(ejs, 0);
    if (result == 0) {
        return 0;
    }

    rc = SQLITE_OK;
    while (cmd && *cmd && (rc == SQLITE_OK || (rc == SQLITE_SCHEMA && ++retries < 2))) {
        stmt = 0;
        rc = sqlite3_prepare_v2(sdb, cmd, -1, &stmt, &tail);
        if (rc != SQLITE_OK) {
            continue;
        }
        if (stmt == 0) {
            /* Comment or white space */
            cmd = tail;
            continue;
        }
        defaultTableName = 0;
        ncol = sqlite3_column_count(stmt);
        for (rowNum = 0; ; rowNum++) {
            if (sqlite3_step(stmt) == SQLITE_ROW) {
                row = ejsCreateEmptyPot(ejs);
                if (row == 0) {
                    sqlite3_finalize(stmt);
                    return 0;
                }
                if (ejsSetProperty(ejs, (EjsObj*) result, rowNum, (EjsObj*) row) < 0) {
                    ejsThrowIOError(ejs, "Can't update query result set");
                    return 0;
                }
                for (i = 0; i < ncol; i++) {
                    tableName = (char*) sqlite3_column_table_name(stmt, i);
                    if (defaultTableName == 0) {
                        defaultTableName = tableName;
                    }
                    colName = sqlite3_column_name(stmt, i);
                    value = (cchar*) sqlite3_column_text(stmt, i);

                    if (tableName == 0 || strcmp(tableName, defaultTableName) == 0) {
                        qname = EN(colName);
                    } else {
                        /*
                            Append the table name for columns from foreign tables. Convert to camel case (tableColumn)
                            TODO - refactor crude singularization.
                         */
                        len = strlen(tableName) + 1;
                        tableName = sjoin("_", tableName, colName, NULL);
                        if (len > 3 && tableName[len - 1] == 's' && tableName[len - 2] == 'e' && tableName[len - 3] == 'i') {
                            tableName[len - 3] = 'y';
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (len > 2 && tableName[len - 1] == 's' && tableName[len - 2] == 'e') {
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (tableName[len - 1] == 's') {
                            strcpy(&tableName[len - 1], colName);
                            len--;
                        }
                        // tableName[0] = tolower((int) tableName[0]);
                        tableName[len] = toupper((int) tableName[len]);
                        qname = EN(tableName);
                    }
                    if (ejsLookupProperty(ejs, (EjsObj*) row, qname) < 0) {
                        svalue = (EjsObj*) ejsCreateStringFromMulti(ejs, value, slen(value));
                        if (ejsSetPropertyByName(ejs, (EjsObj*) row, qname, svalue) < 0) {
                            ejsThrowIOError(ejs, "Can't update query result set name");
                            return 0;
                        }
                    }
                }
            } else {
                rc = sqlite3_finalize(stmt);
                stmt = 0;
                if (rc != SQLITE_SCHEMA) {
                    retries = 0;
                    for (cmd = tail; isspace((int) *cmd); cmd++) {
                        ;
                    }
                }
                break;
            }
        }
    }
    if (stmt) {
        rc = sqlite3_finalize(stmt);
    }
    if (rc != SQLITE_OK) {
        if (rc == sqlite3_errcode(sdb)) {
            ejsThrowIOError(ejs, "SQL error: %s", sqlite3_errmsg(sdb));
        } else {
            ejsThrowIOError(ejs, "Unspecified SQL error");
        }
        return 0;
    }
    return (EjsObj*) result;
}


#if MAP_ALLOC

static void *allocBlock(int size)
{
    void    *ptr;

    if ((ptr = mprAlloc(size)) != 0) {
        mprHold(ptr);
    }
    return ptr;
}


static void freeBlock(void *ptr)
{
    mprRelease(ptr);
}


static void *reallocBlock(void *ptr, int size)
{
    mprRelease(ptr);
    if ((ptr =  mprRealloc(ptr, size)) != 0) {
        mprHold(ptr);
    }
    return ptr;
}


static int blockSize(void *ptr)
{
    return mprGetBlockSize(ptr);
}


static int roundBlockSize(int size)
{
    return MPR_ALLOC_ALIGN(size);
}


static int initAllocator(void *data)
{
    return 0;
}


static void termAllocator(void *data)
{
}


struct sqlite3_mem_methods mem = {
    allocBlock, freeBlock, reallocBlock, blockSize, roundBlockSize, initAllocator, termAllocator, NULL 
};

#endif /* MAP_ALLOC */

#if MAP_MUTEXES

static int initMutex(void) { 
    return 0; 
}


static int termMutex(void) { 
    return 0; 
}


static sqlite3_mutex *allocMutex(int kind)
{
    MprMutex    *lock;

    if ((lock = mprCreateLock()) != 0) {
        mprHold(lock);
    }
    return (sqlite3_mutex*) lock;
}


static void freeMutex(sqlite3_mutex *mutex)
{
    mprRelease((MprMutex*) mutex);
}


static void enterMutex(sqlite3_mutex *mutex)
{
    mprLock((MprMutex*) mutex);
}


static int tryMutex(sqlite3_mutex *mutex)
{
    return mprTryLock((MprMutex*) mutex);
}


static void leaveMutex(sqlite3_mutex *mutex)
{
    mprUnlock((MprMutex*) mutex);
}


static int mutexIsHeld(sqlite3_mutex *mutex) { 
    mprAssert(0); 
    return 0; 
}


static int mutexIsNotHeld(sqlite3_mutex *mutex) { 
    mprAssert(0); 
    return 0; 
}


struct sqlite3_mutex_methods mut = {
    initMutex, termMutex, allocMutex, freeMutex, enterMutex, tryMutex, leaveMutex, mutexIsHeld, mutexIsNotHeld,
};

#endif /* MAP_MUTEXES */


static int manageSqlite(EjsSqlite *db, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(db, flags);

    } else if (flags & MPR_MANAGE_FREE) {
        if (db->sdb) {
            sqliteClose(db->ejs, db, 0, 0);
        }
    }
    return 0;
}


static int configureSqliteTypes(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;
    static int  initialized = 0;
    
    type = (EjsType*) ejsConfigureNativeType(ejs, N("ejs.db.sqlite", "Sqlite"), sizeof(EjsSqlite), manageSqlite, EJS_POT_HELPERS);
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, sqliteConstructor);
    ejsBindMethod(ejs, prototype, ES_ejs_db_sqlite_Sqlite_close, sqliteClose);
    ejsBindMethod(ejs, prototype, ES_ejs_db_sqlite_Sqlite_sql, sqliteSql);

    if (!initialized) {
        initialized++;
#if MAP_ALLOC
        sqlite3_config(SQLITE_CONFIG_MALLOC, &mem);
#endif
#if MAP_MUTEXES
        sqlite3_config(SQLITE_CONFIG_MUTEX, &mut);
#endif
        sqlite3_config(THREAD_STYLE);
        if (sqlite3_initialize() != SQLITE_OK) {
            mprError("Can't initialize SQLite");
            return MPR_ERR_CANT_INITIALIZE;
        }
    }
    return 0;
}


/*
    Module load entry point. This must be idempotent as it will be called for each new interpreter created.
 */
int ejs_db_sqlite_Init(Ejs *ejs, MprModule *mp)
{
    return ejsAddNativeModule(ejs, "ejs.db.sqlite", configureSqliteTypes, _ES_CHECKSUM_ejs_db_sqlite, EJS_LOADER_ETERNAL);
}

#endif /* BLD_FEATURE_SQLITE */
/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.db.sqlite/src/ejsSqlite.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.web/src/ejsFilter.c"
 */
/************************************************************************/

/*
    ejsFilter.c - Transfer chunk endociding filter.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


#include    "http.h"

#if 0

static void incomingFilterData(HttpQueue *q, HttpPacket *packet);
static bool matchFilter(HttpConn *conn, HttpStage *handler);
static void openFilter(HttpQueue *q);
static void outgoingFilterService(HttpQueue *q);
static void setFilterPrefix(HttpQueue *q, HttpPacket *packet);

#define availableBytes(ap)  (((EjsByteArray*) ap)->writePosition - ((EjsByteArray*) ap)->readPosition)

typedef EjsFilter {
    EjsObj          obj;
    HttpQueue       q;
    EjsFunction     *put;
} struct EjsFilter;


static void openFilter(HttpQueue *q)
{
    HttpConn        *conn;
    HttpReceiver    *rec;

    conn = q->conn;
    rec = conn->receiver;

    filter->put = ejsGetPropertyByName(ejs, filter, ejsName(&qname, "", "put"), filter, 1, &data);
    if (filter->put == 0 || ejs->exception) {
        return ejsThrow();
    }
}


static void incomingFilterData(HttpQueue *q, HttpPacket *packet)
{
}


static void outgoingFilterPut(HttpQueue *q)
{
    ejsRunFunction(ejs, ser, filter, data);
}


static void outgoingFilterService(HttpQueue *q)
{
    HttpConn        *conn;
    HttpPacket      *packet;
    HttpTransmitter *trans;

    conn = q->conn;
    trans = conn->transmitter;

    filter = (EjsFilter*) q->pair->queueData;
    ejsRunFunction(ejs, ser, filter, data);

    if () {
    }

    if (trans->chunkSize <= 0 || trans->altBody) {
        httpDefaultOutgoingServiceStage(q);
    } else {
        for (packet = httpGetPacket(q); packet; packet = httpGetPacket(q)) {
            if (!(packet->flags & HTTP_PACKET_HEADER)) {
                httpJoinPackets(q, trans->chunkSize);
                if (httpGetPacketLength(packet) > trans->chunkSize) {
                    httpResizePacket(q, packet, trans->chunkSize);
                }
            }
            if (!httpWillNextQueueAcceptPacket(q, packet)) {
                httpPutBackPacket(q, packet);
                return;
            }
            if (!(packet->flags & HTTP_PACKET_HEADER)) {
                setFilterPrefix(q, packet);
            }
            httpSendPacketToNext(q, packet);
        }
    }
}


/*
    function write(data): Number
 */
static EjsObj *filter_write(Ejs *ejs, EjsObj *filter, int argc, EjsObj *argv)
{
    EjsObj      *data, *written;
    HttpQueue   *q;
    int         available, room;

    data = argv[0];
    mprAssert(ejsIs(ejs, data, ByteArray);
    q = filter->q;

    available = availableBytes(data);
    written = ejsRunFunction(ejs, filter->put, filter, 1, &data);
    if (ejs->exception) {
        return 0;
    }
    if (ejsGetInt(ejs, written) < available) {
        /*
           Could not write all available data. Assume the downstream queue is full. Disable this queue and 
           mark the downstream queue as full and service it immediately if not disabled.
        */
        httpDisbleQueue(q);
        next->flags |= HTTP_QUEUE_FULL;
        if (!(next->flags & HTTP_QUEUE_DISABLED)) {
            httpScheduleQueue(next);
        }
    }
}


static int createEjsHttpFilter(Ejs *ejs)
{
    HttpStage     *stage;

    mprAssert(ejs->http);

    stage = httpCreateFilter(ejs->http, "ejsFilter", HTTP_STAGE_ALL);
    if (stage == 0) {
        return MPR_ERR_CANT_CREATE;
    }
    ejs->http->ejsFilter = stage;
    stage->open = openFilter; 
    stage->outgoingData = outgoingFilterData; 
    stage->outgoingService = outgoingFilterService; 
    stage->incomingData = incomingFilterData; 
    stage->incomingService = incomingFilterService; 
    return 0;
}


void ejsConfigureFilterType(Ejs *ejs)
{
    EjsType         *type;
    EjsTypeHelpers  *helpers;
    EjsObj          *prototype;

    type = ejs->requestType = ejsConfigureNativeType(ejs, "ejs.web", "Filter", sizeof(EjsFilter));

    helpers = &type->helpers;
    helpers->mark = (EjsMarkHelper) markFilter;
    helpers->clone = (EjsCloneHelper) ejsCloneFilter;
    helpers->destroy = (EjsDestroyHelper) destroyFilter;
    helpers->getProperty = (EjsGetPropertyHelper) getFilterProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getFilterPropertyCount;
    helpers->getPropertyName = (EjsGetPropertyNameHelper) getFilterPropertyName;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupFilterProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setFilterProperty;

    createEjsHttpFilter(ejs);

    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_write, filter_write);
/*
    ejsBindAccess(ejs, prototype, ES_ejs_web_Filter_async, filter_async, filter_set_async);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_close, filter_close);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_destroySession, filter_destroySession);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_dontFinalize, filter_dontFinalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_finalize, filter_finalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_flush, filter_flush);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_header, filter_header);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_limits, filter_limits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_off, filter_off);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_read, filter_read);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_sendFile, filter_sendFile);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_setLimits, filter_setLimits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_setHeader, filter_setHeader);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_trace, filter_trace);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Filter_write, filter_write);
*/
}

#endif /* 0 */

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.web/src/ejsFilter.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.web/src/ejsHttpServer.c"
 */
/************************************************************************/

/*
    ejsHttpServer.c -- Ejscript Http Server.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static EjsRequest *createRequest(EjsHttpServer *sp, HttpConn *conn);
static EjsHttpServer *lookupServer(Ejs *ejs, cchar *ip, int port);
static void setHttpPipeline(Ejs *ejs, EjsHttpServer *sp);
static void setupConnTrace(HttpConn *conn);
static void stateChangeNotifier(HttpConn *conn, int state, int notifyFlags);

/*  
    function get address(): String
 */
static EjsString *hs_address(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->ip) {
        return ejsCreateStringFromAsc(ejs, sp->ip);
    } 
    return S(null);
}


/*  
    function accept(): Request
 */
static EjsRequest *hs_accept(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    MprEvent    event;

    memset(&event, 0, sizeof(MprEvent));
    event.dispatcher = sp->server->dispatcher;
    if ((conn = httpAcceptConn(sp->server, &event)) == 0) {
        /* Just ignore */
        mprError("Can't accept connection");
        return 0;
    }
    return createRequest(sp, conn);
}


/*  
    function get async(): Boolean
 */
static EjsObj *hs_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return (sp->async) ? S(true): S(false);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *hs_set_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->async = ejsGetBoolean(ejs, argv[0]);
    if (sp->server) {
        httpSetServerAsync(sp->server, sp->async);
    }
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *hs_close(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->server) {
        ejsSendEvent(ejs, sp->emitter, "close", NULL, sp);
        httpDestroyServer(sp->server);
        sp->server = 0;
    }
    return 0;
}


/*  
    function get limits(): Object
 */
static EjsObj *hs_limits(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpLimits  *limits;

    if (sp->limits == 0) {
        sp->limits = ejsCreateEmptyPot(ejs);
        limits = (sp->server) ? sp->server->limits : ejs->http->serverLimits;
        mprAssert(limits);
        ejsGetHttpLimits(ejs, sp->limits, limits, 1);
    }
    return sp->limits;
}


/*  
    function setLimits(limits: Object): Void
 */
static EjsObj *hs_setLimits(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    EjsObj      *vp, *app, *store, *storeLimits;
    HttpLimits  *limits;

    if (sp->limits == 0) {
        sp->limits = ejsCreateEmptyPot(ejs);
        limits = (sp->server) ? sp->server->limits : ejs->http->serverLimits;
        mprAssert(limits);
        ejsGetHttpLimits(ejs, sp->limits, limits, 1);
    }
    ejsBlendObject(ejs, sp->limits, argv[0], 1);
    if (sp->server) {
        limits = (sp->server) ? sp->server->limits : ejs->http->serverLimits;
        ejsSetHttpLimits(ejs, limits, sp->limits, 1);
    }
    if ((vp = ejsGetPropertyByName(ejs, sp->limits, EN("sessionTimeout"))) != 0) {
        app = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "App"));
        store = ejsGetProperty(ejs, app, ES_App_store);
        if (store) {
            storeLimits = ejsCreateEmptyPot(ejs);
            ejsSetPropertyByName(ejs, storeLimits, EN("lifespan"), vp);
            ejsStoreSetLimits(ejs, store, storeLimits);
        }
    }
    return 0;
}


/*  
    function get isSecure(): Void
 */
static EjsObj *hs_isSecure(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return sp->ssl ? S(true): S(false);
}


/*  
    function listen(endpoint): Void
    An endpoint can be either a "port" or "ip:port", or null
 */
static EjsVoid *hs_listen(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpServer  *server;
    HttpHost    *host;
    EjsString   *address;
    EjsObj      *endpoint, *options;
    EjsPath     *home, *documents;

    endpoint = (argc >= 1) ? argv[0] : S(null);
    if (endpoint != S(null)) {
        address = ejsToString(ejs, endpoint);
        mprParseIp(address->value, &sp->ip, &sp->port, 0);
    } else {
        address = 0;
    }
    if (ejs->hosted) {
        if ((options = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_options)) != 0) {
            sp->hosted = ejsGetPropertyByName(ejs, options, EN("own")) != S(true);
        }
    }

    if (!sp->hosted) {
        if (address == 0) {
            ejsThrowArgError(ejs, "Missing listen endpoint");
            return 0;
        }
        if (sp->server) {
            httpDestroyServer(sp->server);
            sp->server = 0;
        }
        /*
            The server uses the ejsDispatcher. This is VERY important. All connections will inherit this also.
            This serializes all activity on one dispatcher.
         */
        if ((server = httpCreateServer(sp->ip, sp->port, ejs->dispatcher, HTTP_CREATE_HOST)) == 0) {
            ejsThrowIOError(ejs, "Can't create Http server object");
            return 0;
        }
        sp->server = server;
        host = mprGetFirstItem(server->hosts);
        if (sp->limits) {
            ejsSetHttpLimits(ejs, server->limits, sp->limits, 1);
        }
        if (sp->incomingStages || sp->outgoingStages || sp->connector) {
            setHttpPipeline(ejs, sp);
        }
        if (sp->ssl) {
            httpSecureServer(server->ip, sp->port, sp->ssl);
        }
        if (sp->name) {
            httpSetHostName(host, sp->name);
        }
        httpSetSoftware(server->http, EJS_HTTPSERVER_NAME);
        httpSetServerAsync(server, sp->async);
        httpSetServerContext(server, sp);
        httpSetServerNotifier(server, stateChangeNotifier);

        /*
            This is only required for when http is using non-ejs handlers and/or filters
         */
        documents = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_documents);
        if (ejsIs(ejs, documents, Path)) {
            httpSetHostDocumentRoot(host, documents->value);
        }
        home = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_home);
        if (ejsIs(ejs, home, Path)) {
            httpSetHostServerRoot(host, home->value);
        }
        if (httpStartServer(server) < 0) {
            httpDestroyServer(sp->server);
            sp->server = 0;
            ejsThrowIOError(ejs, "Can't listen on %s", address->value);
        }
    }
    if (ejs->httpServers == 0) {
       ejs->httpServers = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    }
    mprRemoveItem(ejs->httpServers, sp);
    mprAddItem(ejs->httpServers, sp);
    return 0;
}


/*  
    function get name(): String
 */
static EjsString *hs_name(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->name) {
        return ejsCreateStringFromAsc(ejs, sp->name);
    }
    return S(null);
}


/*  
    function set name(hostname: String): Void
 */
static EjsObj *hs_set_name(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpHost    *host;

    sp->name = ejsToMulti(ejs, argv[0]);
    if (sp->server && sp->name) {
        host = mprGetFirstItem(sp->server->hosts);
        httpSetHostName(host, sp->name);
    }
    return 0;
}


/*  
    function off(name: [String|Array], observer: Function): Void
 */
static EjsObj *hs_off(Ejs *ejs, EjsHttpServer *sp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name: [String|Array], observer: Function): Void
 */
static EjsObj *hs_on(Ejs *ejs, EjsHttpServer *sp, int argc, EjsAny **argv)
{
    //  TODO -- should fire if currently readable / writable (also socket etc)
    ejsAddObserver(ejs, &sp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get port(): Number
 */
static EjsNumber *hs_port(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, sp->port);
}


/*  
    function secure(keyFile: Path, certFile: Path!, protocols: Array = null, ciphers: Array = null): Void
 */
static EjsObj *hs_secure(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
#if BLD_FEATURE_SSL
    EjsArray    *protocols;
    cchar       *token;
    int         mask, protoMask, i;

    if (sp->ssl == 0 && ((sp->ssl = mprCreateSsl(sp)) == 0)) {
        return 0;
    }
    if (httpLoadSsl(ejs->http) < 0) {
        ejsThrowStateError(ejs, "Can't load SSL provider");
        return 0;
    }
    if (!ejsIs(ejs, argv[0], Null)) {
        mprSetSslKeyFile(sp->ssl, ejsToMulti(ejs, argv[0]));
    }
    if (!ejsIs(ejs, argv[1], Null)) {
        mprSetSslCertFile(sp->ssl, ejsToMulti(ejs, argv[1]));
    }
    if (argc >= 3 && ejsIs(ejs, argv[2], Array)) {
        protocols = (EjsArray*) argv[2];
        protoMask = 0;
        for (i = 0; i < protocols->length; i++) {
            token = ejsToMulti(ejs, ejsGetProperty(ejs, protocols, i));
            mask = -1;
            if (*token == '-') {
                token++;
                mask = 0;
            } else if (*token == '+') {
                token++;
            }
            if (scasecmp(token, "SSLv2") == 0) {
                protoMask &= ~(MPR_PROTO_SSLV2 & ~mask);
                protoMask |= (MPR_PROTO_SSLV2 & mask);

            } else if (scasecmp(token, "SSLv3") == 0) {
                protoMask &= ~(MPR_PROTO_SSLV3 & ~mask);
                protoMask |= (MPR_PROTO_SSLV3 & mask);

            } else if (scasecmp(token, "TLSv1") == 0) {
                protoMask &= ~(MPR_PROTO_TLSV1 & ~mask);
                protoMask |= (MPR_PROTO_TLSV1 & mask);

            } else if (scasecmp(token, "ALL") == 0) {
                protoMask &= ~(MPR_PROTO_ALL & ~mask);
                protoMask |= (MPR_PROTO_ALL & mask);
            }
        }
        mprSetSslProtocols(sp->ssl, protoMask);
    }
    if (argc >= 4 && ejsIs(ejs, argv[3], Array)) {
        mprSetSslCiphers(sp->ssl, ejsToMulti(ejs, argv[3]));
    }
    mprConfigureSsl(sp->ssl);
#else
    ejsThrowReferenceError(ejs, "SSL support was not included in the build");
#endif
    return 0;
}


/*  
    function setPipeline(incoming: Array, outgoing: Array, connector: String): Void
 */
static EjsObj *hs_setPipeline(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->incomingStages = (EjsArray*) argv[0];
    sp->outgoingStages = (EjsArray*) argv[1];
    sp->connector = ejsToMulti(ejs, argv[2]);

    if (sp->server) {
        /* NOTE: this will only impact future requests */
        setHttpPipeline(ejs, sp);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *hs_trace(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    ejsSetupTrace(ejs, sp->trace, argv[0]);
    return 0;
}


/*  
    function get software(headers: Object = null): Void
 */
static EjsString *hs_software(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, EJS_HTTPSERVER_NAME);
}


/*  
    function verifyClients(caCertPath: Path, caCertFile: Path): Void
 */
static EjsObj *hs_verifyClients(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    //  TODO
    return 0;
}


static void receiveRequest(EjsRequest *req, MprEvent *event)
{
    Ejs             *ejs;
    EjsAny          *argv[1];
    EjsFunction     *onrequest;
    HttpConn        *conn;
    
    conn = req->conn;
    ejs = req->ejs;
    mprAssert(ejs);

    onrequest = ejsGetProperty(ejs, req->server, ES_ejs_web_HttpServer_onrequest);
    if (!ejsIsFunction(ejs, onrequest)) {
        ejsThrowStateError(ejs, "HttpServer.onrequest is not a function");
        return;
    }
    argv[0] = req;
    ejsRunFunction(ejs, onrequest, req->server, 1, argv);
    httpEnableConnEvents(conn);
}


/*
    function passRequest(req: Request, worker: Worker): Void
 */
static EjsVoid *hs_passRequest(Ejs *ejs, EjsHttpServer *server, int argc, EjsAny **argv)
{
    Ejs             *nejs;
    EjsRequest      *req, *nreq;
    EjsWorker       *worker;
    HttpConn        *conn;

    req = argv[0];
    worker = argv[1];

    nejs = worker->pair->ejs;
    conn = req->conn;
    conn->ejs = nejs;
    conn->oldDispatcher = conn->dispatcher;
    conn->newDispatcher = nejs->dispatcher;

    if ((nreq = ejsCloneRequest(nejs, req, 1)) == 0) {
        ejsThrowStateError(ejs, "Can't clone request");
        return 0;
    }
    httpSetConnContext(conn, nreq);

    if ((nreq->server = ejsCloneHttpServer(nejs, req->server, 1)) == 0) {
        ejsThrowStateError(ejs, "Can't clone request");
        return 0;
    }
    conn->workerEvent = mprCreateEvent(conn->dispatcher, "RequestWorker", 0, receiveRequest, nreq, MPR_EVENT_DONT_QUEUE);
    if (conn->workerEvent == 0) {
        ejsThrowStateError(ejs, "Can't create worker event");
    }  
    return 0;
}



//  TODO rethink this. This should really go into the HttpHost object

static void setHttpPipeline(Ejs *ejs, EjsHttpServer *sp) 
{
    EjsString       *vs;
    HttpLoc         *loc;
    Http            *http;
    HttpStage       *stage;
    cchar           *name;
    int             i;

    mprAssert(sp->server);
    http = sp->server->http;
    loc = sp->server->loc;

    if (sp->outgoingStages) {
        httpClearStages(loc, HTTP_STAGE_OUTGOING);
        for (i = 0; i < sp->outgoingStages->length; i++) {
            vs = ejsGetProperty(ejs, sp->outgoingStages, i);
            if (vs && ejsIs(ejs, vs, String)) {
                name = vs->value;
                if (httpLookupStage(http, name) == 0) {
                    ejsThrowArgError(ejs, "Can't find pipeline stage name %s", name);
                    return;
                }
                httpAddFilter(loc, name, NULL, HTTP_STAGE_OUTGOING);
            }
        }
    }
    if (sp->incomingStages) {
        httpClearStages(loc, HTTP_STAGE_INCOMING);
        for (i = 0; i < sp->incomingStages->length; i++) {
            vs = ejsGetProperty(ejs, sp->incomingStages, i);
            if (vs && ejsIs(ejs, vs, String)) {
                name = vs->value;
                if (httpLookupStage(http, name) == 0) {
                    ejsThrowArgError(ejs, "Can't find pipeline stage name %s", name);
                    return;
                }
                httpAddFilter(loc, name, NULL, HTTP_STAGE_INCOMING);
            }
        }
    }
    if (sp->connector) {
        if ((stage = httpLookupStage(http, sp->connector)) == 0) {
            ejsThrowArgError(ejs, "Can't find pipeline stage name %s", sp->connector);
            return;
        }
        loc->connector = stage;
    }
}


/*
    Notification callback. This routine is called from the Http pipeline on connection state changes. 
    Readable/writable events come with state == 0 and notifyFlags set accordingly.
 */
static void stateChangeNotifier(HttpConn *conn, int state, int notifyFlags)
{
    Ejs             *ejs;
    EjsRequest      *req;

    mprAssert(conn);

    ejs = 0;
    if ((req = httpGetConnContext(conn)) != 0) {
        ejs = req->ejs;
    }
    switch (state) {
    case HTTP_STATE_BEGIN:
        setupConnTrace(conn);
        break;
            
    case HTTP_STATE_FIRST:
        if (!(conn->rx->flags & (HTTP_OPTIONS | HTTP_TRACE))) {
            conn->tx->handler = (conn->error) ? conn->http->passHandler : conn->http->ejsHandler;
        }
        break;

    case HTTP_STATE_COMPLETE:
        if (req) {
            if (conn->error) {
                ejsSendRequestErrorEvent(ejs, req);
            }
            ejsSendRequestCloseEvent(ejs, req);
            if (req->cloned) {
                ejsSendRequestCloseEvent(req->cloned->ejs, req->cloned);
            }
        }
        break;

    case HTTP_EVENT_IO:
        /*  IO event notification for the request.  */
        if (req && req->emitter) {
            if (notifyFlags & HTTP_NOTIFY_READABLE) {
                ejsSendEvent(ejs, req->emitter, "readable", NULL, req);
            } 
            if (notifyFlags & HTTP_NOTIFY_WRITABLE) {
                ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
            }
        }
        break;

    case HTTP_EVENT_CLOSE:
        /* Connection close */
#if UNUSED
        if (conn->pool) {
            ejsFreePoolVM(conn->pool, conn->ejs);
            conn->ejs = 0;
        }
#endif
        if (req && req->conn) {
            req->conn = 0;
        }
        break;
    }
}


static void closeEjsHandler(HttpQueue *q)
{
    EjsRequest  *req;
    HttpConn    *conn;

    conn = q->conn;

    if ((req = httpGetConnContext(conn)) != 0) {
        ejsSendRequestCloseEvent(req->ejs, req);
        req->conn = 0;
    }
    httpSetConnContext(conn, 0);
    if (conn->pool) {
        ejsFreePoolVM(conn->pool, conn->ejs);
        conn->ejs = 0;
    }
}


static void incomingEjsData(HttpQueue *q, HttpPacket *packet)
{
    HttpConn        *conn;
    HttpRx          *rx;

    conn = q->conn;
    rx = conn->rx;

    if (httpGetPacketLength(packet) == 0) {
        if (rx->remainingContent > 0) {
            httpError(conn, HTTP_CODE_BAD_REQUEST, "Client supplied insufficient body data");
        }
        httpPutForService(q, packet, 0);
        if (rx->form || rx->upload) {
            rx->formVars = httpAddVarsFromQueue(rx->formVars, q);
        }
    } else {
        httpJoinPacketForService(q, packet, 0);
    }
    HTTP_NOTIFY(q->conn, 0, HTTP_NOTIFY_READABLE);
}


static void setupConnTrace(HttpConn *conn)
{
    EjsHttpServer   *sp;
    int             i;

    if ((sp = httpGetServerContext(conn->server)) != 0) {
        for (i = 0; i < HTTP_TRACE_MAX_DIR; i++) {
            conn->trace[i] = sp->trace[i];
        }
    }
}


static EjsRequest *createRequest(EjsHttpServer *sp, HttpConn *conn)
{
    Ejs             *ejs;
    EjsRequest      *req;
    cchar           *dir;

    ejs = sp->ejs;
    dir = conn->host->documentRoot;
    req = ejsCreateRequest(ejs, sp, conn, dir);
    httpSetConnContext(conn, req);

#if FUTURE
    if (sp->pipe) {
        def = ejsRunFunction(ejs, sp->createPipeline, 
        if ((vp = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "handler"))) != 0) { 
            handler = ejsToMulti(ejs, vp);
        }
        if ((incoming = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "incoming"))) != 0) { 
            count = ejsGetProperty(ejs, incoming)
            for (i = 0; i < count; i++) {
                mprAddItem(ilist, 
            }
        }
        if ((outgoing = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "outgoing"))) != 0) { 
            count = ejsGetProperty(ejs, incoming)
        }
        if ((connector = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "connector"))) != 0) { 
            connector = ejsToMulti(ejs, vp);
        }
        httpSetPipeline(conn, ejsToMulti(ejs, Handler), ejsToMulti(ejs, connector), 
    }
#endif
    return req;
}


static void startEjsHandler(HttpQueue *q)
{
    EjsHttpServer   *sp;
    EjsRequest      *req;
    Ejs             *ejs;
    HttpServer      *server;
    HttpConn        *conn;
    MprSocket       *lp;

    conn = q->conn;
    server = conn->server;

    if ((sp = httpGetServerContext(server)) == 0) {
        lp = conn->sock->listenSock;
        if ((sp = lookupServer(conn->ejs, lp->ip, lp->port)) == 0) {
            httpError(conn, HTTP_CODE_INTERNAL_SERVER_ERROR, 
                    "No HttpServer configured to serve for request from %s:%d", lp->ip, lp->port);
            return;
        }
        ejs = sp->ejs;
        sp->server = server;
        sp->ip = server->ip;
        sp->port = server->port;
        if (!ejsIsDefined(ejs, ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_documents))) {
            ejsSetProperty(ejs, sp, ES_ejs_web_HttpServer_documents, 
                ejsCreateStringFromAsc(ejs, conn->host->documentRoot));
        }
    } else {
        ejs = sp->ejs;
    }
    if (conn->notifier == 0) {
        httpSetConnNotifier(conn, stateChangeNotifier);
    }
    if ((req = createRequest(sp, conn)) != 0) {
        ejsSendEvent(ejs, sp->emitter, "readable", req, req);

        /* Send EOF if form or upload and all content has been received.  */
        if (conn->rx->startAfterContent && conn->rx->eof) {
            HTTP_NOTIFY(conn, 0, HTTP_NOTIFY_READABLE);
        }
    }
}


static void processEjsHandler(HttpQueue *q)
{
    HttpConn        *conn;
    
    conn = q->conn;

    if (conn->readq->count > 0) {
        HTTP_NOTIFY(conn, 0, HTTP_NOTIFY_READABLE);
    }
}


/* 
    Create the http pipeline handler
 */
HttpStage *ejsAddWebHandler(Http *http, MprModule *module)
{
    HttpStage   *handler;

    mprAssert(http);

    if (http->ejsHandler) {
        return http->ejsHandler;
    }
    handler = httpCreateHandler(http, "ejsHandler", HTTP_STAGE_ALL | HTTP_STAGE_QUERY_VARS | HTTP_STAGE_FORM_VARS, module);
    if (handler == 0) {
        return 0;
    }
    http->ejsHandler = handler;
    handler->close = closeEjsHandler;
    handler->incomingData = incomingEjsData;
    handler->start = startEjsHandler;
    handler->process = processEjsHandler;
    return handler;
}


/*  
    Mark the object properties for the garbage collector
 */
static void manageHttpServer(EjsHttpServer *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(sp, flags);
        mprMark(sp->ejs);
        mprMark(sp->server);
#if UNUSED
        mprMark(sp->sessionTimer);
        mprMark(sp->sessions);
#endif
        mprMark(sp->ssl);
        mprMark(sp->connector);
        mprMark(sp->keyFile);
        mprMark(sp->certFile);
        mprMark(sp->protocols);
        mprMark(sp->ciphers);
        mprMark(sp->ip);
        mprMark(sp->name);
        mprMark(sp->emitter);
        mprMark(sp->limits);
        mprMark(sp->outgoingStages);
        mprMark(sp->incomingStages);
        httpManageTrace(&sp->trace[0], flags);
        httpManageTrace(&sp->trace[1], flags);
        
    } else {
        if (sp->ejs && sp->ejs->httpServers) {
            mprRemoveItem(sp->ejs->httpServers, sp);
        }
#if UNUSED
        sp->sessions = 0;
#endif
        if (!sp->cloned) {
            if (sp->server && !sp->hosted) {
                httpDestroyServer(sp->server);
                sp->server = 0;
            }
#if UNUSED
            ejsCheckSessionTimer(sp);
#endif
        }
    }
}


static EjsHttpServer *createHttpServer(Ejs *ejs, EjsType *type, int size)
{
    EjsHttpServer   *sp;

    if ((sp = ejsCreatePot(ejs, type, 0)) == 0) {
        return 0;
    }
    sp->ejs = ejs;
    sp->async = 1;
    httpInitTrace(sp->trace);
    return sp;
}


EjsHttpServer *ejsCloneHttpServer(Ejs *ejs, EjsHttpServer *sp, bool deep)
{
    EjsHttpServer   *nsp;

    if ((nsp = ejsClonePot(ejs, sp, deep)) == 0) {
        return 0;
    }
    nsp->cloned = sp;
    nsp->ejs = ejs;
    nsp->async = sp->async;
    nsp->server = sp->server;
    nsp->name = sp->name;
    nsp->ssl = sp->ssl;
    nsp->connector = sp->connector;
    nsp->port = sp->port;
    nsp->ip = sp->ip;
    nsp->certFile = sp->certFile;
    nsp->keyFile = sp->keyFile;
    nsp->ciphers = sp->ciphers;
    nsp->protocols = sp->protocols;
#if UNUSED
    nsp->sessions = sp->sessions;
#endif
    httpInitTrace(nsp->trace);
    return nsp;
}


static EjsHttpServer *lookupServer(Ejs *ejs, cchar *ip, int port)
{
    EjsHttpServer   *sp;
    int             next;

    if (ip == 0) {
        ip = "";
    }
    if (ejs->httpServers) {
        for (next = 0; (sp = mprGetNextItem(ejs->httpServers, &next)) != 0; ) {
            if (sp->port <= 0 || port <= 0 || sp->port == port) {
                if (sp->ip == 0 || *sp->ip == '\0' || *ip == '\0' || scmp(sp->ip, ip) == 0) {
                    return sp;
                }
            }
        }
    }
    return 0;
}


void ejsConfigureHttpServerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs.web", "HttpServer"), sizeof(EjsHttpServer), manageHttpServer, EJS_POT_HELPERS);
    type->helpers.create = (EjsCreateHelper) createHttpServer;
    type->helpers.clone = (EjsCloneHelper) ejsCloneHttpServer;

    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_accept, hs_accept);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_address, hs_address);
    ejsBindAccess(ejs, prototype, ES_ejs_web_HttpServer_async, hs_async, hs_set_async);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_close, hs_close);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_limits, hs_limits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_isSecure, hs_isSecure);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_listen, hs_listen);
    ejsBindAccess(ejs, prototype, ES_ejs_web_HttpServer_name, hs_name, hs_set_name);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_port, hs_port);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_off, hs_off);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_passRequest, hs_passRequest);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_on, hs_on);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_secure, hs_secure);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_setLimits, hs_setLimits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_setPipeline, hs_setPipeline);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_trace, hs_trace);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_verifyClients, hs_verifyClients);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_software, hs_software);

    /* One time initializations */
    ejsLoadHttpService(ejs);
    ejsAddWebHandler(ejs->http, NULL);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.web/src/ejsHttpServer.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.web/src/ejsRequest.c"
 */
/************************************************************************/

/*
    ejsRequest.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static void defineParam(Ejs *ejs, EjsObj *params, cchar *key, cchar *value);

 
static int connOk(Ejs *ejs, EjsRequest *req, int throwException)
{
    if (!req->conn || req->conn->rx == 0) {
        if (!ejs->exception && throwException) {
            ejsThrowString(ejs, "Connection lost or not established");
        }
        return 0;
    }
    return 1;
}


static void defineParam(Ejs *ejs, EjsObj *params, cchar *key, cchar *svalue)
{
    EjsName     qname;
    EjsAny      *value;
    EjsObj      *vp;
    char        *subkey, *end;
    int         slotNum;

    mprAssert(params);

    if (*svalue == '[') {
        value = ejsDeserialize(ejs, ejsCreateStringFromAsc(ejs, svalue));
    } else {
        value = ejsCreateStringFromAsc(ejs, svalue);
    }
    /*  
        name.name.name
     */
    if (strchr(key, '.') == 0) {
        qname = ejsName(ejs, "", key);
        ejsSetPropertyByName(ejs, params, qname, value);

    } else {
        subkey = sclone(key);
        for (end = strchr(subkey, '.'); end; subkey = end, end = strchr(subkey, '.')) {
            *end++ = '\0';
            qname = ejsName(ejs, "", subkey);
            vp = ejsGetPropertyByName(ejs, params, qname);
            if (vp == 0) {
                slotNum = ejsSetPropertyByName(ejs, params, qname, ejsCreateEmptyPot(ejs));
                vp = ejsGetProperty(ejs, params, slotNum);
            }
            params = vp;
        }
        mprAssert(params);
        qname = ejsName(ejs, "", subkey);
        ejsSetPropertyByName(ejs, params, qname, value);
    }
}


static EjsObj *createParams(Ejs *ejs, EjsRequest *req)
{
    EjsObj          *params;
    MprHashTable    *formVars;
    MprHash         *hp;

    if ((params = req->params) == 0) {
        params = (EjsObj*) ejsCreateEmptyPot(ejs);
        if (req->conn && (formVars = req->conn->rx->formVars) != 0) {
            hp = 0;
            while ((hp = mprGetNextHash(formVars, hp)) != NULL) {
                defineParam(ejs, params, hp->key, hp->data);
            }
        }
    }
    return req->params = params;
}


static EjsObj *createCookies(Ejs *ejs, EjsRequest *req)
{
    EjsObj      *argv[1];
    cchar       *cookieHeader;

    if (req->cookies) {
        return req->cookies;
    }
    if (req->conn == 0) {
        return S(null);
    }
    if ((cookieHeader = mprLookupHash(req->conn->rx->headers, "cookie")) == 0) {
        req->cookies = S(null);
    } else {
        argv[0] = (EjsObj*) ejsCreateStringFromAsc(ejs, cookieHeader);
        req->cookies = ejsRunFunctionByName(ejs, ejs->global, N("ejs.web", "parseCookies"), ejs->global, 1, argv);
    }
    return req->cookies;
}


static EjsObj *createEnv(Ejs *ejs, EjsRequest *req)
{
    if (req->env == 0) {
        req->env = ejsCreateEmptyPot(ejs);
    }
    return (EjsObj*) req->env;
}


static EjsObj *createFiles(Ejs *ejs, EjsRequest *req)
{
    HttpUploadFile  *up;
    HttpConn        *conn;
    EjsObj          *files, *file;
    MprHash         *hp;
    int             index;

    if (req->files == 0) {
        if (req->conn == 0) {
            return S(null);
        }
        conn = req->conn;
        if (conn->rx->files == 0) {
            return S(null);
        }
        req->files = files = (EjsObj*) ejsCreateEmptyPot(ejs);
        for (index = 0, hp = 0; (hp = mprGetNextHash(conn->rx->files, hp)) != 0; index++) {
            up = (HttpUploadFile*) hp->data;
            file = (EjsObj*) ejsCreateEmptyPot(ejs);
            ejsSetPropertyByName(ejs, file, EN("filename"), ejsCreateStringFromAsc(ejs, up->filename));
            ejsSetPropertyByName(ejs, file, EN("clientFilename"), ejsCreateStringFromAsc(ejs, up->clientFilename));
            ejsSetPropertyByName(ejs, file, EN("contentType"), ejsCreateStringFromAsc(ejs, up->contentType));
            ejsSetPropertyByName(ejs, file, EN("name"), ejsCreateStringFromAsc(ejs, hp->key));
            ejsSetPropertyByName(ejs, file, EN("size"), ejsCreateNumber(ejs, (MprNumber) up->size));
            ejsSetPropertyByName(ejs, files, EN(hp->key), file);
        }
    }
    return (EjsObj*) req->files;
}


static EjsObj *createHeaders(Ejs *ejs, EjsRequest *req)
{
    EjsName     n;
    EjsString   *value;
    EjsObj      *old;
    HttpConn    *conn;
    MprHash     *hp;
    
    if (req->headers == 0) {
        req->headers = (EjsObj*) ejsCreateEmptyPot(ejs);
        conn = req->conn;
        for (hp = 0; conn && (hp = mprGetNextHash(conn->rx->headers, hp)) != 0; ) {
            n = EN(hp->key);
            if ((old = ejsGetPropertyByName(ejs, req->headers, n)) != 0) {
                value = ejsCreateStringFromAsc(ejs, sjoin(ejsToMulti(ejs, old), "; ", hp->data, NULL));
            } else {
                value = ejsCreateStringFromAsc(ejs, hp->data);
            }
            ejsSetPropertyByName(ejs, req->headers, n, value);
        }
    }
    return (EjsObj*) req->headers;
}


/*
    Callback invoked by Http to fill the http header set just before transmitting headers
 */
static int fillResponseHeaders(EjsRequest *req) 
{
    Ejs         *ejs;
    EjsObj      *vp;
    EjsTrait    *trait;
    EjsName     n;
    char        *value;
    int         i, count;
    
    if (req->responseHeaders) {
        ejs = req->ejs;
        count = ejsGetPropertyCount(ejs, req->responseHeaders);
        for (i = 0; i < count; i++) {
            trait = ejsGetPropertyTraits(ejs, req->responseHeaders, i);
            if (trait && trait->attributes & 
                    (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
                continue;
            }
            n = ejsGetPropertyName(ejs, req->responseHeaders, i);
            vp = ejsGetProperty(ejs, req->responseHeaders, i);
            if (n.name && vp && req->conn) {
                if (ejsIsDefined(ejs, vp)) {
                    value = ejsToMulti(ejs, vp);
                    httpSetHeaderString(req->conn, ejsToMulti(ejs, n.name), value);
                }
            }
        }
    }
    return 0;
}


static EjsObj *createResponseHeaders(Ejs *ejs, EjsRequest *req)
{
    MprHash     *hp;
    HttpConn    *conn;
    
    if (req->responseHeaders == 0) {
        req->responseHeaders = (EjsObj*) ejsCreateEmptyPot(ejs);
        conn = req->conn;
        if (conn && conn->tx) {
            /* Get default headers */
            for (hp = 0; (hp = mprGetNextHash(conn->tx->headers, hp)) != 0; ) {
                ejsSetPropertyByName(ejs, req->responseHeaders, EN(hp->key), ejsCreateStringFromAsc(ejs, hp->data));
            }
            conn->headersCallback = (HttpHeadersCallback) fillResponseHeaders;
            conn->headersCallbackArg = req;
        }
    }
    return (EjsObj*) req->responseHeaders;
}


/*
    Return the session object corresponding to a request cookie. Note the Session class on which session instances are
    based, defines helpers for all accesses to session data objects.
 */
static EjsString *getSessionKey(Ejs *ejs, EjsRequest *req)
{
    cchar   *cookies, *cookie;
    char    *id, *cp, *value;
    int     quoted, len;

    if (!req->conn) {
        return 0;
    }
    cookies = httpGetCookies(req->conn);
    for (cookie = cookies; cookie && (value = strstr(cookie, EJS_SESSION)) != 0; cookie = value) {
        value += strlen(EJS_SESSION);
        while (isspace((int) *value) || *value == '=') {
            value++;
        }
        quoted = 0;
        if (*value == '"') {
            value++;
            quoted++;
        }
        for (cp = value; *cp; cp++) {
            if (quoted) {
                if (*cp == '"' && cp[-1] != '\\') {
                    break;
                }
            } else {
                if ((*cp == ',' || *cp == ';') && cp[-1] != '\\') {
                    break;
                }
            }
        }
        len = (int) (cp - value);
        id = mprMemdup(value, len + 1);
        id[len] = '\0';
        return ejsCreateStringFromAsc(ejs, id);
    }
    return 0;
}


/*
    This will get the current session or create a new session if required
 */
static EjsSession *getSession(Ejs *ejs, EjsRequest *req, int create)
{
    HttpConn    *conn;
    EjsString   *key;

    conn = req->conn;
    if (req->probedSession || !conn) {
        return req->session;
    }
    key = getSessionKey(ejs, req);
    if (key || create) {
        req->session = ejsGetSession(ejs, key, conn->limits->sessionTimeout, create);
        if (req->session && !key) {
            //UNICODE
            httpSetCookie(conn, EJS_SESSION, req->session->key->value, "/", NULL, 0, conn->secure);
        }
        req->probedSession = 1;
    }
    return req->session;
}


static EjsString *createString(Ejs *ejs, cchar *value)
{
    if (value == 0) {
        return S(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


static int getDefaultInt(Ejs *ejs, EjsNumber *value, int defaultValue)
{
    if (value == 0 || ejsIs(ejs, value, Null)) {
        return defaultValue;
    }
    return ejsGetInt(ejs, value);
}


static cchar *getDefaultString(Ejs *ejs, EjsString *value, cchar *defaultValue)
{
    if (value == 0 || ejsIs(ejs, value, Null)) {
        return defaultValue;
    }
    return ejsToMulti(ejs, value);
}


static cchar *getRequestString(Ejs *ejs, EjsObj *value)
{
    if (value == 0) {
        return "";
    }
    return ejsToMulti(ejs, value);
}


static EjsAny *mapNull(Ejs *ejs, EjsAny *value)
{
    if (value == 0) {
        return S(null);
    }
    return value;
}


/*
    Get the best public host name for the serving host
 */
static cchar *getHost(HttpConn *conn, EjsRequest *req)
{
    cchar       *hostName, *cp;

    if (req->server && req->server->name && *req->server->name) {
        hostName = req->server->name;
    } else if (conn && conn->rx->hostHeader && conn->rx->hostHeader) {
        hostName = conn->rx->hostHeader;
    } else if (conn && conn->sock) {
        hostName = conn->sock->acceptIp;
    } else {
        hostName = "localhost";
    }
    if ((cp = schr(hostName, ':')) != 0) {
        return snclone(hostName, cp - hostName);
    }
    return hostName;
}


static EjsObj *getLimits(Ejs *ejs, EjsRequest *req)
{
    if (req->limits == 0) {
        req->limits = ejsCreateEmptyPot(ejs);
        if (req->conn) {
            ejsGetHttpLimits(ejs, req->limits, req->conn->limits, 0);
        }
    }
    return req->limits;
}


static char *makeRelativeHome(Ejs *ejs, EjsRequest *req)
{
    HttpRx      *rx;
    cchar       *path, *end, *sp;
    char        *home, *cp;
    int         levels;

    if (req->conn == NULL) {
        return sclone("/");
    }
    rx = req->conn->rx;
    mprAssert(rx->pathInfo);

    path = rx->pathInfo;
    end = &path[strlen(path)];
    for (levels = 1, sp = &path[1]; sp < end; sp++) {
        if (*sp == '/' && sp[-1] != '/') {
            levels++;
        }
    }
    home = mprAlloc(levels * 3 + 2);
    if (levels) {
        for (cp = home; levels > 0; levels--) {
            strcpy(cp, "../");
            cp += 3;
        }
        *cp = '\0';
    } else {
        strcpy(home, "./");
    }
    return home;
}


/*
    Lookup a property. These properties are virtualized.
 */
static EjsAny *getRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum)
{
    EjsAny      *value, *app;
    HttpConn    *conn;
    cchar       *pathInfo, *scriptName;
    char        *path, *filename, *uri, *ip, *scheme;
    int         port;

    conn = req->conn;

    switch (slotNum) {
    case ES_ejs_web_Request_absHome:
        if (req->absHome == 0) {
            if (req->conn) {
                scheme = conn->secure ? "https" : "http";
                ip = conn->sock ? conn->sock->acceptIp : req->server->ip;
                port = conn->sock ? conn->sock->acceptPort : req->server->port;
                uri = mprAsprintf("%s://%s:%d%s/", scheme, ip, port, conn->rx->scriptName);
                req->absHome = (EjsObj*) ejsCreateUriFromMulti(ejs, uri);
            } else {
                req->absHome = S(null);
            }
        }
        return req->absHome;

    case ES_ejs_web_Request_authGroup:
        return createString(ejs, conn ? conn->authGroup : NULL);

    case ES_ejs_web_Request_authType:
        return createString(ejs, conn ? conn->authType : NULL);

    case ES_ejs_web_Request_authUser:
        return createString(ejs, conn ? conn->authUser : NULL);

    case ES_ejs_web_Request_autoFinalizing:
        return ejsCreateBoolean(ejs, !req->dontAutoFinalize);

    case ES_ejs_web_Request_config:
        value = ST(Object)->helpers.getProperty(ejs, req, slotNum);
        if (value == 0 || ejsIs(ejs, value, Null)) {
            /* Default to App.config */
            app = ejsGetProperty(ejs, ejs->global, ES_App);
            value = ejsGetProperty(ejs, app, ES_App_config);
            ejsSetProperty(ejs, req, slotNum, value);
        }
        return mapNull(ejs, value);

    case ES_ejs_web_Request_contentLength:
        return ejsCreateNumber(ejs, conn ? (MprNumber) conn->rx->length : 0);

    case ES_ejs_web_Request_contentType:
        if (conn) {
            createHeaders(ejs, req);
            return mapNull(ejs, ejsGetPropertyByName(ejs, req->headers, EN("content-type")));
        } else return S(null);

    case ES_ejs_web_Request_cookies:
        if (conn) {
            return createCookies(ejs, req);
        } else return S(null);

    case ES_ejs_web_Request_dir:
        return req->dir;

    case ES_ejs_web_Request_env:
        return createEnv(ejs, req);

    case ES_ejs_web_Request_errorMessage:
        return createString(ejs, conn ? conn->errorMsg : NULL);

    case ES_ejs_web_Request_filename:
        if (req->filename == 0) {
            pathInfo = ejsToMulti(ejs, req->pathInfo);
            if (req->dir) {
                filename = mprJoinPath(req->dir->value, &pathInfo[1]);
                req->filename = ejsCreatePathFromAsc(ejs, filename);
            } else {
                req->filename = ejsCreatePathFromAsc(ejs, pathInfo);
            }
        }
        return req->filename ? (EjsObj*) req->filename : S(null);

    case ES_ejs_web_Request_files:
        return createFiles(ejs, req);

    case ES_ejs_web_Request_headers:
        return createHeaders(ejs, req);

    case ES_ejs_web_Request_home:
        if (req->home == 0) {
            if (conn) {
                req->home = ejsCreateUriFromMulti(ejs, makeRelativeHome(ejs, req));
            } else return S(null);
        }
        return req->home;

    case ES_ejs_web_Request_host:
        if (req->host == 0) {
            /* getHost can handle a null conn */
            req->host = createString(ejs, getHost(conn, req));
        }
        return req->host;

    case ES_ejs_web_Request_isSecure:
        return ejsCreateBoolean(ejs, conn ? conn->secure : 0);

    case ES_ejs_web_Request_limits:
        return getLimits(ejs, req);

    case ES_ejs_web_Request_localAddress:
        return createString(ejs, conn ? conn->sock->acceptIp : NULL);

    case ES_ejs_web_Request_log:
        if (req->log == 0) {
            app = ejsGetProperty(ejs, ejs->global, ES_App);
            req->log = ejsGetProperty(ejs, app, ES_App_log);
        }
        return req->log;

    case ES_ejs_web_Request_method:
        return createString(ejs, conn ? conn->rx->method : NULL);

    case ES_ejs_web_Request_originalMethod:
        return mapNull(ejs, req->originalMethod);

    case ES_ejs_web_Request_originalUri:
        if (req->originalUri == 0) {
            if (conn) {
                scheme = (conn->secure) ? "https" : "http";
                /* NOTE: conn->rx->uri is not normalized or decoded */
                req->originalUri = (EjsObj*) ejsCreateUriFromParts(ejs, scheme, getHost(conn, req), req->server->port, 
                    conn->rx->uri, conn->rx->parsedUri->query, conn->rx->parsedUri->reference, 0);
            } else {
                return S(null);
            }
        }
        return req->originalUri;

    case ES_ejs_web_Request_params:
        return createParams(ejs, req);

    case ES_ejs_web_Request_pathInfo:
        return req->pathInfo;

    case ES_ejs_web_Request_port:
        if (req->port == 0) {
            if (req->server) {
                req->port = ejsCreateNumber(ejs, req->server->port);
            } else return S(null);
        }
        return req->port;

    case ES_ejs_web_Request_protocol:
        return createString(ejs, conn ? conn->protocol : NULL);

    case ES_ejs_web_Request_query:
        if (req->query == 0) {
            req->query = createString(ejs, conn ? conn->rx->parsedUri->query : NULL);
        }
        return req->query;

    case ES_ejs_web_Request_reference:
        if (req->reference == 0) {
            req->reference = createString(ejs, conn ? conn->rx->parsedUri->reference : NULL);
        } 
        return req->reference;

    case ES_ejs_web_Request_referrer:
        return createString(ejs, conn ? conn->rx->referrer: NULL);

    case ES_ejs_web_Request_remoteAddress:
        return createString(ejs, conn ? conn->ip : NULL);

    case ES_ejs_web_Request_responded:
        return ejsCreateBoolean(ejs, req->responded);

    case ES_ejs_web_Request_responseHeaders:
        return createResponseHeaders(ejs, req);

    case ES_ejs_web_Request_route:
        return mapNull(ejs, req->route);

    case ES_ejs_web_Request_scheme:
        if (req->scheme == 0) {
            req->scheme = createString(ejs, (conn && conn->secure) ? "https" : "http");
        }
        return req->scheme;

    case ES_ejs_web_Request_scriptName:
        return req->scriptName ? req->scriptName : S(empty);

    case ES_ejs_web_Request_server:
        return req->server;

    case ES_ejs_web_Request_session:
        if (req->session == 0) {
            req->session = getSession(ejs, req, 1);
        }
        return req->session ? req->session : S(null);

    case ES_ejs_web_Request_sessionID:
        getSession(ejs, req, 0);
        return (req->session) ? req->session->key : S(null);

    case ES_ejs_web_Request_status:
        if (conn) {
            return ejsCreateNumber(ejs, conn->tx->status);
        } else return S(null);

    case ES_ejs_web_Request_uri:
        if (req->uri == 0) {
            scriptName = getDefaultString(ejs, req->scriptName, "");
            if (conn) {
                path = sjoin(scriptName, getDefaultString(ejs, req->pathInfo, conn->rx->uri), NULL);
                scheme = (conn->secure) ? "https" : "http";
                req->uri = ejsCreateUriFromParts(ejs, 
                    getDefaultString(ejs, req->scheme, scheme),
                    getDefaultString(ejs, req->host, getHost(conn, req)),
                    getDefaultInt(ejs, req->port, req->server->port),
                    path,
                    getDefaultString(ejs, req->query, conn->rx->parsedUri->query),
                    getDefaultString(ejs, req->reference, conn->rx->parsedUri->reference), 
                    0);
            } else {
                path = sjoin(scriptName, getDefaultString(ejs, req->pathInfo, NULL), NULL);
                req->uri = ejsCreateUriFromParts(ejs, 
                    getDefaultString(ejs, req->scheme, NULL),
                    getDefaultString(ejs, req->host, NULL),
                    getDefaultInt(ejs, req->port, 0),
                    path,
                    getDefaultString(ejs, req->query, NULL),
                    getDefaultString(ejs, req->reference, NULL), 
                    0);
            }
        }
        return req->uri;

    default:
        if (slotNum < req->pot.numProp) {
            return ST(Object)->helpers.getProperty(ejs, req, slotNum);
        }
    }
    return 0;
}


static int getRequestPropertyCount(Ejs *ejs, EjsRequest *req)
{
    return ES_ejs_web_Request_NUM_INSTANCE_PROP;
}


static EjsName getRequestPropertyName(Ejs *ejs, EjsRequest *req, int slotNum)
{
    EjsName     qname;

    qname = ejsGetPropertyName(ejs, TYPE(req)->prototype, slotNum);
    if (qname.name == 0) {
        qname = ejsGetPotPropertyName(ejs, &req->pot, slotNum);
    }
    return qname;
}


static int lookupRequestProperty(Ejs *ejs, EjsRequest *req, EjsName qname)
{
    int slotNum;
    
    slotNum = ejsLookupProperty(ejs, TYPE(req)->prototype, qname);
    if (slotNum < 0) {
        slotNum = ejsLookupPotProperty(ejs, &req->pot, qname);
    }
    return slotNum;
}


static int getNum(Ejs *ejs, EjsObj *vp)
{
    if (!ejsIs(ejs, vp, Number) && (vp = (EjsObj*) ejsToNumber(ejs, vp)) == 0) {
        return 0;
    }
    return (int) ((EjsNumber*) vp)->value;
}


static int setRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum,  EjsObj *value)
{
    EjsType     *type;
    EjsUri      *up;

    switch (slotNum) {
    default:
        return ST(Object)->helpers.setProperty(ejs, req, slotNum, value);

    case ES_ejs_web_Request_config:
        req->config = value;
        break;

    case ES_ejs_web_Request_absHome:
        req->absHome = (EjsObj*) ejsToUri(ejs, value);
        break;

    case ES_ejs_web_Request_autoFinalizing:
        req->dontAutoFinalize = !ejsGetBoolean(ejs, value);
        break;

    case ES_ejs_web_Request_dir:
        req->dir = ejsToPath(ejs, value);
        req->filename = 0;
        break;

    case ES_ejs_web_Request_filename:
        req->filename = ejsToPath(ejs, value);
        break;

    case ES_ejs_web_Request_headers:
        /*
            This updates the cached header set only. The original headers in the http module are unchanged.
         */
        req->headers = value;
        break;

    case ES_ejs_web_Request_home:
        req->home = ejsToUri(ejs, value);
        break;

    case ES_ejs_web_Request_host:
        req->host = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_log:
        type = ejsGetType(ejs, ES_Logger);
        if (!ejsIsA(ejs, value, type)) {
            ejsThrowArgError(ejs, "Property is not a logger");
            break;
        }
        req->log = value;
        break;

    case ES_ejs_web_Request_pathInfo:
        req->pathInfo = ejsToString(ejs, value);
        req->filename = 0;
        req->uri = 0;
        break;

    case ES_ejs_web_Request_port:
        req->port = ejsToNumber(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_query:
        req->query = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_reference:
        req->reference = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_responded:
        req->responded = (value == S(true));
        break;

    case ES_ejs_web_Request_responseHeaders:
        req->responseHeaders = value;
        break;

    case ES_ejs_web_Request_route:
        req->route = value;
        break;

    case ES_ejs_web_Request_scriptName:
        req->scriptName = ejsToString(ejs, value);
        req->filename = 0;
        req->uri = 0;
        req->absHome = 0;
        break;

    case ES_ejs_web_Request_server:
        type = ejsGetTypeByName(ejs, N("ejs.web", "HttpServer"));
        if (!ejsIsA(ejs, value, type)) {
            ejsThrowArgError(ejs, "Property is not an instance of HttpServer");
            break;
        }
        req->server = (EjsHttpServer*) value;
        break;

    case ES_ejs_web_Request_scheme:
        req->scheme = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_uri:
        up = ejsToUri(ejs, value);
        req->uri = up;
        req->filename = 0;
        if (!connOk(ejs, req, 0)) {
            /*
                This is really just for unit testing without a connection
             */
            if (up->uri->scheme) {
                req->scheme = ejsCreateStringFromAsc(ejs, up->uri->scheme);
            }
            if (up->uri->host) {
                req->host = ejsCreateStringFromAsc(ejs, up->uri->host);
            }
            if (up->uri->port) {
                req->port = ejsCreateNumber(ejs, up->uri->port);
            }
            if (up->uri->path) {
                req->pathInfo = ejsCreateStringFromAsc(ejs, up->uri->path);
            }
            if (up->uri->query) {
                req->query = ejsCreateStringFromAsc(ejs, up->uri->query);
            }
            if (up->uri->reference) {
                req->reference = ejsCreateStringFromAsc(ejs, up->uri->reference);
            }
        }
        break;

    /*
        Read-only fields
     */
    case ES_ejs_web_Request_authGroup:
    case ES_ejs_web_Request_authType:
    case ES_ejs_web_Request_authUser:
    case ES_ejs_web_Request_contentLength:
    case ES_ejs_web_Request_cookies:
    case ES_ejs_web_Request_env:
    case ES_ejs_web_Request_errorMessage:
    case ES_ejs_web_Request_files:
    case ES_ejs_web_Request_isSecure:
    case ES_ejs_web_Request_limits:
    case ES_ejs_web_Request_localAddress:
    case ES_ejs_web_Request_originalMethod:
    case ES_ejs_web_Request_originalUri:
    case ES_ejs_web_Request_params:
    case ES_ejs_web_Request_protocol:
    case ES_ejs_web_Request_referrer:
    case ES_ejs_web_Request_remoteAddress:
    case ES_ejs_web_Request_session:
    case ES_ejs_web_Request_sessionID:
        ejsThrowReferenceError(ejs, "Property is readonly");
        break;

    /*
        These tests require a connection
     */
    case ES_ejs_web_Request_method:
        if (!connOk(ejs, req, 1)) return 0;
        if (req->originalMethod == 0) {
            req->originalMethod = ejsCreateStringFromAsc(ejs, req->conn->rx->method);
        }
        req->conn->rx->method = sclone(getRequestString(ejs, value));
        break;

    case ES_ejs_web_Request_status:
        if (!connOk(ejs, req, 1)) return 0;
        httpSetStatus(req->conn, getNum(ejs, value));
        req->responded = 1;
        break;
    }
    return 0;
}


/*  
    function get async(): Boolean
 */
static EjsObj *req_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return S(true);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *req_set_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (argv[0] != S(true)) {
        ejsThrowIOError(ejs, "Request only supports async mode");
    }
    return 0;
}


/*  
    function autoFinalize(): Void

    Auto-finalize the request if dontAutoFinalize has not been set.
 */
static EjsObj *req_autoFinalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (req->conn && !req->dontAutoFinalize) {
        httpFinalize(req->conn);
    }
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *req_close(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (req->conn) {
        httpFinalize(req->conn);
        httpCloseRx(req->conn);
    }
    ejsSendRequestCloseEvent(ejs, req);
    return 0;
}


/*  
    function destroySession(): Void
 */
static EjsObj *req_destroySession(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsSession  *sp;

    if ((sp = getSession(ejs, req, 0)) != 0) {
        ejsDestroySession(ejs, sp);
    }
    req->probedSession = 0;
    req->session = 0;
    return 0;
}


/*  
    function dontAutoFinalize(): Void
 */
static EjsObj *req_dontAutoFinalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    req->dontAutoFinalize = 1;
    return 0;
}


/*  
    function finalize(): Void
 */
static EjsObj *req_finalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (req->conn) {
        httpFinalize(req->conn);
    }
    req->responded = 1;
    return 0;
}


/*  
    function get finalized(): Boolean
 */
static EjsBoolean *req_finalized(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, req->conn == 0 || req->conn->tx->finalized);
}


/*  
    function flush(dir: Number = Stream.WRITE): Void
 */
static EjsObj *req_flush(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    int     dir;

    if (req->conn) {
        dir = (argc == 1) ? ejsGetInt(ejs, argv[0]) : EJS_STREAM_WRITE;
        if (dir & EJS_STREAM_WRITE) {
            httpFlush(req->conn);
        }
    }
    return 0;
}


/*  
    function header(key: String): String
 */
static EjsObj *req_header(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsObj      *value;
    EjsName     qname;
    char        *key;
    int         count, i;

    createHeaders(ejs, req);
    key = (char*) ejsToMulti(ejs, argv[0]);

    if ((value = ejsGetPropertyByName(ejs, req->headers, EN(key))) == 0) {
        count = ejsGetPropertyCount(ejs, req->headers);
        for (i = 0; i < count; i++) {
            qname = ejsGetPropertyName(ejs, req->headers, i);
            if (mcasecmp(qname.name->value, key) == 0) {
                value = ejsGetProperty(ejs, req->headers, i);
                break;
            }
        }
    }
    return (value) ? value : S(null);
}


/*  
    function off(name: [String|Array], listener: Function): Void
 */
static EjsObj *req_off(Ejs *ejs, EjsRequest *req, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, req->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name: [String|Array], listener: Function): Void
 */
static EjsObj *req_on(Ejs *ejs, EjsRequest *req, int argc, EjsAny **argv)
{
    HttpConn    *conn;
    
    conn = req->conn;
    ejsAddObserver(ejs, &req->emitter, argv[0], argv[1]);

    if (conn->readq->count > 0) {
        ejsSendEvent(ejs, req->emitter, "readable", NULL, req);
    }
    if (!conn->writeComplete && !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_COMPLETE &&
            conn->writeq->ioCount == 0) {
        //  MOB - where else are writable events issued?  - what if write blocked and then resuming?
        ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
    }
    return 0;
}


/*  
    function read(buffer, offset, count): Number
 */
static EjsNumber *req_read(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    ssize           offset, count, nbytes;

    if (!connOk(ejs, req, 1)) return 0;

    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]) : -1;

    if (!ejsMakeRoomInByteArray(ejs, ba, count >= 0 ? count : MPR_BUFSIZE)) {
        return 0;
    }
    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->length - offset;
    }
    if (count < 0) {
        ejsThrowStateError(ejs, "Read count is negative");
        return 0;
    }
    mprAssert(count > 0);
    nbytes = httpRead(req->conn, (char*) &ba->value[offset], count);
    if (nbytes < 0) {
        ejsThrowIOError(ejs, "Can't read from socket");
        return 0;
    }
    if (nbytes == 0) {
        if (httpIsEof(req->conn)) {
            //  TODO -- should this set req->conn to zero?
            return S(null);
        }
    }
    ba->writePosition += nbytes;
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
static EjsObj *req_setHeader(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsString   *value;
    EjsObj      *old;
    cchar       *key;
    int         overwrite;

    if (!connOk(ejs, req, 1)) return 0;
    key = ejsToMulti(ejs, argv[0]);
    value = (EjsString*) argv[1];
    overwrite = argc < 3 || argv[2] == S(true);
    createResponseHeaders(ejs, req);
    if (!overwrite) {
        if ((old = ejsGetPropertyByName(ejs, req->responseHeaders, EN(key))) != 0) {
            value = ejsSprintf(ejs, "%@, %@", old, value);
        }
    }
    ejsSetPropertyByName(ejs, req->responseHeaders, EN(key), value);

    /* Just until we have filters - to disable chunk filtering */
    if (strcmp(key, "x-chunk-size") == 0) {
        httpSetChunkSize(req->conn, ejsGetInt(ejs, value));
    }
    return 0;
}


/*  
    function set limits(limits: Object): Void
 */
static EjsObj *req_setLimits(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (!connOk(ejs, req, 1)) return 0;
    if (req->conn->limits == req->server->server->limits) {
        httpSetUniqueConnLimits(req->conn);
    }
    if (req->limits == 0) {
        req->limits = ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, req->limits, req->conn->limits, 0);
    }
    ejsBlendObject(ejs, req->limits, argv[0], 1);
    ejsSetHttpLimits(ejs, req->conn->limits, req->limits, 0);
    if (req->session) {
        ejsSetSessionTimeout(ejs, req->session, req->conn->limits->sessionTimeout);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *req_trace(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    ejsSetupTrace(ejs, req->conn->trace, argv[0]);
    return 0;
}


/*  
    Write text to the client. This call writes the arguments back to the client's browser. 
 
    function write(data: Object): Void
 */
static EjsObj *req_write(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsString       *s;
    EjsObj          *data;
    EjsByteArray    *ba;
    HttpQueue       *q;
    HttpConn        *conn;
    ssize           len, written;
    int             err, i;

    if (!connOk(ejs, req, 1)) return 0;

    err = 0;
    written = 0;
    args = (EjsArray*) argv[0];
    conn = req->conn;
    q = conn->writeq;

    if (httpIsFinalized(conn)) {
        /*
            Better to just eat the data if already finalized
         */
#if UNUSED
        ejsThrowIOError(ejs, "Response already finalized");
#endif
        return 0;
    }
    for (i = 0; i < args->length; i++) {
        data = args->data[i];
        switch (TYPE(data)->sid) {
        case S_String:
            s = (EjsString*) data;
            if ((written = httpWriteBlock(q, s->value, s->length)) != s->length) {
                err++;
            }
            break;

        case S_ByteArray:
            ba = (EjsByteArray*) data;
            //  TODO -- not updating the read position
            //      ba->readPosition += len;
            //      should reset ptrs also
            len = ba->writePosition - ba->readPosition;
            if ((written = httpWriteBlock(q, (char*) &ba->value[ba->readPosition], len)) != len) {
                err++;
            }
            break;

        default:
            s = (EjsString*) ejsToString(ejs, data);
            if (s == NULL || (written = httpWriteBlock(q, s->value, s->length)) != s->length) {
                err++;
            }
        }
        if (err) {
            ejsThrowIOError(ejs, "%s", conn->errorMsg);
        }
        if (ejs->exception) {
            return 0;
        }
        req->written += written;
    }
    req->responded = 1;

    if (!conn->writeComplete && !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_COMPLETE &&
            conn->writeq->ioCount == 0) {
        ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
    }
    return 0;
}


/*  
    function writeFile(path: Path): Boolean
 */
static EjsObj *req_writeFile(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsPath         *path;
    HttpConn        *conn;
    HttpRx          *rx;
    HttpTx          *tx;
    HttpPacket      *packet;
    MprPath         info;

    if (!connOk(ejs, req, 1)) return 0;
    conn = req->conn;
    rx = conn->rx;
    tx = conn->tx;

    if (rx->ranges || conn->secure || tx->chunkSize > 0) {
        return S(false);
    }
    path = (EjsPath*) argv[0];
    if (mprGetPathInfo(path->value, &info) < 0) {
        ejsThrowIOError(ejs, "Cannot open %s", path->value);
        return S(false);
    }
    packet = httpCreateEntityPacket(0, info.size, NULL);
    tx->length = tx->entityLength = info.size;
    httpSetSendConnector(req->conn, path->value);
    httpPutForService(conn->writeq, packet, 0);
    httpFinalize(req->conn);
    return S(true);
}


/*
    function get written(): Number
 */
static EjsNumber *req_written(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) req->written);
}


/*
    Clone the request object into the "ejs" interpreter.
    This does a "minimal" clone for speed.
 */
EjsRequest *ejsCloneRequest(Ejs *ejs, EjsRequest *req, bool deep)
{
    HttpConn    *conn;
    EjsRequest  *nreq;

    if ((nreq = ejsCreatePot(ejs, ST(Request), 0)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    conn = req->conn;
    nreq->conn = conn;
    nreq->ejs = ejs;
    nreq->dir = ejsClone(ejs, req->dir, 1);
    nreq->filename = ejsClone(ejs, req->filename, 1);
    nreq->pathInfo = ejsCreateStringFromAsc(ejs, conn->rx->pathInfo);
    nreq->scriptName = ejsCreateStringFromAsc(ejs, conn->rx->scriptName);
#if UNUSED
    nreq->accepted = req->accepted;
#endif
    nreq->running = req->running;
    nreq->cloned = req;

//  MOB - limits?
    if (req->route) {
        nreq->route = ejsClone(ejs, req->route, 1);
    }
    if (req->config) {
        nreq->config = ejsClone(ejs, req->config, 1);
    }
    if (req->params) {
        nreq->params = ejsClone(ejs, req->params, 1);
    }
    return nreq;
}


EjsRequest *ejsCreateRequest(Ejs *ejs, EjsHttpServer *server, HttpConn *conn, cchar *dir)
{
    EjsRequest      *req;
    EjsType         *type;
    HttpRx          *rx;

    mprAssert(server);
    mprAssert(conn);
    mprAssert(dir && *dir);

    type = ejsGetTypeByName(ejs, N("ejs.web", "Request"));
    if (type == NULL || (req = ejsCreateObj(ejs, type, 0)) == NULL) {
        return 0;
    }
    req->running = 1;
    req->conn = conn;
    req->ejs = ejs;
    req->server = server;
    rx = conn->rx;
    if (mprIsRelPath(dir)) {
        req->dir = ejsCreatePathFromAsc(ejs, dir);
    } else {
        req->dir = ejsCreatePathFromAsc(ejs, mprGetRelPath(dir));
    }
    mprAssert(!VISITED(req->dir));
    //  OPT -- why replicate these two
    req->pathInfo = ejsCreateStringFromAsc(ejs, rx->pathInfo);
    req->scriptName = ejsCreateStringFromAsc(ejs, rx->scriptName);
    return req;
}


void ejsSendRequestCloseEvent(Ejs *ejs, EjsRequest *req)
{
    if (!req->closed && req->emitter) {
        req->closed = 1;
        ejsSendEvent(ejs, req->emitter, "close", NULL, req);
    }
}


void ejsSendRequestErrorEvent(Ejs *ejs, EjsRequest *req)
{
    if (!req->error && req->emitter) {
        req->error = 1;
        ejsSendEvent(ejs, req->emitter, "error", NULL, req);
    }
}


void ejsSendRequestEvent(Ejs *ejs, EjsRequest *req, cchar *event)
{
    if (req->emitter) {
        ejsSendEvent(ejs, req->emitter, event, NULL, req);
    }
}


/*  
    Mark the object properties for the garbage collector
 */
static void manageRequest(EjsRequest *req, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(req, flags);
        mprMark(req->absHome);
        mprMark(req->config);
        mprMark(req->conn);
        mprMark(req->cookies);
        mprMark(req->dir);
        mprMark(req->emitter);
        mprMark(req->env);
        mprMark(req->filename);
        mprMark(req->files);
        mprMark(req->headers);
        mprMark(req->home);
        mprMark(req->host);
        mprMark(req->limits);
        mprMark(req->originalMethod);
        mprMark(req->originalUri);
        mprMark(req->params);
        mprMark(req->pathInfo);
        mprMark(req->port);
        mprMark(req->query);
        mprMark(req->reference);
        mprMark(req->responseHeaders);
        mprMark(req->route);
        mprMark(req->scheme);
        mprMark(req->scriptName);
        mprMark(req->server);
        mprMark(req->session);
        mprMark(req->uri);
        mprMark(req->cloned);
    } else {
        // mprLog(0, "FREE REQUEST - cloned %p", req->cloned);
    }
}


void ejsConfigureRequestType(Ejs *ejs)
{
    EjsType     *type;
    EjsHelpers  *helpers;
    EjsPot      *prototype;

    type = ejsConfigureNativeType(ejs, N("ejs.web", "Request"), sizeof(EjsRequest), manageRequest, EJS_POT_HELPERS);
    ejsSetSpecialType(ejs, S_Request, type);

    helpers = &type->helpers;
    helpers->getProperty = (EjsGetPropertyHelper) getRequestProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getRequestPropertyCount;
    helpers->getPropertyName = (EjsGetPropertyNameHelper) getRequestPropertyName;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupRequestProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setRequestProperty;

    prototype = type->prototype;
    ejsBindAccess(ejs, prototype, ES_ejs_web_Request_async, req_async, req_set_async);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_autoFinalize, req_autoFinalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_close, req_close);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_destroySession, req_destroySession);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_dontAutoFinalize, req_dontAutoFinalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_finalize, req_finalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_finalized, req_finalized);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_flush, req_flush);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_header, req_header);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_off, req_off);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_on, req_on);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_read, req_read);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_setLimits, req_setLimits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_setHeader, req_setHeader);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_trace, req_trace);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_write, req_write);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_writeFile, req_writeFile);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_written, req_written);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
 
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
 
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
 
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.web/src/ejsRequest.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.web/src/ejsSession.c"
 */
/************************************************************************/

/**
    ejsSession.c - Native code for the Session class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int getSessionState(Ejs *ejs, EjsSession *sp);


static EjsSession *initSession(Ejs *ejs, EjsSession *sp, EjsString *key, MprTime timeout)
{
    EjsObj      *app;

    app = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "App"));
    sp->store = ejsGetProperty(ejs, app, ES_App_store);

    sp->lifespan = timeout;
    sp->key = key;
    return sp;
}


static EjsString *makeKey(Ejs *ejs, EjsSession *sp)
{
    char        idBuf[64];
    static int  nextSession = 0;

    /* Thread race here on nextSession++ not critical */
    mprSprintf(idBuf, sizeof(idBuf), "%08x%08x%d", PTOI(ejs) + PTOI(sp), (int) mprGetTime(), nextSession++);
    return ejsCreateStringFromAsc(ejs, mprGetMD5Hash(idBuf, sizeof(idBuf), "session-"));
}


/*
    Get (create) a session object using the supplied key. If the key has expired or is NULL, then generate a new key if
    create is true.
 */
EjsSession *ejsGetSession(Ejs *ejs, EjsString *key, MprTime timeout, int create)
{
    EjsSession  *sp;

    if ((sp = ejsCreateObj(ejs, ST(Session), 0)) == 0) {
        return 0;
    }
    mprSetName(sp, "session");
    initSession(ejs, sp, key, timeout);
    if (!getSessionState(ejs, sp) && create) {
        sp->key = makeKey(ejs, sp);
    }
    return sp;
}


int ejsDestroySession(Ejs *ejs, EjsSession *sp)
{
    if (sp) {
        ejsStoreRemove(ejs, sp->store, sp->key);
    }
    return 0;
}


static void manageSession(EjsSession *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(sp, flags);
        mprMark(sp->key);
    }
}


/*
    Session state is read once and cached. Writes to session properties are cached with write-through
 */
static int getSessionState(Ejs *ejs, EjsSession *sp) 
{
    EjsName     qname;
    EjsObj      *src, *vp;
    int         i, count;

    if (sp->ready) {
        return 1;
    }
    sp->ready = 1;
    if (sp->key && (src = ejsStoreReadObj(ejs, sp->store, sp->key, 0)) != 0) {
        sp->pot.numProp = 0;
        count = ejsGetPropertyCount(ejs, src);
        for (i = 0; i < count; i++) {
            if ((vp = ejsGetProperty(ejs, src, i)) == 0) {
                continue;
            }
            qname = ejsGetPropertyName(ejs, src, i);
            ejs->potHelpers.setProperty(ejs, sp, i, vp);
            ejs->potHelpers.setPropertyName(ejs, sp, i, qname);
        }
        return 1;
    }
    return 0;
}


static EjsObj *getSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum)
{
    EjsObj  *value;

    getSessionState(ejs, sp);
    value = ejs->potHelpers.getProperty(ejs, sp, slotNum);
    if (ejsIs(ejs, value, Void)) {
        /*  Return empty string so that web pages can access session values without having to test for null/undefined */
        value = S(empty);
    }
    return value;
}


static EjsObj *getSessionPropertyByName(Ejs *ejs, EjsSession *sp, EjsName qname)
{
    int     slotNum;

    getSessionState(ejs, sp);
    slotNum = ejs->potHelpers.lookupProperty(ejs, sp, qname);
    return (slotNum < 0) ? S(empty) : ejs->potHelpers.getProperty(ejs, sp, slotNum);
}


static int lookupSessionProperty(Ejs *ejs, EjsSession *sp, EjsName qname)
{
    getSessionState(ejs, sp);
    return ejs->potHelpers.lookupProperty(ejs, sp, qname);
}


/*
    Set a session property with write-through to the key/value store
 */
static int setSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum, EjsAny *value)
{
    if (ejs->potHelpers.setProperty(ejs, sp, slotNum, value) != slotNum) {
        return EJS_ERR;
    }
    if (sp->options == 0) {
        sp->options = ejsCreateEmptyPot(ejs);
        ejsSetPropertyByName(ejs, sp->options, EN("lifespan"), ejsCreateNumber(ejs, sp->lifespan));
    }
    if (ejsStoreWriteObj(ejs, sp->store, sp->key, sp, sp->options) == 0) {
        return EJS_ERR;
    }
    return 0;
}


void ejsSetSessionTimeout(Ejs *ejs, EjsSession *sp, int timeout)
{
    ejsStoreExpire(ejs, sp->store, sp->key, ejsCreateDate(ejs, mprGetTime() + timeout));
}


/*
    function Session(key: String, options: Object)

    The constructor is bypassed when ejsGetSession is called from Request.
 */
static EjsSession *sess_constructor(Ejs *ejs, EjsSession *sp, int argc, EjsAny **argv)
{
    EjsAny      *vp;
    EjsPot      *options;
    MprTime     lifespan;

    lifespan = 0;
    if (argc > 0) {
        options = argv[0];
        vp = ejsGetPropertyByName(ejs, options, EN("lifespan"));
        lifespan = ejsGetInt(ejs, vp);
    }
    return initSession(ejs, sp, sp->key, lifespan);
}


/*
    static function destroySession(session: Session)
 */
static EjsVoid *sess_destroySession(Ejs *ejs, EjsType *Session, int argc, EjsAny **argv)
{
    ejsDestroySession(ejs, argv[0]);
    return 0;
}


/*
    static function key(session: Session): String
 */
static EjsString *sess_key(Ejs *ejs, EjsType *Session, int argc, EjsAny **argv)
{
    EjsSession  *sp;

    sp = argv[0];
    return sp->key;
}


void ejsConfigureSessionType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;

    type = ejsConfigureNativeType(ejs, N("ejs.web", "Session"), sizeof(EjsSession), manageSession, EJS_POT_HELPERS);
    ejsSetSpecialType(ejs, S_Session, type);
    mprAssert(type->mutex == 0);

    /*
        Sessions are created indirectly by accessing Request.session[] which uses ejsGetSession.
     */
    helpers = &type->helpers;
    helpers->getProperty = (EjsGetPropertyHelper) getSessionProperty;
    helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getSessionPropertyByName;
    helpers->setProperty = (EjsSetPropertyHelper) setSessionProperty;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupSessionProperty;

    ejsBindConstructor(ejs, type, sess_constructor);
    ejsBindAccess(ejs, type, ES_ejs_web_Session_destorySession, sess_destroySession, 0);
    ejsBindAccess(ejs, type, ES_ejs_web_Session_key, sess_key, 0);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.web/src/ejsSession.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/jems/ejs.web/src/ejsWeb.c"
 */
/************************************************************************/

//  MOB - remove Web class and blend into HttpServer
/*
    ejsWeb.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static int configureWebTypes(Ejs *ejs);

/*  
    HTML escape a string
    function escapeHtml(str: String): String
 */
static EjsObj *web_escapeHtml(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;

    str = (EjsString*) argv[0];
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprEscapeHtml(str->value));
}


static int configureWebTypes(Ejs *ejs)
{
    int         slotNum;

    if ((slotNum = ejsLookupProperty(ejs, ejs->global, N("ejs.web", "escapeHtml"))) != 0) {
        ejsBindFunction(ejs, ejs->global, slotNum, web_escapeHtml);
    }
    ejsConfigureHttpServerType(ejs);
    ejsConfigureRequestType(ejs);
    ejsConfigureSessionType(ejs);
    return 0;
}


/*  
    Module load entry point. This must be idempotent as it will be called for each new interpreter created.
 */
int ejs_web_Init(Ejs *ejs, MprModule *mp)
{
    return ejsAddNativeModule(ejs, "ejs.web", configureWebTypes, _ES_CHECKSUM_ejs_web, EJS_LOADER_ETERNAL);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
 
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
 
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
 
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/jems/ejs.web/src/ejsWeb.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecAst.c"
 */
/************************************************************************/

/**
    ecAst.c - Process AST nodes and define all variables.

    Note on error handling. If a non-recoverable error occurs, then EcCompiler.hasFatalError will be set and
    processing will be aborted. If a recoverable error occurs, then hasError will be set and processing will continue.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(cp) if (ecEnterState(cp) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp) ecLeaveState(cp)


static void     addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname);
static void     addScope(EcCompiler *cp, EjsBlock *block);
static void     astBinaryOp(EcCompiler *cp, EcNode *np);
static void     astBindName(EcCompiler *cp, EcNode *np);
static void     astBlock(EcCompiler *cp, EcNode *np);
static void     astBreak(EcCompiler *cp, EcNode *np);
static void     astCall(EcCompiler *cp, EcNode *np);
static void     astCaseElements(EcCompiler *cp, EcNode *np);
static void     astCaseLabel(EcCompiler *cp, EcNode *np);
static void     astCatch(EcCompiler *cp, EcNode *np);
static void     astClass(EcCompiler *cp, EcNode *np);
static void     astDirectives(EcCompiler *cp, EcNode *np);
static void     astDot(EcCompiler *cp, EcNode *np);
static void     astDo(EcCompiler *cp, EcNode *np);
static void     astError(EcCompiler *cp, EcNode *np, cchar *fmt, ...);
static void     astExpressions(EcCompiler *cp, EcNode *np);
static void     astField(EcCompiler *cp, EcNode *np);
static void     astFor(EcCompiler *cp, EcNode *np);
static void     astForIn(EcCompiler *cp, EcNode *np);
static void     astFunction(EcCompiler *cp, EcNode *np);
static void     astHash(EcCompiler *cp, EcNode *np);
static void     astIf(EcCompiler *cp, EcNode *np);
static void     astName(EcCompiler *cp, EcNode *np);
static void     astNew(EcCompiler *cp, EcNode *np);
static void     astObjectLiteral(EcCompiler *cp, EcNode *np);
static void     astPostfixOp(EcCompiler *cp, EcNode *np);
static void     astPragmas(EcCompiler *cp, EcNode *np);
static void     astPragma(EcCompiler *cp, EcNode *np);
static void     astProgram(EcCompiler *cp, EcNode *np);
static void     astReturn(EcCompiler *cp, EcNode *np);
static void     astSuper(EcCompiler *cp, EcNode *np);
static void     astSwitch(EcCompiler *cp, EcNode *np);
static void     astThis(EcCompiler *cp, EcNode *np);
static void     astThrow(EcCompiler *cp, EcNode *np);
static void     astTry(EcCompiler *cp, EcNode *np);
static void     astUnaryOp(EcCompiler *cp, EcNode *np);
static void     astModule(EcCompiler *cp, EcNode *np);
static void     astUseNamespace(EcCompiler *cp, EcNode *np);
static void     astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode);
static void     astVoid(EcCompiler *cp, EcNode *np);
static void     astWarn(EcCompiler *cp, EcNode *np, cchar *fmt, ...);
static void     astWith(EcCompiler *cp, EcNode *np);
static void     badAst(EcCompiler *cp, EcNode *np);
static void     bindVariableDefinition(EcCompiler *cp, EcNode *np);
static void     closeBlock(EcCompiler *cp);
static EjsNamespace *createHoistNamespace(EcCompiler *cp, EjsObj *obj);
static EjsModule    *createModule(EcCompiler *cp, EcNode *np);
static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp);
static int      defineParameters(EcCompiler *cp, EcNode *np);
static void     defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     fixupClass(EcCompiler *cp, EjsType *type);
static EjsBlock *getBlockForDefinition(EcCompiler *cp, EcNode *np, EjsBlock *block, int attributes);
static EcNode   *getNextAstNode(EcCompiler *cp, EcNode *np, int *next);
static EjsObj   *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName name);
static bool     hoistBlockVar(EcCompiler *cp, EcNode *np);
static void     openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block);
static void     processAstNode(EcCompiler *cp, EcNode *np);
static void     removeProperty(EcCompiler *cp, EjsObj *block, EcNode *np);
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsAny *block, bool *modified);
static void     removeScope(EcCompiler *cp);
static int      resolveName(EcCompiler *cp, EcNode *node, EjsAny *vp,  EjsName name);
static int      resolveProperty(EcCompiler *cp, EcNode *node, EjsType *type, EjsName name);
static void     setAstDocString(Ejs *ejs, EcNode *np, cchar *tag, void *vp, int slotNum);
static EjsNamespace *lookupNamespace(Ejs *ejs, EjsString *namespace);

/*
    Top level AST node processing.
 */
static int astProcess(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;
    int     phase;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }

    ejs = cp->ejs;
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, conditional, fixup, bind and erase
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        /*
            Looping through the input source files. A single top level node describes the source file.
         */
        cp->phase = phase;
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        processAstNode(cp, np);
    }
    ecLeaveState(cp);
    cp->fileState = 0;
    cp->blockState = 0;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


int ecAstProcess(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;
    int         phase, i, count;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }

    ejs = cp->ejs;
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, load, fixup, block vars and bind
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        cp->phase = phase;

        /*
            Loop over each source file
         */
        count = mprGetListLength(cp->nodes);
        for (i = 0; i < count && !cp->fatalError; i++) {
            /*
                Looping through the input source files. A single top level node describes the source file.
             */
            np = mprGetItem(cp->nodes, i);
            if (np == 0) {
                continue;
            }
            cp->fileState = cp->state;
            cp->fileState->strict = cp->strict;
            processAstNode(cp, np);
        }
    }
    ecLeaveState(cp);
    cp->fileState = 0;
    cp->blockState = 0;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


static void astArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_ARGS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astSpread(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_SPREAD);
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate an assignment expression
 */
static void astAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    int         rc;

    ENTER(cp);

    state = cp->state;
    rc = 0;

    mprAssert(np->kind == N_ASSIGN_OP);
    mprAssert(np->left);
    mprAssert(np->right);

    if (state->inSettings && cp->phase >= EC_PHASE_BIND) {
        /*
            Assignment in a class initializer. The lhs must be scoped outside the block. The rhs must be scoped inside.
         */
        openBlock(cp, state->currentFunctionNode->function.body, (EjsBlock*) state->currentFunction->activation);
        processAstNode(cp, np->right);
        closeBlock(cp);
    } else {
        processAstNode(cp, np->right);
    }
    state->onLeft = 1;
    processAstNode(cp, np->left);
    LEAVE(cp);
}


/*
    Handle a binary operator. We recursively process left and right nodes.
 */
static void astBinaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_BINARY_OP);

    if (np->left) {
        processAstNode(cp, np->left);
    }
    if (np->right) {
        processAstNode(cp, np->right);
    }
    LEAVE(cp);
}


static void defineBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsBlock    *block, *letBlock;
    int         slotNum;

    ejs = cp->ejs;
    state = cp->state;
    letBlock = state->letBlock;

    mprAssert(cp->phase == EC_PHASE_CONDITIONAL);
    mprAssert(np->kind == N_BLOCK || np->kind == N_MODULE);

    block = np->blockRef;

    if (np->createBlockObject) {
        slotNum = ejsDefineProperty(ejs, letBlock, -1, np->qname, TYPE(block), 0, block);
        if (slotNum < 0) {
            astError(cp, np, "Can't define block");
        } else {
            np->blockCreated = 1;
            if (letBlock == ejs->global) {
                addGlobalProperty(cp, np, &np->qname);
            }
        }
    }
}


static void bindBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsBlock    *block;
    int         rc;
    
    mprAssert(cp->phase == EC_PHASE_BIND);
    mprAssert(np->kind == N_BLOCK || np->kind == N_MODULE);

    ejs = cp->ejs;
    block = np->blockRef;
    mprAssert(block);

    rc = resolveName(cp, np, NULL, np->qname);
    if (np->blockCreated) {
        if (! np->createBlockObject) {
            mprAssert(cp->lookup.obj);
            mprAssert(np->lookup.slotNum >= 0);
            ejsDeleteProperty(ejs, np->lookup.obj, np->lookup.slotNum);
            np->blockCreated = 0;
        } else {
            /*
                Mark the parent block as needing to be created to hold this block.
             */
            if (cp->state->next->letBlockNode) {
                cp->state->next->letBlockNode->createBlockObject = 1;
            }
        }
    }
}


static void astBlock(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next, needBlock;

    ENTER(cp);
    
    needBlock = 0;
    if (cp->phase < EC_PHASE_BIND) {
        needBlock = 1;
    } else if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np);
        needBlock = np->blockCreated;
    }

    /*
        Open block will change state->letBlock which we need preserved in defineBlock. Use ENTER/LEAVE to save and restore.
     */
    ENTER(cp);
    if (needBlock) {
        openBlock(cp, np, NULL);
    }
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    if (needBlock) {
        closeBlock(cp);
    }
    LEAVE(cp);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Do define block after the variables have been processed. This allows us to determine if the block is 
            really needed.
         */
        defineBlock(cp, np);

        /* Try to hoist the block object itself */
        if (np->blockCreated && !hoistBlockVar(cp, np)) {
            cp->state->letBlockNode->createBlockObject = 1;
        }
    }
    LEAVE(cp);
}


static void astBreak(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->kind == N_BREAK);
}


static void astCall(EcCompiler *cp, EcNode *np)
{
    EcState         *state;

    mprAssert(np->kind == N_CALL);

    ENTER(cp);
    
    state = cp->state;

    if (state->onLeft) {
        astError(cp, np, "Invalid call expression on the left hand side of assignment");
        LEAVE(cp);
        return;
    }
    if (np->right) {
        mprAssert(np->right->kind == N_ARGS);
        astArgs(cp, np->right);
    }
    processAstNode(cp, np->left);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (np->left) {
            np->lookup = np->left->lookup;
            np->qname = np->left->qname;
        }
    }
    LEAVE(cp);
}


static void astCaseElements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCaseLabel(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_CASE_LABEL);

    if (np->caseLabel.kind == EC_SWITCH_KIND_CASE) {
        mprAssert(np->caseLabel.expression);
        processAstNode(cp, np->caseLabel.expression);

    } else {
        mprAssert(np->caseLabel.kind == EC_SWITCH_KIND_DEFAULT);
    }

    /*
        Process the directives for this case label
     */
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCatch(EcCompiler *cp, EcNode *np)
{
    EjsBlock    *block;
    Ejs         *ejs;

    ENTER(cp);

    ejs = cp->ejs;
    block = ejsCreateBlock(cp->ejs, 0);
    mprSetName(block, MPR_NAME("catch"));
    addScope(cp, block);
    processAstNode(cp, np->left);
    removeScope(cp);
    LEAVE(cp);
}


static EjsType *defineClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructorNode;
    EjsName         qname;
    EjsNamespace    *nsp;
    int             fatt, attributes, slotNum, sid;
    
    mprAssert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;
    sid = -1;

    if ((slotNum = ecLookupVar(cp, ejs->global, np->qname)) >= 0 && cp->fileState->strict) {
        astError(cp, np, "%N Class is already defined.", np->qname);
        return 0;
    }
    if (ejs->empty) {
        type = ejsGetPropertyByName(ejs, ejs->service->foundation, np->qname);
    }
    if (np->attributes & EJS_PROP_NATIVE) {
        astWarn(cp, np, "Native attribute on class %@ is not required, ignoring.", np->qname.name);
    }
    attributes = np->attributes | EJS_TYPE_FIXUP;
    if (np->klass.isInterface) {
        attributes |= EJS_TYPE_INTERFACE;
    }
    if (type == 0) {
        type = ejsCreateType(ejs, np->qname, state->currentModule, NULL, NULL, sizeof(EjsPot), sid, 0, 0, attributes);
        if (type == 0) {
            astError(cp, np, "Can't create type %N", type->qname);
            return 0;
        }
        ejsClonePotHelpers(ejs, type);
        
    } else {
        ejsSetTypeAttributes(type, attributes);
        type->module = state->currentModule;
    }
    type->typeData = np;
    np->klass.ref = type;

    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);

    /*
        Define a property for the type in global
     */
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, np->qname, ST(Type), attributes, type);
    if (slotNum < 0) {
        astError(cp, np, "Can't install type %n",  np->qname);
        return 0;
    }
    if (!type->isInterface) {
        /*
            Reserve one slot for the static initializer to ensure it is the first non-inherited slot.
            This slot may be reclaimed during fixup if not required. Instance initializers are prepended to the constructor.
         */
        //  MOB -- rethink name
        qname.name = ejsCreateStringFromAsc(ejs, mprAsprintf("-%@-", type->qname.name));
        qname.space = ejsCreateStringFromAsc(ejs, EJS_INIT_NAMESPACE);
        fatt = EJS_TRAIT_HIDDEN | EJS_PROP_STATIC;
        ejsDefineProperty(ejs, type, 0, qname, ST(Function), fatt, S(null));
        constructorNode = np->klass.constructor;
        if (constructorNode && !constructorNode->function.isDefault) {
            type->hasConstructor = 1;
        }
    }
    return type;
}


static void validateFunction(EcCompiler *cp, EcNode *np, EjsFunction *spec, EjsFunction *fun)
{
}

static void validateClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type, *iface, *baseType;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;
    EcState     *state;
    int         next, i, count;

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;

    baseType = type->baseType;
    if (baseType && baseType->final) {
        astError(cp, np, "Class \"%@\" is attempting to subclass a final class \"%@\"", type->qname.name, 
            baseType->qname.name);
    }

    /*
        Ensure the class implements all required implemented methods
     */
    for (next = 0; ((iface = (EjsType*) mprGetNextItem(type->implements, &next)) != 0); ) {
        count = ejsGetPropertyCount(ejs, iface);
        for (i = 0; i < count; i++) {
            fun = ejsGetProperty(ejs, iface, i);
            if (!ejsIsFunction(ejs, fun) || fun->isInitializer) {
                continue;
            }
            qname = ejsGetPropertyName(ejs, iface, i);
            vp = ejsGetPropertyByName(ejs, type, qname);
            if (vp == 0 || !ejsIsFunction(ejs, vp)) {
                astError(cp, np, "Missing method \"%@\" required by interface \"%@\"", qname.name, iface->qname.name);
            } else {
                validateFunction(cp, np, fun, (EjsFunction*) vp);
            }
        }
    }
    if (type->implements) {
        if (mprGetListLength(type->implements) > 1 || 
                (type->baseType && ejsCompareMulti(ejs, type->baseType->qname.name, "Object") != 0)) {
            //  MOB -- fix. Should support multiple implements
            astError(cp, np, "Only one implements or one extends supported");
        }
    }        
}


/*
    Lookup the set of open namespaces for the required namespace for this class
 */
static void bindClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type;
    EjsFunction *fun;
    EjsModule   *mp;
    EcState     *state;
    bool        modified;

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;

    mprAssert(cp->phase == EC_PHASE_BIND);

    if (type->hasInitializer) {
        /*
            Create the static initializer function. Code gen will fill out the code
         */
        mp = state->currentModule;
        fun = ejsCreateFunction(ejs, np->qname.name, NULL, -1, 0, 0, 0, ST(Void), EJS_FUN_INITIALIZER, mp, NULL, 
            cp->fileState->strict);
        np->klass.initializer = fun;
        //  MOB -- better to use DefineProperty and set traits for initializer
        ejsSetProperty(ejs, type, 0, fun);
    }

    modified = 0;
    if (!np->literalNamespace && resolveNamespace(cp, np, ejs->global, &modified) == 0) {
        return;
    }
    if (modified) {
        ejsSetTypeName(ejs, type, np->qname);
    }
    addGlobalProperty(cp, np, &type->qname);

    if (type->hasBaseConstructors) {
        //  MOB --remove - should already be set.
        mprAssert(type->hasConstructor);
        type->hasConstructor = 1;
    }
    if (resolveName(cp, np, ejs->global, type->qname) < 0) {
        return;
    }
    setAstDocString(ejs, np, "class", ejs->global, np->lookup.slotNum);
}


/*
    Process a class node
 */
static void astClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructor;
    bool            hasInitializer;

    mprAssert(np->kind == N_CLASS);
    
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->classState = state;
    type = np->klass.ref;
    
    if (np->klass.implements) {
        processAstNode(cp, np->klass.implements);
    }        
    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            removeProperty(cp, ejs->global, np);
        }
        LEAVE(cp);
        return;
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        type = defineClass(cp, np);

    } else if (cp->phase == EC_PHASE_FIXUP) {
         fixupClass(cp, type);

    } else if (cp->phase >= EC_PHASE_BIND) {
        validateClass(cp, np);
        bindClass(cp, np);
    }
    if (cp->error) {
        LEAVE(cp);
        return;
    }
    state->currentClass = type;
    state->currentClassNode = np;
#if UNUSED
    state->currentClassName = type->qname;
#endif
    state->inClass = 1;
    
    //  MOB -- need a way to zero things that should not be inherited
    state->inFunction = 0;
    state->inMethod = 0;
    state->blockIsMethod = 0;
    state->currentFunction = 0;
    state->currentFunctionNode = 0;

    /*
        Add the type to the scope chain and the static initializer if present. Use push frame to make it eaiser to
        pop the type off the scope chain later.
     */
    hasInitializer = 0;
    addScope(cp, (EjsBlock*) type);
    if (np->klass.initializer) {
        openBlock(cp, np, (EjsBlock*) np->klass.initializer);
        hasInitializer++;
    }
    if (cp->phase == EC_PHASE_FIXUP && type->baseType) {
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }
    state->optimizedLetBlock = (EjsBlock*) type;
    state->letBlock = (EjsBlock*) type;
    state->varBlock = (EjsBlock*) type;

    /*
        Process the class body
     */
    mprAssert(np->left->kind == N_DIRECTIVES);
    processAstNode(cp, np->left);
    
    if (hasInitializer) {
        closeBlock(cp);
    }

    /*
        Only need to do this if this is a default constructor, ie. does not exist in the class body.
     */
    constructor = np->klass.constructor;
    if (constructor && constructor->function.isDefault) {
        astFunction(cp, constructor);
    }
    removeScope(cp);
    LEAVE(cp);
}


static void astDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_DASSIGN);

    if (np->objectLiteral.typeNode) {
        processAstNode(cp, np->objectLiteral.typeNode);
    }
    for (next = 0; (child = getNextAstNode(cp, np, &next)) != 0; ) {
        processAstNode(cp, child);
    }
}


static void astDirectives(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    Ejs         *ejs;
    int         next;

    mprAssert(np->kind == N_DIRECTIVES);

    ENTER(cp);

    ejs = cp->ejs;
    cp->state->blockNestCount++;
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    cp->state->blockNestCount--;
    LEAVE(cp);
}


/*
    Handle a do statement
 */
static void astDo(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_DO);

    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine will bind a
    name path reference into slot bindings if possible. The dot node is a
    binary node.

            local.a.b.c
            arg.a.b.c
            obj.a.b.c
            static.a.b.c
            any[expression]
            unqualifiedName         - dynamic bound
            expression              - dynamic bound
 */
static void astDot(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *left;

    mprAssert(np->kind == N_DOT);
    mprAssert(np->left);
    mprAssert(np->right);

    ENTER(cp);

    state = cp->state;
    state->onLeft = 0;
    left = np->left;

    /*
        Optimize to assist with binding. Remove an expressions node which has a sole QNAME.
     */
    if (left && left->kind == N_EXPRESSIONS && left->left && left->left->kind == N_QNAME && left->right == 0) {
        np->left = np->left->left;
    }

    /*
        Process the left of the "."
     */
    processAstNode(cp, np->left);

    state->currentObjectNode = np->left;
    
    /*
        If the right is a terminal node, then assume the parent state's onLeft status
     */
    switch (np->right->kind) {
    case N_QNAME:
/*
    Need to allow obj[fun()] = 7
    case N_EXPRESSIONS: 
 */
    case N_LITERAL:
    case N_OBJECT_LITERAL:
        cp->state->onLeft = cp->state->next->onLeft;
        break;

    default:
        break;
    }
    processAstNode(cp, np->right);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        np->lookup = np->right->lookup;
        np->qname = np->right->qname;
    }
    LEAVE(cp);
}


/*
    Process an expressions node
 */
static void astExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    /*
        No current object when computing an expression. E.g. obj[a + b]
        We don't want obj set as the context object for a or b.
     */
    cp->state->currentObjectNode = 0;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        child = mprGetLastItem(np->children);
        if (child) {
            np->lookup = child->lookup;
            np->qname = child->qname;
        }
    }
    LEAVE(cp);
}


static EjsFunction *defineFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcState         *state;
    EcNode          *parameters;
    EjsFunction     *fun;
    EjsBlock        *block;
    int             numArgs;
    int             slotNum;

    mprAssert(np->kind == N_FUNCTION);
    mprAssert(cp->phase == EC_PHASE_DEFINE);

    ejs = cp->ejs;
    state = cp->state;

    if (np->function.isMethod) {
        np->attributes |= EJS_TRAIT_FIXED | EJS_TRAIT_READONLY;
        if (!(np->attributes & EJS_PROP_ENUMERABLE) 
                /* Don't inherit enumerable for functions */
                /* MOB && !(state->currentClassNode->attributes & EJS_PROP_ENUMERABLE) */) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);

    } else {
        if (np->function.isExpression) {
            block = state->letBlock;
        } else {
            block = state->optimizedLetBlock;
        }
        if (block != state->varBlock && block != ejs->global) {
            state->letBlockNode->createBlockObject = 1;
        }
    }
    parameters = np->function.parameters;
    numArgs = (parameters) ? mprGetListLength(parameters->children) : 0;
    
    if (np->function.resultType) {
        np->attributes |= np->function.resultType->attributes;
    }
    if (np->function.isConstructor) {
        mprAssert(ejsIsType(ejs, block));
        np->attributes |= EJS_FUN_CONSTRUCTOR;
        fun = (EjsFunction*) block;
        ejsInitFunction(ejs, fun, np->qname.name, NULL, 0, numArgs, 0, 0, NULL, np->attributes, state->currentModule, 
            NULL, cp->fileState->strict);
        
    } else {
        /*
            Create a function object. Don't have code yet so we create without it. Can't resolve the return type yet, so we 
            leave it unset. The numDefault and numExceptions will be fixed when the function is bound.
         */
        fun = ejsCreateFunction(ejs, np->qname.name, NULL, 0, numArgs, 0, 0, NULL, np->attributes, state->currentModule, 
            NULL, cp->fileState->strict);
        if (fun == 0) {
            astError(cp, np, "Can't create function \"%@\"", np->qname.name);
            return 0;
        }  

        /*
            Check if this function has already been defined in this block. Can't check base classes yes. Must wait till 
            bindFunction()
         */
        slotNum = ejsLookupProperty(ejs, block, np->qname);

        if (slotNum >= 0 && cp->fileState->strict) {
            if ((np->function.setter && ejsPropertyHasTrait(ejs, block, slotNum, EJS_TRAIT_SETTER)) ||
                (np->function.getter && ejsPropertyHasTrait(ejs, block, slotNum, EJS_TRAIT_GETTER))) {
                astError(cp, np, "Property \"%@\" is already defined.", np->qname);
                return 0;
            }
        }
        slotNum = ejsDefineProperty(ejs, block, slotNum, np->qname, TYPE(fun), np->attributes, fun);
        if (slotNum < 0) {
            astError(cp, np, "Can't define function in type \"%@\"", state->currentClass->qname.name);
            return 0;
        }
    }
    np->function.functionVar = fun;
    fun->activation = (EjsPot*) ejsCreateCompilerFrame(ejs, fun);
    return fun;
}


/*
    Define function parameters during the DEFINE phase.
 */
static int defineParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *nameNode, *child, *parameters;
    int             next, attributes, slotNum, numDefault;

    ejs = cp->ejs;
    parameters = np->function.parameters;
    if (parameters == 0) {
        return 0;
    }
    fun = np->function.functionVar;
    slotNum = 0;
    next = 0;
    numDefault = 0;

    while ((child = getNextAstNode(cp, parameters, &next))) {
        mprAssert(child->kind == N_VAR_DEFINITION);
        attributes = 0;
        nameNode = 0;
        if (child->left->kind == N_QNAME) {
            nameNode = child->left;
#if UNUSED
            if (numDefault) {
                astError(cp, np, "Can't have non-default parameters after default parameters");
            }
#endif
        } else if (child->left->kind == N_ASSIGN_OP) {
            numDefault++;
            nameNode = child->left->left;
        }
        attributes |= nameNode->attributes;
        slotNum = ejsDefineProperty(ejs, fun->activation, slotNum, nameNode->qname, NULL, attributes, NULL);
        mprAssert(slotNum >= 0);
        /*
            Can assign the lookup information here as these never need fixups.
         */
        nameNode->lookup.slotNum = slotNum;
        nameNode->lookup.obj = fun;
        nameNode->lookup.trait = ejsGetPropertyTraits(ejs, fun->activation, slotNum);
        mprAssert(nameNode->lookup.trait);
        slotNum++;
    }
    fun->numDefault = numDefault;
    if (np->function.getter && fun->numArgs != 0) {
        astError(cp, np, "Getter function \"%@\" must not define parameters.", np->qname.name);
    } else if (np->function.setter && fun->numArgs != 1) {
        astError(cp, np, "Setter function \"%@\" must define exactly one parameter.", np->qname.name);
    }
    return 0;
}


/*
    Bind the function parameter types. Local variables get bound as the block gets traversed.
 */
static void bindParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *child, *varNode, *assignNode, *parameters, *localType;
    EjsTrait        *trait;
    EjsFunction     *fun;
    EjsType         *arrayType;
    int             next, slotNum, arraySlot, attributes;

    ejs = cp->ejs;
    fun = np->function.functionVar;
    next = 0;
    parameters = np->function.parameters;

    if (parameters) {
        while ((child = getNextAstNode(cp, parameters, &next))) {
            mprAssert(child->kind == N_VAR_DEFINITION);
            slotNum = next - 1;
            trait = ejsGetPropertyTraits(ejs, fun->activation, slotNum);
            attributes = trait->attributes;
            
            varNode = 0;
            if (child->left->kind == N_QNAME) {
                varNode = child->left;

            } else if (child->left->kind == N_ASSIGN_OP) {
                /*
                    Bind defaulting parameters. Only need to do if there is a body. Native functions ignore this code as they
                    have no body. The lhs must be scoped inside the function. The rhs must be scoped outside.
                 */
                if (np->function.body) {
                    assignNode = child->left;
                    openBlock(cp, np->function.body, (EjsBlock*) fun->activation);
                    processAstNode(cp, assignNode->left);
                    closeBlock(cp);
                    processAstNode(cp, assignNode->right);
                }
                varNode = child->left->left;
            }
            mprAssert(varNode);
            mprAssert(varNode->kind == N_QNAME);

            if (varNode->typeNode == 0) {
                if (varNode->name.isRest) {
                    arraySlot = ejsLookupProperty(ejs, ejs->global, N(EJS_EJS_NAMESPACE, "Array"));
                    mprAssert(arraySlot >= 0);
#if UNUSED
                    ejsSetTraitType(cp->ejs, trait, ejsGetProperty(ejs, ejs->global, arraySlot));
#else
                    arrayType = ejsGetProperty(ejs, ejs->global, arraySlot);
                    ejsSetPropertyTraits(ejs, fun->activation, slotNum, arrayType, -1);
#endif
                    fun->rest = 1;
                }

            } else {
                localType = varNode->typeNode;
                processAstNode(cp, localType);
                if (localType->lookup.ref) {
                    attributes |= (localType->attributes & (EJS_TRAIT_CAST_NULLS | EJS_TRAIT_THROW_NULLS));
#if UNUSED
                    ejsSetTraitAttributes(cp->ejs, trait, attributes);
                    ejsSetTraitType(cp->ejs, trait, (EjsType*) localType->lookup.ref);
#else
                    ejsSetPropertyTraits(cp->ejs, fun->activation, slotNum, (EjsType*) localType->lookup.ref, attributes);
#endif
                }
            }
        }
    }
}


/*
    Utility routine to bind function return type and locals/args
 */
static EjsFunction *bindFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *resultTypeNode;
    EcState         *state;
    EjsType         *iface, *currentClass;
    EjsFunction     *fun;
    EjsBlock        *block;
    EjsName         qname;
    bool            modified;
    int             next, slotNum;

    mprAssert(cp->phase >= EC_PHASE_BIND);
    mprAssert(np->kind == N_FUNCTION);
    mprAssert(np->qname.name);

    state = cp->state;
    ejs = cp->ejs;
    fun = np->function.functionVar;
    currentClass = state->currentClass;
    mprAssert(fun);

    if (np->function.isMethod) {
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
    } else if (np->function.isExpression) {
        block = state->letBlock;
    } else {
        block = state->optimizedLetBlock;
    }
    resultTypeNode = np->function.resultType;

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Exclude a literalNamespace as the empty phase as the namespace name is changed for the URI.
            Exclude constructors which are hidden in the virtual constructor namespace.
         */
        if (!np->literalNamespace && !np->function.isConstructor) {
            if (resolveNamespace(cp, np, block, &modified) == 0) {
                return 0;
            }
            if (modified && np->left) {
                np->left->qname = np->qname;
            }
        }
        if (block == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    
    /*
        Test for clashes with non-overridden methods in base classes.
     */
    if (currentClass && currentClass->baseType) {
        slotNum = ecLookupVar(cp, currentClass->baseType, np->qname);
        if (slotNum >= 0 && ejsIsA(ejs, np->lookup.ref, (EjsType*) cp->lookup.obj)) {
            if (!(np->attributes & EJS_FUN_OVERRIDE) && !currentClass->baseType->isInterface) {
                //  MOB - OPT
                if (currentClass->qname.space != ejsCreateStringFromAsc(ejs, EJS_EJS_NAMESPACE) && 
                    currentClass->qname.name != ejsCreateStringFromAsc(ejs, "Type")) {
                    astError(cp, np, 
                        "Function \"%@\" is already defined in a base class. Using \"override\" keyword.", np->qname.name);
                    return 0;
                }
            }

            mprAssert(!ejsLookupProperty(ejs, currentClass, np->qname));
            slotNum = -1;
#if MOB && BINDING_ONLY
            /*
                Install the new function into the v-table by overwriting the method from the closest base class.
                Must now define the name of the property and attributes.
             */
#endif
            ejsDefineProperty(ejs, block, slotNum, np->qname, 0, np->attributes, fun);
        }
    }

    /*
        Test for clashes with non-overridden methods in implemented classes.
     */
    if (state->currentClass && state->currentClass->implements) {
        next = 0;
        while ((iface = (EjsType*) mprGetNextItem(state->currentClass->implements, &next))) {
            slotNum = ecLookupVar(cp, iface, np->qname);
            if (slotNum >= 0 && cp->lookup.obj == iface) {
                if (!iface->isInterface) {
                    if (!(np->attributes & EJS_FUN_OVERRIDE)) {
                        astError(cp, np, 
                            "Function \"%@\" is already defined in an implemented class. Use the \"override\" keyword.", 
                            np->qname.name);
                        return 0;
                    }

                    /*
                        Install the new function into the v-table by overwriting the inherited implemented method.
                     */
                    ejsDefineProperty(ejs, block, slotNum, np->qname, 0, np->attributes, fun);
                }
            }
        }
    }

    if (resultTypeNode) {
        //  MOB -- assumes all types are in global. Should do a scope search?
        if (resolveName(cp, resultTypeNode, ejs->global, resultTypeNode->qname) < 0) {
            if (STRICT_MODE(cp)) {
                astError(cp, np, "Can't find type \"%@\". All variables must be declared and typed in strict mode.", 
                    resultTypeNode->qname.name);
            }
        } else {
            resultTypeNode->qname.space = resultTypeNode->lookup.name.space;
        }
    }

    if (!np->function.isConstructor) {
        if (resolveName(cp, np, block, np->qname) < 0) {
            astError(cp, np, "Internal error. Can't resolve function %@", np->qname.name);
        }
        if (np->lookup.slotNum >= 0) {
            setAstDocString(ejs, np, "fun", np->lookup.obj, np->lookup.slotNum);
        }
    } else {
        qname.space = NULL;
        qname.name = np->qname.name;
        if (resolveName(cp, np, ejs->global, qname) < 0) {
            if (resolveName(cp, np, ejs->global, np->qname) < 0) {
                astError(cp, np, "Internal error. Can't resolve constructor %@", np->qname.name);
            }
        }
        if (np->lookup.slotNum >= 0) {
            setAstDocString(ejs, np, "fun", np->lookup.obj, np->lookup.slotNum);
        }
    }

    /*
        Bind the result type. Set the result type in np->trait->type
     */
    if (resultTypeNode) {
        mprAssert(resultTypeNode->lookup.ref == 0 || ejsIsType(ejs, resultTypeNode->lookup.ref));
        fun->resultType = (EjsType*) resultTypeNode->lookup.ref;
    }

    /*
        Optimize away closures
        Global functions need scope for the "internal" namespace. If defined as public, dont need it.
        TODO OPT. Dont set fullScope if public
     */
    if (/* fun->owner == ejs->global || */ np->function.isMethod || np->attributes & EJS_PROP_NATIVE) {
        fun->fullScope = 0;
    } else {
        fun->fullScope = 1;
    }
    if (!np->function.isConstructor) {
        if (np->function.isMethod) {
            fun->block.scope = (EjsBlock*) state->varBlock;
        } else {
            fun->block.scope = (EjsBlock*) state->optimizedLetBlock;
        }
    }
    return fun;
}


/*
    Process the N_FUNCTION node and bind the return type and parameter types
 */
static void astFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsBlock        *block;
    EcState         *state;

    mprAssert(np->kind == N_FUNCTION);
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    fun = np->function.functionVar;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            //  MOB -- refactor this somehow
            if (np->function.isMethod) {
                block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
            } else {
                block = state->optimizedLetBlock;
            }
            removeProperty(cp, (EjsObj*) block, np);
        }
        LEAVE(cp);
        return;
    }

    /*
        Process the function definition (no parameters yet)
     */
    if (cp->phase == EC_PHASE_DEFINE) {
        fun = defineFunction(cp, np);
    } else if (cp->phase >= EC_PHASE_BIND) {
        fun = bindFunction(cp, np);
    }
    if (fun == 0) {
        LEAVE(cp);
        return;
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        defineParameters(cp, np);
    } else if (cp->phase >= EC_PHASE_BIND) {
        bindParameters(cp, np);
    }
    state->currentFunction = fun;
    state->currentFunctionNode = np;
    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;

    state->optimizedLetBlock = (EjsBlock*) fun->activation;
    state->letBlock = (EjsBlock*) fun->activation;
    state->varBlock = (EjsBlock*) fun->activation;

    if (np->function.body) {
        mprAssert(fun->activation);
        mprAssert(ejsIsFrame(ejs, fun->activation));
        openBlock(cp, np->function.body, (EjsBlock*) fun->activation);
        mprAssert(np->function.body->kind == N_DIRECTIVES);
        processAstNode(cp, np->function.body);
        closeBlock(cp);
    }
    /*
        Fixup scope if the class has a static initializer. The static initializer is opened for static initialization
        statements. TODO - refactor this some how.
     */
    if (state->inMethod && state->currentClassNode->klass.initializer) {
        if (fun->block.scope == (EjsBlock*) state->currentClassNode->klass.initializer) {
            fun->block.scope = fun->block.scope->scope;
        }
    }
    if (np->function.constructorSettings) {
        /*
            TODO The constructor settings need special namespace treatment. Consider:
            class Shape {
                var x
                function Shape(arg1) : this.x = arg1 {}
            }
        
            Note the left hand side can use "this" whereas the right hand side must not.
            The right hand side can see the parameters wheres the left hand side must not.
         */
        state->inSettings = 1;
        processAstNode(cp, np->function.constructorSettings);
        state->inSettings = 0;
    }

    /*
        TODO -- No need to add this namespace to be emitted as all function variables are bound (always)
        Process the parameters. Scope for default initialization code for the parameters is as follows:
            left hand side:  inside the function block
            right hand side: outside the function block.
    
        Namespaces are done on each phase because pragmas must apply only from the point of declaration onward 
        (use namespace)
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (!np->function.hasReturn && (np->function.resultType != 0)) {
            if (fun->resultType == 0 || fun->resultType != ST(Void)) {
                /*
                    Native classes have no body defined in script, so we can't verify whether or not it has 
                    an appropriate return.
                 */
                if (!(state->currentClass && state->currentClass->isInterface) && !(np->attributes & EJS_PROP_NATIVE)) {
                    if (ejs->initialized || fun->resultType == 0 || fun->resultType != ST(Void)) {
                        astError(cp, np, "Function \"%@\" must return a value",  np->qname.name);
                    }
                }
            }
        }
        if (fun->activation->numProp == 0) {
            /* Activation object not required */
            fun->activation = 0;
        }
    }
    LEAVE(cp);
}


/*
    Handle a for statement
 */
static void astFor(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_FOR);

    if (np->forLoop.initializer) {
        processAstNode(cp, np->forLoop.initializer);
    }
    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.perLoop) {
        processAstNode(cp, np->forLoop.perLoop);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle a for/in statement
 */
static void astForIn(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;
    int     rc;

    ENTER(cp);

    mprAssert(np->kind == N_FOR_IN);
    
    ejs = cp->ejs;

    if (np->forInLoop.iterVar) {
        processAstNode(cp, np->forInLoop.iterVar);
    }
    if (np->forInLoop.iterGet) {
        processAstNode(cp, np->forInLoop.iterGet);
    }

    /*
        Link to the iterGet node so we can bind the "next" call.
     */
    if (cp->phase >= EC_PHASE_BIND) {
#if UNUSED
        EjsType     *iteratorType;
        EjsName     qname;
        iteratorType = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, N("iterator", "Iterator"));
        mprAssert(iteratorType);
        if (iteratorType == 0) {
            astError(cp, np, "Can't find Iterator class");
        } else {
            /*
                TODO MOB - this assumes that iterators use Iterator and it is bindable. What if an operator that
                implements an Iterable/Iterator interface
             */
            rc = resolveName(cp, np->forInLoop.iterNext, iteratorType->prototype, N("public", "next"));
            if (rc < 0) {
                astError(cp, np, "Can't find Iterator.next method");
            }
        }
        
#else
        np->forInLoop.iterNext->qname = N("public", "next");
        rc = resolveName(cp, np->forInLoop.iterNext, ST(Iterator)->prototype, np->forInLoop.iterNext->qname);
        np->forInLoop.iterNext->lookup.bind = 0;
#endif
    }
    if (np->forInLoop.body) {
        processAstNode(cp, np->forInLoop.body);
    }
    LEAVE(cp);
}


static EjsObj *evalNode(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *mp;
    EjsType     *config;
    EjsObj      *result;
    int         saveDebug;

    ejs = cp->ejs;
    mprAssert(ejs->exception == 0);
    
    if ((mp = ejsCreateModule(cp->ejs, ejsCreateStringFromAsc(ejs, "__conditional__"), 0, NULL)) == NULL) {
        return 0;
    }
    mp->initializer = createModuleInitializer(cp, np, mp);
    mp->initializer->isInitializer = 1;
    mp->hasInitializer = 1;
    saveDebug = cp->debug;
    cp->debug = 0;

    if (astProcess(cp, np) < 0) {
        cp->debug = saveDebug;
        return 0;
    }
    ecResetParser(cp);
    ecGenConditionalCode(cp, np, mp);
    if (cp->errorCount > 0) {
        cp->debug = saveDebug;
        return 0;
    }
    /*  Install the Config object as a local variable in the initializer function */
    config = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "Config"));
    ejsDefineProperty(ejs, mp->initializer->activation, 0, EN("Config"), ST(Type), 0, config);
    ejsDefineConfigProperties(ejs);

    result = ejsRunInitializer(ejs, mp);
    cp->debug = saveDebug;

    if (result == 0) {
        ejsClearException(ejs);
        return 0;
    }
    return result;
}


/*
    Handle an hash statement (conditional compilation)
 */
static void astHash(EcCompiler *cp, EcNode *np)
{
    EjsObj      *result;
    int         savePhase;

    ENTER(cp);

    mprAssert(np->kind == N_HASH);
    mprAssert(np->hash.expr);
    mprAssert(np->hash.body);

    cp->state->inHashExpression = 1;

    if (cp->phase < EC_PHASE_CONDITIONAL) {
        processAstNode(cp, np->hash.expr);

    } else if (cp->phase == EC_PHASE_CONDITIONAL) {
        ENTER(cp);
        savePhase = cp->phase;
        result = evalNode(cp, np->hash.expr);
        cp->phase = savePhase;
        LEAVE(cp);

        if (result) {
            result = (EjsObj*) ejsToBoolean(cp->ejs, result);
            if (result && !ejsGetBoolean(cp->ejs, result)) {
                result = 0;
            }
        }
        if (result == 0) {
            np->hash.disabled = 1;
        }
    }
    if (np->hash.disabled) {
        cp->state->disabled = 1;
    }
    cp->state->inHashExpression = 0;
    processAstNode(cp, np->hash.body);
    LEAVE(cp);
}


/*
    Handle an if statement (tenary node)
 */
static void astIf(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_IF);

    mprAssert(np->tenary.cond);
    mprAssert(np->tenary.thenBlock);

    processAstNode(cp, np->tenary.cond);
    processAstNode(cp, np->tenary.thenBlock);

    if (np->tenary.elseBlock) {
        processAstNode(cp, np->tenary.elseBlock);
    }
    LEAVE(cp);
}


static void astImplements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;
    
    ENTER(cp);
    mprAssert(np->kind == N_TYPE_IDENTIFIERS);
    
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate a name reference. This routine will bind a name path reference into slot bindings if possible.
    The node and its children represent a  name path.
 */
static void astName(EcCompiler *cp, EcNode *np)
{
    if (np->name.qualifierExpr) {
        processAstNode(cp, np->name.qualifierExpr);
    }
    if (np->name.nameExpr) {
        processAstNode(cp, np->name.nameExpr);
    }
    if (cp->phase >= EC_PHASE_BIND) {
        astBindName(cp, np);
        return;
    }
}


static void astBindName(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EjsLookup       *lookup;
    EjsFunction     *fun, *currentFunction;
    EcNode          *left;
    EcState         *state;
    int             rc;

    mprAssert(cp->phase >= EC_PHASE_BIND);
    mprAssert(np->kind == N_QNAME);
    
    if (np->qname.name == 0 || np->name.qualifierExpr || np->name.nameExpr) {
        return;
    }
    ENTER(cp);
    state = cp->state;

    /*
        If resolving a name to the right of a "." or "[", then only search relative to the object to the left of the dot.
     */
    left = state->currentObjectNode;
    ejs = cp->ejs;
    rc = -1;

    if (np->name.isType) {
        rc = resolveName(cp, np, ejs->global, np->qname);
        if (rc < 0) {
            //  NOTE: np->qname.space may be null
            astError(cp, np, "Can't find class \"%@\". Ensure the class is visible.", np->qname.name);
        }

    } else if (left) {
        if (left->kind == N_THIS) {
            /*
                Explicit "this.property"
                TODO - does not yet handle "this function, this callee, this function, this type"
             */
            if (state->currentClass) {
                rc = resolveProperty(cp, np, state->currentClass, np->qname);
                if (rc < 0 && STRICT_MODE(cp)) {
                    astError(cp, np, "Can't find property \"%@\" in this class %@.", np->qname.name, 
                         state->currentClass->qname.name);
                }
            }

        /*
            Do we know the type of the left side?
         */
        } else if (left->lookup.trait && left->lookup.trait->type) {
            /*
                We must handle 2 cases differently:
                    1. obj.property
                    2. Type.property
            
                This is because in the first case, we must extract the type of an object, whereas in the 2nd case,
                we already have the type via an explicit type reference.
             */
            if (left->lookup.ref && (ejsIsType(ejs, left->lookup.ref) 
                        /* UNUSED || ejsIsPrototype(ejs, left->lookup.ref) */)) {
                /*
                    Case 2. Type.property. We have resolved the type reference.
                 */
                np->lookup.ownerIsType = 1;
                rc = resolveProperty(cp, np, (EjsType*) left->lookup.ref, np->qname);
                if (rc < 0 && STRICT_MODE(cp) && !((EjsType*) left->lookup.ref)->dynamicInstances) {
                    astError(cp, np, "Can't find property \"%@\" in class \"%@\".", np->qname.name,
                        ((EjsType*) left->lookup.ref)->qname.name);

                } else if (np->lookup.trait && !(np->lookup.trait->attributes & EJS_PROP_STATIC) &&
                        np->lookup.obj != ejs->global) {
                    if (np->lookup.slotNum >= ES_Object_NUM_CLASS_PROP) {
                        /* Exclude the case of calling a function (constructor) to create a new instance */
                        if (!(left->kind == N_CALL || left->kind == N_EXPRESSIONS)) {
                            astError(cp, np, "Accessing instance level propery \"%@\" without an instance", np->qname.name);
                        }
                    }
                    
                } else if (left->kind == N_CALL) {
                    /*
                        Calling a constructor as a function. This will return an instance
                     */
                    np->lookup.nthBase++;
                }

            } else {
                fun = (EjsFunction*) left->lookup.ref;
                if (fun && ejsIsFunction(ejs, fun)) {
                    /* 
                        Can't use a getter to bind to as the value is determined at run time.
                     */
                    rc = -1;

                } else {

                    /*
                        Case 1: Left side is a normal object. We use the type of the lhs to search for name.
                     */
                    rc = resolveProperty(cp, np, left->lookup.trait->type, np->qname);
                    if (rc == 0) {
                        /*
                            Since we searched above on the type of the object and the lhs is an object, increment nthBase.
                            BUG: but what if lhs is a type? then nthBase is one too many
                         */
                        if (!np->lookup.instanceProperty) {
                            np->lookup.nthBase++;
                        }
                    }
                }
            }

        } else if (left->kind == N_EXPRESSIONS) {
            /* 
                Suppress error message below. We can't know the left because it is an expression. 
                So we can't bind the variable 
             */
            rc = 0;
        }

    } else {
        /*
            No left side, so search the scope chain
         */
        rc = resolveName(cp, np, NULL, np->qname);

        /*
            Check for static function code accessing instance properties or instance methods
         */
        lookup = &np->lookup;
        if (rc == 0 && state->inClass && !state->instanceCode) {
            if (ejsIsPrototype(ejs, lookup->obj) || 
                    (ejsIsType(ejs, lookup->obj) && (lookup->trait && !(lookup->trait->attributes & EJS_PROP_STATIC)))) {
                if (!state->inFunction || (state->currentFunctionNode->attributes & EJS_PROP_STATIC)) {
                    astError(cp, np, "Accessing instance level property \"%@\" without an instance", np->qname.name);
                    rc = -1;
                }
            }
        }
    }

    if (rc < 0) {
#if FUTURE
        //  TODO - need propert expression calculation and propagation
        if (left && left->lookup.trait && left->lookup.trait->type) {
            type = left->lookup.trait->type;
            if (!type->dynamicInstances) {
                astError(cp, np, "Can't find a declaration for \"%@\".", np->qname.name);
            }
        }
#endif
        if (STRICT_MODE(cp) && !cp->error) {
            astError(cp, np, "Can't find a declaration for \"%@\". All variables must be declared and typed in strict mode.",
                np->qname.name);
        }

    } else {
        if (np->lookup.trait) {
            /* Copy traits of property into the reference. Not sure if all are needed */
            np->attributes |= np->lookup.trait->attributes;
        }
    }

    /*
        Disable binding of names in certain cases.
     */
    lookup = &np->lookup;
    
    if (ejsIsFrame(ejs, lookup->obj) && lookup->nthBlock == 0) {
        ;
    } else {
        lookup->bind = 0;
        lookup->useThis = 0;
    }

#if UNUSED
    if (lookup->obj != (EjsObj*) state->currentFunction || ejsIsType(ejs, lookup->obj)) {
        lookup->bind = 0;
        lookup->useThis = 0;
    }
#endif

#if UNUSED || 1
    //  MOB -- restore some binding
    if (lookup->slotNum >= 0) {
        /*
            Unbind if slot number won't fit in one byte or the object is not a standard Object. The bound op codes 
            require one byte slot numbers.
         */
        if (lookup->slotNum >= 256) {
            lookup->bind = 0;
        }

        if (lookup->obj == ejs->global && !cp->bind) {
            /*
                Unbind non-core globals
             */
            if ((lookup->slotNum >= ES_global_NUM_CLASS_PROP) /* UNUSED && !(lookup->ref && BUILTIN(lookup->ref)) */) {
                lookup->bind = 0;
            }
        }
        if (ejsIsType(ejs, np->lookup.obj)) {
            type = (EjsType*) np->lookup.obj;
            if (type->constructor.block.nobind || type->isInterface) {
                /*
                    Type requires non-bound access. Types that implement interfaces will have different slots.
                 */
                lookup->bind = 0;

            } else if (type->dynamicInstances /* && !BUILTIN(type) */) {
                /*
                    Don't bind non-core dynamic properties
                 */
                lookup->bind = 0;

            } else {
                /*
                    Ugly (but effective) hack just for XML to discriminate between length and length()
                    TODO - refactor away
                 */
                if (type == ST(XML) || type == ST(XMLList)) {
                    if (np->parent == 0 || np->parent->parent == 0 || np->parent->parent->kind != N_CALL) {
                        lookup->bind = 0;
                    }
                }
            }

#if UNUSED
        } else if (ejsIsPrototype(ejs, np->lookup.obj)) {
            if (!BUILTIN(np->lookup.obj)) {
                lookup->bind = 0;
            }
#endif
        }
        if (lookup->trait && lookup->trait->attributes & EJS_TRAIT_GETTER) {
            lookup->bind = 0;
        }
    }
#endif

    /*
        If accessing unbound variables, then the function will require full scope if a closure is ever required.
     */
    currentFunction = state->currentFunction;
    if (lookup->slotNum < 0) {
        if (cp->phase == EC_PHASE_BIND && cp->warnLevel > 5) {
            astWarn(cp, np, "Using unbound variable reference for \"%@\"", np->qname.name);
        }
    }
    LEAVE(cp);
}


static void astNew(EcCompiler *cp, EcNode *np)
{
    EjsType     *type;
    EcNode      *left;

    mprAssert(np->kind == N_NEW);
    mprAssert(np->left);
    mprAssert(np->left->kind == N_QNAME || np->left->kind == N_DOT);
    mprAssert(np->right == 0);

    ENTER(cp);

    left = np->left;
    processAstNode(cp, left);

    if (cp->phase != EC_PHASE_BIND) {
        LEAVE(cp);
        return;
    }
    mprAssert(cp->phase >= EC_PHASE_BIND);

    np->newExpr.callConstructors = 1;

    if (left->lookup.ref) {
        type = (EjsType*) left->lookup.ref;
        if (type && ejsIsType(cp->ejs, type)) {
            /* Type is bound, has no constructor or base class constructors */
            if (!type->hasConstructor && !type->hasBaseConstructors) {
                np->newExpr.callConstructors = 0;
            }
            /*
                Propagate up the left side. Increment nthBase because it is an instance.
             */
            np->qname = left->qname;
            np->lookup = left->lookup;
            np->lookup.trait = mprAllocObj(EjsTrait, NULL);
            np->lookup.trait->type = (EjsType*) np->lookup.ref;
            np->lookup.ref = 0;
            np->lookup.instanceProperty = 1;
        }
    }
    LEAVE(cp);
}


static void astObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_OBJECT_LITERAL);

    processAstNode(cp, np->objectLiteral.typeNode);
    for (next = 0; (child = getNextAstNode(cp, np, &next)) != 0; ) {
        processAstNode(cp, child);
    }
}


static void astField(EcCompiler *cp, EcNode *np)
{
    if (np->field.fieldKind == FIELD_KIND_VALUE && np->field.expr) {
        processAstNode(cp, np->field.expr);
    }
}


static void astPragmas(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_PRAGMAS);

    ENTER(cp);
    ejs = cp->ejs;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astPragma(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->kind == N_PRAGMA);

    ENTER(cp);
    if (np->pragma.strict) {
        cp->fileState->strict = np->pragma.strict;
    }
    LEAVE(cp);
}



static void astPostfixOp(EcCompiler *cp, EcNode *np)
{
    EcNode      *left;
    
    mprAssert(np->kind == N_POSTFIX_OP);

    ENTER(cp);
    left = np->left;
    if (left->kind == N_LITERAL) {
        astError(cp, np, "Invalid postfix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


static void astProgram(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *child;
    int         next;

    ENTER(cp);
    ejs = cp->ejs;
    state = cp->state;
    state->nspace = np->qname.name;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astReturn(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *functionNode;
    EcState         *state;

    ENTER(cp);
    ejs = cp->ejs;
    state = cp->state;

    mprAssert(state->currentFunctionNode->kind == N_FUNCTION);
    state->currentFunctionNode->function.hasReturn = 1;

    if (np->left) {
        processAstNode(cp, np->left);
    }

    if (cp->phase >= EC_PHASE_BIND) {
        mprAssert(state->currentFunction);
        mprAssert(state->currentFunction);
        functionNode = state->currentFunctionNode;
        state->currentFunction->hasReturn = functionNode->function.hasReturn;

        fun = state->currentFunction;
        if (fun->hasReturn) {
            if (np->left) {
                if (fun->resultType && fun->resultType == ST(Void)) {
                    /*
                        Allow block-less function expressions where a return node was generated by the parser.
                     */
                    if (!np->ret.blockless) {
                        astError(cp, np, "Void function \"%@\" can't return a value", functionNode->qname.name);
                    }
                }

            } else {
                if (fun->resultType && fun->resultType != ST(Void)) {
                    if (! (!ejs->initialized && fun->resultType->qname.name == ST(Void)->qname.name)) {
                        astError(cp, np, "Return in function \"%@\" must return a value", functionNode->qname.name);
                    }
                }
            }
        }
    }
    LEAVE(cp);
}


static void astSuper(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;
    if (state->currentObjectNode == 0) {
        if (state->currentFunction == 0) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Can't use unqualified \"super\" outside a method");
            }
            LEAVE(cp);
            return;
        }
        if (!state->currentFunctionNode->function.isConstructor) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Can't use unqualified \"super\" outside a constructor");
            }
            LEAVE(cp);
            return;
        }
        if (cp->phase >= EC_PHASE_BIND) {
            if (state->currentClass->hasBaseConstructors == 0) {
                astError(cp, np, "No base class constructors exist to call via super");
                LEAVE(cp);
                return;
            }
        }
        state->currentClass->callsSuper = 1;
        if (np->left && np->left->kind != N_NOP) {
            processAstNode(cp, np->left);
        }

    } else {
        astError(cp, np, "Can't use unqualified \"super\" outside a method");
    }
    LEAVE(cp);
}


static void astSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_SWITCH);
    mprAssert(np->right->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    switch (np->thisNode.thisKind) {
    case EC_THIS_GENERATOR:
        //  TODO - binding not implemented
        break;

    case EC_THIS_CALLEE:
        //  TODO - binding not implemented
        break;

    case EC_THIS_TYPE:
        //  TODO - binding not implemented
        if (!state->inClass) {
            astError(cp, np, "\"this type\" is only valid inside a class");
        } else {
            np->lookup.obj = (EjsObj*) state->currentClass;
            np->lookup.slotNum = 0;
        }
        break;

    case EC_THIS_FUNCTION:
        //  TODO - binding not implemented
        if (!state->inFunction) {
            astError(cp, np, "\"this function\" is not valid outside a function");
        } else {
            np->lookup.obj = (EjsObj*) state->currentFunction;
            np->lookup.slotNum = 0;
        }
        break;

    default:
        np->lookup.obj = (EjsObj*) state->currentClass;
        np->lookup.slotNum = 0;
    }
    LEAVE(cp);
}


static void astThrow(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->left);
    processAstNode(cp, np->left);
}


/*
    Try, catch, finally
 */
static void astTry(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsBlock    *block;
    EcNode      *child;
    EcState     *state;
    int         next, count;

    ENTER(cp);

    mprAssert(np->kind == N_TRY);
    mprAssert(np->exception.tryBlock);

    ejs = cp->ejs;
    state = cp->state;

    processAstNode(cp, np->exception.tryBlock);

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Calculate the number of lexical blocks in the try block. These must be discarded by the VM when executing
            catch and finally blocks.
         */
        for (count = 0, block = ejs->state->bp->scope; block && !ejsIsFrame(ejs, block); block = block->scope) {
            count++;
        }
        np->exception.numBlocks = count;
    }
    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextAstNode(cp, np->exception.catchClauses, &next))) {
            processAstNode(cp, child);
        }
    }
    if (np->exception.finallyBlock) {
        block = ejsCreateBlock(cp->ejs, 0);
        addScope(cp, block);
        processAstNode(cp, np->exception.finallyBlock);
        removeScope(cp);
    }
    LEAVE(cp);
}


/*
    Handle a unary operator.
 */
static void astUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_UNARY_OP);
    mprAssert(np->left);

    if (np->left->kind == N_LITERAL && (np->tokenId == T_PLUS_PLUS || np->tokenId == T_MINUS_MINUS)) {
        astError(cp, np, "Invalid prefix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


/*
    Create a module defined via a module directive.
 */
static void astModule(EcCompiler *cp, EcNode *np)
{
    EjsModule       *mp, *core;
    Ejs             *ejs;
    EcState         *state;
    EcNode          *child;
    EjsBlock        *saveChain;
    int             next;

    mprAssert(np->kind == N_MODULE);

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    
    if (cp->phase == EC_PHASE_DEFINE) {
        mp = createModule(cp, np);
    } else {
        mp = np->module.ref;
        mprAssert(mp);
    }
    if (mp == 0) {
        return;
    }
    mprAssert(mp->initializer);
    mprAssert(mp->initializer->activation);

    /*
        Start a new scope chain for this module. ie. Don't nest modules in the scope chain.
     */
    saveChain = ejs->state->bp->scope;
    ejs->state->bp->scope = mp->scope;

    /*
        Create a block for the module initializer. There is also a child block but that is to hide namespace declarations 
        from other compilation units. Open the block explicitly rather than using astBlock. We do this because we need 
        varBlock to be set to ejs->global and let block to be mp->initializer. The block is really only used to scope 
        namespaces.
     */
    openBlock(cp, np, (EjsBlock*) mp->initializer->activation);
    
    if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np->left);
    }
    
    /*
        Open the child block here so we can set the letBlock and varBlock values inside the block.
     */
    mprAssert(np->left->kind == N_BLOCK);
    openBlock(cp, np->left, NULL);
    
    state->optimizedLetBlock = (EjsBlock*) ejs->global;
    state->varBlock = (EjsBlock*) ejs->global;
    state->letBlock = (EjsBlock*) mp->initializer->activation;
    state->currentModule = mp;

    if (mp->dependencies == 0) {
        mp->dependencies = mprCreateList(-1, 0);
        core = ejsLookupModule(ejs, ejsCreateStringFromAsc(ejs, "ejs"), 0, 0);
        if (core && core != mp && mprLookupItem(mp->dependencies, core) < 0) {
            mprAddItem(mp->dependencies, core);
        }
    }

    /*
        Skip the first (block) child that was processed manually above.
     */
    for (next = 0; (child = getNextAstNode(cp, np->left, &next)); ) {
        processAstNode(cp, child);
    }
    closeBlock(cp);
    closeBlock(cp);
    
    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Define block after the variables have been processed. This allows us to determine if the block is really needed.
         */
        defineBlock(cp, np->left);
    }
    ejs->state->bp->scope = saveChain;
    LEAVE(cp);
}


/*
    Use Namespace
 */
static void astUseNamespace(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsNamespace    *namespace;
    EcState         *state, *s;

    mprAssert(np->kind == N_USE_NAMESPACE);
    
    ENTER(cp);

    state = cp->state;
    ejs = cp->ejs;
    namespace = 0;

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            At the define phase, we create a dummy namespace assuming that it will exist somewhere in this block or an 
            outer block. At the fixup phase, we actually resolve the reference to the namespace unless it is a string 
            literal namespace.
         */
        namespace = ejsCreateNamespace(ejs, np->qname.name);
        np->namespaceRef = namespace;

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->name.isLiteral) {
            namespace = np->namespaceRef;

        } else {
            /*
                Resolve the real namespace. Must be visible in the current scope (even in standard mode). 
                Then update the URI. URI not used.
             */
            if (resolveName(cp, np, NULL, np->qname) < 0) {
                astError(cp, np, "Can't find namespace \"%@\"", np->qname.name);

            } else {
                //  MOB -- UN BIND
                np->lookup.bind = 0;
                namespace = (EjsNamespace*) np->lookup.ref;
                if (namespace) {
                    np->namespaceRef->value = namespace->value;
                    if (!ejsIs(ejs, namespace, Namespace)) {
                        astError(cp, np, "The variable \"%@\" is not a namespace", np->qname.name);
                    } else {
                        np->namespaceRef = namespace;
                    }
                }
            }
            if (namespace && np->name.isDefault) {
                /*
                    Apply the namespace URI to all upper blocks
                    MOB -- not right
                 */
                for (s = cp->state; s; s = s->next) {
                    s->nspace = namespace->value;
                    if (s == cp->blockState) {
                        break;
                    }
                }
            }
        }
    } else {
        namespace = np->namespaceRef;
    }
    if (namespace) {
        if (state->letBlockNode) {
            state->letBlockNode->createBlockObject = 1;
        }
        if (state->inClass && !state->inFunction) {
            /*
                Must attach to the class itself and not to the outermost block
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) state->currentClass, namespace);
        } else {
            ejsAddNamespaceToBlock(ejs, state->letBlock, namespace);
        }
    }
    LEAVE(cp);
}


/*
    Module depenency
 */
static void astRequire(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *currentModule, *mp;
    int         flags;

    mprAssert(np->kind == N_USE_MODULE);
    mprAssert(np->qname.name);

    ENTER(cp);

    ejs = cp->ejs;
    currentModule = cp->state->currentModule;
    mprAssert(currentModule);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Is this a module we are currently compiling?
         */
        mp = ecLookupModule(cp, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
        if (mp == 0) {
            /*
                Is this module already loaded by the vm?
             */
            mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            if (mp == 0) {
                flags = cp->fileState->strict ? EJS_LOADER_STRICT : 0;
                if (ejsLoadModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion, flags) < 0) {
                    astError(cp, np, "%s", ejsGetErrorMsg(ejs, 1));
                    cp->fatalError = 1;
                    LEAVE(cp);
                    return;
                }
                mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            }
        }

        if (mp == 0) {
            astError(cp, np, "Can't find required module \"%@\"", np->qname.name);

        } else if (mp != currentModule) {
            if (currentModule->dependencies == 0) {
                currentModule->dependencies = mprCreateList(-1, 0);
            }
            if (mprLookupItem(currentModule->dependencies, mp) < 0 && 
                    mprAddItem(currentModule->dependencies, mp) < 0) {
                mprAssert(0);
            }
        }
        mprAssert(np->left->kind == N_USE_NAMESPACE);
        np->left->qname.name = mp->vname;
    }
    mprAssert(np->left->kind == N_USE_NAMESPACE);
    processAstNode(cp, np->left);
    LEAVE(cp);
}


static void astWith(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    bool        pushed;

    ENTER(cp);

    ejs = cp->ejs;
    pushed = 0;

    processAstNode(cp, np->with.object);

    if (cp->phase >= EC_PHASE_BIND) {
        processAstNode(cp, np->with.object);
        /*
            To permit early binding, if the object is typed, then add that type to the scope chain.
         */
        lookup = &np->with.object->lookup;
        if (lookup->trait && lookup->trait->type) {
            addScope(cp, (EjsBlock*) lookup->trait->type);
            pushed++;
        }
    }
    processAstNode(cp, np->with.statement);

    if (pushed) {
        removeScope(cp);
    }
    LEAVE(cp);

}


static bool typeIsCompatible(EcCompiler *cp, EjsType *first, EjsType *second)
{
    Ejs     *ejs;

    ejs = cp->ejs;
    if (first == 0 || second == 0) {
        return 1;
    }
    if (first->qname.name == second->qname.name && first->qname.space == second->qname.space) {
        return 1;
    }
    return 0;
}


/*
    Define a variable
 */
static void defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    Ejs             *ejs;
    EjsFunction     *method;
    EjsObj          *obj;
    EjsType         *type;
    EcState         *state;
    int             slotNum, attributes;

    ejs = cp->ejs;
    mprAssert(cp->phase == EC_PHASE_DEFINE);

    state = cp->state;
    method = state->currentFunction;

    if (state->inClass) {
        np->attributes |= EJS_TRAIT_FIXED;
        if (!(np->attributes & EJS_PROP_ENUMERABLE) && !(state->currentClassNode->attributes & EJS_PROP_ENUMERABLE)) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
        if (ejsContainsMulti(ejs, np->qname.space, ",private")) {
            //  MOB -- TEMP only. Need a reliable flag in attributes for private
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    attributes = np->attributes;

    /*
        Only create block scope vars if the var block is different to the let block. This converts global let vars to vars.
     */
    np->name.letScope = 0;
    if (varKind & KIND_LET && (state->varBlock != state->optimizedLetBlock)) {
        np->name.letScope = 1;
    }
    if (np->name.letScope) {
        mprAssert(varKind & KIND_LET);
        obj = (EjsObj*) getBlockForDefinition(cp, np, state->optimizedLetBlock, attributes);
        if (ecLookupScope(cp, np->qname) >= 0 && cp->lookup.obj == obj) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%@\" is already defined", np->qname.name);
                return;
            }
        } else {
            //  TODO MOB BUG - could / should change context to be obj for the names
            slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, value);
        }

    } else {
        if (ecLookupVar(cp, (EjsObj*) state->varBlock, np->qname) >= 0) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%@\" is already defined.", np->qname.name);
                return;
            }
        }
        /*
            Var declarations are hoisted to the nearest function, class or global block (never nested block scope)
         */
        obj = (EjsObj*) getBlockForDefinition(cp, np, state->varBlock, attributes);
        slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, value);
    }
    if (slotNum < 0) {
        astError(cp, np, "Can't define variable \"%@\"", np->qname.name);
        return;
    }
    if (ejsIsType(ejs, obj) && !(np->attributes & EJS_TRAIT_READONLY)) {
        type = (EjsType*) obj;
        if (state->instanceCode) {
            type->mutableInstances = 1;
        } else {
            type->mutable = 1;
        }
    }
}


/*
    Hoist a block scoped variable and define in the nearest function, class or global block. This runs during the
    Hoist conditional phase. We hoist the variable by defining with a "-hoisted-%d" namespace which is added to the set of
    Hoist open namespaces. This namespace is only used when compiling and not at runtime. All access to the variable is bound
 */
static bool hoistBlockVar(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsBlock    *block;
    EjsObj      *obj, *vp;
    int         slotNum, attributes;

    mprAssert(cp->phase == EC_PHASE_CONDITIONAL);

    //  MOB -- all hoisting is currently disabled.
    if (1 || cp->optimizeLevel == 0) {
        return 0;
    }
    ejs = cp->ejs;
    state = cp->state;
    block = (np->kind == N_BLOCK) ? state->letBlock : state->optimizedLetBlock;
    attributes = np->attributes;

    if (state->inClass && state->inFunction) {
        obj = (EjsObj*) state->varBlock;
    } else {
        /*
            Global or class level block
         */
        mprAssert(!state->instanceCode);
        obj = (EjsObj*) state->varBlock;
        attributes |= EJS_PROP_STATIC;
    }
    if (!cp->bind && obj == ejs->global) {
        /* Can't hoist variables to global scope if not binding */
        return 0;
    }

    /*
        Delete the property from the original block. Don't reclaim slot, delete will set to 0.
        This lookup may fail it there were more than one declaration in a block. ie. already hoisted.
     */
    slotNum = ejsLookupProperty(ejs, block, np->qname);
    if (slotNum < 0) {
        mprAssert(state->letBlockNode->namespaceRef);
        np->namespaceRef = state->letBlockNode->namespaceRef;
        np->qname.space = np->namespaceRef->value;
    } else {
        vp = ejsGetProperty(ejs, block, slotNum);
        ejsDeleteProperty(ejs, block, slotNum);

        /*
            Redefine hoisted in the outer var block. Use a unique hoisted namespace to avoid clashes with other
            hoisted variables of the same name. Save the generated namespace for this block and reuse for any
            other hoisted vars from this block.
         */
        if (state->letBlockNode->namespaceRef) {
            np->namespaceRef = state->letBlockNode->namespaceRef;
        } else {
            np->namespaceRef = createHoistNamespace(cp, obj);
            state->letBlockNode->namespaceRef = np->namespaceRef;
        }
        np->qname.space = np->namespaceRef->value;

        slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, vp);
        if (slotNum < 0) {
            astError(cp, np, "Can't define local variable \"%N\"", np->qname.space, np->qname.name);
            return 0;
        }
        if (obj == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    np->name.letScope = 0;
    return 1;
}


/*
    Fully bind a variable definition. We already know the owning type and the slot number.
    We now need to  bind the variable type and set the trait reference.
 */
static void bindVariableDefinition(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsBlock        *block;
    EjsTrait        *trait;
    EcState         *state;
    EcNode          *typeNode;
    bool            modified;

    ENTER(cp);

    mprAssert(cp->phase >= EC_PHASE_BIND);

    ejs = cp->ejs;
    state = cp->state;
    fun = state->currentFunction;

    if (np->name.letScope) {
        block = state->optimizedLetBlock;
    } else {
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
    }
    if (/*MOB*/1 || !state->inFunction) {
        if (!np->literalNamespace && resolveNamespace(cp, np, block, &modified) == 0) {
            LEAVE(cp);
            return;
        }
        if (modified && np->left && np->left->left && np->left->left->kind == N_QNAME) {
            /* Fix the namespace of the lhs */
            np->left->left->qname = np->qname;
        }
    }
    if (cp->phase == EC_PHASE_BIND && (EjsObj*) block == ejs->global) {
        addGlobalProperty(cp, np, &np->qname);
    }
    /*
        Check if there is a name clash with any subclasses. Must do after fixup so that the base type has been defined.
        Look in the current type for any public property of the same name.
     */
    if (state->inClass && !state->inFunction && state->currentClass->baseType) {
        if (ecLookupVar(cp, (EjsObj*) state->currentClass->baseType, np->qname) >= 0) {
            astError(cp, np, "Public property %@ is already defined in a base class", np->qname.name);
            LEAVE(cp);
            return;
        }
    }
    if (resolveName(cp, np, block, np->qname) < 0) {
        astError(cp, np, "Can't find variable \"%N\"", np->qname.space, np->qname.name);
    }
    typeNode = np->typeNode;
    if (typeNode && np->lookup.trait) {
        if (typeNode->lookup.ref) {
            if (!ejsIsType(ejs, typeNode->lookup.ref)) {
                astError(cp, np, "Type is not a type object");
                LEAVE(cp);
                return;
            }
            if (!cp->fileState->strict) {
                /*
                    Allow variable redefinitions providing they are compatible
                 */
                trait = ejsGetPropertyTraits(ejs, np->lookup.obj, np->lookup.slotNum);
                if (!typeIsCompatible(cp, trait->type, (EjsType*) typeNode->lookup.ref)) {
                    astError(cp, np, "Redefinition of \"%@\" is not compatible with prior definition", np->qname.name);
                    LEAVE(cp);
                    return;
                }
            }
#if UNUSED
            ejsSetTraitType(cp->ejs, np->lookup.trait, (EjsType*) typeNode->lookup.ref);
#else
            ejsSetPropertyTraits(cp->ejs, np->lookup.obj, np->lookup.slotNum, (EjsType*) typeNode->lookup.ref, -1);
#endif
        }
    }
    setAstDocString(ejs, np, "var", np->lookup.obj, np->lookup.slotNum);
    np->lookup.bind = 0;
    LEAVE(cp);
}


/*
    Initialize constants here so they can be used for conditional compilation and "use namespace"
 */
static void astInitVar(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *right;
    int         slotNum;

    ejs = cp->ejs;
    state = cp->state;

    mprAssert(np->left);
    mprAssert(np->left->kind == N_ASSIGN_OP);

    right = np->left->right;
    mprAssert(right);

    if (right->kind == N_LITERAL && !(np->name.varKind & KIND_LET) && !(np->attributes & EJS_PROP_NATIVE)) {
        mprAssert(np->kind == N_VAR);
        mprAssert(right->literal.var);

        /* Exclude class instance variables */
        if (! (state->inClass && !(np->attributes & EJS_PROP_STATIC))) {
            slotNum = ejsLookupProperty(ejs, state->varBlock, np->qname);
            if (cp->phase == EC_PHASE_DEFINE) {
                ejsSetProperty(ejs, state->varBlock, slotNum, right->literal.var);

            } else if (cp->phase >= EC_PHASE_BIND && !np->name.isNamespace && slotNum >= 0) {
                /*
                    Erase the value incase being run in the ejs shell. Must not prematurely define values.
                 */
                ejsSetProperty(ejs, state->varBlock, slotNum, S(undefined));
            }
        }
    }
}


static void astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    EcState     *state;
    Ejs         *ejs;
    EjsObj      *obj;

    ejs = cp->ejs;
    state = cp->state;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            obj = (EjsObj*) getBlockForDefinition(cp, np, state->varBlock, np->attributes);
            removeProperty(cp, obj, np);
        }
        return;
    }
    state->instanceCode = 0;
    if (state->inClass && !(np->attributes & EJS_PROP_STATIC)) {
        if (state->inMethod) {
            state->instanceCode = 1;
        } else if (state->classState->blockNestCount == (state->blockNestCount - 1)) {
            /*
                Top level var declaration without a static attribute
             */
            state->instanceCode = 1;
        }
    }

    if (np->typeNode) {
        if (np->typeNode->kind != N_QNAME) {
            astError(cp, np, "Bad type name");
            return;
        }
        if (ejsCompareMulti(ejs, np->typeNode->qname.name, "*") != 0) {
            processAstNode(cp, np->typeNode);
        }
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        defineVar(cp, np, varKind, value);

    } else if (cp->phase == EC_PHASE_CONDITIONAL && np->name.letScope) {
        if (!hoistBlockVar(cp, np)) {
            /*
                Unhoisted let scoped variable.
             */
            state->letBlockNode->createBlockObject = 1;
        }

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->namespaceRef) {
            /*
                Add any hoist namespaces that were defined in hoistBlockVar in the conditional phase
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) cp->state->optimizedLetBlock, np->namespaceRef);
        }
        bindVariableDefinition(cp, np);
    }
    if (!state->disabled && np->left) {
        astAssignOp(cp, np->left);
        astInitVar(cp, np);
    }
}


static void astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode)
{
    Ejs         *ejs;
    EcNode      *var;
    EcState     *state;
    int         next;

    mprAssert(np->kind == N_VAR_DEFINITION);

    ENTER(cp);
    ejs = cp->ejs;
    state = cp->state;

    for (next = 0; (var = getNextAstNode(cp, np, &next)); ) {
        if (var->kind == N_VAR) {
            astVar(cp, var, var->name.varKind, var->name.nsvalue);
            if (var->left && !state->disabled) {
                *codeRequired = 1;
                *instanceCode = state->instanceCode;
            }
        } else {
            processAstNode(cp, var);
        }
    }
    LEAVE(cp);
}


/*
    Void type node
 */
static void astVoid(EcCompiler *cp, EcNode *np)
{
    EjsName     qname;
    Ejs         *ejs;

    mprAssert(np->kind == N_VOID);
    ejs = cp->ejs;

    ENTER(cp);

    if (cp->phase >= EC_PHASE_BIND) {
        qname = N(EJS_EJS_NAMESPACE, "Void");
        if (resolveName(cp, np, 0, qname) < 0) {
            astError(cp, np, "Can't find variable \"%N\"", qname.space, qname.name);
        }
    }
    LEAVE(cp);
}


/*
    Create a function to hold the module initialization code. Set a basic scope chain here incase running in ejs.
 */

static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ejs = cp->ejs;
    
    //  MOB - name shold be EJS_INITIALIZER_NAME
    fun = ejsCreateFunction(ejs, mp->name, 0, -1, 0, 0, 0, ST(Void), EJS_FUN_MODULE_INITIALIZER, mp, mp->scope, 
        cp->state->strict);
    if (fun == 0) {
        astError(cp, np, "Can't create initializer function");
        return 0;
    }
    fun->activation = (EjsPot*) ejsCreateCompilerFrame(ejs, fun);
    return fun;
}


/*
    Create the required module
 */
static EjsModule *createModule(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsModule       *mp;

    ejs = cp->ejs;

    mprAssert(np->kind == N_MODULE);

    if (np->module.version == 0 && cp->modver && ejsCompareMulti(ejs, np->qname.name, EJS_DEFAULT_MODULE) != 0) {
        np->module.version = cp->modver;
    }
    mp = ecLookupModule(cp, np->qname.name, np->module.version, np->module.version);
    if (mp == 0) {
        mp = ejsCreateModule(cp->ejs, np->qname.name, np->module.version, NULL);
        if (mp == 0) {
            astError(cp, np, "Can't create module %@", np->qname.name);
            return 0;
        }
#if UNUSED
        mp->scope = (EjsBlock*) ejs->global;
#endif
        if (ecAddModule(cp, mp) < 0) {
            astError(cp, 0, "Can't insert module");
            return 0;
        }
        /*
            This will prevent the loading of any module that uses this module.
         */
        if (ejsCompareMulti(ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->compiling = 1;
        }
    }
    if (mp->initializer == 0 /* MOB BUG || mp->initializer->activation */) {
        mp->initializer = createModuleInitializer(cp, np, mp);
    }
    np->module.ref = mp;

    if (cp->outputFile) {
        np->module.filename = cp->outputFile;
    } else {
        np->module.filename = mprAsprintf("%@%s", np->qname.name, EJS_MODULE_EXT);
    }
    return mp;
}


static EcNode *getNextAstNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError) {
        return 0;
    }
    if (np == 0 || np->children == 0) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static void processAstNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EjsType     *type;
    int         codeRequired, instanceCode;

    ENTER(cp);
    mprAssert(np->parent || np->kind == N_PROGRAM);

    state = cp->state;
    codeRequired = 0;
    instanceCode = state->instanceCode;
    
    switch (np->kind) {
    case N_ARGS:
        astArgs(cp, np);
        codeRequired++;
        break;

    case N_ASSIGN_OP:
        astAssignOp(cp, np);
        codeRequired++;
        break;

    case N_BINARY_OP:
        astBinaryOp(cp, np);
        codeRequired++;
        break;

    case N_BLOCK:
        astBlock(cp, np);
        break;

    case N_BREAK:
        astBreak(cp, np);
        break;

    case N_CALL:
        astCall(cp, np);
        codeRequired++;
        break;

    case N_CASE_ELEMENTS:
        astCaseElements(cp, np);
        codeRequired++;
        break;

    case N_CASE_LABEL:
        astCaseLabel(cp, np);
        codeRequired++;
        break;

    case N_CATCH:
        astCatch(cp, np);
        codeRequired++;
        break;

    case N_CATCH_ARG:
        codeRequired++;
        break;

    case N_CLASS:
        astClass(cp, np);
        type = np->klass.ref;
        codeRequired++;
        break;

    case N_CONTINUE:
        break;

    case N_DASSIGN:
        astDassign(cp, np);
        break;

    case N_DIRECTIVES:
        astDirectives(cp, np);
        break;

    case N_DO:
        astDo(cp, np);
        codeRequired++;
        break;

    case N_DOT:
        astDot(cp, np);
        codeRequired++;
        break;

    case N_END_FUNCTION:
        break;

    case N_EXPRESSIONS:
        astExpressions(cp, np);
        break;

    case N_FOR:
        astFor(cp, np);
        codeRequired++;
        break;

    case N_FOR_IN:
        astForIn(cp, np);
        codeRequired++;
        break;

    case N_FUNCTION:
        astFunction(cp, np);
        break;

    case N_LITERAL:
        codeRequired++;
        break;

    case N_OBJECT_LITERAL:
        astObjectLiteral(cp, np);
        codeRequired++;
        break;

    case N_FIELD:
        astField(cp, np);
        codeRequired++;
        break;

    case N_QNAME:
        astName(cp, np);
        break;

    case N_NEW:
        astNew(cp, np);
        codeRequired++;
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        astPostfixOp(cp, np);
        codeRequired++;
        break;

    case N_PRAGMAS:
        astPragmas(cp, np);
        break;

    case N_PRAGMA:
        astPragma(cp, np);
        break;

    case N_PROGRAM:
        astProgram(cp, np);
        break;

    case N_REF:
        codeRequired++;
        break;

    case N_RETURN:
        astReturn(cp, np);
        codeRequired++;
        break;

    case N_SPREAD:
        astSpread(cp, np);
        codeRequired++;
        break;

    case N_SUPER:
        astSuper(cp, np);
        codeRequired++;
        break;

    case N_SWITCH:
        astSwitch(cp, np);
        codeRequired++;
        break;

    case N_HASH:
        astHash(cp, np);
        break;

    case N_IF:
        astIf(cp, np);
        codeRequired++;
        break;

    case N_THIS:
        astThis(cp, np);
        codeRequired++;
        break;

    case N_THROW:
        astThrow(cp, np);
        codeRequired++;
        break;

    case N_TRY:
        astTry(cp, np);
        break;

    case N_UNARY_OP:
        astUnaryOp(cp, np);
        codeRequired++;
        break;

    case N_MODULE:
        astModule(cp, np);
        break;
            
    case N_TYPE_IDENTIFIERS:
        astImplements(cp, np);
        break;

    case N_USE_NAMESPACE:
        astUseNamespace(cp, np);
        break;

    case N_USE_MODULE:
        astRequire(cp, np);
        break;

    case N_VAR_DEFINITION:
        astVarDefinition(cp, np, &codeRequired, &instanceCode);
        break;

    case N_VOID:
        astVoid(cp, np);
        break;

    case N_WITH:
        astWith(cp, np);
        break;

    default:
        mprAssert(0);
        badAst(cp, np);
    }
    
    /*
        Determine if classes need initializers. If class code is generated outside of a method, then some form of
        initialization will be required. Either a class constructor, initializer or a global initializer.
     */
    if (cp->phase == EC_PHASE_DEFINE && codeRequired && !state->inMethod && !state->inHashExpression) {
        if (state->inClass && !state->currentClass->isInterface) {
            if (instanceCode) {
                state->currentClass->hasConstructor = 1;
            } else {
                state->currentClass->hasInitializer = 1;
            }
        } else {
            state->currentModule->hasInitializer = 1;
        }
    }
    mprAssert(state == cp->state);
    LEAVE(cp);
}


static void removeProperty(EcCompiler *cp, EjsObj *obj, EcNode *np)
{
    Ejs             *ejs;
    EjsName         *prop;
    MprList         *globals;
    int             next, slotNum;

    mprAssert(obj);
    ejs = cp->ejs;

    if (np->globalProp) {
        globals = cp->state->currentModule->globalProperties;
        mprAssert(globals);

        for (next = 0; ((prop = (EjsName*) mprGetNextItem(globals, &next)) != 0); ) {
            if (np->qname.space == prop->space && np->qname.name == prop->name) {
                mprRemoveItem(globals, prop);
                break;
            }
        }
    }
    slotNum = ejsLookupProperty(ejs, obj, np->qname);
    if (slotNum >= 0) {
        ejsRemovePotProperty(ejs, obj, slotNum);
    }
}


/*
    Fixup all slot definitions in types. When types are first created, they do not reserve space for inherited slots.
    Now that all types should have been resolved, we can reserve room for inherited slots. Override functions also 
    must be removed.
 */
static void fixupClass(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsType         *baseType, *iface, *typeType;
    EjsFunction     *fun;
    EjsPot          *prototype;
    EjsObj          *obj;
    EjsName         qname;
    EjsTrait        *trait;
    EcNode          *np, *child;
    int             next, rc, slotNum, attributes, hasInstanceVars;

    if (VISITED(type) || !type->needFixup) {
        return;
    }
    type->needFixup = 0;

    mprAssert(cp);
    mprAssert(type);
    mprAssert(ejsIsType(ejs, type));

    ENTER(cp);

    rc = 0;
    ejs = cp->ejs;
    SET_VISITED(type, 1);
    np = (EcNode*) type->typeData;
    type->typeData = 0;
    baseType = type->baseType;

    if (baseType == 0) {
        if (np && np->kind == N_CLASS && !np->klass.isInterface) {
            if (np->klass.extends) {
                qname.space = NULL;
                qname.name = np->klass.extends;
                baseType = (EjsType*) getTypeProperty(cp, ejs->global, qname);
            } else {
                if (! (!ejs->initialized && type->qname.name == ST(Object)->qname.name)) {
                    baseType = (EjsType*) getTypeProperty(cp, ejs->global, N(EJS_EJS_NAMESPACE, "Object"));
                }
            }
        }
    }
    if (np->klass.implements) {
        type->implements = mprCreateList(-1, 0);
        next = 0;
        while ((child = getNextAstNode(cp, np->klass.implements, &next))) {
            iface = (EjsType*) getTypeProperty(cp, ejs->global, child->qname);
            if (iface) {
                mprAddItem(type->implements, iface);
            } else {
                astError(cp, np, "Can't find interface \"%@\"", child->qname.name);
                SET_VISITED(type, 0);
                LEAVE(cp);
                return;
            }
        }
    }
    if (baseType == 0) {
        if (! (!ejs->initialized && type->qname.name == ST(Object)->qname.name) && !np->klass.isInterface) {
            astError(cp, np, "Can't find base type for %@", type->qname.name);
            SET_VISITED(type, 0);
            LEAVE(cp);
            return;
        }
    }
    if (baseType) {
        if (baseType->needFixup) {
            fixupClass(cp, baseType);
        }
        if (baseType->hasConstructor) {
            type->hasBaseConstructors = 1;
        }
        if (baseType->hasInitializer) {
            type->hasBaseInitializers = 1;
        }
    }
    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (iface->needFixup) {
                fixupClass(cp, iface);
            }
            if (iface->hasConstructor) {
                type->hasBaseConstructors = 1;
            }
            if (iface->hasInitializer) {
                type->hasBaseInitializers = 1;
            }
        }
    }
    if (!type->constructor.block.pot.isPrototype && (EjsObj*) type != ejs->global && !type->isInterface) {
        /*
            Remove the static initializer slot if this class does not require a static initializer
            By convention, it is installed in slot number 1.
         */
        if (type->hasBaseInitializers) {
            type->hasInitializer = 1;
        }
        if (!type->hasInitializer) {
            ejsRemovePotProperty(ejs, (EjsObj*) type, 0);
        }
        /*
            Disable the constructor if this class does not require it
         */
        if (type->hasBaseConstructors) {
            type->hasConstructor = 1;
        }
        if (!type->hasConstructor) {
            np->klass.constructor = 0;
            ejsDisableFunction(ejs, (EjsFunction*) type);
            mprAssert(!(np->attributes & EJS_TYPE_HAS_CONSTRUCTOR));
        }
    }

    /*
        Determine if instances need to copy the prototype properties
     */
    hasInstanceVars = 0;
    prototype = type->prototype;
    for (slotNum = 0; slotNum < prototype->numProp; slotNum++) {
        obj = ejsGetProperty(ejs, prototype, slotNum);
        if (!ejsIsFunction(ejs, obj) && !ejsIsBlock(ejs, obj)) {
            hasInstanceVars = 1;
            break;
        }
    }
    type->hasInstanceVars |= hasInstanceVars;
    if (baseType) {
        type->hasInstanceVars |= baseType->hasInstanceVars;
    }
    ejsFixupType(ejs, type, baseType, 1);
    
    if (ejs->empty) {
        typeType = (EjsType*) getTypeProperty(cp, ejs->global, N(EJS_EJS_NAMESPACE, "Type"));
    } else {
        typeType = ST(Type);
    }
    if (typeType == 0) {
        astError(cp, 0, "Can't find Type class");
    }
    if (typeType->needFixup) {
        fixupClass(cp, typeType);
    }
#if UNUSED
    if (type != typeType) {
        ejsBlendTypeProperties(ejs, type, typeType);
    }
#endif

    /*
        Remove the original overridden method. Set the inherited slot to the overridden method. This implements a v-table.
     */
    prototype = type->prototype;
    for (slotNum = type->numInherited; slotNum < prototype->numProp; slotNum++) {
        trait = ejsGetPropertyTraits(ejs, prototype, slotNum);
        if (trait == 0) {
            continue;
        }
        attributes = trait->attributes;
        if (attributes & EJS_FUN_OVERRIDE && type->numInherited > 0) {
            /*
                If the type is not an orphan, it must preserve the slot order dictated by the base class
             */
            fun = ejsGetProperty(ejs, prototype, slotNum);
            mprAssert(fun && ejsIsFunction(ejs, fun));
            qname = ejsGetPropertyName(ejs, prototype, slotNum);
            ejsRemovePotProperty(ejs, prototype, slotNum);
            slotNum--;
            if (resolveName(cp, NULL, (EjsObj*) type, qname) < 0 || cp->lookup.slotNum < 0) {
                astError(cp, 0, "Can't find method \"%N\" in base type of \"%@\" to override", qname.space, qname.name, 
                    type->qname.name);
            } else {
                ejsSetProperty(ejs, prototype, cp->lookup.slotNum, (EjsObj*) fun);
                ejsSetPropertyTraits(cp->ejs, prototype, cp->lookup.slotNum, NULL, attributes);
            }
        }
    }
    SET_VISITED(type, 0);
    LEAVE(cp);
}


/*
    Lookup the namespace for a definition (np->qname.space).  We look for the namespace variable declaration if it is a user
    defined namespace. Otherwise, we trust that if the set of open namespaces has the namespace -- it must exist.
 */
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsAny *block, bool *modified)
{
    Ejs             *ejs;
    EjsName         qname;
    EjsNamespace    *nspace;
    int             slotNum;

    ejs = cp->ejs;

    if (modified) {
        *modified = 0;
    }
    qname.name = np->qname.space;
    qname.space = 0;
    nspace = (EjsNamespace*) getTypeProperty(cp, 0, qname);
    if (nspace == 0 || !ejsIs(ejs, nspace, Namespace)) {
        nspace = lookupNamespace(cp->ejs, np->qname.space);
    }
    if (nspace == 0 && cp->state->nspace == np->qname.space) {
        nspace = ejsCreateNamespace(ejs, np->qname.space);
    }
    if (nspace == 0) {
        if (!np->literalNamespace) {
            astError(cp, np, "Can't find namespace \"%@\"", qname.name);
        }
    } else {
        if (nspace->value != np->qname.space) {
            slotNum = ejsLookupProperty(ejs, block, np->qname);
            mprAssert(slotNum >= 0);
            if (slotNum >= 0) {
                /*
                    Change the name to use the namespace URI. This will change the property name and set
                    "modified" so that the caller can modify the derrived names (type->qname)
                 */
                np->qname.space = nspace->value;
                ejsSetPropertyName(ejs, block, slotNum, np->qname);
                if (modified) {
                    *modified = 1;
                }
            }
        }
    }
    //  MOB - nobody uses this except as a return code
    return nspace;
}


/*
    Locate a property in context. NOTE this only works for type properties not instance properties.
 */
static EjsObj *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName name)
{
    EcNode      node;

    mprAssert(cp);

    if (resolveName(cp, &node, vp, name) < 0) {
        return 0;
    }
    return node.lookup.ref;
}


static int resolveProperty(EcCompiler *cp, EcNode *np, EjsType *type, EjsName name)
{
    EcNode      node;

    mprAssert(cp);

    if (resolveName(cp, &node, (EjsObj*) type->prototype, name) < 0) {
        if (resolveName(cp, &node, (EjsObj*) type, name) < 0) {
            return -1;
        }
    }
    //  MOB -- should return slotNum
    return 0;
}


/*
    Locate a property via lookup and determine the best way to address the property.
 */
static int resolveName(EcCompiler *cp, EcNode *np, EjsAny *vp, EjsName qname)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    EjsType     *type, *currentClass, *tp;
    EcState     *state;
    EjsBlock    *block;

    ejs = cp->ejs;
    state = cp->state;
    lookup = &cp->lookup;

    cp->lookup.bind = 0;

    if (vp) {
        if (ecLookupVar(cp, vp, qname) < 0) {
            return EJS_ERR;
        }
    } else if (ecLookupScope(cp, qname) < 0) {
        return EJS_ERR;
    }
    cp->lookup.bind = 1;

    /*
        Revise the nth block to account for blocks that will be erased
     */
    lookup->nthBlock = 0;
    for (block = ejs->state->bp->scope; block; block = block->scope) {
        if ((EjsObj*) block == lookup->obj) {
            break;
        }
        if (ejsIsType(ejs, block)) {
            type = (EjsType*) block;
            if ((EjsObj*) type->prototype == lookup->obj) {
                break;
            }
        }
        lookup->nthBlock++;
    }
    if (block == 0) {
        lookup->nthBlock = 0;
    }
    mprAssert(lookup->ref);    
    if (lookup->ref == S(null)) {
        lookup->ref = 0;
    }

    if ((ejsIsType(ejs, lookup->obj) || ejsIsPrototype(ejs, lookup->obj)) && state->currentObjectNode == 0) {
        mprAssert(lookup->obj != ejs->global);
        //  NOTE: could potentially do this for static properties as well
        if (lookup->trait && lookup->slotNum >= 0) {
            /*
                class instance or method properties
             */
            type = (EjsType*) lookup->obj;
            currentClass = state->currentClass;
            if (currentClass) {
                mprAssert(state->inClass);
                for (tp = currentClass; tp; tp = tp->baseType) {
                    if ((EjsObj*) tp == lookup->obj || (EjsObj*) tp->prototype == lookup->obj) {
                        /*
                            Method code or class level instance initialization code. This is code that is a subtype of the 
                            type owning the property, so we can use the thisObj to access it.
                         */
                        if (state->inClass) {
                            lookup->useThis = 1;
                        }
                    }
                }
            }
        }
    }

    if (np) {
        np->lookup = cp->lookup;
    }
    //  MOB -- should return slotNum
    return 0;
}


/*
    Wrap the define property routine. Need to keep a module to property mapping
 */
static void addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname)
{
    Ejs         *ejs;
    EjsModule   *up;
    EjsName     *p;
    int         next;

    ejs = cp->ejs;

    up = cp->state->currentModule;
    mprAssert(up);

    if (up->globalProperties == 0) {
        up->globalProperties = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    }
    //  TODO OPT - should this be a hash?
    for (next = 0; (p = (EjsName*) mprGetNextItem(up->globalProperties, &next)) != 0; ) {
        if (p->name == qname->name && p->space == qname->space) {
            return;
        }
    }
    next = mprAddItem(up->globalProperties, qname);
    if (np) {
        np->globalProp = qname;
    }
}


static void setAstDocString(Ejs *ejs, EcNode *np, cchar *tag, void *vp, int slotNum)
{
    mprAssert(vp);
    mprAssert(slotNum >= 0);

    if (np->doc && vp && slotNum >= 0) {
        ejsCreateDoc(ejs, tag, vp, slotNum, np->doc);
    }
}


static void addScope(EcCompiler *cp, EjsBlock *block)
{
    mprAssert(block != cp->ejs->state->bp);

    //  MOB -- why is there a "Compiler" object on the top at all times?
    block->scope = cp->ejs->state->bp->scope;
    cp->ejs->state->bp->scope = block;
    mprAssert(block != block->scope);
}


static void removeScope(EcCompiler *cp)
{
    EjsBlock    *block;

    block = cp->ejs->state->bp;
    mprAssert(block != block->scope);
    block->scope = block->scope->scope;
}


/*
    Create a new lexical block scope and open it
 */
static void openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block)
{
    Ejs             *ejs;
    EcState         *state;
    EjsNamespace    *namespace;
    char            *debugName;
    int             next;

    ejs = cp->ejs;
    state = cp->state;

    if (cp->phase == EC_PHASE_DEFINE) {
        if (block == 0) {
            static int index = 0;
            if (np->loc.filename == 0) {
                debugName = mprAsprintf("block_%04d", index++);
            } else {
                debugName = mprAsprintf("block_%04d_%d", np->loc.lineNumber, index++);
            }
            block = ejsCreateBlock(cp->ejs, 0);
            np->qname = N(EJS_BLOCK_NAMESPACE, debugName);
        }
        np->blockRef = block;

    } else {
        /*
            Must reset the namespaces each phase. This is because pragmas must apply from the point of use in a block onward
            only. Except for hoisted variable namespaces which must apply from the start of the block. They are applied below
         */
        if (block == 0) {
            block = np->blockRef;
        }
        if (!ejsIsType(ejs, block) && block != ejs->global) {
            ejsResetBlockNamespaces(ejs, block);
        }
    }
    state->namespaceCount = ejsGetNamespaceCount(block);

    /*
        Special case for the outermost module block. The module (file) block is created to provide a compilation unit
        level scope. However, we do not use the block for the let or var scope, rather we use the global scope.
        Namespaces always use this new block.
     */
    if (! (state->letBlock == ejs->global && np->parent->kind == N_MODULE)) {
        state->optimizedLetBlock = block;
    }
    state->letBlock = block;
    state->letBlockNode = np;

    /*
        Add namespaces that must apply from the start of the block. Current users: hoisted let vars.
     */
    //  MOB -- this seems to always be null
    mprAssert(np->namespaces == NULL);
    if (np->namespaces) {
        for (next = 0; (namespace = (EjsNamespace*) mprGetNextItem(np->namespaces, &next)) != 0; ) {
            ejsAddNamespaceToBlock(ejs, block, namespace);
        }
    }
    /*
        Mark the state corresponding to the last opened block
     */
    state->prevBlockState = cp->blockState;
    cp->blockState = state;
    addScope(cp, block);
}


static void closeBlock(EcCompiler *cp)
{
    EjsBlock    *block;
    EcState     *state;
    
    state = cp->state;
    
    block = cp->ejs->state->bp->scope;
    ejsPopBlockNamespaces(block, state->namespaceCount);
    cp->blockState = state->prevBlockState;
    removeScope(cp);
}


static EjsNamespace *createHoistNamespace(EcCompiler *cp, EjsObj *obj)
{
    EjsNamespace    *namespace;
    Ejs             *ejs;
    EcNode          *letBlockNode;
    char            *spaceName;

    ejs = cp->ejs;
    spaceName = mprAsprintf("-hoisted-%d", ejsGetPropertyCount(ejs, obj));
    namespace = ejsCreateNamespace(ejs, ejsCreateStringFromAsc(ejs, spaceName));

    letBlockNode = cp->state->letBlockNode;
    if (letBlockNode->namespaces == 0) {
        letBlockNode->namespaces = mprCreateList(-1, 0);
    }
    mprAddItem(letBlockNode->namespaces, namespace);
    ejsAddNamespaceToBlock(ejs, (EjsBlock*) cp->state->optimizedLetBlock, namespace);
    return namespace;
}


/*
    Determine the block in which to define a variable.
 */
static EjsBlock *getBlockForDefinition(EcCompiler *cp, EcNode *np, EjsBlock *block, int attributes)
{
    EcState     *state;
    EjsType     *type;

    state = cp->state;

    if (ejsIsType(cp->ejs, block) && state->inClass) {
        if (!(attributes & EJS_PROP_STATIC) && !state->inFunction &&
                state->blockNestCount <= (state->classState->blockNestCount + 1)) {
            /*
                Use the prototype object if not static, outside a function and in the top level block.
             */
            type = (EjsType*) block;
            if (!(np->kind == N_FUNCTION && np->function.isConstructor)) {
                block = (EjsBlock*) type->prototype;
            }
            if (np->kind == N_QNAME || np->kind == N_VAR) {
                np->name.instanceVar = 1;
            }
        }
    }
    return block;
}


static EjsNamespace *lookupNamespace(Ejs *ejs, EjsString *nspace)
{
    MprList         *namespaces;
    EjsNamespace    *nsp;
    EjsBlock        *block;
    int             nextNamespace;

    /*
        Lookup the scope chain considering each block and the open namespaces at that block scope.
     */
    for (block = ejs->state->bp; block; block = block->scope) {
        if (!ejsIsBlock(ejs, block)) {
            continue;
        }
        namespaces = &block->namespaces;
        for (nextNamespace = -1; (nsp = (EjsNamespace*) mprGetPrevItem(namespaces, &nextNamespace)) != 0; ) {
            if (nsp->value == nspace) {
                return nsp;
            }
        }
    }
    block = ejs->global;
    namespaces = &block->namespaces;
    for (nextNamespace = -1; (nsp = (EjsNamespace*) mprGetPrevItem(namespaces, &nextNamespace)) != 0; ) {
        if (nsp->value == nspace) {
            return nsp;
        }
    }
    return 0;
}


/*
    Look for a variable by name in the scope chain and return the location in "cp->lookup" and a positive slot 
    number if found.  If the name.space is non-null/non-empty, then only the given namespace will be used. 
    otherwise the set of open namespaces will be used. The lookup structure will contain details about the location 
    of the variable.
 */
int ecLookupScope(EcCompiler *cp, EjsName name)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsBlock        *bp;
    EjsState        *state;
    EjsType         *type;
    EjsPot          *prototype;
    EjsLookup       *lookup;
    int             slotNum, nthBase;

    mprAssert(cp);
    mprAssert(name.name);

    ejs = cp->ejs;
    if (name.space == NULL) {
        name.space = S(empty);
    }
    lookup = &cp->lookup;
    state = ejs->state;
    slotNum = -1;
    
    memset(lookup, 0, sizeof(*lookup));

    //  MOB -- remove nthBlock. Not needed if not binding
    //  MOB -- should start one in to step over Compiler block
    for (lookup->nthBlock = 0, bp = state->bp; bp; bp = bp->scope, lookup->nthBlock++) {
        /* Seach simple object */
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, bp, name, lookup)) >= 0) {
            return slotNum;
        }
        if (ejsIsFrame(ejs, bp)) {
            fun = (EjsFunction*) bp;
            if (cp->state->inMethod && !fun->staticMethod && !fun->isInitializer) {
                /* Instance method only */
                /* Search prototype chain */
                for (nthBase = 1, type = cp->state->currentClass; type; type = type->baseType, nthBase++) {
                    if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
        } else if (ejsIsType(ejs, bp)) {
            if (cp->state->inClass && !cp->state->inFunction) {
                /* MOBXX Instance level initialization code. Should really be inside a constructor */
                for (nthBase = 1, type = cp->state->currentClass; type; type = type->baseType, nthBase++) {
                    if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
            //  MOB -- remove nthBase. Not needed if not binding.
            /* Search base class chain */
            for (nthBase = 1, type = (EjsType*) bp; type; type = type->baseType, nthBase++) {
                if (type->constructor.block.pot.shortScope) {
                    break;
                }
                if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                    lookup->nthBase = nthBase;
                    return slotNum;
                }
            }
        }
    }
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, ejs->global, name, lookup)) >= 0) {
        return slotNum;
    }
    return -1;
}


int ecLookupVar(EcCompiler *cp, EjsAny *obj, EjsName name)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    EjsType     *type;
    EjsPot      *prototype;
    int         slotNum, nthBase;

    mprAssert(obj);
    
    ejs = cp->ejs;
    lookup = &cp->lookup;
    if (name.space == NULL) {
        name.space = S(empty);
    }
    memset(lookup, 0, sizeof(*lookup));

    /* Lookup simple object */
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Lookup prototype chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj) : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if ((prototype = type->prototype) == 0 || prototype->shortScope) {
            break;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    /* Lookup base-class chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj)->baseType : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if (type->constructor.block.pot.shortScope) {
            //  MOB -- continue or break?
            continue;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    return -1;
}


static void astError(EcCompiler *cp, EcNode *np, cchar *fmt, ...)
{
    EcLocation  *loc;
    va_list     args;

    va_start(args, fmt);
    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;
    
    if (np) {
        loc = &np->loc;
        ecErrorv(cp, "Error", loc, fmt, args);
    } else {
        ecError(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
}


static void astWarn(EcCompiler *cp, EcNode *np, cchar *fmt, ...)
{
    va_list     args;
    EcLocation  *loc;

    va_start(args, fmt);

    cp->warningCount++;
    loc = &np->loc;
    ecError(cp, "Warning", loc, fmt, args);
    va_end(args);
}


static void badAst(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError("Unsupported language feature\nUnknown AST node kind %d",  np->kind);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecAst.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecCodeGen.c"
 */
/************************************************************************/

/**
    ecCodeGen.c - Ejscript code generator
  
    This module generates code for a program that is represented by an in-memory AST set of nodes.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)    if (ecEnterState(a) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp)   ecLeaveState(cp)

#define SAVE_ONLEFT(cp)                                     \
    if (1) {                                                \
            cp->state->saveOnLeft = cp->state->onLeft;      \
            cp->state->onLeft = 0;                          \
    } else

#define RESTORE_ONLEFT(cp)                                  \
    cp->state->onLeft = cp->state->saveOnLeft


static void     addDebug(EcCompiler *cp, EcNode *np);
static void     addDebugLine(EcCompiler *cp, EcCodeGen *code, int offset, MprChar *source);
static void     addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, 
                    uint handlerEnd, int numBlocks, int numStack, int flags);
static void     addJump(EcCompiler *cp, EcNode *np, int kind);
static void     addModule(EcCompiler *cp, EjsModule *mp);
static EcCodeGen *allocCodeBuffer(EcCompiler *cp);
static void     badNode(EcCompiler *cp, EcNode *np);
static void     copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *code);
static void     createInitializer(EcCompiler *cp, EjsModule *mp);
static void     discardBlockItems(EcCompiler *cp, int preserve);
static void     discardStackItems(EcCompiler *cp, int preserve);
static void     emitNamespace(EcCompiler *cp, EjsNamespace *nsp);
static int      flushModule(MprFile *file, EcCodeGen *code);
static void     genBinaryOp(EcCompiler *cp, EcNode *np);
static void     genBlock(EcCompiler *cp, EcNode *np);
static void     genBreak(EcCompiler *cp, EcNode *np);
static void     genBoundName(EcCompiler *cp, EcNode *np);
static void     genCall(EcCompiler *cp, EcNode *np);
static void     genCatchArg(EcCompiler *cp, EcNode *np);
static void     genClass(EcCompiler *cp, EcNode *child);
static void     genClassName(EcCompiler *cp, EjsType *type);
static void     genContinue(EcCompiler *cp, EcNode *np);
static void     genDassign(EcCompiler *cp, EcNode *np);
static void     genDirectives(EcCompiler *cp, EcNode *np, bool saveResult);
static void     genDo(EcCompiler *cp, EcNode *np);
static void     genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost);
static void     genError(EcCompiler *cp, EcNode *np, char *fmt, ...);
static void     genEndFunction(EcCompiler *cp, EcNode *np);
static void     genExpressions(EcCompiler *cp, EcNode *np);
static void     genField(EcCompiler *cp, EcNode *np);
static void     genFor(EcCompiler *cp, EcNode *np);
static void     genForIn(EcCompiler *cp, EcNode *np);
static void     genFunction(EcCompiler *cp, EcNode *np);
static void     genHash(EcCompiler *cp, EcNode *np);
static void     genIf(EcCompiler *cp, EcNode *np);
static void     genLeftHandSide(EcCompiler *cp, EcNode *np);
static void     genLiteral(EcCompiler *cp, EcNode *np);
static void     genLogicalOp(EcCompiler *cp, EcNode *np);
static void     genModule(EcCompiler *cp, EcNode *np);
static void     genName(EcCompiler *cp, EcNode *np);
static void     genNameExpr(EcCompiler *cp, EcNode *np);
static void     genNew(EcCompiler *cp, EcNode *np);
static void     genArrayLiteral(EcCompiler *cp, EcNode *np);
static void     genObjectLiteral(EcCompiler *cp, EcNode *np);
static void     genProgram(EcCompiler *cp, EcNode *np);
static void     genPragmas(EcCompiler *cp, EcNode *np);
static void     genPostfixOp(EcCompiler *cp, EcNode *np);
static void     genReturn(EcCompiler *cp, EcNode *np);
static void     genSuper(EcCompiler *cp, EcNode *np);
static void     genSwitch(EcCompiler *cp, EcNode *np);
static void     genThis(EcCompiler *cp, EcNode *np);
static void     genThrow(EcCompiler *cp, EcNode *np);
static void     genTry(EcCompiler *cp, EcNode *np);
static void     genUnaryOp(EcCompiler *cp, EcNode *np);
static void     genUnboundName(EcCompiler *cp, EcNode *np);
static void     genUseNamespace(EcCompiler *cp, EcNode *np);
static void     genVar(EcCompiler *cp, EcNode *np);
static void     genVarDefinition(EcCompiler *cp, EcNode *np);
static void     genWith(EcCompiler *cp, EcNode *np);
static int      getCodeLength(EcCompiler *cp, EcCodeGen *code);
static EcNode   *getNextNode(EcCompiler *cp, EcNode *np, int *next);
static EcNode   *getPrevNode(EcCompiler *cp, EcNode *np, int *next);
static int      getStackCount(EcCompiler *cp);
static int      mapToken(EcCompiler *cp, int tokenId);
static MprFile  *openModuleFile(EcCompiler *cp, cchar *filename);
static void     orderModule(EcCompiler *cp, MprList *list, EjsModule *mp);
static void     patchJumps(EcCompiler *cp, int kind, int target);
static void     popStack(EcCompiler *cp, int count);
static void     processNode(EcCompiler *cp, EcNode *np);
static void     processModule(EcCompiler *cp, EjsModule *mp);
static void     pushStack(EcCompiler *cp, int count);
static void     setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode);
static void     setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code);
static void     setStack(EcCompiler *cp, int count);

/*
    Generate code for evaluating conditional compilation directives
 */
void ecGenConditionalCode(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    EcState         *state;

    ENTER(cp);

    state = cp->state;
    mprAssert(state);

    addModule(cp, mp);
    genDirectives(cp, np, 1);

    if (cp->errorCount > 0) {
        ecRemoveModule(cp, mp);
        LEAVE(cp);
        return;
    }
    createInitializer(cp, mp);
    ecRemoveModule(cp, mp);
    LEAVE(cp);
}


/*
    Top level for code generation. Loop through the AST nodes recursively.
 */
int ecCodeGen(EcCompiler *cp)
{
    Ejs         *ejs;
    EjsModule   *mp;
    EcNode      *np;
    MprList     *modules;
    int         next, i, version, count;

    ejs = cp->ejs;
    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }
    count = mprGetListLength(cp->nodes);
    for (i = 0; i < count && !cp->error; i++) {
        np = mprGetItem(cp->nodes, i);
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        if (np) {
            processNode(cp, np);
        }
    }
    if (cp->error) {
        return EJS_ERR;
    }

    /*
        Open once if merging into a single output file
     */
    if (cp->outputFile) {
        for (version = next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
            if (next <= 1 || mp->globalProperties || mp->hasInitializer || 
                    ejsCompareMulti(cp->ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
                version = mp->version;
                break;
            }
        }
        if (openModuleFile(cp, cp->outputFile) == 0) {
            return EJS_ERR;
        }
    }

    /*
        Now generate code for all the modules
     */
    modules = mprCreateList(-1, 0);
    for (next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
        orderModule(cp, modules, mp);
    }
    for (next = 0; (mp = mprGetNextItem(modules, &next)) != 0 && !cp->fatalError; ) {
        //  MOB -- remove this test. Should be able to add to a loaded module??
        mprAssert(!mp->loaded);
        if (mp->loaded) {
            continue;
        }
        /*
            Don't generate the default module unless it contains some real code or definitions and 
            we have more than one module.
         */
        if (mprGetListLength(cp->modules) == 1 || mp->globalProperties || mp->hasInitializer || 
                ejsCompareMulti(cp->ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->initialized = 0;
            processModule(cp, mp);
        }
    }
    cp->modules = modules;

    if (cp->outputFile) {
        if (flushModule(cp->file, cp->state->code) < 0) {
            genError(cp, 0, "Can't write to module file %s", cp->outputFile);
        }
        mprCloseFile(cp->file);
    }
    cp->file = 0;
    ecLeaveState(cp);
    return (cp->fatalError) ? EJS_ERR : 0;
}


static void orderModule(EcCompiler *cp, MprList *list, EjsModule *mp)
{
    EjsModule   *dp;
    Ejs         *ejs;
    int         next;
    
    ejs = cp->ejs;
    mp->visited = 1;
    for (next = 0; (dp = mprGetNextItem(mp->dependencies, &next)) != 0; ) {
        if (mprLookupItem(list, dp) < 0 && mprLookupItem(cp->modules, dp) >= 0) {
            if (!dp->visited) {
                orderModule(cp, list, dp);
            }
        }
    }
    if (mprLookupItem(list, mp) < 0) {
        mprAddItem(list, mp);
    }
    mp->visited = 0;
}


static void genArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);
    mprAssert(np->kind == N_ARGS);

    cp->state->needsValue = 1;

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        if (child->kind == N_ASSIGN_OP) {
            child->needDup = 1;
        }
        processNode(cp, child);
        child->needDup = 0;
    }
    LEAVE(cp);
}


static void genSpread(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_SPREAD);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        if (child->kind == N_ASSIGN_OP) {
            child->needDup = 1;
        }
        processNode(cp, child);
        child->needDup = 0;
    }
    ecEncodeOpcode(cp, EJS_OP_SPREAD);
    LEAVE(cp);
}


#if UNUSED
static void genArrayLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        /* Don't propagate needsValue here. We have a new and that will take care of the residual value */
        cp->state->needsValue = 0;
        processNode(cp, child);
    }
    LEAVE(cp);
}
#endif


/*
    Generate an assignment expression
 */
static void genAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    int         next, rc;

    ENTER(cp);

    state = cp->state;
    rc = 0;
    next = 0;

    mprAssert(np->kind == N_ASSIGN_OP);
    mprAssert(np->left);
    mprAssert(np->right);

    state->onLeft = 0;

    /*
        Dup the object on the stack so it is available for subsequent operations
     */
    if (np->needDupObj) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Process the expression on the right. Leave the result on the stack.
     */
    if (np->right->kind == N_ASSIGN_OP) {
        np->right->needDup = 1;
    }

    state->needsValue = 1;
    processNode(cp, np->right);
    state->needsValue = 0;

    if (np->needDupObj) {
        /*
            Get the object on the top above the value
         */
        ecEncodeOpcode(cp, EJS_OP_SWAP);
    }

    /*
        If this expression is part of a function argument, the result must be preserved.
     */
    if (np->needDup || state->next->needsValue) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Store to the left hand side
     */
    genLeftHandSide(cp, np->left);
    LEAVE(cp);
}


static void genBinaryOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->needsValue = 1;

    mprAssert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
    case T_LOGICAL_OR:
        genLogicalOp(cp, np);
        break;

    default:
        if (np->left) {
            processNode(cp, np->left);
        }
        if (np->right) {
            processNode(cp, np->right);
        }
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        popStack(cp, 2);
        pushStack(cp, 1);
        break;
    }
    mprAssert(state == cp->state);
    LEAVE(cp);
}


static void genBreak(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    discardBlockItems(cp, state->code->blockMark);
    if (state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    } else if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
    }
    if (state->code->jumps == 0 || !(state->code->jumpKinds & EC_JUMP_BREAK)) {
        genError(cp, np, "Illegal break statement");
    } else {
        discardStackItems(cp, state->code->breakMark);
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_BREAK);
        ecEncodeInt32(cp, 0);
    }
    LEAVE(cp);
}


static void genBlock(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsNamespace    *namespace;
    EcState         *state;
    EjsBlock        *block;
    EjsLookup       *lookup;
    EcNode          *child;
    int             next;

    ENTER(cp);

    state = cp->state;
    ejs = cp->ejs;
    block = (EjsBlock*) np->blockRef;

    if (block && np->createBlockObject) {
        state->prevBlockState = cp->blockState;
        cp->blockState = state;

        lookup = &np->lookup;
        if (lookup->slotNum >= 0) {
            mprAssert(lookup->bind);
            ecEncodeOpcode(cp, EJS_OP_OPEN_BLOCK);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, lookup->nthBlock);
            state->code->blockCount++;
        }
        /*
            Emit block namespaces
         */
        if (block->namespaces.length > 0) {
            for (next = 0; ((namespace = (EjsNamespace*) mprGetNextItem(&block->namespaces, &next)) != 0); ) {
                if (namespace->value->value[0] == '-') {
                    emitNamespace(cp, namespace);
                }
            }
        }
        state->letBlock = block;
        state->letBlockNode = np;

        next = 0;
        while ((child = getNextNode(cp, np, &next))) {
            processNode(cp, child);
        }
        if (lookup->slotNum >= 0) {
            mprAssert(lookup->bind);
            ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
            state->code->blockCount--;
        }
        cp->blockState = state->prevBlockState;
        ecAddNameConstant(cp, np->qname);

    } else {
        next = 0;
        while ((child = getNextNode(cp, np, &next))) {
            processNode(cp, child);
        }
    }
    LEAVE(cp);
}


/*
    Block scope variable reference
 */
static void genBlockName(EcCompiler *cp, int slotNum, int nthBlock)
{
    int         code;

    mprAssert(slotNum >= 0);

    //  MOB BINDING OK
    code = (!cp->state->onLeft) ?  EJS_OP_GET_BLOCK_SLOT :  EJS_OP_PUT_BLOCK_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBlock);
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


static void genContinue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    discardBlockItems(cp, cp->state->code->blockMark);
    if (cp->state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    } else if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
    }
    if (cp->state->code->jumps == 0 || !(cp->state->code->jumpKinds & EC_JUMP_CONTINUE)) {
        genError(cp, np, "Illegal continue statement");
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_CONTINUE);
        ecEncodeInt32(cp, 0);
    }
    LEAVE(cp);
}


static void genDelete(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *left, *lright;

    ENTER(cp);
    mprAssert(np);

    ejs = cp->ejs;
    left = np->left;
    mprAssert(left);

    switch (left->kind) {
    case N_DOT:
        processNode(cp, left->left);
        lright = left->right;
        if (lright->kind == N_QNAME) {
            /* delete obj.name */
            genNameExpr(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 3);
            pushStack(cp, 1);
        } else {
            /* delete obj[expr] */
            ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
            ecEncodeConst(cp, S(empty));
            processNode(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 2);
            pushStack(cp, 1);
        }
        break;

    case N_QNAME:
        /* delete space::name */
        genNameExpr(cp, left);
        ecEncodeOpcode(cp, EJS_OP_DELETE_SCOPED_NAME_EXPR);
        popStack(cp, 2);
        pushStack(cp, 1);
        break;

    default:
        mprAssert(0);
    }
    LEAVE(cp);
}


/*
    Global variable
 */
static void genGlobalName(EcCompiler *cp, int slotNum)
{
    int     code;

    mprAssert(slotNum >= 0);

    //  MOB - TEMP warning if being called.
    // mprAssert(0);
    code = (!cp->state->onLeft) ?  EJS_OP_GET_GLOBAL_SLOT :  EJS_OP_PUT_GLOBAL_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);

    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Function local variable or argument reference
 */
static void genLocalName(EcCompiler *cp, int slotNum)
{
    int     code;

    mprAssert(slotNum >= 0);

    //  MOB BINDING OK

    if (slotNum < 10) {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT_0 :  EJS_OP_PUT_LOCAL_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT :  EJS_OP_PUT_LOCAL_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a logical operator. Called by genBinaryOp
  
    (expression OP expression)
 */
static void genLogicalOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcCodeGen   *saveCode, *rightCode;
    int         doneIfTrue, rightLen;

    ENTER(cp);

    state = cp->state;
    saveCode = state->code;
    rightCode = 0;

    mprAssert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
        doneIfTrue = 0;
        break;

    case T_LOGICAL_OR:
        doneIfTrue = 1;
        break;

    default:
        doneIfTrue = 1;
        mprAssert(0);
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        break;
    }

    /*
        Process the conditional test. Put the pop for the branch here prior to the right hand side.
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);
    popStack(cp, 1);

    //  MOB - remove test
    mprAssert(np->right);
    if (np->right) {
        state->code = allocCodeBuffer(cp);
        rightCode = state->code;
        /*
            Evaluating right hand side, so we must pop the left side duped value.
         */
        ecEncodeOpcode(cp, EJS_OP_POP);
        popStack(cp, 1);
        processNode(cp, np->right);
    }
    rightLen = (int) mprGetBufLength(rightCode->buf);

    /*
        Now copy the code to the output code buffer
     */
    setCodeBuffer(cp, saveCode);

    /*
        Jump to done if we know the result due to lazy evalation.
     */
    if (rightLen > 0 && rightLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE_8: EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, rightLen);
    } else {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE: EJS_OP_BRANCH_FALSE);
        ecEncodeInt32(cp, rightLen);
    }
    copyCodeBuffer(cp, state->code, rightCode);
    mprAssert(state == cp->state);
    LEAVE(cp);
}


/*
    Generate a property name reference based on the object already pushed.
    The owning object (pushed on the VM stack) may be an object or a type.
 */
static void genPropertyName(EcCompiler *cp, int slotNum)
{
    EcState     *state;
    int         code;

    mprAssert(slotNum >= 0);

    state = cp->state;

    mprAssert(0);
    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT_0 :  EJS_OP_PUT_OBJ_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT :  EJS_OP_PUT_OBJ_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genBaseClassPropertyName(EcCompiler *cp, int slotNum, int nthBase)
{
    EcState     *state;
    int         code;

    mprAssert(slotNum >= 0);

    state = cp->state;

    mprAssert(0);
    code = (!cp->state->onLeft) ?  EJS_OP_GET_TYPE_SLOT : EJS_OP_PUT_TYPE_SLOT;

    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBase);

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genThisBaseClassPropertyName(EcCompiler *cp, EjsType *type, int slotNum)
{
    Ejs         *ejs;
    EcState     *state;
    int         code, nthBase;

    mprAssert(slotNum >= 0);
    mprAssert(type && ejsIsType(ejs, type));

    ejs = cp->ejs;
    state = cp->state;

    mprAssert(0);
    /*
        Count based up from object 
     */
    for (nthBase = 0; type->baseType; type = type->baseType) {
        nthBase++;
    }
    code = (!state->onLeft) ?  EJS_OP_GET_THIS_TYPE_SLOT :  EJS_OP_PUT_THIS_TYPE_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBase);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class name reference or a global reference.
 */
static void genClassName(EcCompiler *cp, EjsType *type)
{
    Ejs         *ejs;
    EcState     *state;
    int         slotNum;

    mprAssert(type);

    ejs = cp->ejs;
    state = cp->state;

    if (type == ejs->global) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        return;
    }
    slotNum = ejsLookupProperty(ejs, ejs->global, type->qname);
    if (cp->bind && slotNum <= ES_global_NUM_CLASS_PROP) {
        mprAssert(slotNum >= 0);
        genGlobalName(cp, slotNum);

    } else if (type == state->currentClass &&
            (!state->inFunction || (state->currentFunction && state->currentFunction->staticMethod))) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
#if UNUSED
            /*
                This is broken. When calling a subclass method, this refers to the outer class and so the base is not right
             */
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS_BASE);
            ecEncodeNum(cp, 0);
#endif

    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME);
        ecEncodeName(cp, type->qname);
        popStack(cp, 1);
        pushStack(cp, 1);
    }
}


/*
    Generate a property reference in the current object
 */
static void genPropertyViaThis(EcCompiler *cp, int slotNum)
{
    Ejs             *ejs;
    EcState         *state;
    int             code;

    mprAssert(slotNum >= 0);

    ejs = cp->ejs;
    state = cp->state;

    mprAssert(0);
    /*
        Property in the current "this" object
     */
    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT_0 :  EJS_OP_PUT_THIS_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT :  EJS_OP_PUT_THIS_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a bound name reference. We already know the slot for the property and its owning type.
 */
static void genBoundName(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsLookup   *lookup;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    lookup = &np->lookup;

    mprAssert(lookup->slotNum >= 0);
    mprAssert(lookup->bind);

    if (lookup->obj == ejs->global) {
        /*
            Global variable.
         */
        //  TODO -- this logic looks strange
#if UNUSED
        if (lookup->slotNum < 0 || (!cp->bind && (lookup->ref == 0 || !BUILTIN(lookup->ref)))) {
#else
        if (lookup->slotNum < 0 || lookup->slotNum > ES_global_NUM_CLASS_PROP) {
#endif
            lookup->bind = 0;
            genUnboundName(cp, np);

        } else {
            genGlobalName(cp, lookup->slotNum);
        }
#if OLD
    } else if (ejsIsFunction(ejs, lookup->obj) && lookup->nthBlock == 0) {
        genLocalName(cp, lookup->slotNum);
#else
    } else if (lookup->obj == (EjsObj*) state->currentFunction->activation) {
        genLocalName(cp, lookup->slotNum);
#endif

    } else if ((ejsIsBlock(ejs, lookup->obj) || ejsIsFunction(ejs, lookup->obj)) && 
            (!ejsIsType(ejs, lookup->obj) && !ejsIsPrototype(ejs, lookup->obj))) {
        genBlockName(cp, lookup->slotNum, lookup->nthBlock);

    } else if (lookup->useThis) {
        if (lookup->instanceProperty) {
            /*
                Property being accessed via the current object "this" or an explicit object?
             */
            genPropertyViaThis(cp, lookup->slotNum);
        } else {
            genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
        }

    } else if (!state->currentObjectNode) {
        if (lookup->instanceProperty) {
            genBlockName(cp, lookup->slotNum, lookup->nthBlock);

        } else {
            /*
                Static property with no explicit object. ie. Not "obj.property". The property was found via a scope search.
                We ignore nthBase as we use the actual type (lookup->obj) where the property was found.
             */
            if (state->inClass && state->inFunction && state->currentFunction->staticMethod) {
                genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                
            } else {
                if (state->inFunction && ejsIsA(ejs, (EjsObj*) state->currentClass, (EjsType*) lookup->obj)) {
                    genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                    
                } else {
                    SAVE_ONLEFT(cp);
                    genClassName(cp, (EjsType*) lookup->obj);
                    RESTORE_ONLEFT(cp);
                    genPropertyName(cp, lookup->slotNum);
                }
            }
        }

    } else {
        /*
            Explicity object. ie. "obj.property". The object in a dot expression is already pushed on the stack.
            Determine if we can access the object itself or if we need to use the type of the object to access
            static properties.
         */
        if (lookup->instanceProperty) {
            genPropertyName(cp, lookup->slotNum);

        } else {
            /*
                Property is in the nth base class from the object already pushed on the stack (left hand side).
             */
            genBaseClassPropertyName(cp, lookup->slotNum, lookup->nthBase);
        }
    }
    LEAVE(cp);
}


static void processNodeGetValue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    cp->state->needsValue = 1;
    processNode(cp, np);
    LEAVE(cp);
}


static int genCallArgs(EcCompiler *cp, EcNode *np) 
{
    if (np == 0) {
        return 0;
    }
    processNode(cp, np);
    return mprGetListLength(np->children);
}


static void genCallSequence(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    EjsLookup       *lookup;
    int             fast, argc, staticMethod, count;    
        
    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    lookup = &np->left->lookup;
    argc = 0;
    
    if (!lookup->bind || lookup->slotNum < 0) {
        /*
            Unbound or Function expression or instance variable containing a function. Can't use fast path op codes below.
         */
        if (left->kind == N_QNAME && !(left->name.nameExpr || left->name.qualifierExpr)) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_SCOPED_NAME);
            ecEncodeName(cp, np->qname);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME && 
                   !(left->right->name.nameExpr || left->right->name.qualifierExpr)) {
            processNodeGetValue(cp, left->left);
            if (state->dupLeft) {
                ecEncodeOpcode(cp, EJS_OP_DUP);
                pushStack(cp, 1);
                state->dupLeft = 0;
            }
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_NAME);
            ecEncodeName(cp, np->qname);
            popStack(cp, 1);
            
        } else {
            /*
                MOB BUG. Could be an arbitrary expression on the left. Need a consistent way to save the right most
                object before the property. */
            count = getStackCount(cp);
#if UNUSED
            left->needThis = 1;
#endif
            processNodeGetValue(cp, left);
#if UNUSED
            if (getStackCount(cp) < (count + 2)) {
                ecEncodeOpcode(cp, EJS_OP_DUP);
                pushStack(cp, 1);
            }
#endif
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS_LOOKUP);
            pushStack(cp, 1);
            ecEncodeOpcode(cp, EJS_OP_SWAP);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL);
            popStack(cp, 2);
        }
        ecEncodeNum(cp, argc); 
        popStack(cp, argc);
        return;
    }
        
    fun = (EjsFunction*) lookup->ref;
    staticMethod = (ejsIsFunction(ejs, fun) && fun->staticMethod);
        
    /*
        Use fast opcodes when the call sequence is bindable and either:
            expression.name()
            name
     */
    fast = (left->kind == N_DOT && left->right->kind == N_QNAME) || left->kind == N_QNAME;      
        
    if (!fast) {
        /*
            Resolve a reference to a function expression
            TODO REFACTOR needThis. Example: (function (s) { print(s);})("hello");
         */
        if (left->kind == N_EXPRESSIONS) {
            if (left->right == 0) {
                left->left->needThis = 1;
            } else {
                left->right->needThis = 1;
            }
        } else {
            left->needThis = 1;
        }
        processNodeGetValue(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL);
        popStack(cp, 2);
        ecEncodeNum(cp, argc); 
        popStack(cp, argc);
        return;
    }
    if (staticMethod) {
        mprAssert(ejsIsType(ejs, lookup->obj));
        if (state->currentClass && state->inFunction && 
#if UNUSED
                ejsIsTypeSubType(ejs, state->currentClass, (EjsType*) lookup->originalObj) && 
#endif
                lookup->obj != ST(Object)) {
            /*
                Calling a static method from within a class or subclass. So we can use "this".
             */
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
#if UNUSED
            /*
                If searching the scope chain (i.e. without a qualifying obj.property), and if the current class is not the 
                original object, then see how far back on the inheritance chain we must go.
             */
            if (lookup->originalObj != lookup->obj) {
                for (type = state->currentClass; type != (EjsType*) lookup->originalObj; type = type->baseType) {
                    lookup->nthBase++;
                }
            }
#endif
            if (!state->currentFunction->staticMethod) {
                /*
                    If calling from within an instance function, need to step over the instance also
                 */
                lookup->nthBase++;
            }
            ecEncodeNum(cp, lookup->nthBase);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            /*
                Calling a static method with an explicit object or expression. Call via the object.
             */
            processNode(cp, left->left);
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            if (lookup->ownerIsType) {
                lookup->nthBase--;
            }
            ecEncodeNum(cp, lookup->nthBase);
            popStack(cp, 1);
            
        } else {
            /*
                Foreign static method. Call directly on the correct class type object.
             */
            genClassName(cp, (EjsType*) lookup->obj);
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, 0);
            popStack(cp, 1);
        }
        
    } else {
        // pushStack(cp, 1);
        if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            if (left->left->kind == N_THIS) {
                lookup->useThis = 1;
            }
        }
        
        if (lookup->useThis && !lookup->instanceProperty) {
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            
        } else if (lookup->obj == ejs->global) {
            /*
                Instance function or type being invoked as a constructor (e.g. Date(obj))
             */
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_GLOBAL_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            
        } else if (lookup->instanceProperty && left->left) {
            processNodeGetValue(cp, left->left);
            argc = genCallArgs(cp, right);
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_INSTANCE_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            popStack(cp, 1);
            
        } else if (ejsIsType(ejs, lookup->obj) || ejsIsPrototype(ejs, lookup->obj)) {
            if (left->kind == N_DOT && left->right->kind == N_QNAME) {
                processNodeGetValue(cp, left->left);
                argc = genCallArgs(cp, right);
                mprAssert(0);
                ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
                mprAssert(lookup->slotNum >= 0);
                ecEncodeNum(cp, lookup->slotNum);
                popStack(cp, 1);
                
            } else {
                left->needThis = 1;
                processNodeGetValue(cp, left);
                argc = genCallArgs(cp, right);
                ecEncodeOpcode(cp, EJS_OP_CALL);
                popStack(cp, 2);
            }
            
        } else if (ejsIsBlock(ejs, lookup->obj)) {
            //  MOB BINDING OK
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_BLOCK_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, lookup->nthBlock);
        }
    }
    ecEncodeNum(cp, argc); 
    popStack(cp, argc);
}


/*
    Code generation for function calls
 */
static void genCall(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    int             argc, hasResult;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    fun = (EjsFunction*) np->lookup.ref;    
    
    if (left->kind == N_NEW && !left->newExpr.callConstructors) {
        processNode(cp, left);
        LEAVE(cp);
        return;
    }
    if (left->kind == N_NEW) {
        processNode(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL_CONSTRUCTOR);
        ecEncodeNum(cp, argc);
        popStack(cp, argc);
        LEAVE(cp);
        return;
    }
    genCallSequence(cp, np);

    /*
        Process the function return value. Call by ref has a this pointer plus method reference plus args
     */
    hasResult = 0;
    if (fun && ejsIsFunction(ejs, fun)) {
        if (fun->resultType && fun->resultType != ST(Void)) {
            hasResult = 1;

        } else if (fun->hasReturn || ejsIsType(ejs, fun)) {
            /*
                Untyped function, but it has a return stmt.
                We don't do data flow to make sure all return cases have returns (sorry).
             */
            hasResult = 1;
        }
        if (state->needsValue && !hasResult) {
            genError(cp, np, "Function call does not return a value.");
        }
    }
    /*
        If calling a type as a constructor (Date()), must push result
     */
    if (state->needsValue || ejsIsType(ejs, np->lookup.ref)) {
        ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genCatchArg(EcCompiler *cp, EcNode *np)
{
    ecEncodeOpcode(cp, EJS_OP_PUSH_CATCH_ARG);
    pushStack(cp, 1);
}


/*
    Code is injected before existing code
 */
static int injectCode(Ejs *ejs, EjsFunction *fun, EcCodeGen *extra)
{
    EjsCode     *old;
    EjsEx       *ex;
    EjsDebug    *debug;
    uchar       *byteCode;
    int         next, i, len, codeLen, extraCodeLen;

    if (extra == NULL || extra->buf == NULL) {
        return 0;
    }
    old = fun->body.code;
    codeLen = (fun->body.code) ? old->codeLen : 0;
    extraCodeLen = (int) mprGetBufLength(extra->buf);
    len = codeLen + extraCodeLen;

    if (extraCodeLen == 0 || len == 0) {
        return 0;
    }
    if ((byteCode = mprAllocZeroed(len)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprMemcpy(byteCode, extraCodeLen, mprGetBufStart(extra->buf), extraCodeLen);
    if (codeLen) {
        mprMemcpy(&byteCode[extraCodeLen], codeLen, old->byteCode, codeLen);
    }
    ejsSetFunctionCode(ejs, fun, old->module, byteCode, len, extra->debug);

    debug = old->debug;
    if (debug && debug->numLines > 0) {
        for (i = 0; i < debug->numLines; i++) {
            if (ejsAddDebugLine(ejs, &fun->body.code->debug, debug->lines[i].offset + extraCodeLen, 
                    debug->lines[i].source) < 0) {
                return MPR_ERR_MEMORY;
            }
        }
    }

    /*
        Recreate all exception handlers
     */
    for (i = 0; i < old->numHandlers; i++) {
        ex = old->handlers[i];
        ex->tryStart += extraCodeLen;
        ex->tryEnd += extraCodeLen;
        ex->handlerStart += extraCodeLen;
        ex->handlerEnd += extraCodeLen;
        ejsAddException(ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, 
            ex->numBlocks, ex->numStack, ex->flags, -1);
    }
    for (next = 0; (ex = mprGetNextItem(extra->exceptions, &next)) != 0; ) {
        ejsAddException(ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, 
            ex->numBlocks, ex->numStack, ex->flags, -1);
    }
    return 0;
}


/*
    Process a class node.
 */
static void genClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type, *baseType;
    EjsFunction     *constructor;
    EcCodeGen       *code;
    EcState         *state;
    EcNode          *constructorNode;
    EjsName         qname;

    ENTER(cp);
    mprAssert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = (EjsType*) np->klass.ref;
    mprAssert(type);

    state->inClass = 1;
    state->inFunction = 0;

    /*
        Op code to define the class. This goes into the module code buffer. DefineClass will capture the current scope
        including the internal namespace for this file.
        OPT See above todo
     */
    ecEncodeOpcode(cp, EJS_OP_DEFINE_CLASS);
    ecEncodeGlobal(cp, (EjsObj*) type, type->qname);

    state->letBlock = (EjsBlock*) type;
    state->varBlock = (EjsBlock*) type;
    state->currentClass = type;
    state->currentClassNode = np;

    constructorNode = np->klass.constructor;

    /*
        Create code buffers to hold the static and instance level initialization code. The AST module will always
        create a constructor node for us if there is instance level initialization code. We currently put the class
        initialization code in the constructor. Static variable initialization code will go into the current
        module buffer (cp->currentModule) and will be run when the module is loaded. 
        BUG - CLASS INITIALIZATION ORDERING.
     */
    state->code = state->currentModule->code;

    /*
        Create a code buffer for static initialization code and set it as the default buffer
     */
    state->code = state->staticCodeBuf = allocCodeBuffer(cp);

    if (type->constructor.block.pot.isFunction) {
        state->instanceCodeBuf = allocCodeBuffer(cp);
    }

    /*
        The current code buffer is the static initializer buffer. genVar will redirect to the instanceCodeBuf as required.
     */
    processNode(cp, np->left);

    if (type->hasInitializer) {
        /*
            Create the static initializer
         */
        ecEncodeOpcode(cp, EJS_OP_RETURN);
        setFunctionCode(cp, np->klass.initializer, state->staticCodeBuf);
    }

    if (type->constructor.block.pot.isFunction) {
        mprAssert(constructorNode);
        mprAssert(state->instanceCodeBuf);
        code = state->code = state->instanceCodeBuf;

        constructor = state->currentFunction = (EjsFunction*) type;
        mprAssert(constructor);
        if (constructorNode->function.isDefault) {
            /*
                No constructor exists, so generate the default constructor. Append the default constructor 
                instructions after any initialization code. Will only get here if there is no required instance 
                initialization.
             */
            baseType = type->baseType;
            if (baseType && baseType->constructor.block.pot.isFunction) {
                ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
                ecEncodeName(cp, baseType->qname);
                ecEncodeNum(cp, 0);
            }
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            setFunctionCode(cp, (EjsFunction*) type, code);
            //  MOB -- make these standard strings in native core
            ecAddCStringConstant(cp, EJS_PUBLIC_NAMESPACE);
            ecAddCStringConstant(cp, EJS_CONSTRUCTOR_NAMESPACE);

        } else if (type->constructor.block.pot.isFunction) {
#if UNUSED
            /*
                Inject instance initializer code into (before) pre-existing constructor code. 
             */
            initializerCode = code->buf;
            initializerLen = mprGetBufLength(initializerCode);
            mprAssert(initializerLen >= 0);
            if (initializerLen > 0) {
                constructorLen = (constructor->body.code) ? constructor->body.code->codeLen : 0;
                mprAssert(constructorLen >= 0);
                len = initializerLen + constructorLen;
                if ((byteCode = mprAllocZeroed(len)) == 0) {
                    genError(cp, np, "Can't allocate code buffer");
                    LEAVE(cp);
                }
                mprMemcpy(byteCode, initializerLen, mprGetBufStart(initializerCode), initializerLen);
                if (constructorLen) {
                    mprMemcpy(&byteCode[initializerLen], constructorLen, constructor->body.code->byteCode, constructorLen);
                }
                if (constructor->body.code) {
                    debug = constructor->body.code->debug;
                    mprAssert(debug->magic == EJS_DEBUG_MAGIC);
                    if (debug && debug->numLines > 0) {
                        for (i = 0; i < debug->numLines; i++) {
                            addDebugLine(cp, code, debug->lines[i].offset, debug->lines[i].source);
                        }
                    }
                }
                /*
                    Adjust existing exception blocks to accomodate injected code.
                    Then define new try/catch blocks encountered.
                 */
                for (i = 0; i < constructor->body.code->numHandlers; i++) {
                    ex = constructor->body.code->handlers[i];
                    ex->tryStart += initializerLen;
                    ex->tryEnd += initializerLen;
                    ex->handlerStart += initializerLen;
                    ex->handlerEnd += initializerLen;
                }
                for (next = 0; (ex = (EjsEx*) mprGetNextItem(code->exceptions, &next)) != 0; ) {
                    ejsAddException(ejs, constructor, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, 
                        ex->handlerEnd, ex->numBlocks, ex->numStack, ex->flags, -1);
                }
            }
#endif
            injectCode(ejs, constructor, code);
        }
    }
    ecAddNameConstant(cp, np->qname);

    if (type->hasInitializer) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) type, 0);
        ecAddNameConstant(cp, qname);
    }
    if (type->baseType) {
        ecAddNameConstant(cp, type->baseType->qname);
    }

    /*
        Emit any properties implemented via another class (there is no Node for these)
     */
    ecAddConstants(cp, (EjsObj*) type);
    if (type->prototype) {
        ecAddConstants(cp, (EjsObj*) type->prototype);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "class", np->lookup.obj, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *field;
    int         next, count;

    mprAssert(np->kind == N_DASSIGN);

    ENTER(cp);

    count = mprGetListLength(np->children);
    for (next = 0; (field = getNextNode(cp, np, &next)) != 0; ) {
        mprAssert(field->kind == N_FIELD);
        if (next < count) {
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
        }
        if (np->objectLiteral.isArray) {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_SLOT);
            ecEncodeNum(cp, field->field.index);
        } else {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME);
            ecEncodeName(cp, field->field.fieldName->qname);
        }
        mprAssert(field->field.expr);
        processNode(cp, field->field.expr);
    }
    LEAVE(cp);
}


static void genDirectives(EcCompiler *cp, EcNode *np, bool saveResult)
{
    EcState     *lastDirectiveState;
    EcNode      *child;
    int         next, lastKind, mark;

    ENTER(cp);

    lastDirectiveState = cp->directiveState;
    lastKind = -1;
    next = 0;
    mark = getStackCount(cp);
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        lastKind = child->kind;
        cp->directiveState = cp->state;
        processNode(cp, child);
        if (!saveResult) {
            discardStackItems(cp, mark);
        }
    }
    if (saveResult) {
        ecEncodeOpcode(cp, EJS_OP_SAVE_RESULT);
    }
    cp->directiveState = lastDirectiveState;
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine generates code for bound properties where we know
    the slot offsets and also for unbound references. Return the right most node in right.
 */
static void genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *left, *right;
    int         put;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->onLeft = 0;
    left = np->left;
    right = np->right;

    /*
        Process the left of the dot and leave an object reference on the stack
     */
    switch (left->kind) {
    case N_DOT:
    case N_EXPRESSIONS:
    case N_LITERAL:
    case N_THIS:
    case N_REF:
    case N_QNAME:
    case N_CALL:
    case N_SUPER:
    case N_OBJECT_LITERAL:
        state->needsValue = 1;
        processNode(cp, left);
        state->needsValue = state->next->needsValue;
        break;

    default:
        mprAssert(0);
    }
    state->currentObjectNode = np->left;

    if (np->needThis || state->dupLeft) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
        state->dupLeft = 0;
    }
    put = state->next->onLeft;

    /*
        Process the right
     */
    switch (right->kind) {
    case N_CALL:
        state->needsValue = state->next->needsValue;
        genCall(cp, right);
        state->needsValue = 0;
        break;

    case N_QNAME:
        state->onLeft = state->next->onLeft;
        genName(cp, right);
        break;

    case N_SUPER:
        ecEncodeOpcode(cp, EJS_OP_SUPER);
        break;

    case N_LITERAL:
    case N_OBJECT_LITERAL:
    default:
        state->currentObjectNode = 0;
        state->needsValue = 1;
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, S(empty));
        pushStack(cp, 1);
        if (right->kind == N_LITERAL) {
            genLiteral(cp, right);
        } else if (right->kind == N_OBJECT_LITERAL) {
            genObjectLiteral(cp, right);
        } else {
            processNode(cp, right);
        }
        state->onLeft = state->next->onLeft;
        ecEncodeOpcode(cp, put ? EJS_OP_PUT_OBJ_NAME_EXPR :  EJS_OP_GET_OBJ_NAME_EXPR);
        popStack(cp, (put) ? 4 : 2);
        break;
    }
    if (rightMost) {
        *rightMost = right;
    }
    LEAVE(cp);
}


static void genEndFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ENTER(cp);

    mprAssert(np);

    ejs = cp->ejs;
    fun = cp->state->currentFunction;
    
    if (cp->lastOpcode != EJS_OP_RETURN_VALUE && cp->lastOpcode != EJS_OP_RETURN) {
        /*
            Ensure code cannot run off the end of a method.
            TODO OPT - must do a better job of basic block analysis and check if all paths out of a function have a return.
         */
        if (fun->isConstructor) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);

        } else if (fun->resultType == 0) {
            if (fun->hasReturn) {
                //  TODO - OPT. Should be able to avoid this somehow. We put it here now to ensure that all
                //  paths out of the function terminate with a return.
                ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
                ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            } else {
                ecEncodeOpcode(cp, EJS_OP_RETURN);
            }

        } else if (fun->resultType == ST(Void)) {
            ecEncodeOpcode(cp, EJS_OP_RETURN);

        } else {
            //  TODO - OPT. Should be able to avoid this somehow.
            ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
        }
    }
    cp->lastOpcode = 0;
    LEAVE(cp);
}


static void genExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


/*
    This handles "do { ... } while" constructs.
  
    do {
         body
    } while (conditional)
  
    Labels:
        topOfLoop:
            body
        continueLabel:
            conditional
            bxx topOfLoop
        endLoop:
 */
static void genDo(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, len, condShortJump, continueLabel, breakLabel, mark;

    ENTER(cp);
    mprAssert(np->kind == N_DO);

    state = cp->state;
    state->captureFinally = 0;
    state->captureBreak = 0;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.body) {
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.body);
        discardStackItems(cp, mark);
    }
    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        state->needsValue = 1;
        processNode(cp, np->forLoop.cond);
        state->needsValue = 0;
    }
    /*
        Get the lengths of code blocks
     */
    condLen = bodyLen = 0;
    if (np->forLoop.condCode) {
        condLen = (int) mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = (int) mprGetBufLength(np->forLoop.bodyCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump back to the top.
     */
    condShortJump = 0;
    len = bodyLen + condLen;
    if (len > 0) {
        if (len < 0x7f && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;
        } else {
            condLen += 5;
        }
    }

    setCodeBuffer(cp, code);
    if (np->forLoop.cond) {
        pushStack(cp, 1);
    }
    continueLabel = (int) mprGetBufLength(cp->state->code->buf);

    /*
        Add the body
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }

    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        len = bodyLen + condLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE_8);
            ecEncodeByte(cp, -len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE);
            ecEncodeInt32(cp, -len);
        }
        popStack(cp, 1);
    }

    breakLabel = (int) mprGetBufLength(cp->state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This handles "for" and while" constructs but not "for .. in"
  
    for (initializer; conditional; perLoop) { body }
  
    Labels:
            initializer
        topOfLoop:
            conditional
            bxx endLoop
        topOfBody:
            body
        continueLabel:
            perLoop
        endIteration:
            goto topOfLoop
        endLoop:
 */
static void genFor(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, perLoopLen, len, condShortJump, perLoopShortJump, continueLabel, breakLabel, mark;
    int         startMark;

    ENTER(cp);

    mprAssert(np->kind == N_FOR);

    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    startMark = getStackCount(cp);
    state->captureFinally = 0;
    state->captureBreak = 0;

    /*
        initializer is outside the loop
     */
    if (np->forLoop.initializer) {
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.initializer);
        discardStackItems(cp, mark);
    }

    /*
        For conditional
     */
    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        state->needsValue = 1;
        processNode(cp, np->forLoop.cond);
        state->needsValue = 0;
        /* Leaves one item on the stack, but this will be cleared when compared */
        mprAssert(state->code->stackCount >= 1);
        popStack(cp, 1);
    }

    if (np->forLoop.body) {
        mark = getStackCount(cp);
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        processNode(cp, np->forLoop.body);
        discardStackItems(cp, mark);
    }

    /*
        Per loop iteration
     */
    if (np->forLoop.perLoop) {
        np->forLoop.perLoopCode = state->code = allocCodeBuffer(cp);
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.perLoop);
        discardStackItems(cp, mark);
    }

    /*
        Get the lengths of code blocks
     */
    perLoopLen = condLen = bodyLen = 0;

    if (np->forLoop.condCode) {
        condLen = (int) mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = (int) mprGetBufLength(np->forLoop.bodyCode->buf);
    }
    if (np->forLoop.perLoopCode) {
        perLoopLen = (int) mprGetBufLength(np->forLoop.perLoopCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump at the top. This is the shorter of
        the two jumps as it does not span the conditional code, so we optimize it first incase the saving
        of 3 bytes allows us to also optimize the branch back to the top. Subtract 5 to the test with 0x7f to
        account for the worst-case jump at the bottom back to the top
     */
    condShortJump = 0;
    if (condLen > 0) {
        len = bodyLen + perLoopLen;
        if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;
        } else {
            condLen += 5;
        }
    }

    /*
        Calculate the jump back to the top of the loop (per-iteration jump). Subtract 5 to account for the worst case
        where the per loop jump is a long jump.
     */
    len = condLen + bodyLen + perLoopLen;
    if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
        perLoopShortJump = 1;
        perLoopLen += 2;
    } else {
        perLoopShortJump = 0;
        perLoopLen += 5;
    }

    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    setCodeBuffer(cp, code);
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        len = bodyLen + perLoopLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
            ecEncodeByte(cp, len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
            ecEncodeInt32(cp, len);
        }
    }

    /*
        Add the body and per loop code
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }
    continueLabel = (int) mprGetBufLength(state->code->buf);
    if (np->forLoop.perLoopCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.perLoopCode);
    }

    /*
        Add the per-loop jump back to the top of the loop
     */
    len = condLen + bodyLen + perLoopLen;
    if (perLoopShortJump) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, -len);
    }
    breakLabel = (int) mprGetBufLength(state->code->buf);
    discardStackItems(cp, startMark);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This routine is a little atypical in that it hand-crafts an exception block.
 */
static void genForIn(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *iterVar, *iterGet;
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         len, breakLabel, tryStart, tryEnd, handlerStart, mark, startMark, varCount;

    ENTER(cp);

    mprAssert(cp->state->code->stackCount >= 0);
    mprAssert(np->kind == N_FOR_IN);

    ejs = cp->ejs;
    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    startMark = getStackCount(cp);
    state->captureFinally = 0;
    state->captureBreak = 0;
    iterVar = np->forInLoop.iterVar;
    iterGet = np->forInLoop.iterGet;
    varCount = mprGetListLength(iterVar->children);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);
    processNode(cp, iterVar);

    /*
        Consider:
            for (i in obj.get())
                body
      
        Now process the obj.get()
     */
    np->forInLoop.initCode = state->code = allocCodeBuffer(cp);

    if (varCount == 2) {
        state->dupLeft = 1;
        processNode(cp, iterGet);
        state->dupLeft = 0;
    } else {
        processNode(cp, iterGet);
    }
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);
    mprAssert(state->code->stackCount >= 1);

    /*
        Process the iter.next()
     */
    np->forInLoop.bodyCode = state->code = allocCodeBuffer(cp);

    /*
        Dup the iterator reference each time round the loop as iter.next() will consume the object.
        TODO - OPT. Consider having a CALL op code that does not consume the object.
     */
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);

    /*
        Emit code to invoke the iterator
     */
    tryStart = getCodeLength(cp, np->forInLoop.bodyCode);

    if (np->forInLoop.iterNext->lookup.bind && np->forInLoop.iterNext->lookup.slotNum >= 0) {
        mprAssert(0);
        ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
        ecEncodeNum(cp, np->forInLoop.iterNext->lookup.slotNum);
    } else {
        ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_NAME);
        ecEncodeName(cp, np->forInLoop.iterNext->qname);
    }
    ecEncodeNum(cp, 0);
    popStack(cp, 1);
    
    tryEnd = getCodeLength(cp, np->forInLoop.bodyCode);

    if (varCount == 2) {
        /* Dup original object being iterated */
        ecEncodeOpcode(cp, EJS_OP_DUP_STACK);
        ecEncodeByte(cp, 1);
        pushStack(cp, 1);
        //  TODO space is not used with numericIndicies
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, S(empty));
        pushStack(cp, 1);
    }

    /*
        Save the result of the iter.next() call
     */
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);

    if (varCount == 2) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }
    
#if UNUSED
    //  MOB -- MUST CLEANUP this so we can use genLeftHandSide. But genVar() can't call genName??
    genLeftHandSide(cp, iterVar->left);
#else
    state->onLeft = 1;
    genName(cp, iterVar->left);
    state->onLeft = 0;
#endif
    if (iterVar->kind == N_VAR_DEFINITION && iterVar->def.varKind == KIND_LET) {
        ecAddNameConstant(cp, iterVar->left->qname);
    }
    mark = getStackCount(cp);
    if (np->forInLoop.body) {
        if (varCount == 2) {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME_EXPR);
            popStack(cp, 2);
            state->onLeft = 1;
            genName(cp, iterVar->right);
            state->onLeft = 0;
        }
        processNode(cp, np->forInLoop.body);
        discardStackItems(cp, mark);
    }
    len = getCodeLength(cp, np->forInLoop.bodyCode);
    if (len < (0x7f - 5)) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        len += 2;
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        len += 5;
        ecEncodeInt32(cp, -len);
    }

    /*
        Create exception catch block around iter.next() to catch the StopIteration exception.
        Note: we have a zero length handler (noop)
     */
    handlerStart = ecGetCodeOffset(cp);
    addException(cp, tryStart, tryEnd, ST(StopIteration), handlerStart, handlerStart, 0, startMark,
        EJS_EX_CATCH | EJS_EX_ITERATION);

    /*
        Patch break/continue statements
     */
#if UNUSED
    if (varCount == 2) {
        ecEncodeOpcode(cp, EJS_OP_POP);
    }
#endif
    discardStackItems(cp, startMark);
    breakLabel = (int) mprGetBufLength(state->code->buf);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, 0);

    setCodeBuffer(cp, code);
    copyCodeBuffer(cp, state->code, np->forInLoop.initCode);
    copyCodeBuffer(cp, state->code, np->forInLoop.bodyCode);
    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Generate code for default parameters. Native classes must handle this themselves. We
    generate the code for all default parameters in sequence with a computed goto at the front.
 */
static void genDefaultParameterCode(EcCompiler *cp, EcNode *np, EjsFunction *fun)
{
    Ejs             *ejs;
    EcNode          *parameters, *child;
    EcState         *state;
    EcCodeGen       **buffers, *saveCode;
    int             len, next, needLongJump, count, firstDefault;

    ejs = cp->ejs;
    state = cp->state;
    saveCode = state->code;

    parameters = np->function.parameters;
    mprAssert(parameters);

    count = mprGetListLength(parameters->children);
    buffers = (EcCodeGen**) mprAllocZeroed(count * sizeof(EcCodeGen*));

    for (next = 0; (child = getNextNode(cp, parameters, &next)) && !cp->error; ) {
        mprAssert(child->kind == N_VAR_DEFINITION);
        if (child->left->kind == N_ASSIGN_OP) {
            buffers[next - 1] = state->code = allocCodeBuffer(cp);
            genAssignOp(cp, child->left);
        }
    }
    if (fun->rest) {
        buffers[count - 1] = state->code = allocCodeBuffer(cp);
        ecEncodeOpcode(cp, EJS_OP_NEW_ARRAY);
        ecEncodeGlobal(cp, (EjsObj*) ST(Array), ST(Array)->qname);
        ecEncodeNum(cp, 0);
        pushStack(cp, 1);
        //  MOB -- convenience routine
        if (fun->numArgs < 10) {
            ecEncodeOpcode(cp, EJS_OP_PUT_LOCAL_SLOT_0 + fun->numArgs - 1);
        } else {
            ecEncodeOpcode(cp, EJS_OP_PUT_LOCAL_SLOT);
            ecEncodeNum(cp, fun->numArgs - 1);
        }
    }
    firstDefault = fun->numArgs - fun->numDefault - fun->rest;
    mprAssert(firstDefault >= 0);
    needLongJump = cp->optimizeLevel > 0 ? 0 : 1;

    /*
        Compute the worst case jump size. Start with 4 because the table is always one larger than the
        number of default args.
     */
    len = 4;
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            len = (int) mprGetBufLength(buffers[next]->buf) + 4;
            if (len >= 0x7f) {
                needLongJump = 1;
                break;
            }
        }
    }
    setCodeBuffer(cp, saveCode);

    /*
        This is a jump table where each parameter initialization segments falls through to the next one.
        We have one more entry in the table to jump over the entire computed jump section.
     */
    ecEncodeOpcode(cp, (needLongJump) ? EJS_OP_INIT_DEFAULT_ARGS: EJS_OP_INIT_DEFAULT_ARGS_8);
    ecEncodeByte(cp, fun->numDefault + fun->rest + 1);

    len = (fun->numDefault + fun->rest + 1) * ((needLongJump) ? 4 : 1);
    for (next = firstDefault; next < count; next++) {
        if (buffers[next] == 0) {
            continue;
        }
        if (needLongJump) {
            ecEncodeInt32(cp, len);
        } else {
            ecEncodeByte(cp, len);
        }
        len += (int) mprGetBufLength(buffers[next]->buf);
    }
    /*
        Add one more jump to jump over the entire jump table
     */
    if (needLongJump) {
        ecEncodeInt32(cp, len);
    } else {
        ecEncodeByte(cp, len);
    }

    /*
        Now copy all the initialization code
     */
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            copyCodeBuffer(cp, state->code, buffers[next]);
        }
    }
}


static void genFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsEx           *ex;
    EcState         *state;
    EcCodeGen       *code;
    EjsFunction     *fun;
    EjsType         *baseType;
    EjsName         qname;
    EjsTrait        *trait;
    EjsLookup       *lookup;
    EjsPot          *activation;
    int             i, numProp;

    ENTER(cp);

    mprAssert(np->kind == N_FUNCTION);
    
    ejs = cp->ejs;
    state = cp->state;
    cp->lastOpcode = 0;
    mprAssert(state);

    mprAssert(np->function.functionVar);
    fun = np->function.functionVar;
    activation = fun->activation;
    numProp = activation ? activation->numProp: 0;

    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;
#if UNUSED
    state->currentFunctionName = np->qname.name;
#endif
    state->currentFunction = fun;
    state->currentFunctionNode = np;

    /*
        Capture the scope chain by the defineFunction op code. Emit this into the existing code buffer. 
        Don't do if a method as they get scope via other means. Native methods also don't use this as an optimization.
        Native methods must handle scope explicitly.
      
        We only need to define the function if it needs full scope (unbound property access) or it is a nested function.
     */
    if (fun->fullScope) {
        lookup = &np->lookup;
        ecEncodeOpcode(cp, EJS_OP_DEFINE_FUNCTION);
        ecEncodeName(cp, np->qname);
    }
    code = state->code = allocCodeBuffer(cp);

    if (!fun->isNativeProc) {
        addDebug(cp, np);
    }

    /*
        Generate code for any parameter default initialization.
        Native classes must do default parameter initialization themselves.
     */
    if (fun->numDefault > 0 && !(np->attributes & EJS_PROP_NATIVE)) {
        genDefaultParameterCode(cp, np, fun);
    }
    if (np->function.constructorSettings) {
        genDirectives(cp, np->function.constructorSettings, 0);
    }
    state->letBlock = (EjsBlock*) fun;
    state->varBlock = (EjsBlock*) fun;

    if (np->function.isConstructor) {
        /*
            Function is a constructor. Call any default constructors if required.
            Should this be before or after default variable initialization?
         */
        mprAssert(state->currentClass);
        baseType = state->currentClass->baseType;
        if (!state->currentClass->callsSuper && baseType && baseType->constructor.block.pot.isFunction && 
                !(np->attributes & EJS_PROP_NATIVE)) {
            ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
            ecEncodeName(cp, baseType->qname);
            ecEncodeNum(cp, 0);
        }
    }

    /*
        May be no body for native functions
     */
    if (np->function.body) {
        mprAssert(np->function.body->kind == N_DIRECTIVES);
        processNode(cp, np->function.body);
    }
    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    setFunctionCode(cp, fun, code);
    ecAddNameConstant(cp, np->qname);

    for (i = 0; i < numProp; i++) {
        qname = ejsGetPropertyName(ejs, activation, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, activation, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
    }
    for (i = 0; i < fun->block.pot.numProp; i++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) fun, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, fun, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
    }
    if (fun->resultType) {
        ecAddNameConstant(cp, fun->resultType->qname);
    }
    if (fun->body.code) {
        for (i = 0; i < fun->body.code->numHandlers; i++) {
            ex = fun->body.code->handlers[i];
            if (ex && ex->catchType) {
                ecAddNameConstant(cp, ex->catchType->qname);
            }
        }
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "fun", np->lookup.obj, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genHash(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (!np->hash.disabled) {
        processNode(cp, np->hash.body);
    }
    LEAVE(cp);
}


static void genIf(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *saveCode;
    EcState     *state;
    int         thenLen, elseLen, mark;

    ENTER(cp);

    mprAssert(np->kind == N_IF);

    state = cp->state;
    saveCode = state->code;

    /*
        Process the conditional. Put the popStack for the branch here so the stack is correct for the "then" and 
        "else" blocks.
     */
    state->needsValue = 1;
    processNode(cp, np->tenary.cond);
    state->needsValue = 0;
    popStack(cp, 1);

    /*
        Process the "then" block.
     */
    np->tenary.thenCode = state->code = allocCodeBuffer(cp);
    mark = getStackCount(cp);
    
    //  CHANGE: Added for return (cond) ? call(): other;
    state->needsValue = state->next->needsValue;
    processNode(cp, np->tenary.thenBlock);
    if (state->next->needsValue) {
        /* Part of a tenary expression */
        if (state->code->stackCount < (mark + 1)) {
            genError(cp, np, "Then expression does not evaluate to a value. Check if operands are void");
        }
        discardStackItems(cp, mark + 1);
        if (np->tenary.elseBlock) {
            setStack(cp, mark);
        }
    } else {
        discardStackItems(cp, mark);
    }

    /*
        Else block (optional)
     */
    if (np->tenary.elseBlock) {
        np->tenary.elseCode = state->code = allocCodeBuffer(cp);
        state->needsValue = state->next->needsValue;
        processNode(cp, np->tenary.elseBlock);
        state->needsValue = 0;
        if (state->next->needsValue) {
            if (state->code->stackCount < (mark + 1)) {
                genError(cp, np, "Else expression does not evaluate to a value. Check if operands are void");
            }
            discardStackItems(cp, mark + 1);
        } else {
            discardStackItems(cp, mark);
        }
    }

    /*
        Calculate jump lengths. Then length will vary depending on if the jump at the end of the "then" block
        can jump over the "else" block with a short jump.
     */
    elseLen = (np->tenary.elseCode) ? (int) mprGetBufLength(np->tenary.elseCode->buf) : 0;
    thenLen = (int) mprGetBufLength(np->tenary.thenCode->buf);
    thenLen += (elseLen < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;

    /*
        Now copy the basic blocks into the output code buffer, starting with the jump around the "then" code.
     */
    setCodeBuffer(cp, saveCode);

    if (thenLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, thenLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
        ecEncodeInt32(cp, thenLen);
    }

    /*
        Copy the then code
     */
    copyCodeBuffer(cp, state->code, np->tenary.thenCode);

    /*
        Create the jump to the end of the if statement
     */
    if (elseLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, elseLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, elseLen);
    }
    if (np->tenary.elseCode) {
        copyCodeBuffer(cp, state->code, np->tenary.elseCode);
    }
    if (state->next->needsValue) {
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Expect data on the stack already to assign
 */
static void genLeftHandSide(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(cp);
    mprAssert(np);

    cp->state->onLeft = 1;

    switch (np->kind) {
    case N_DASSIGN:
    case N_DOT:
    case N_QNAME:
    case N_SUPER:
    case N_EXPRESSIONS:
    case N_OBJECT_LITERAL:
    case N_VAR:
        processNode(cp, np);
        break;

    case N_CALL:
    default:
        genError(cp, np, "Illegal left hand side");
    }
    LEAVE(cp);
}


static void genLiteral(EcCompiler *cp, EcNode *np)
{
    EjsNamespace    *nsp;
    EjsBoolean      *bp;
    EjsNumber       *ip;
    EjsString       *pattern, *data;
    Ejs             *ejs;
    int64           n;
    int             sid;

    ENTER(cp);
    ejs = cp->ejs;

    if (TYPE(np->literal.var) == ST(XML)) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_XML);
        data = ejsCreateString(ejs, mprGetBufStart(np->literal.data), mprGetBufLength(np->literal.data) / sizeof(MprChar));
        ecEncodeConst(cp, data);
        pushStack(cp, 1);
        LEAVE(cp);
        return;
    }

    /*
        Map Numbers to the configured real type
     */
    sid = TYPE(np->literal.var)->sid;

    switch (sid) {
    case S_Boolean:
        bp = (EjsBoolean*) np->literal.var;
        if (bp->value) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_TRUE);
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_FALSE);
        }
        break;

    case S_Number:
        /*
            These are signed values
         */
        ip = (EjsNumber*) np->literal.var;
        if (ip->value != floor(ip->value) || ip->value <= -MAXINT || ip->value >= MAXINT) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_DOUBLE);
            ecEncodeDouble(cp, ip->value);
        } else {
            n = (int64) ip->value;
            if (0 <= n && n <= 9) {
                ecEncodeOpcode(cp, EJS_OP_LOAD_0 + (int) n);
            } else {
                ecEncodeOpcode(cp, EJS_OP_LOAD_INT);
                ecEncodeNum(cp, n);
            }
        }
        break;

    case S_Namespace:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NAMESPACE);
        nsp = (EjsNamespace*) np->literal.var;
        ecEncodeConst(cp, nsp->value);
        break;

    case S_Null:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
        break;

    case S_String:
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, ((EjsString*) np->literal.var));
        break;

    case S_RegExp:
        ecEncodeOpcode(cp, EJS_OP_LOAD_REGEXP);
        pattern = (EjsString*) ejsRegExpToString(cp->ejs, (EjsRegExp*) np->literal.var);
        ecEncodeConst(cp, pattern);
        break;

    case S_Void:
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        break;

    default:
        mprAssert(0);
        break;
    }
    pushStack(cp, 1);
    LEAVE(cp);
}


/*
    Generate code for name reference. This routine handles both loads and stores.
 */
static void genName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_QNAME || np->kind == N_USE_NAMESPACE || np->kind == N_VAR);

    if (np->needThis) {
        if (np->lookup.useThis) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);

        } else if (np->lookup.obj == cp->ejs->global){
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);

        } else if (cp->state->currentObjectNode) {
            ecEncodeOpcode(cp, EJS_OP_DUP);

        } else {
            /*
                Unbound function
             */
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        }
        pushStack(cp, 1);
        np->needThis = 0;
    }
    if (np->lookup.bind && np->lookup.slotNum >= 0) {
        genBoundName(cp, np);
    } else {
        genUnboundName(cp, np);
    }
    LEAVE(cp);
}


static void genNew(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    mprAssert(np->kind == N_NEW);
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_NEW);
    popStack(cp, 1);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genArrayLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child, *typeNode;
    EjsType     *type;
    Ejs         *ejs;
    int         next, argc;

    ENTER(cp);
    ejs = cp->ejs;

    for (next = 0; (child = getNextNode(cp, np, &next)) != 0; ) {
        processNode(cp, child);
    }
    argc = next;
    ecEncodeOpcode(cp, EJS_OP_NEW_ARRAY);
    typeNode = np->objectLiteral.typeNode;
    type = (EjsType*) typeNode->lookup.ref;
    ecEncodeGlobal(cp, (EjsObj*) type, (type) ? type->qname: N(NULL, NULL));
    ecEncodeNum(cp, argc);
    pushStack(cp, 1);
    popStack(cp, argc * 2);
    LEAVE(cp);
}


static void genObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child, *typeNode;
    EjsType     *type;
    Ejs         *ejs;
    int         next, argc;

    if (np->objectLiteral.isArray) {
        genArrayLiteral(cp, np);
        return;
    }
    ENTER(cp);
    ejs = cp->ejs;

    /*
        Push all the literal args
     */
    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    argc = next;
    ecEncodeOpcode(cp, EJS_OP_NEW_OBJECT);
    typeNode = np->objectLiteral.typeNode;
    type = (EjsType*) typeNode->lookup.ref;
    ecEncodeGlobal(cp, (EjsObj*) type, (type) ? type->qname: N(NULL, NULL));
    ecEncodeNum(cp, argc);
    for (next = 0; (child = getNextNode(cp, np, &next)) != 0; ) {
        ecEncodeNum(cp, child->attributes);
    }
    pushStack(cp, 1);
    popStack(cp, argc * 3);
    LEAVE(cp);
}


static void genField(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *fieldName;

    ejs = cp->ejs;
    fieldName = np->field.fieldName;

    if (np->field.index >= 0) {
        //  TODO OPT use LOAD_INT_NN instructions
        ecEncodeOpcode(cp, EJS_OP_LOAD_INT);
        ecEncodeNum(cp, np->field.index);
        pushStack(cp, 1);

    } else if (fieldName->kind == N_QNAME) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->field.fieldName->qname.space);
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->field.fieldName->qname.name);
        pushStack(cp, 2);

    } else if (fieldName->kind == N_LITERAL) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, S(empty));
        pushStack(cp, 1);
        genLiteral(cp, fieldName);

    } else {
        //  MOB
        mprAssert(0);
        processNode(cp, fieldName);
    }
    if (np->field.fieldKind == FIELD_KIND_VALUE || np->field.fieldKind == FIELD_KIND_FUNCTION) {
        if (np->field.expr) {
            processNode(cp, np->field.expr);
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
            pushStack(cp, 1);            
        }
    } else {
        mprAssert(0);
#if UNUSED
        processNode(cp, np->field.fieldName);
#endif
    }
}


static void genPostfixOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    /*
        Dup before inc
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    ecEncodeOpcode(cp, EJS_OP_INC);
    ecEncodeByte(cp, (np->tokenId == T_PLUS_PLUS) ? 1 : -1);
    genLeftHandSide(cp, np->left);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genProgram(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *child;
    int         next;

    ENTER(cp);

    ejs = cp->ejs;

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {

        switch (child->kind) {
        case N_MODULE:
            genModule(cp, child);
            break;

        case N_DIRECTIVES:
            genDirectives(cp, child, 0);
            break;

        default:
            badNode(cp, np);
        }
    }
    LEAVE(cp);
}


static void genPragmas(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
}


/*
    Generate code for function returns
 */
static void genReturn(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ENTER(cp);

    ejs = cp->ejs;
    if (cp->state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }
    if (np->left) {
        fun = cp->state->currentFunction;
        if (fun->resultType == NULL || fun->resultType != ST(Void)) {
            cp->state->needsValue = 1;
            processNode(cp, np->left);
            cp->state->needsValue = 0;
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            popStack(cp, 1);

        } else if (np->ret.blockless) {
            /*
                The return was inserted by the parser. So we must still process the statement
             */
            processNode(cp, np->left);
        }

    } else {
        /*
            return;
         */
        fun = cp->state->currentFunction;
        if (fun->isConstructor) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
        } else {
            ecEncodeOpcode(cp, EJS_OP_RETURN);
        }
    }
    LEAVE(cp);
}


/*
    Load the super pointer. Super function calls (super()) are handled via N_CALL.
 */
static void genSuper(EcCompiler *cp, EcNode *np)
{
    int         argc;

    ENTER(cp);
    mprAssert(np->kind == N_SUPER);

    if (np->left) {
        argc = mprGetListLength(np->left->children);
        if (argc > 0) {
            processNode(cp, np->left);
        }
        ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
        ecEncodeName(cp, cp->state->currentClass->baseType->qname);
#if UNUSED
        ejsName(&qname, EJS_CONSTRUCTOR_NAMESPACE, cp->state->currentClass->baseType->qname.name);
        ecEncodeName(cp, qname);
#endif
        ecEncodeNum(cp, argc);        
        popStack(cp, argc);
    } else {
        ecEncodeOpcode(cp, EJS_OP_SUPER); 
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *caseItem, *elements;
    EcCodeGen   *code, *outerBlock;
    EcState     *state;
    int         next, len, nextCaseLen, nextCodeLen, totalLen, mark;

    ENTER(cp);

    state = cp->state;
    state->captureFinally = 0;
    state->captureBreak = 0;

    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    /*
        Generate code for the switch (expression)
     */
    processNode(cp, np->left);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK);

    /*
        Generate the code for each case label expression and case statements.
        next set to one to skip the switch expression.
     */
    elements = np->right;
    mprAssert(elements->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {
        /*
            Allocate a buffer for the case expression and generate that code
         */
        mark = getStackCount(cp);
        mprAssert(caseItem->kind == N_CASE_LABEL);
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            caseItem->caseLabel.expressionCode = state->code = allocCodeBuffer(cp);
            /*
                Dup the switch expression value to preserve it for later cases.
                OPT - don't need to preserve for default cases or if this is the last case
             */
            ecEncodeOpcode(cp, EJS_OP_DUP);
            mprAssert(caseItem->caseLabel.expression);
            processNode(cp, caseItem->caseLabel.expression);
            popStack(cp, 1);
        }

        /*
            Generate code for the case directives themselves.
         */
        caseItem->code = state->code = allocCodeBuffer(cp);
        mprAssert(caseItem->left->kind == N_DIRECTIVES);
        processNode(cp, caseItem->left);
        setStack(cp, mark);
    }

    /*
        Calculate jump lengths. Start from the last case and work backwards.
     */
    nextCaseLen = 0;
    nextCodeLen = 0;
    totalLen = 0;

    next = -1;
    while ((caseItem = getPrevNode(cp, elements, &next)) && !cp->error) {
        if (caseItem->kind != N_CASE_LABEL) {
            break;
        }
        /*
            CODE jump
            Jump to the code block of the next case. In the last block, we just fall out the bottom.
         */
        caseItem->caseLabel.nextCaseCode = nextCodeLen;
        if (nextCodeLen > 0) {
            len = (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            nextCodeLen += len;
            nextCaseLen += len;
            totalLen += len;
        }

        /*
            CASE jump
            Jump to the next case expression evaluation.
         */
        len = getCodeLength(cp, caseItem->code);
        nextCodeLen += len;
        nextCaseLen += len;
        totalLen += len;

        caseItem->jumpLength = nextCaseLen;
        nextCodeLen = 0;

        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            /*
                Jump to the next case expression test. Increment the length depending on whether we are using a
                goto_8 (2 bytes) or goto (4 bytes). Add one for the CMPEQ instruction (3 vs 6)
             */
            len = (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 3 : 6;
            nextCodeLen += len;
            totalLen += len;

            if (caseItem->caseLabel.expressionCode) {
                len = getCodeLength(cp, caseItem->caseLabel.expressionCode);
                nextCodeLen += len;
                totalLen += len;
            }
        }
        nextCaseLen = 0;
    }

    /*
        Now copy the basic blocks into the output code buffer.
     */
    setCodeBuffer(cp, code);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {

        if (caseItem->caseLabel.expressionCode) {
            copyCodeBuffer(cp, state->code, caseItem->caseLabel.expressionCode);
        }

        /*
            Encode the jump to the next case
         */
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            ecEncodeOpcode(cp, EJS_OP_COMPARE_STRICTLY_EQ);
            if (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
                ecEncodeByte(cp, caseItem->jumpLength);
            } else {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
                ecEncodeInt32(cp, caseItem->jumpLength);
            }
        }
        mprAssert(caseItem->code);
        copyCodeBuffer(cp, state->code, caseItem->code);

        /*
            Encode the jump to the next case's code. Last case/default block may have zero length jump.
         */
        if (caseItem->caseLabel.nextCaseCode > 0) {
            if (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                ecEncodeByte(cp, caseItem->caseLabel.nextCaseCode);
            } else {
                ecEncodeOpcode(cp, EJS_OP_GOTO);
                ecEncodeInt32(cp, caseItem->caseLabel.nextCaseCode);
            }
        }
    }
    popStack(cp, 1);

    totalLen = (int) mprGetBufLength(state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, totalLen);

    /*
        Pop the switch value
     */
    ecEncodeOpcode(cp, EJS_OP_POP);
    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Load the this pointer.
 */
static void genThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;

    switch (np->thisNode.thisKind) {
    case EC_THIS_GENERATOR:
        //  TODO
        break;

    case EC_THIS_CALLEE:
        //  TODO
        break;

    case EC_THIS_TYPE:
        genClassName(cp, state->currentClass);
        break;

    case EC_THIS_FUNCTION:
        genName(cp, state->currentFunctionNode);
        break;

    default:
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
  
 */
static void genThrow(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    cp->state->needsValue = 1;
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_THROW);
    popStack(cp, 1);
    LEAVE(cp);
}


/*
    Try, catch, finally.
 */
static void genTry(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *child, *arg;
    EcCodeGen       *saveCode;
    EcState         *state;
    EjsType         *catchType;
    uint            tryStart, tryEnd, handlerStart, handlerEnd;
    int             next, len, numStack;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    fun = state->currentFunction;
    mprAssert(fun);

    /*
        Switch to a new code buffer for the try block
     */
    numStack = getStackCount(cp);
    saveCode = state->code;
    mprAssert(saveCode);
    np->exception.tryBlock->code = state->code = allocCodeBuffer(cp);

    /*
        Process the try block. Will add a goto into either the finally block or if no finally block,
        to after the last catch.
     */
    processNode(cp, np->exception.tryBlock);

    if (np->exception.catchClauses) {
        /*
            If there is a finally block it must be invoked before acting on any break/continue and return statements 
         */
        next = 0;
        state->captureFinally = np->exception.finallyBlock ? 1 : 0;
        state->captureBreak = 1;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->code = state->code = allocCodeBuffer(cp);
            mprAssert(child->left);
            processNode(cp, child->left);
            if (np->exception.finallyBlock == 0) {
                ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
            }
            /* Add jumps below */
        }
        state->captureFinally = 0;
        state->captureBreak = 0;
    }

    if (np->exception.finallyBlock) {
        state->captureBreak = 1;
        np->exception.finallyBlock->code = state->code = allocCodeBuffer(cp);
        /* Finally pushes the original PC */
        pushStack(cp, 1);
        processNode(cp, np->exception.finallyBlock);
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
        popStack(cp, 1);
        state->captureBreak = 0;
    }

    /*
        Calculate jump lengths for the catch block into a finally block. Start from the last catch block and work backwards.
     */
    len = 0;
    if (np->exception.catchClauses) {
        next = -1;
        while ((child = getPrevNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->jumpLength = len;
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                /*
                    Add jumps if there is a finally block. Otherwise, we use and end_ecception instruction
                    Increment the length depending on whether we are using a goto_8 (2 bytes) or goto (4 bytes)
                 */
                len += (child->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            }
            len += getCodeLength(cp, child->code);
        }
    }

    /*
        Now copy the code. First the try block. Restore the primary code buffer and copy try/catch/finally
        code blocks into the code buffer.
     */
    setCodeBuffer(cp, saveCode);

    tryStart = ecGetCodeOffset(cp);

    /*
        Copy the try code and add a jump
     */
    copyCodeBuffer(cp, state->code, np->exception.tryBlock->code);

    if (np->exception.finallyBlock) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }
    if (len < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, len);
    }
    tryEnd = ecGetCodeOffset(cp);


    /*
        Now the copy the catch blocks and add jumps
     */
    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            handlerStart = ecGetCodeOffset(cp);
            copyCodeBuffer(cp, state->code, child->code);
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                if (child->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                    ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                    ecEncodeByte(cp, child->jumpLength);
                } else {
                    ecEncodeOpcode(cp, EJS_OP_GOTO);
                    ecEncodeInt32(cp, child->jumpLength);
                }
            }
            handlerEnd = ecGetCodeOffset(cp);

            /*
                Create exception handler record
             */
            catchType = 0;
            arg = 0;
            if (child->catchBlock.arg && child->catchBlock.arg->left) {
                arg = child->catchBlock.arg->left;
            }
            if (arg && arg->typeNode && ejsIsType(cp->ejs, arg->typeNode->lookup.ref)) {
                catchType = (EjsType*) arg->typeNode->lookup.ref;
            }
            if (catchType == 0) {
                catchType = ST(Void);
            }
            ecAddNameConstant(cp, catchType->qname);
            addException(cp, tryStart, tryEnd, catchType, handlerStart, handlerEnd, np->exception.numBlocks, numStack, 
                EJS_EX_CATCH);
        }
    }

    /*
        Finally, the finally block
     */
    if (np->exception.finallyBlock) {
        handlerStart = ecGetCodeOffset(cp);
        copyCodeBuffer(cp, state->code, np->exception.finallyBlock->code);
        handlerEnd = ecGetCodeOffset(cp);
        addException(cp, tryStart, tryEnd, ST(Void), handlerStart, handlerEnd, np->exception.numBlocks, numStack, 
            EJS_EX_FINALLY);
    }
    LEAVE(cp);
}


static void genUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_UNARY_OP);
    mprAssert(np->left);

    switch (np->tokenId) {
    case T_DELETE:
        genDelete(cp, np);
        break;

    case T_LOGICAL_NOT:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_LOGICAL_NOT);
        break;

    case T_PLUS:
        /* Just ignore the plus */
        processNode(cp, np->left);
        break;

    case T_PLUS_PLUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NEG);
        break;

    case T_MINUS_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, -1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_TILDE:
        /* Bitwise not */
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NOT);
        break;

    case T_TYPEOF:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_TYPE_OF);
        break;

    case T_VOID:
        /* Ignore the node and just push a void */
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        pushStack(cp, 1);
        break;
    }
    LEAVE(cp);
}


static void genNameExpr(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    
    ENTER(cp);
    
    state = cp->state;
    state->currentObjectNode = 0;
    state->onLeft = 0;
    
    if (np->name.qualifierExpr) {
        processNode(cp, np->name.qualifierExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->qname.space);
        pushStack(cp, 1);
    }
    if (np->name.nameExpr) {
        processNode(cp, np->name.nameExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->qname.name);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Generate code for an unbound name reference. We don't know the slot.
 */
static void genUnboundName(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsObj      *owner;
    EjsLookup   *lookup;
    int         code;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;

    mprAssert(!np->lookup.bind || !cp->bind);

    lookup = &np->lookup;
    owner = lookup->obj;
    
    if (state->currentObjectNode && np->needThis) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
    }
    if (np->name.qualifierExpr || np->name.nameExpr) {
        genNameExpr(cp, np);
        if (state->currentObjectNode) {
            code = (!cp->state->onLeft) ? EJS_OP_GET_OBJ_NAME_EXPR :  EJS_OP_PUT_OBJ_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 4 : 2);
        } else {
            code = (!cp->state->onLeft) ? EJS_OP_GET_SCOPED_NAME_EXPR :  EJS_OP_PUT_SCOPED_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 3 : 1);
        }
        ecEncodeOpcode(cp, code);
        LEAVE(cp);
        return;
    }
    if (state->currentObjectNode) {
        /*
            Property name (requires obj on stack)
            Store: -2, load: 0
         */
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

#if UNUSED
    } else if (owner == ejs->global) {
        /* Can't do early binding. Using Function.call/apply may change scope chain and invalidate the early-bound global */
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);
#endif

    } else if (lookup->useThis) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (owner && ejsIsType(ejs, owner)) {
        SAVE_ONLEFT(cp);
        genClassName(cp, (EjsType*) owner);
        RESTORE_ONLEFT(cp);

        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else {
        /*
            Unqualified name
         */
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_SCOPED_NAME :  EJS_OP_PUT_SCOPED_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -1, load: 1
         */
        pushStack(cp, (state->onLeft) ? -1 : 1);
    }
    LEAVE(cp);
}


static void genModule(EcCompiler *cp, EcNode *np)
{    
    ENTER(cp);

    mprAssert(np->kind == N_MODULE);

    addModule(cp, np->module.ref);
    genBlock(cp, np->left);
    LEAVE(cp);
}


static void genUseModule(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    Ejs         *ejs;
    int         next;

    ENTER(cp);

    ejs = cp->ejs;

    mprAssert(np->kind == N_USE_MODULE);

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


static void genUseNamespace(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_USE_NAMESPACE);

    /*
        Load the namespace reference. NOTE: use default space; will not add a namespace to the set of open spaces.
     */
    if (np->name.isLiteral) {
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
        ecEncodeConst(cp, np->qname.name);
    } else {
        genName(cp, np);
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE_REF);
        popStack(cp, 1);
    }
    LEAVE(cp);
}


static void genVar(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    mprAssert(np->kind == N_VAR);

    ENTER(cp);
    state = cp->state;

    ecAddNameConstant(cp, np->qname);
    if (np->lookup.trait && np->lookup.trait->type) {
        ecAddStringConstant(cp, np->lookup.trait->type->qname.name);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "var", np->lookup.obj, np->lookup.slotNum);
    }
    if (np->left) {
        processNode(cp, np->left);
    }
    LEAVE(cp);
}


static void genVarDefinition(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *var;
    int         next;

    mprAssert(np->kind == N_VAR_DEFINITION);

    ENTER(cp);
    state = cp->state;

    for (next = 0; (var = getNextNode(cp, np, &next)) != 0; ) {
        if (var->kind == N_VAR) {
            if (var->left) {
                /*
                    Class level variable initializations must go into the instance code buffer.
                 */
                if (var->name.instanceVar) {
                    state->instanceCode = 1;
                    mprAssert(state->instanceCodeBuf);
                    state->code = state->instanceCodeBuf;
                }
            }
            genVar(cp, var);
        } else {
            processNode(cp, var);
        }
    }
    LEAVE(cp);
}


static void genWith(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    processNode(cp, np->with.object);
    ecEncodeOpcode(cp, EJS_OP_OPEN_WITH);
    popStack(cp, 1);
    processNode(cp, np->with.statement);
    ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
    LEAVE(cp);
}


/*
    Create the module file.
 */

static MprFile *openModuleFile(EcCompiler *cp, cchar *filename)
{
    EcState     *state;

    mprAssert(cp);
    mprAssert(filename && *filename);

    state = cp->state;

    if (cp->noout) {
        return 0;
    }
    if ((cp->file = mprOpenFile(filename,  O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, 0664)) == 0) {
        genError(cp, 0, "Can't create %s", filename);
        return 0;
    }

    /*
        Create a module header once per file instead of per-module in the file
     */
    state->code = allocCodeBuffer(cp);
    if (ecCreateModuleHeader(cp) < 0) {
        genError(cp, 0, "Can't write module file header");
        return 0;
    }
    return cp->file;
}


static void manageCodeGen(EcCodeGen *code, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(code->buf);
        mprMark(code->jumps);
        mprMark(code->exceptions);
        if (code->debug) {
            mprAssert(code->debug->magic == EJS_DEBUG_MAGIC);
        }
        mprMark(code->debug);
    }
}


/*
    Create a new code buffer
 */
static EcCodeGen *allocCodeBuffer(EcCompiler *cp)
{
    EcState     *state;
    EcCodeGen   *code;

    mprAssert(cp);

    state = cp->state;
    mprAssert(state);

    if ((code = mprAllocObj(EcCodeGen, manageCodeGen)) == 0) {
        cp->fatalError = 1;
        return 0;
    }
    if ((code->buf = mprCreateBuf(EC_CODE_BUFSIZE, 0)) == 0) {
        mprAssert(0);
        cp->fatalError = 1;
        return 0;
    }
    if ((code->exceptions = mprCreateList(-1, 0)) == 0) {
        mprAssert(0);
        return 0;
    }
    /*
        Jumps are fully processed before the state is freed
     */
    code->jumps = mprCreateList(-1, 0);
    if (code->jumps == 0) {
        mprAssert(0);
        return 0;
    }

    /*
        Inherit the allowable jump kinds and stack level
     */
    if (state->code) {
        code->jumpKinds = state->code->jumpKinds;
        code->blockCount = state->code->blockCount;
        code->stackCount = state->code->stackCount;
        code->breakMark = state->code->breakMark;
        code->blockMark = state->code->blockMark;
    }
    return code;
}


static int getCodeLength(EcCompiler *cp, EcCodeGen *code)
{
    return (int) mprGetBufLength(code->buf);
}


static void copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *src)
{
    EjsEx           *exception;
    EjsDebug        *debug;
    EcJump          *jump;
    EcState         *state;
    uint            baseOffset;
    int             next, len, i;

    state = cp->state;
    mprAssert(state);
    mprAssert(dest != src);

    len = getCodeLength(cp, src);
    if (len <= 0) {
        return;
    }
    /*
        Copy the code
     */
    baseOffset = (int) mprGetBufLength(dest->buf);
    if (mprPutBlockToBuf(dest->buf, mprGetBufStart(src->buf), len) != len) {
        mprAssert(0);
        return;
    }
    /*
        Copy and fix the jump offset of jump patch records. jump->offset starts out being relative to the current code src.
        We add the original length of dest to make it absolute to the new dest buffer.
     */
    if (src->jumps) {
        if (src->jumps != dest->jumps) {
            next = 0;
            while ((jump = (EcJump*) mprGetNextItem(src->jumps, &next)) != 0) {
                jump->offset += baseOffset;
                mprAddItem(dest->jumps, jump);
            }
        }
    }

    /*
        Copy and fix exception target addresses
     */
    if (src->exceptions) {
        next = 0;
        while ((exception = (EjsEx*) mprGetNextItem(src->exceptions, &next)) != 0) {
            exception->tryStart += baseOffset;
            exception->tryEnd += baseOffset;
            exception->handlerStart += baseOffset;
            exception->handlerEnd += baseOffset;
            mprAddItem(dest->exceptions, exception);
        }
    }

    /*
        Copy and fix debug offsets
     */
    if (src->debug) {
        debug = src->debug;
        for (i = 0; i < debug->numLines; i++) {
            addDebugLine(cp, dest, baseOffset + debug->lines[i].offset, debug->lines[i].source);
        }
    }
}


/*
    Patch jump addresses a code buffer. Kind is the kind of jump (break | continue)
 */
static void patchJumps(EcCompiler *cp, int kind, int target)
{
    EcJump      *jump;
    EcCodeGen   *code;
    int         next, offset;

    code = cp->state->code;
    mprAssert(code);

rescan:
    next = 0;
    while ((jump = (EcJump*) mprGetNextItem(code->jumps, &next)) != 0) {
        if (jump->kind == kind) {
            offset = target - jump->offset - 4;
            mprAssert(-10000 < offset && offset < 10000);
            mprAssert(jump->offset < mprGetBufLength(code->buf));
            ecEncodeInt32AtPos(cp, jump->offset, offset);
            mprRemoveItem(code->jumps, jump);
            goto rescan;
        }
    }
}


/*
    Write the module contents
 */
static int flushModule(MprFile *file, EcCodeGen *code)
{
    int         len;

    len = (int) mprGetBufLength(code->buf);
    if (len > 0) {
        if (mprWriteFile(file, mprGetBufStart(code->buf), len) != len) {
            return EJS_ERR;
        }
        mprFlushBuf(code->buf);
    }
    return 0;
}


/*
    Create the module initializer
 */
static void createInitializer(EcCompiler *cp, EjsModule *mp)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcState         *state;
    EcCodeGen       *code;
    int             len;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    mprAssert(state);

    /*
        Note: if hasInitializer is false, we may still have some code in the buffer if --debug is used.
        We can safely just ignore this debug code.
     */
    if (!mp->hasInitializer) {
        LEAVE(cp);
        return;
    }
    mprAssert((int) mprGetBufLength(mp->code->buf) > 0);

    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    state->code = mp->code;
    cp->directiveState = state;
    code = cp->state->code;
    len = (int) mprGetBufLength(code->buf);
    mprAssert(len > 0);
    ecEncodeOpcode(cp, EJS_OP_END_CODE);

    /*
        Extract the initialization code
     */
    fun = state->currentFunction = mp->initializer;
    if (fun) {
        setFunctionCode(cp, fun, code);
    }
    LEAVE(cp);
}


static EcNode *getNextNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->error) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static EcNode *getPrevNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError || cp->error) {
        return 0;
    }
    return (EcNode*) mprGetPrevItem(np->children, next);
}


/*
    Map a lexical token to an op code
 */
static int mapToken(EcCompiler *cp, int tokenId)
{
    int     cond;

    cond = cp->state->conditional;

    switch (tokenId) {
    case T_BIT_AND:
        return EJS_OP_AND;

    case T_BIT_OR:
        return EJS_OP_OR;

    case T_BIT_XOR:
        return EJS_OP_XOR;

    case T_DIV:
        return EJS_OP_DIV;

    case T_EQ:
        return (cond) ? EJS_OP_BRANCH_EQ : EJS_OP_COMPARE_EQ;

    case T_NE:
        return (cond) ? EJS_OP_BRANCH_NE : EJS_OP_COMPARE_NE;

    case T_GT:
        return (cond) ? EJS_OP_BRANCH_GT : EJS_OP_COMPARE_GT;

    case T_GE:
        return (cond) ? EJS_OP_BRANCH_GE : EJS_OP_COMPARE_GE;

    case T_LT:
        return (cond) ? EJS_OP_BRANCH_LT : EJS_OP_COMPARE_LT;

    case T_LE:
        return (cond) ? EJS_OP_BRANCH_LE : EJS_OP_COMPARE_LE;

    case T_STRICT_EQ:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_EQ : EJS_OP_COMPARE_STRICTLY_EQ;

    case T_STRICT_NE:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_NE : EJS_OP_COMPARE_STRICTLY_NE;

    case T_LSH:
        return EJS_OP_SHL;

    case T_LOGICAL_NOT:
        return EJS_OP_NOT;

    case T_MINUS:
        return EJS_OP_SUB;

    case T_MOD:
        return EJS_OP_REM;

    case T_MUL:
        return EJS_OP_MUL;

    case T_PLUS:
        return EJS_OP_ADD;

    case T_RSH:
        return EJS_OP_SHR;

    case T_RSH_ZERO:
        return EJS_OP_USHR;

    case T_IS:
        return EJS_OP_IS_A;

    case T_INSTANCEOF:
        return EJS_OP_INST_OF;

    case T_CAST:
        return EJS_OP_CAST;

    case T_IN:
        return EJS_OP_IN;

    default:
        mprAssert(0);
        return -1;
    }
}


static void addDebugLine(EcCompiler *cp, EcCodeGen *code, int offset, MprChar *source)
{
    mprAssert(code->debug == 0 || code->debug->magic == EJS_DEBUG_MAGIC);
    if (ejsAddDebugLine(cp->ejs, &code->debug, offset, source) < 0) {
        genError(cp, 0, "Can't allocate memory for debug section");
        return;
    }
}


static void addDebug(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *code;
    MprChar     *source;
    int         offset;

    code = cp->state->code;
    if (!cp->debug || code == 0 || np->loc.lineNumber <= code->lastLineNumber) {
        return;
    }
    source = np->loc.source;
    if (source[0] == '}' && source[1] == 0) {
        return;
    }
    offset = (int) mprGetBufLength(code->buf);
    source = mfmt("%s|%d|%w", np->loc.filename, np->loc.lineNumber, np->loc.source);
    addDebugLine(cp, code, offset, source);
    code->lastLineNumber = np->loc.lineNumber;
}


static void processNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    mprAssert(np->parent || np->kind == N_PROGRAM || np->kind == N_MODULE);

    if (np->kind != N_FUNCTION) {
        addDebug(cp, np);
    }
    switch (np->kind) {
    case N_ARGS:
        state->needsValue = 1;
        genArgs(cp, np);
        break;

    case N_ASSIGN_OP:
        genAssignOp(cp, np);
        break;

    case N_BINARY_OP:
        genBinaryOp(cp, np);
        break;

    case N_BLOCK:
        genBlock(cp, np);
        break;

    case N_BREAK:
        genBreak(cp, np);
        break;

    case N_CALL:
        genCall(cp, np);
        break;

    case N_CLASS:
        genClass(cp, np);
        break;

    case N_CATCH_ARG:
        genCatchArg(cp, np);
        break;

    case N_CONTINUE:
        genContinue(cp, np);
        break;

    case N_DASSIGN:
        genDassign(cp, np);
        break;

    case N_DIRECTIVES:
        genDirectives(cp, np, 0);
        break;

    case N_DO:
        genDo(cp, np);
        break;

    case N_DOT:
        genDot(cp, np, 0);
        break;

    case N_END_FUNCTION:
        genEndFunction(cp, np);
        break;

    case N_EXPRESSIONS:
        genExpressions(cp, np);
        break;

    case N_FOR:
        genFor(cp, np);
        break;

    case N_FOR_IN:
        genForIn(cp, np);
        break;

    case N_FUNCTION:
        genFunction(cp, np);
        break;

    case N_HASH:
        genHash(cp, np);
        break;

    case N_IF:
        genIf(cp, np);
        break;

    case N_LITERAL:
        genLiteral(cp, np);
        break;

    case N_OBJECT_LITERAL:
        genObjectLiteral(cp, np);
        break;

    case N_FIELD:
        genField(cp, np);
        break;

    case N_QNAME:
        genName(cp, np);
        break;

    case N_NEW:
        genNew(cp, np);
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        genPostfixOp(cp, np);
        break;

    case N_PRAGMA:
        break;

    case N_PRAGMAS:
        genPragmas(cp, np);
        break;

    case N_PROGRAM:
        genProgram(cp, np);
        break;

    case N_REF:
        break;

    case N_RETURN:
        genReturn(cp, np);
        break;

    case N_SPREAD:
        genSpread(cp, np);
        break;

    case N_SUPER:
        genSuper(cp, np);
        break;

    case N_SWITCH:
        genSwitch(cp, np);
        break;

    case N_THIS:
        genThis(cp, np);
        break;

    case N_THROW:
        genThrow(cp, np);
        break;

    case N_TRY:
        genTry(cp, np);
        break;

    case N_UNARY_OP:
        genUnaryOp(cp, np);
        break;

    case N_USE_NAMESPACE:
        genUseNamespace(cp, np);
        break;

    case N_VAR:
        genVar(cp, np);
        break;

    case N_VAR_DEFINITION:
        genVarDefinition(cp, np);
        break;

    case N_MODULE:
        genModule(cp, np);
        break;

    case N_USE_MODULE:
        genUseModule(cp, np);
        break;

    case N_WITH:
        genWith(cp, np);
        break;

    default:
        mprAssert(0);
        badNode(cp, np);
    }
    mprAssert(state == cp->state);
    LEAVE(cp);
}


/*
    Oputput one module.
 */
static void processModule(EcCompiler *cp, EjsModule *mp)
{
    Ejs         *ejs;
    EcState     *state;
    EcCodeGen   *code;
    char        *path;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->currentModule = mp;

    createInitializer(cp, mp);

    if (cp->noout) {
        return;
    }
    if (! cp->outputFile) {
        if (mp->version) {
            path = mprAsprintf("%s-%d.%d.%d%s", mp->name, EJS_MAJOR(mp->version), EJS_MINOR(mp->version), 
                EJS_PATCH(mp->version), EJS_MODULE_EXT);
        } else {
            path = mprAsprintf("%@%s", mp->name, EJS_MODULE_EXT);
        }
        if ((mp->file = openModuleFile(cp, path)) == 0) {
            LEAVE(cp);
            return;
        }

    } else {
        mp->file = cp->file;
    }
    mprAssert(mp->code);
    mprAssert(mp->file);

    code = state->code;

    if (mp->hasInitializer) {
        //  MOB -- make these standard strings in native core
        ecAddCStringConstant(cp, EJS_INITIALIZER_NAME);
        ecAddCStringConstant(cp, EJS_EJS_NAMESPACE);
        if (mp->initializer->resultType) {
            ecAddNameConstant(cp, mp->initializer->resultType->qname);
        }
    }
    if (ecCreateModuleSection(cp) < 0) {
        genError(cp, 0, "Can't write module sections");
        LEAVE(cp);
        return;
    }
    if (flushModule(mp->file, code) < 0) {
        genError(cp, 0, "Can't write to module file %s", mp->name);
        LEAVE(cp);
        return;
    }
    if (! cp->outputFile) {
        mprCloseFile(mp->file);
        mp->file = 0;
        mp->code = 0;
    } else {
        mp->code = 0;
    }
    mp->file = 0;
}


/*
    Keep a list of modules potentially containing generated code and declarations.
 */
static void addModule(EcCompiler *cp, EjsModule *mp)
{
    EjsModule       *module;
    Ejs             *ejs;
    EcState         *state;
    int             next;

    mprAssert(cp);

    state = cp->state;
    ejs = cp->ejs;

    if (mp->code == 0 || cp->interactive) {
        mp->code = state->code = allocCodeBuffer(cp);
    }
    mp->loaded = 0;
    state->code = mp->code;
    mprAssert(mp->code);
    mprAssert(mp->code->buf);

    state->currentModule = mp;
    state->varBlock = ejs->global;
    state->letBlock = ejs->global;

    mprAssert(mp->initializer);
    state->currentFunction = mp->initializer;

    /*
        Merge means aggregate dependent input modules with the output
     */
    if (mp->dependencies && !cp->merge) {
        for (next = 0; (module = mprGetNextItem(mp->dependencies, &next)) != 0; ) {
            ecAddStringConstant(cp, module->name);
        }
    }
}


//  MOB -- cleanup
static int level = 8;

static void pushStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);

    mprAssert(code->stackCount >= 0);
    code->stackCount += count;
    mprAssert(code->stackCount >= 0);

    mprLog(level, "Stack %d, after push %d", code->stackCount, count);
}


static void popStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);
    mprAssert(code->stackCount >= 0);

    code->stackCount -= count;
    mprAssert(code->stackCount >= 0);

    mprLog(level, "Stack %d, after pop %d", code->stackCount, count);
}


static void setStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;
    mprAssert(code);
    code->stackCount = count;
}


static int getStackCount(EcCompiler *cp)
{
    return cp->state->code->stackCount;
}


static void discardStackItems(EcCompiler *cp, int preserve)
{
    EcCodeGen       *code;
    int             count;

    code = cp->state->code;

    mprAssert(code);
    count = code->stackCount - preserve;

    if (count <= 0) {
        return;
    }
    if (count == 1) {
        ecEncodeOpcode(cp, EJS_OP_POP);
    } else {
        ecEncodeOpcode(cp, EJS_OP_POP_ITEMS);
        ecEncodeByte(cp, count);
    }
    code->stackCount -= count;
    mprAssert(code->stackCount >= 0);
    mprLog(level, "Stack %d, after discard\n", code->stackCount);
}


static void discardBlockItems(EcCompiler *cp, int preserve)
{
    EcCodeGen       *code;
    int             count, i;

    code = cp->state->code;
    mprAssert(code);
    count = code->blockCount - preserve;

    for (i = 0; i < count; i++) {
        ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
    }
    code->blockCount -= count;
    mprAssert(code->blockCount >= 0);
    mprLog(level, "Block level %d, after discard\n", code->blockCount);
}


/*
    Set the default code buffer
 */
static void setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode)
{
    cp->state->code = saveCode;
    mprLog(level, "Stack %d, after restore code buffer\n", cp->state->code->stackCount);
}


static void addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, uint handlerEnd, 
    int numBlocks, int numStack, int flags)
{
    EcCodeGen       *code;
    EcState         *state;
    EjsEx           *exception;

    state = cp->state;
    mprAssert(state);

    code = state->code;
    mprAssert(code);

    if ((exception = mprAllocZeroed(sizeof(EjsEx))) == 0) {
        mprAssert(0);
        return;
    }
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;
    exception->flags = flags;
    mprAddItem(code->exceptions, exception);
}


static void addJump(EcCompiler *cp, EcNode *np, int kind)
{
    EcJump      *jump;

    ENTER(cp);

    jump = mprAllocZeroed(sizeof(EcJump));
    mprAssert(jump);

    jump->kind = kind;
    jump->node = np;
    jump->offset = ecGetCodeOffset(cp);

    mprAddItem(cp->state->code->jumps, jump);
    LEAVE(cp);
}


static void setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code)
{
    EjsEx       *ex;
    int         next, len;

    len = (int) mprGetBufLength(code->buf);
    mprAssert(len >= 0);
    if (len > 0) {
        ejsSetFunctionCode(cp->ejs, fun, cp->state->currentModule, (uchar*) mprGetBufStart(code->buf), len, code->debug);
    }
    /*
        Define any try/catch blocks encountered
     */
    next = 0;
    while ((ex = (EjsEx*) mprGetNextItem(code->exceptions, &next)) != 0) {
        ejsAddException(cp->ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, 
            ex->handlerEnd, ex->numBlocks, ex->numStack, ex->flags, -1);
    }
}


static void emitNamespace(EcCompiler *cp, EjsNamespace *nsp)
{
    ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
    ecEncodeConst(cp, nsp->value);
}


/*
    Aggregate the allowable kinds of jumps
 */
void ecStartBreakableStatement(EcCompiler *cp, int kinds)
{
    EcState     *state;

    mprAssert(cp);

    state = cp->state;
    state->code->jumpKinds |= kinds;
    state->breakState = state;
    state->code->breakMark = state->code->stackCount;
    state->code->blockMark = state->code->blockCount;
}

static void genError(EcCompiler *cp, EcNode *np, char *fmt, ...)
{
    va_list     args;
    EcLocation  *loc;

    va_start(args, fmt);

    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;
    if (np) {
        loc = &np->loc;
        ecError(cp, "Error", loc, fmt, args);
    } else {
        ecError(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
}


static void badNode(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError("Unsupported language feature\nUnknown AST node kind %d", np->kind);
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
 *  End of file "../../src/compiler/ecCodeGen.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecCompiler.c"
 */
/************************************************************************/

/**
    ecCompile.c - Interface to the compiler

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void compileError(EcCompiler *cp, cchar *fmt, ...);
static int compileInner(EcCompiler *cp, int argc, char **argv);
static EjsObj *loadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache);
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache);
static void manageCompiler(EcCompiler *cp, int flags);


EcCompiler *ecCreateCompiler(Ejs *ejs, int flags)
{
    EcCompiler      *cp;

    if ((cp = mprAllocObj(EcCompiler, manageCompiler)) == 0) {
        return 0;
    }
    cp->ejs = ejs;
    cp->strict = 0;
    cp->tabWidth = EC_TAB_WIDTH;
    cp->warnLevel = 1;
    cp->shbang = 1;
    cp->optimizeLevel = 9;
    cp->warnLevel = 1;

    if (flags & EC_FLAGS_DOC) {
        cp->doc = 1;
    }
    if (flags & EC_FLAGS_BIND) {
        cp->bind = 1;
    }
    if (flags & EC_FLAGS_DEBUG) {
        cp->debug = 1;
    }
    if (flags & EC_FLAGS_MERGE) {
        cp->merge = 1;
    }
    if (flags & EC_FLAGS_NO_OUT) {
        cp->noout = 1;
    }
    if (flags & EC_FLAGS_VISIBLE) {
        cp->visibleGlobals = 1;
    }
    if (ecResetModuleList(cp) < 0) {
        return 0;
    }
    ecInitLexer(cp);
    ecResetParser(cp);
    return cp;
}

        
//  MOB - remove
void ecDestroyCompiler(EcCompiler *cp)
{
}


static void manageCompiler(EcCompiler *cp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(cp->nodes);
        mprMark(cp->certFile);
        mprMark(cp->docToken);
        mprMark(cp->extraFiles);
        mprMark(cp->file);
        mprMark(cp->keywords);
        mprMark(cp->peekToken);
        mprMark(cp->putback);
        mprMark(cp->state);
        mprMark(cp->stream);
        mprMark(cp->token);
        mprMark(cp->outputFile);
        mprMark(cp->fixups);
        mprMark(cp->require);
        mprMark(cp->modules);
        mprMark(cp->errorMsg);
    }
}


int ecCompile(EcCompiler *cp, int argc, char **argv)
{
    Ejs     *ejs;
    int     rc, saveCompiling, frozen;

#if BLD_DEBUG
    MprThread   *tp;
    
    tp = mprGetCurrentThread();
#endif
    ejs = cp->ejs;
    saveCompiling = ejs->compiling;
    ejs->compiling = 1;
    
    //  MOB -- remove this. Should not be required.
    frozen = ejsFreeze(ejs, -1);

    rc = compileInner(cp, argc, argv);

    ejsFreeze(ejs, frozen);
    ejs->compiling = saveCompiling;
    return rc;
}


static int compileInner(EcCompiler *cp, int argc, char **argv)
{
    Ejs         *ejs;
    EjsModule   *mp;
    MprList     *nodes;
    EjsBlock    *block;
    EcLocation  loc;
    cchar       *ext;
    char        *msg;
    int         next, i, j, nextModule, lflags, rc, frozen;

    ejs = cp->ejs;
    if ((nodes = mprCreateList(-1, 0)) == 0) {
        return EJS_ERR;
    }
    cp->nodes = nodes;

    /*
        Warn about source files mentioned multiple times.
        TODO OPT. This is slow.
     */
    for (i = 0; i < argc; i++) {
        for (j = 0; j < argc; j++) {
            if (i == j) {
                continue;
            }
            if (mprSamePath(argv[i], argv[j])) {
                compileError(cp, "Loading source %s multiple times. Ignoring extra copies.", argv[i]);
                return EJS_ERR;
            }
        }
        if (cp->outputFile && mprSamePath(cp->outputFile, argv[i])) {
            compileError(cp, "Output file is the same as input file: %s", argv[i]);
            return EJS_ERR;
        }
    }

    /*
        Compile source files and load any module files
     */
    for (i = 0; i < argc && !cp->fatalError; i++) {
        ext = mprGetPathExtension(argv[i]);
        if (scasecmp(ext, "mod") == 0 || scasecmp(ext, BLD_SHOBJ) == 0) {
            nextModule = mprGetListLength(ejs->modules);
            lflags = cp->strict ? EJS_LOADER_STRICT : 0;
            if ((rc = ejsLoadModule(cp->ejs, ejsCreateStringFromAsc(ejs, argv[i]), -1, -1, lflags)) < 0) {
                msg = mprAsprintf("Error initializing module %s\n%s", argv[i], ejsGetErrorMsg(cp->ejs, 1));
                memset(&loc, 0, sizeof(EcLocation));
                loc.filename = sclone(argv[i]);
                if (rc == MPR_ERR_CANT_INITIALIZE) {
                    ecError(cp, "Error", &loc, msg);
                } else {
                    ecError(cp, "Error", &loc, msg);
                }
                cp->nodes = NULL;
                return EJS_ERR;
            }
            if (cp->merge) {
                /*
                    If merging, we must emit the loaded module into the output. So add to the compiled modules list.
                 */
                for (next = nextModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
                    if (mprLookupItem(cp->modules, mp) < 0 && mprAddItem(cp->modules, mp) < 0) {
                        compileError(cp, "Can't add module %s", mp->name);
                    }
                }
            }
            //  MOB -- does this really need to be added?
            mprAddItem(nodes, 0);
        } else  {
            mprAssert(!MPR->marking);
            //  MOB - move this deeper (gradually)
            frozen = ejsFreeze(ejs, 1);
            mprAddItem(nodes, ecParseFile(cp, argv[i]));
            ejsFreeze(ejs, frozen);
        }
        mprAssert(!MPR->marking);
    }
    mprAssert(ejs->result == 0 || (MPR_GET_GEN(MPR_GET_MEM(ejs->result)) != MPR->heap.dead));


    /*
        Allocate the eval frame stack. This is used for property lookups. We have one dummy block at the top always.
        MOB -- why ?
     */
    block = ejsCreateBlock(ejs, 0);
    mprSetName(block, "Compiler");
    ejsPushBlock(ejs, block);
    
    /*
        Process the internal representation and generate code
     */
    frozen = ejsFreeze(ejs, 1);
    if (!cp->parseOnly && cp->errorCount == 0) {
        ecResetParser(cp);
        if (ecAstProcess(cp) < 0) {
            ejsPopBlock(ejs);
            cp->nodes = NULL;
            return EJS_ERR;
        }
        if (cp->errorCount == 0) {
            ecResetParser(cp);
            if (ecCodeGen(cp) < 0) {
                ejsPopBlock(ejs);
                cp->nodes = NULL;
                return EJS_ERR;
            }
        }
    }
    ejsPopBlock(ejs);
    mprAssert(ejs->result == 0 || (MPR_GET_GEN(MPR_GET_MEM(ejs->result)) != MPR->heap.dead));

    /*
        Add compiled modules to the interpreter
     */
    for (next = 0; ((mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0); ) {
        ejsAddModule(cp->ejs, mp);
    }
    cp->nodes = NULL;
    ejsFreeze(ejs, frozen);
    if (!frozen) {
        mprYield(0);
    }
    mprAssert(ejs->result == 0 || (MPR_GET_GEN(MPR_GET_MEM(ejs->result)) != MPR->heap.dead));
    return (cp->errorCount > 0) ? EJS_ERR: 0;
}


//  MOB - remove this
int ejsInitCompiler(EjsService *service)
{
    service->loadScriptLiteral = loadScriptLiteral;
    service->loadScriptFile = loadScriptFile;
    return 0;
}


//  MOB -- remove these
/*
    Load a script file. This indirect routine is used by the core VM to compile a file when required.
 */
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache)
{
    MPR_VERIFY_MEM();
    if (ejsLoadScriptFile(ejs, path, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


//  MOB -- remove these
/*
    Function for ejs->loadScriptLiteral. This indirect routine is used by the core VM to compile a script when required.
 */
static EjsObj *loadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache)
{
    if (ejsLoadScriptLiteral(ejs, script, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


/*
    Load and initialize a script file
 */
int ejsLoadScriptFile(Ejs *ejs, cchar *path, cchar *cache, int flags)
{
    EcCompiler      *ec;

    if ((ec = ecCreateCompiler(ejs, flags)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ec);
    if (cache) {
        ec->noout = 0;
        ecSetOutputFile(ec, cache);
    } else {
        ec->noout = 1;
    }
    if (ecCompile(ec, 1, (char**) &path) < 0) {
        if (flags & EC_FLAGS_THROW) {
            ejsThrowSyntaxError(ejs, "%s", ec->errorMsg ? ec->errorMsg : "Can't parse script");
        }
        mprRemoveRoot(ec);
        ecDestroyCompiler(ec);
        return EJS_ERR;
    }
    mprRemoveRoot(ec);
    ecDestroyCompiler(ec);

    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Load and initialize a script literal
 */
int ejsLoadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache, int flags)
{
    EcCompiler      *cp;
    cchar           *path;

    if ((cp = ecCreateCompiler(ejs, flags)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(cp);
    if (cache) {
        cp->noout = 0;
        ecSetOutputFile(cp, cache);
    } else {
        cp->noout = 1;
    }
    //  UNICODE -- should this API be multi or unicode
    if (ecOpenMemoryStream(cp, ejsToMulti(ejs, script), script->length) < 0) {
        mprError("Can't open memory stream");
        mprRemoveRoot(cp);
        ecDestroyCompiler(cp);
        return EJS_ERR;
    }
    path = "__script__";
    if (ecCompile(cp, 1, (char**) &path) < 0) {
        if (flags & EC_FLAGS_THROW) {
            ejsThrowSyntaxError(ejs, "%s", cp->errorMsg ? cp->errorMsg : "Can't parse script");
        }
        mprRemoveRoot(cp);
        ecDestroyCompiler(cp);
        return EJS_ERR;
    }
    ecCloseStream(cp);
    mprRemoveRoot(cp);
    ecDestroyCompiler(cp);
    MPR_VERIFY_MEM();
    
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    One-line embedding. Evaluate a file. This will compile and interpret the given Ejscript source file.
 */
int ejsEvalFile(cchar *path)
{
    Ejs     *ejs;
    Mpr     *mpr;

    mpr = mprCreate(0, 0, 0);
    if ((ejs = ejsCreateVM(0, 0, 0, 0, 0, 0, 0)) == 0) {
        mprDestroy(0);
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ejs);
    if (ejsLoadScriptFile(ejs, path, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG) == 0) {
        ejsReportError(ejs, "Error in program");
        mprDestroy(0);
        return MPR_ERR;
    }
    mprDestroy(MPR_EXIT_DEFAULT);
    return 0;
}


/*
    One-line embedding. Evaluate a script. This will compile and interpret the given script.
 */
int ejsEvalScript(cchar *script)
{
    Ejs     *ejs;
    Mpr     *mpr;

    mpr = mprCreate(0, 0, 0);
    if ((ejs = ejsCreateVM(0, 0, 0, 0, 0, 0, 0)) == 0) {
        mprDestroy(0);
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ejs);
    if (ejsLoadScriptLiteral(ejs, ejsCreateStringFromAsc(ejs, script), NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG) == 0) {
        ejsReportError(ejs, "Error in program");
        mprDestroy(0);
        return MPR_ERR;
    }
    mprDestroy(MPR_EXIT_DEFAULT);
    return 0;
}


static void compileError(EcCompiler *cp, cchar *fmt, ...)
{
    va_list     args;


    cp->errorCount++;
    cp->error = 1;
    va_start(args, fmt);
    ecError(cp, "Error", NULL, fmt, args);
    va_end(args);
}


void ecError(EcCompiler *cp, cchar *severity, EcLocation *loc, cchar *fmt, ...)
{
    va_list     args;

    va_start(args, fmt);
    ecErrorv(cp, severity, loc, fmt, args);
    va_end(args);
}


/*
    Create a line of spaces with an "^" pointer at the current parse error.
 */
static char *makeHighlight(EcCompiler *cp, MprChar *source, int col)
{
    MprChar     *up, *sp;
    char        *dest, *dp;
    int         tabCount, len, i;

    tabCount = 0;

    for (up = source, len = 0; *up; up++) {
        if (*up == '\t') {
            tabCount++;
        }
        len++;
    }
    len = (int) len + (tabCount * cp->tabWidth);
    len = max(len, col);

    /*
        Allow for "^" to be after the last char, plus one null.
     */
    if ((dest = mprAlloc(len + 2)) == NULL) {
        mprAssert(dest);
        return 0;
    }
    for (i = 0, dp = dest, sp = source; *sp; sp++, i++) {
        if (*sp== '\t') {
            *dp++ = *sp;
        } else {
            *dp++ = ' ';
        }
    }
    /*
        Cover the case where the ^ must go after the end of the input
     */
    if (col >= 0) {
        dest[col] = '^';
        if (dp == &dest[col]) {
            ++dp;
        }
        *dp = '\0';
    }
    return dest;
}


void ecErrorv(EcCompiler *cp, cchar *severity, EcLocation *loc, cchar *fmt, va_list args)
{
    cchar   *appName;
    char    *pointer, *errorMsg, *msg;
    int     errCode;

    errCode = 0;
    appName = mprGetAppName(cp);
    msg = mprAsprintfv(fmt, args);

    if (loc) {
        if (loc->source) {
            pointer = makeHighlight(cp, loc->source, loc->column);
            errorMsg = mprAsprintf("%s: %s: %s: %d: %s\n  %w  \n  %s", appName, severity, loc->filename, 
                loc->lineNumber, msg, loc->source, pointer);
        } else if (loc->lineNumber >= 0) {
            errorMsg = mprAsprintf("%s: %s: %s: %d: %s", appName, severity, loc->filename, loc->lineNumber, msg);
        } else {
            errorMsg = mprAsprintf("%s: %s: %s: 0: %s", appName, severity, loc->filename, msg);
        }
    } else {
        errorMsg = mprAsprintf("%s: %s: %s", appName, severity, msg);
    }
    cp->errorMsg = srejoin(cp->errorMsg, errorMsg, NULL);
    mprBreakpoint();
}


void ecSetRequire(EcCompiler *cp, MprList *modules)
{
    cp->require = modules;
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecCompiler.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecLex.c"
 */
/************************************************************************/

/**
    ecLex.c - Lexical analyzer

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/*
    TODO - must preserve inter-token white space for XML literals
 */




typedef struct ReservedWord {
    void    *name;
    int     groupMask;
    int     tokenId;
    int     subId;
} ReservedWord;


/*
    Reserved keyword table
    The "true", "false", "null" and "undefined" are handled as global variables
 */
static ReservedWord keywords[] =
{
  { "break",            G_RESERVED,         T_BREAK,                    0, },
  { "case",             G_RESERVED,         T_CASE,                     0, },
  { "cast",             G_CONREV,           T_CAST,                     0, },
  { "catch",            G_RESERVED,         T_CATCH,                    0, },
  { "class",            G_RESERVED,         T_CLASS,                    0, },
  { "const",            G_CONREV,           T_CONST,                    0, },
  { "continue",         G_RESERVED,         T_CONTINUE,                 0, },
  { "default",          G_RESERVED,         T_DEFAULT,                  0, },
  { "delete",           G_RESERVED,         T_DELETE,                   0, },
  { "do",               G_RESERVED,         T_DO,                       0, },
  { "dynamic",          G_CONREV,           T_ATTRIBUTE,                T_DYNAMIC, },
  { "each",             G_CONREV,           T_EACH,                     0, },
  { "else",             G_RESERVED,         T_ELSE,                     0, },
  { "enumerable",       G_CONREV,           T_ATTRIBUTE,                T_ENUMERABLE, },
  { "extends",          G_RESERVED,         T_EXTENDS,                  0, },
  { "false",            G_RESERVED,         T_FALSE,                    0, },
  { "final",            G_CONREV,           T_ATTRIBUTE,                T_FINAL, },
  { "finally",          G_RESERVED,         T_FINALLY,                  0, },
  { "for",              G_RESERVED,         T_FOR,                      0, },
  { "function",         G_RESERVED,         T_FUNCTION,                 0, },
  { "get",              G_CONREV,           T_GET,                      0, },
  { "goto",             G_CONREV,           T_GOTO,                     0, },
  { "if",               G_RESERVED,         T_IF,                       0, },
  { "implements",       G_CONREV,           T_IMPLEMENTS,               0, },
  { "in",               G_RESERVED,         T_IN,                       0, },
  { "include",          G_CONREV,           T_INCLUDE,                  0, },
  { "instanceof",       G_RESERVED,         T_INSTANCEOF,               0, },
  { "interface",        G_CONREV,           T_INTERFACE,                0, },
  { "internal",         G_CONREV,           T_RESERVED_NAMESPACE,       T_INTERNAL, },
  { "intrinsic",        G_CONREV,           T_RESERVED_NAMESPACE,       T_INTRINSIC, },
  { "is",               G_CONREV,           T_IS,                       0, },
  { "let",              G_CONREV,           T_LET,                      0, },
  { "module",           G_CONREV,           T_MODULE,                   0, },
  { "namespace",        G_CONREV,           T_NAMESPACE,                0, },
  { "native",           G_CONREV,           T_ATTRIBUTE,                T_NATIVE, },
  { "new",              G_RESERVED,         T_NEW,                      0, },
  { "null",             G_RESERVED,         T_NULL,                     0, },
  { "override",         G_CONREV,           T_ATTRIBUTE,                T_OVERRIDE, },
  { "private",          G_CONREV,           T_RESERVED_NAMESPACE,       T_PRIVATE, },
  { "protected",        G_CONREV,           T_RESERVED_NAMESPACE,       T_PROTECTED, },
  { "public",           G_CONREV,           T_RESERVED_NAMESPACE,       T_PUBLIC, },
  { "require",          G_CONREV,           T_REQUIRE,                  0, },
  { "return",           G_RESERVED,         T_RETURN,                   0, },
  { "set",              G_CONREV,           T_SET,                      0, },
  { "standard",         G_CONREV,           T_STANDARD,                 0, },
  { "static",           G_CONREV,           T_ATTRIBUTE,                T_STATIC, },
  { "strict",           G_CONREV,           T_STRICT,                   0, },
  { "super",            G_RESERVED,         T_SUPER,                    0, },
  { "switch",           G_RESERVED,         T_SWITCH,                   0, },
  { "this",             G_RESERVED,         T_THIS,                     0, },
  { "throw",            G_RESERVED,         T_THROW,                    0, },
  { "to",               G_CONREV,           T_TO,                       0, },
  { "true",             G_RESERVED,         T_TRUE,                     0, },
  { "try",              G_RESERVED,         T_TRY,                      0, },
  { "typeof",           G_RESERVED,         T_TYPEOF,                   0, },
  { "var",              G_RESERVED,         T_VAR,                      0, },
  { "undefined",        G_CONREV,           T_UNDEFINED,                0, },
  { "use",              G_CONREV,           T_USE,                      0, },
  { "void",             G_RESERVED,         T_VOID,                     0, },
  { "while",            G_RESERVED,         T_WHILE,                    0, },
  { "with",             G_RESERVED,         T_WITH,                     0, },

#if UNUSED && KEEP
  /*
        Reserved but not implemented
   */
  { "abstract",         G_RESERVED,         T_ABSTRACT,                 0, },
  { "callee",           G_CONREV,           T_CALLEE,                   0, },
  { "enum",             G_RESERVED,         T_ENUM,                     T_ENUM, },
  { "generator",        G_CONREV,           T_GENERATOR,                0, },
  { "has",              G_CONREV,           T_HAS,                      0, },
  { "like",             G_CONREV,           T_LIKE,                     0, },
  { "readonly",         G_RESERVED,         T_ATTRIBUTE,                T_READONLY, },
  { "synchronized",     G_RESERVED,         T_ATTRIBUTE,                T_SYNCHRONIZED, },
  { "type",             G_CONREV,           T_TYPE,                     0, },
  { "volatile",         G_CONREV,           T_VOLATILE,                 0, },
  { "yield",            G_CONREV,           T_YIELD,                    0, },
#endif
  { 0,                  0,                  0, },
};


static int  addCharToToken(EcToken *tp, int c);
static int  addFormattedStringToToken(EcToken *tp, char *fmt, ...);
static int  addStringToToken(EcToken *tp, char *str);
static int  decodeNumber(EcCompiler *cp, int radix, int length);
static int  finalizeToken(EcToken *tp);
static int  initializeToken(EcToken *tp, EcStream *stream);
static int  setTokenID(EcToken *tp, int tokenId, int subId, int groupMask);
static int  makeNumberToken(EcCompiler *cp, EcToken *tp, int c);
static int  makeAlphaToken(EcCompiler *cp, EcToken *tp, int c);
static int  getComment(EcCompiler *cp, EcToken *tp, int c);
static int  getNextChar(EcStream *stream);
static int  makeQuotedToken(EcCompiler *cp, EcToken *tp, int c);
static int  makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask);
static int  makeToken(EcToken *tp, int c, int tokenId, int groupMask);
static void putBackChar(EcStream *stream, int c);


void ecInitLexer(EcCompiler *cp)
{
    ReservedWord    *rp;
    int             size;

    size = sizeof(keywords) / sizeof(ReservedWord);
    if ((cp->keywords = mprCreateHash(size, MPR_HASH_UNICODE | MPR_HASH_STATIC_KEYS | MPR_HASH_STATIC_VALUES)) == 0) {
        return;
    }
    for (rp = keywords; rp->name; rp++) {
#if BLD_CHAR_LEN > 1
        rp->name = amtow(cp->keywords, rp->name, NULL);
#endif
        mprAddKey(cp->keywords, rp->name, rp);
    }
}


static void manageToken(EcToken *tp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(tp->text);
        ecMarkLocation(&tp->loc);
    }
}


static EcToken *getLexToken(EcCompiler *cp)
{
    EcToken     *prev, *tp;

    if ((tp = cp->putback) != 0) {
        cp->putback = tp->next;
        prev = cp->token;
        cp->token = tp;
    } else {
        if ((cp->token = mprAllocObj(EcToken, manageToken)) == 0) {
            return 0;
        }
        initializeToken(cp->token, cp->stream);
    }
    return cp->token;
}


int ecGetToken(EcCompiler *cp)
{
    EcToken     *tp;
    EcStream    *stream;
    int         c;

    if ((tp = getLexToken(cp)) == NULL) {
        return T_ERR;
    }
    if (tp->tokenId) {
        return tp->tokenId;
    }
    stream = cp->stream;

    while (1) {
        c = getNextChar(stream);
        /*
            Overloadable operators
            + - ~ * / % < > <= >= == << >> >>> & | === != !==
            TODO FUTURE, we could allow also:  ".", "[", "(" and unary !, ^
         */
        switch (c) {
        default:
            if (isdigit(c)) {
                return makeNumberToken(cp, tp, c);

            } else if (c == '\\') {
                c = getNextChar(stream);
                if (c == '\n') {
                    break;
                }
                putBackChar(stream, c);
                c = '\n';
            }
            if (isalpha(c) || c == '_' || c == '\\' || c == '$') {
                return makeAlphaToken(cp, tp, c);
            }
            return makeToken(tp, 0, T_ERR, 0);

        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            }
            return makeToken(tp, 0, T_EOF, 0);

        case ' ':
        case '\f':
        case '\t':
        case '\v':
        case 0xA0:      /* No break space */
            break;

        case '\r':
        case '\n':
            break;

        case '"':
        case '\'':
            return makeQuotedToken(cp, tp, c);

        case '#':
            return makeToken(tp, c, T_HASH, 0);

        case '[':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LBRACKET, G_OPERATOR);

        case ']':
            return makeToken(tp, c, T_RBRACKET, 0);

        case '(':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LPAREN, G_OPERATOR);

        case ')':
            return makeToken(tp, c, T_RPAREN, 0);

        case '{':
            return makeToken(tp, c, T_LBRACE, 0);

        case '}':
            return makeToken(tp, c, T_RBRACE, 0);

        case '@':
            return makeToken(tp, c, T_AT, 0);

        case ';':
            return makeToken(tp, c, T_SEMICOLON, 0);

        case ',':
            return makeToken(tp, c, T_COMMA, 0);

        case '?':
            return makeToken(tp, c, T_QUERY, 0);

        case '~':
            return makeToken(tp, c, T_TILDE, G_OPERATOR);

        case '+':
            c = getNextChar(stream);
            if (c == '+') {
                addCharToToken(tp, '+');
                return makeToken(tp, c, T_PLUS_PLUS, G_OPERATOR);
            } else if (c == '=') {
                addCharToToken(tp, '+');
                return makeSubToken(tp, c, T_ASSIGN, T_PLUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '+', T_PLUS, G_OPERATOR);

        case '-':
            c = getNextChar(stream);
            if (isdigit(c)) {
                putBackChar(stream, c);
                return makeToken(tp, '-', T_MINUS, G_OPERATOR);

            } else if (c == '-') {
                addCharToToken(tp, '-');
                return makeToken(tp, c, T_MINUS_MINUS, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '-');
                return makeSubToken(tp, c, T_ASSIGN, T_MINUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '-', T_MINUS, G_OPERATOR);

        case '*':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '*');
                return makeSubToken(tp, c, T_ASSIGN, T_MUL_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '*', T_MUL, G_OPERATOR);

        case '/':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '/');
                return makeSubToken(tp, c, T_ASSIGN, T_DIV_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            } else if (c == '>') {
                addCharToToken(tp, '/');
                return makeToken(tp, c, T_SLASH_GT, G_OPERATOR);

            } else if (c == '*' || c == '/') {
                /*
                    C and C++ comments
                 */
                if (getComment(cp, tp, c) < 0) {
                    return tp->tokenId;
                }
                /*
                    Doc comments are: [slash]**. The second "*' becomes the first char of the comment.
                    Don't regard: [slash]*** (three stars) as a comment.
                 */
                if (cp->doc) {
                    if (tp->text && tp->text[0] == '*' && tp->text[1] != '*') {
                        cp->docToken = mprMemdup(tp->text, tp->length * sizeof(MprChar));;
                    }
                }
                initializeToken(tp, stream);
                break;
            }
            putBackChar(stream, c);
            return makeToken(tp, '/', T_DIV, G_OPERATOR);

        case '%':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '%');
                return makeSubToken(tp, c, T_ASSIGN, T_MOD_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '%', T_MOD, G_OPERATOR);

        case '.':
            c = getNextChar(stream);
            if (c == '.') {
                c = getNextChar(stream);
                if (c == '.') {
                    addStringToToken(tp, "..");
                    return makeToken(tp, c, T_ELIPSIS, 0);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '.');
                return makeToken(tp, '.', T_DOT_DOT, 0);
#if FUTURE
            } else if (c == '<') {
                addCharToToken(tp, '.');
                return makeToken(tp, c, T_DOT_LESS, 0);
#endif
            } else if (isdigit(c)) {
                putBackChar(stream, c);
                return makeNumberToken(cp, tp, '.');
            }
            putBackChar(stream, c);
            //  EJS extension to consider this an operator
            return makeToken(tp, '.', T_DOT, G_OPERATOR);

        case ':':
            c = getNextChar(stream);
            if (c == ':') {
                addCharToToken(tp, ':');
                return makeToken(tp, c, T_COLON_COLON, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, ':', T_COLON, 0);

        case '!':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "!=");
                    return makeToken(tp, c, T_STRICT_NE, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '!');
                return makeToken(tp, '=', T_NE, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '!', T_LOGICAL_NOT, G_OPERATOR);

        case '&':
            c = getNextChar(stream);
            if (c == '&') {
                addCharToToken(tp, '&');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '&');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '&', T_LOGICAL_AND, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '&');
                return makeSubToken(tp, c, T_ASSIGN, T_BIT_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '&', T_BIT_AND, G_OPERATOR);

        case '<':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LE, G_OPERATOR);
            } else if (c == '<') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "<<");
                    return makeSubToken(tp, c, T_ASSIGN, T_LSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LSH, G_OPERATOR);

            } else if (c == '/') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LT_SLASH, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, '<', T_LT, G_OPERATOR);

        case '=':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "==");
                    return makeToken(tp, c, T_STRICT_EQ, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '=');
                return makeToken(tp, c, T_EQ, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '=', T_ASSIGN, G_OPERATOR);

        case '>':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_GE, G_OPERATOR);
            } else if (c == '>') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, ">>");
                    return makeSubToken(tp, c, T_ASSIGN, T_RSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                } else if (c == '>') {
                    c = getNextChar(stream);
                    if (c == '=') {
                        addStringToToken(tp, ">>>");
                        return makeSubToken(tp, c, T_ASSIGN, T_RSH_ZERO_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                    }
                    putBackChar(stream, c);
                    addStringToToken(tp, ">>");
                    return makeToken(tp, '>', T_RSH_ZERO, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '>');
                return makeToken(tp, '>', T_RSH, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '>', T_GT, G_OPERATOR);

        case '^':
            c = getNextChar(stream);
            if (c == '^') {
                addCharToToken(tp, '^');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '^');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '^', T_LOGICAL_XOR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '^');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '^', T_BIT_XOR, G_OPERATOR);

        case '|':
            c = getNextChar(stream);
            if (c == '|') {
                addCharToToken(tp, '|');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '|');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '|', T_LOGICAL_OR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '|');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            }
            putBackChar(stream, c);
            return makeToken(tp, '|', T_BIT_OR, G_OPERATOR);
        }
    }
}


int ecGetRegExpToken(EcCompiler *cp, MprChar *prefix)
{
    EcToken     *token, *tp;
    EcStream    *stream;
    MprChar     *pp;
    int         c;

    stream = cp->stream;
    tp = token = cp->token;
    mprAssert(tp != 0);

    initializeToken(tp, stream);

    for (pp = prefix; pp && *pp; pp++) {
        addCharToToken(tp, *pp);
    }
    while (1) {
        c = getNextChar(stream);
        switch (c) {
        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            }
            return makeToken(tp, 0, T_EOF, 0);

        case '/':
            addCharToToken(tp, '/');
            while (1) {
                c = getNextChar(stream);
                if (c != 'g' && c != 'i' && c != 'm' && c != 'y' && c != 'x' && c != 'X' && c != 'U' && c != 's') {
                    putBackChar(stream, c);
                    break;
                }
                addCharToToken(tp, c);
            }
            return makeToken(tp, 0, T_REGEXP, 0);

        case '\\':
            c = getNextChar(stream);
            if (c == '\r' || c == '\n' || c == 0) {
                ecError(cp, "Warning", &stream->loc, "Illegal newline in regular expression");
                return makeToken(tp, 0, T_ERR, 0);
            }
            addCharToToken(tp, '\\');
            addCharToToken(tp, c);
            break;

        case '\r':
        case '\n':
            ecError(cp, "Warning", &stream->loc, "Illegal newline in regular expression");
            return makeToken(tp, 0, T_ERR, 0);

        default:
            addCharToToken(tp, c);
        }
    }
}


/*
    Put back the current lexer token
 */
int ecPutToken(EcCompiler *cp)
{
    ecPutSpecificToken(cp, cp->token);
    cp->token = 0;
    return 0;
}


/*
    Put the given (specific) token back on the input queue. The current input token is unaffected.
 */
int ecPutSpecificToken(EcCompiler *cp, EcToken *tp)
{
    mprAssert(tp);
    mprAssert(tp->tokenId > 0);

    tp->next = cp->putback;
    cp->putback = tp;
    return 0;
}


EcToken *ecTakeToken(EcCompiler *cp)
{
    EcToken *token;

    token = cp->token;
    cp->token = 0;
    return token;
}


/*
    Hex:        0(x|X)[DIGITS]
    Octal:      0[DIGITS]
    Float:      [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
 */
static int makeNumberToken(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;

    stream = cp->stream;
    if (c == '0') {
        c = getNextChar(stream);
        if (tolower(c) == 'x') {
            /* Hex */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while (isxdigit(c));
            putBackChar(stream, c);
            setTokenID(tp, T_NUMBER, -1, 0);
            return finalizeToken(tp);

        } else if ('0' <= c && c <= '7') {
            /* Octal */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while ('0' <= c && c <= '7');
            putBackChar(stream, c);
            setTokenID(tp, T_NUMBER, -1, 0);
            return finalizeToken(tp);

        } else {
            putBackChar(stream, c);
            c = '0';
        }
    }

    /*
        Float
     */
    while (isdigit(c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c == '.') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    while (isdigit(c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (tolower(c) == 'e') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
        if (c == '+' || c == '-') {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
        while (isdigit(c)) {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
    }
    putBackChar(stream, c);
    setTokenID(tp, T_NUMBER, -1, 0);
    return finalizeToken(tp);
}


static int makeAlphaToken(EcCompiler *cp, EcToken *tp, int c)
{
    ReservedWord    *rp;
    EcStream        *stream;

    /*
        We know that c is an alpha already
     */
    stream = cp->stream;

    while (isalnum(c) || c == '_' || c == '$' || c == '\\') {
        if (c == '\\') {
            c = getNextChar(stream);
            if (c == '\n' || c == '\r') {
                break;
            } else if (c == 'u') {
                c = decodeNumber(cp, 16, 4);
                //  TODO - for now, mask back to 8 bits.
                c = c & 0xff;
            }
        }
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c) {
        putBackChar(stream, c);
    }
    rp = (ReservedWord*) mprLookupHash(cp->keywords, tp->text);
    if (rp) {
        setTokenID(tp, rp->tokenId, rp->subId, rp->groupMask);
    } else {
        setTokenID(tp, T_ID, -1, 0);
    }
    return finalizeToken(tp);
}


static int makeQuotedToken(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;
    int         quoteType;

    stream = cp->stream;
    quoteType = c;

    for (c = getNextChar(stream); c && c != quoteType; c = getNextChar(stream)) {
        if (c == 0) {
            return makeToken(tp, 0, T_ERR, 0);
        }
        if (c == '\\') {
            c = getNextChar(stream);
            switch (c) {
            //  TBD -- others
            case '\\':
                break;
            case '\'':
            case '\"':
                break;
            case 'b':
                c = '\b';
                break;
            case 'f':
                c = '\f';
                break;
            case 'n':
                c = '\n';
                break;
            case 'r':
                c = '\r';
                break;
            case 't':
                c = '\t';
                break;
            case 'u':
                c = decodeNumber(cp, 16, 4);
                break;
            case 'x':
                c = decodeNumber(cp, 16, 2);
                break;
            case 'v':
                c = '\v';
                break;
            case '0':
                c = decodeNumber(cp, 8, 3);
                break;
            default:
                break;
            }
        }
        addCharToToken(tp, c);
    }
    mprAssert(tp->text);
    setTokenID(tp, T_STRING, -1, 0);
    return finalizeToken(tp);
}


static int makeToken(EcToken *tp, int c, int tokenId, int groupMask)
{
    if (c && addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    setTokenID(tp, tokenId, -1, groupMask);
    return finalizeToken(tp);
}


static int makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask)
{
    if (addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    setTokenID(tp, tokenId, subId, groupMask);
    return finalizeToken(tp);
}


//  MOB - should this return int64
//  MOB -- should be same arg format as stoi
static int decodeNumber(EcCompiler *cp, int radix, int length)
{
    char        buf[16];
    int         i, c, lowerc;

    for (i = 0; i < length; i++) {
        c = getNextChar(cp->stream);
        if (c == 0) {
            break;
        }
        if (radix <= 10) {
            if (!isdigit(c)) {
                break;
            }
        } else if (radix == 16) {
            lowerc = tolower(c);
            if (!isdigit(lowerc) && !('a' <= lowerc && lowerc <= 'f')) {
                break;
            }
        }
        buf[i] = c;
    }
    if (i < length) {
        putBackChar(cp->stream, c);
    }
    buf[i] = '\0';
    return (int) stoi(buf, radix, NULL);
}


/*
    C, C++ and doc style comments. Return token or zero for no token.
 */
static int getComment(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;
    int         form, startLine;

    startLine = cp->stream->loc.lineNumber;
    stream = cp->stream;
    form = c;

    for (form = c; c > 0;) {
        c = getNextChar(stream);
        if (c <= 0) {
            /*
                Unterminated Comment
             */
            addFormattedStringToToken(tp, "Unterminated comment starting on line %d", startLine);
            makeToken(tp, 0, form == '/' ? T_EOF: T_ERR, 0);
            return 1;
        }
        if (form == '/') {
            if (c == '\n' || c == '\r') {
                break;
            }
        } else {
            if (c == '*') {
                c = getNextChar(stream);
                if (c == '/') {
                    break;
                }
                addCharToToken(tp, '*');
                putBackChar(stream, c);

            } else if (c == '/') {
                c = getNextChar(stream);
                if (c == '*') {
                    /*
                        Nested comment
                     */
                    if (cp->warnLevel > 0) {
                        ecError(cp, "Warning", &stream->loc, "Possible nested comment");
                    }
                }
                addCharToToken(tp, '/');
            }
        }
        addCharToToken(tp, c);
    }
    return 0;
}


static int initializeToken(EcToken *tp, EcStream *stream)
{
    tp->stream = stream;
    tp->loc = tp->stream->loc;
    tp->length = 0;
    tp->loc.lineNumber = 0;
    tp->tokenId = 0;
    if (tp->text == 0) {
        tp->size = EC_TOKEN_INCR;
        if ((tp->text = mprAlloc(tp->size * sizeof(MprChar))) == 0) {
            return MPR_ERR_MEMORY;
        }
        tp->text[0] = '\0';
    }
    return 0;
}


static int finalizeToken(EcToken *tp)
{
    if (tp->loc.lineNumber == 0) {
        tp->loc = tp->stream->loc;
    }
    return tp->tokenId;
}


static int addCharToToken(EcToken *tp, int c)
{
    if (tp->length >= (tp->size - 1)) {
        tp->size += EC_TOKEN_INCR;
        if ((tp->text = mprRealloc(tp->text, tp->size * sizeof(MprChar))) == 0) {
            return MPR_ERR_MEMORY;
        }
    }
    tp->text[tp->length++] = c;
    tp->text[tp->length] = '\0';
    if (tp->loc.lineNumber == 0) {
        tp->loc = tp->stream->loc;
    }
    return 0;
}


static int addStringToToken(EcToken *tp, char *str)
{
    char    *cp;

    for (cp = str; *cp; cp++) {
        if (addCharToToken(tp, *cp) < 0) {
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


static int addFormattedStringToToken(EcToken *tp, char *fmt, ...)
{
    va_list     args;
    char        *buf;

    va_start(args, fmt);
    buf = mprAsprintfv(fmt, args);
    addStringToToken(tp, buf);
    va_end(args);
    return 0;
}


static int setTokenID(EcToken *tp, int tokenId, int subId, int groupMask)
{
    mprAssert(tp);

    tp->tokenId = tokenId;
    tp->subId = subId;
    tp->groupMask = groupMask;
    return tokenId;
}


static int getNextChar(EcStream *stream)
{
    MprChar     c, *next, *start;

    if (stream->nextChar >= stream->end && stream->getInput) {
        if (stream->getInput(stream) < 0) {
            return 0;
        }
    }
    if (stream->nextChar < stream->end) {
        c = *stream->nextChar++;
        if (c == '\n') {
            stream->lastLoc = stream->loc;
            stream->loc.lineNumber++;
            stream->loc.column = 0;
            stream->loc.source = 0;
        } else {
            stream->loc.column++;
        }
        if (stream->loc.source == 0) {
            //  MOB -- replace this when doing lazy loading. source should be an index into a buffer.
            for (start = stream->nextChar - 1; isspace((int) *start); start++) ;
            for (next = start; *next && *next != '\n'; next++) ;
            stream->loc.source = wsub(start, 0, next - start);
        }
        return c;
    }
    return 0;
}


static void putBackChar(EcStream *stream, int c)
{
    if (stream->buf < stream->nextChar && c) {
        stream->nextChar--;
        mprAssert(c == (uchar) *stream->nextChar);
        if (c == '\n') {
            stream->loc = stream->lastLoc;
            stream->loc.column = 0;
        } else {
            stream->loc.column--;
        }
        mprAssert(stream->loc.column >= 0);
    }
}


void ecManageStream(EcStream *sp, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ecMarkLocation(&sp->loc);
        ecMarkLocation(&sp->lastLoc);
        mprMark(sp->buf);
    }
}


void *ecCreateStream(EcCompiler *cp, ssize size, cchar *path, void *manager)
{
    EcLocation  *loc;
    EcStream    *sp;

    if ((sp = mprAllocBlock(size, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(sp, manager);
    sp->compiler = cp;
    cp->stream = sp;
    loc = &sp->loc;
    loc->column = 0;
    loc->source = 0;
    loc->lineNumber = 1;
    loc->filename = sclone(path);
    cp->putback = NULL;
    return sp;
}


void ecSetStreamBuf(EcStream *sp, cchar *contents, ssize len)
{
    MprChar     *buf;

    if (contents) {
#if BLD_CHAR_LEN > 1
        buf = amtow(cp, contents, &len);
#else
        buf = (MprChar*) contents;
        if (len <= 0) {
            len = strlen(buf);
        }
#endif
        sp->buf = buf;
        sp->nextChar = buf;
        sp->end = &buf[len];

        //  MOB -- should flush old token
        putBackChar(sp, getNextChar(sp));
    }
}


void manageFileStream(EcFileStream *fs, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ecManageStream((EcStream*) fs, flags);
        mprMark(fs->file);

    } else if (flags & MPR_MANAGE_FREE) {
        mprCloseFile(fs->file);
    }
}


int ecOpenFileStream(EcCompiler *cp, cchar *path)
{
    EcFileStream    *fs;
    MprPath         info;
    char            *contents;

    if ((fs = ecCreateStream(cp, sizeof(EcFileStream), path, manageFileStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    if ((fs->file = mprOpenFile(path, O_RDONLY | O_BINARY, 0666)) == 0) {
        return MPR_ERR_CANT_OPEN;
    }
    if (mprGetPathInfo(path, &info) < 0 || info.size < 0) {
        mprCloseFile(fs->file);
        return MPR_ERR_CANT_ACCESS;
    }
    if ((contents = mprAlloc((int) info.size + 1)) == 0) {
        mprCloseFile(fs->file);
        return MPR_ERR_MEMORY;
    }
    if (mprReadFile(fs->file, contents, (int) info.size) != (int) info.size) {
        mprCloseFile(fs->file);
        return MPR_ERR_CANT_READ;
    }
    contents[info.size] = '\0';
    ecSetStreamBuf((EcStream*) fs, contents, (ssize) info.size);
    return 0;
}


int ecOpenMemoryStream(EcCompiler *cp, cchar *contents, ssize len)
{
    EcMemStream     *ms;

    if ((ms = ecCreateStream(cp, sizeof(EcMemStream), "memory", ecManageStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    ecSetStreamBuf((EcStream*) ms, contents, len);
    return 0;
}


int ecOpenConsoleStream(EcCompiler *cp, EcStreamGet getInput, cchar *contents)
{
    EcConsoleStream     *cs;

    if ((cs = ecCreateStream(cp, sizeof(EcConsoleStream), "console", ecManageStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    cs->stream.getInput = getInput;
    ecSetStreamBuf((EcStream*) cs, sclone(contents), contents ? strlen(contents) : 0);
    return 0;
}


void ecCloseStream(EcCompiler *cp)
{
    cp->stream = 0;
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecLex.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecModuleWrite.c"
 */
/************************************************************************/

/**
    ejsModuleWrite.c - Routines to encode and emit Ejscript byte code.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void createBlockSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsBlock *vp);
static void createClassSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsPot *klass);
static void createDebugSection(EcCompiler *cp, EjsFunction *fun);
static void createDependencySection(EcCompiler *cp);
static void createDocSection(EcCompiler *cp, cchar *tag, EjsPot *block, int slotNum);
static void createExceptionSection(EcCompiler *cp, EjsFunction *mp);
static void createFunctionSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsFunction *fun, int isSetter);
static void createGlobalProperties(EcCompiler *cp);
static void createGlobalType(EcCompiler *cp, EjsType *klass);
static void createPropertySection(EcCompiler *cp, EjsPot *block, int slotNum, EjsObj *vp);
static void createSection(EcCompiler *cp, EjsPot *block, int slotNum);
static int reserveRoom(EcCompiler *cp, int room);

static int sumNum(int value);
static int sumString(EjsString *name);

/*
    Write out the module file header
 */
int ecCreateModuleHeader(EcCompiler *cp)
{
    EjsModuleHdr    hdr;

    memset(&hdr, 0, sizeof(hdr));
    hdr.magic = ejsSwapInt32(cp->ejs, EJS_MODULE_MAGIC);
    hdr.fileVersion = ejsSwapInt32(cp->ejs, EJS_MODULE_VERSION);
    ecEncodeBlock(cp, (uchar*) &hdr, sizeof(hdr));
    return (cp->fatalError) ? EJS_ERR : 0;
}


/*
    Create a module section. This writes all classes, functions, variables and blocks contained by the module.
 */
int ecCreateModuleSection(EcCompiler *cp)
{
    Ejs             *ejs;
    EjsConstants    *constants;
    EjsModule       *mp;
    EcState         *state;
    MprBuf          *buf;
    int             checksumOffset;

    state = cp->state;
    buf = state->code->buf;
    mp = state->currentModule;

    mprLog(7, "Create module section %s", mp->name);

    ejs = cp->ejs;
    constants = mp->constants;

    ecEncodeByte(cp, EJS_SECT_MODULE);
    ecEncodeConst(cp, mp->name);
    ecEncodeNum(cp, mp->version);

    /*
        Remember this location for the module checksum. Reserve 4 bytes.
     */
    checksumOffset = (int) (mprGetBufEnd(buf) - buf->data);
    ecEncodeInt32(cp, 0);

    /*
        Write the constant pool and lock it against further updates.
     */
    mp->constants->locked = 1;
    ecEncodeNum(cp, constants->poolLength);
    ecEncodeNum(cp, constants->indexCount);
    ecEncodeBlock(cp, (uchar*) constants->pool, (int) constants->poolLength);

    createDependencySection(cp);
    if (mp->hasInitializer) {
        createFunctionSection(cp, NULL, -1, mp->initializer, 0);
    }
    createGlobalProperties(cp);
    ecEncodeByte(cp, EJS_SECT_MODULE_END);

    if (cp->fatalError) {
        return MPR_ERR_CANT_WRITE;
    }
    mp->checksum += (sumString(mp->name) & EJS_ENCODE_MAX_WORD);
    ecEncodeInt32AtPos(cp, checksumOffset, mp->checksum);
    return 0;
}


static void createDependencySection(EcCompiler *cp)
{
    Ejs         *ejs;
    EjsModule   *module, *mp;
    int         i, count, version;

    mp = cp->state->currentModule;
    mprAssert(mp);

    ejs = cp->ejs;

    /*
        If merging, don't need references to dependent modules as they are aggregated onto the output
     */
    if (mp->dependencies && !cp->merge) {
        count = mprGetListLength(mp->dependencies);
        for (i = 0; i < count; i++) {
            module = (EjsModule*) mprGetItem(mp->dependencies, i);

            if (module->compiling && cp->outputFile) {
                continue;
            }
            if (mp->name == module->name) {
                /* A module can't depend on itself */
                continue;
            }
            ecEncodeByte(cp, EJS_SECT_DEPENDENCY);
            ecEncodeConst(cp, module->name);
            ecEncodeNum(cp, module->checksum);

            if (!cp->bind) {
                ecEncodeNum(cp, module->minVersion);
                ecEncodeNum(cp, module->maxVersion);
            } else {
                version = EJS_MAKE_COMPAT_VERSION(module->version);
                ecEncodeNum(cp, version);
                ecEncodeNum(cp, version);
            }
            if (cp->fatalError) {
                return;
            }
            mp->checksum += sumString(module->name);
            mprLog(7, "    dependency section for %s from module %s", module->name, mp->name);
        }
    }
}


/*
    Emit all global classes, functions, variables and blocks.
 */
static void createGlobalProperties(EcCompiler *cp)
{
    Ejs             *ejs;
    EjsName         *prop;
    EjsModule       *mp;
    EjsObj          *vp;
    int             next, slotNum;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (mp->globalProperties == 0) {
        return;
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, *prop);
        if (slotNum < 0) {
            cp->fatalError = 1;
            mprError("Code generation error. Can't find global property %s.", prop->name);
            return;
        }
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        if (VISITED(vp)) {
            continue;
        }
        if (ejsIsType(ejs, vp)) {
            createGlobalType(cp, (EjsType*) vp);
        } else {
            createSection(cp, ejs->global, slotNum);
        }
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, *prop);
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        SET_VISITED(vp, 0);
    }
}


/*
    Recursively emit a class and its base classes
 */
static void createGlobalType(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *iface;
    int             next, slotNum;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (VISITED(type) || type->module != mp) {
        return;
    }
    SET_VISITED(type, 1);

    if (type->baseType && !VISITED(type->baseType)) {
        createGlobalType(cp, type->baseType);
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            createGlobalType(cp, iface);
        }
    }
    slotNum = ejsLookupProperty(ejs, ejs->global, type->qname);
    mprAssert(slotNum >= 0);

    createSection(cp, ejs->global, slotNum);
}


static void createSection(EcCompiler *cp, EjsPot *block, int slotNum)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;

    ejs = cp->ejs;
    vp = ejsGetProperty(ejs, block, slotNum);
    qname = ejsGetPropertyName(ejs, block, slotNum);
    trait = ejsGetPropertyTraits(ejs, block, slotNum);

    /*
        hoistBlockVar will delete hoisted properties but will not (yet) compact to reclaim the slot.
     */
    if (slotNum < 0 || trait == 0 || vp == 0 || qname.name->value[0] == '\0') {
        return;
    }
    mprAssert(qname.name);

    if (ejsIsType(ejs, vp)) {
        createClassSection(cp, block, slotNum, (EjsPot*) vp);

    } else if (ejsIsFunction(ejs, vp)) {
        fun = (EjsFunction*) vp;
        createFunctionSection(cp, block, slotNum, fun, 0);
        if (trait->attributes & EJS_TRAIT_SETTER) {
            mprAssert(fun->setter);
            createFunctionSection(cp, block, slotNum, fun->setter, 1);
        }

    } else if (ejsIsBlock(ejs, vp)) {
        createBlockSection(cp, block, slotNum, (EjsBlock*) vp);

    } else {
        createPropertySection(cp, block, slotNum, vp);
    }
}


/*
    Create a type section in the module file.
 */
static void createClassSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsPot *klass)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *type, *iface;
    EjsPot          *prototype;
    EjsTrait        *trait;
    EjsName         qname, pname;
    int             next, attributes, interfaceCount, instanceTraits, count;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    createDocSection(cp, "class", ejs->global, slotNum);
    qname = ejsGetPropertyName(ejs, ejs->global, slotNum);
    mprAssert(qname.name);

    mprLog(7, "    type section %@ for module %@", qname.name, mp->name);
    
    type = ejsGetProperty(ejs, ejs->global, slotNum);
    mprAssert(type);
    mprAssert(ejsIsType(ejs, type));

    ecEncodeByte(cp, EJS_SECT_CLASS);
    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);

    trait = ejsGetPropertyTraits(ejs, ejs->global, slotNum);
    attributes = (trait) ? trait->attributes : 0;
    attributes &= ~EJS_TYPE_FIXUP;

    if (type->hasConstructor) {
        attributes |= EJS_TYPE_HAS_CONSTRUCTOR;
    }
    if (type->hasInitializer) {
        attributes |= EJS_TYPE_HAS_TYPE_INITIALIZER;
    }
    if (type->hasInstanceVars) {
        attributes |= EJS_TYPE_HAS_INSTANCE_VARS;
    }
    if (type->callsSuper) {
        attributes |= EJS_TYPE_CALLS_SUPER;
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            if (!iface->isInterface) {
                attributes |= EJS_TYPE_FIXUP;
                break;
            }
        }
    }
    ecEncodeNum(cp, attributes);
    ecEncodeNum(cp, (cp->bind) ? slotNum : -1);

    mprAssert(type != type->baseType);
    //  MOB -- refactor
    if (type->baseType) {
        ecEncodeGlobal(cp, (EjsObj*) type->baseType, type->baseType->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }
    ecEncodeNum(cp, ejsGetPropertyCount(ejs, (EjsObj*) type));

    instanceTraits = ejsGetPropertyCount(ejs, (EjsObj*) type->prototype);
    mprAssert(instanceTraits >= 0);
    ecEncodeNum(cp, instanceTraits);
    
    interfaceCount = (type->implements) ? mprGetListLength(type->implements) : 00;
    mprAssert(interfaceCount >= 0);
    ecEncodeNum(cp, interfaceCount);

    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            ecEncodeGlobal(cp, (EjsObj*) iface, iface->qname);
        }
    }
    if (cp->fatalError) {
        return;
    }    
    if (type->hasConstructor) {
        mprAssert(type->constructor.isConstructor);
        mprAssert(type->constructor.block.pot.isFunction);
        createFunctionSection(cp, block, slotNum, (EjsFunction*) type, 0);
    }
    /*
        Loop over type traits
     */
    count = ejsGetPropertyCount(ejs, type); 
    for (slotNum = 0; slotNum < count; slotNum++) {
        createSection(cp, (EjsPot*) type, slotNum);
    }
    /*
        Loop over prototype (instance) properties.
     */
    prototype = type->prototype;
    if (prototype) {
        count = ejsGetPropertyCount(ejs, prototype);
        for (slotNum = 0; slotNum < count; slotNum++) {
            pname = ejsGetPropertyName(ejs, prototype, slotNum);
            trait = ejsGetPropertyTraits(ejs, prototype, slotNum);
            if (slotNum < type->numInherited) {
                if (trait && !(trait->attributes & EJS_FUN_OVERRIDE)) {
                    continue;
                }
            }
            createSection(cp, prototype, slotNum);
        }
    }
    mp->checksum += sumNum(ejsGetPropertyCount(ejs, type) + instanceTraits + interfaceCount);
    mp->checksum += sumString(type->qname.name);
    ecEncodeByte(cp, EJS_SECT_CLASS_END);
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static void createFunctionSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsFunction *fun, int isSetter)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsTrait        *trait;
    EjsName         qname;
    EjsCode         *code;
    EjsType         *resultType;
    EjsPot          *activation;
    int             i, attributes, numProp;

    mprAssert(fun);

    mp = cp->state->currentModule;
    ejs = cp->ejs;
    activation = fun->activation;
    numProp = (activation) ? activation->numProp: 0;
    code = fun->body.code;
    
    if (block && slotNum >= 0) {
        qname = ejsGetPropertyName(ejs, block, slotNum);
        createDocSection(cp, "fun", block, slotNum);
        trait = ejsGetPropertyTraits(ejs, block, slotNum);
        attributes = trait->attributes;
        if (fun->isInitializer) {
            attributes |= EJS_FUN_INITIALIZER;
        }
        if (fun->moduleInitializer) {
            attributes |= EJS_FUN_MODULE_INITIALIZER;
        }
        if (trait->attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
            if (isSetter) {
                attributes &= ~EJS_TRAIT_GETTER;
            } else {
                attributes &= ~EJS_TRAIT_SETTER;
            }
        }
    } else {
        attributes = EJS_FUN_MODULE_INITIALIZER;
        qname = N(EJS_EJS_NAMESPACE, EJS_INITIALIZER_NAME);
    }
    if (fun->isConstructor) {
        mprAssert(fun->block.pot.isFunction);
        attributes |= EJS_FUN_CONSTRUCTOR;
    }
    if (fun->rest) {
        attributes |= EJS_FUN_REST_ARGS;
    }
    if (fun->fullScope) {
        attributes |= EJS_FUN_FULL_SCOPE;
    }
    if (fun->hasReturn) {
        attributes |= EJS_FUN_HAS_RETURN;
    }
    resultType = fun->resultType;

    ecEncodeByte(cp, EJS_SECT_FUNCTION);
    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);
    ecEncodeNum(cp, attributes);
    ecEncodeByte(cp, fun->strict);
    if (resultType) {
        ecEncodeGlobal(cp, resultType, resultType->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum: -1);
    ecEncodeNum(cp, numProp);
    ecEncodeNum(cp, fun->numArgs);
    ecEncodeNum(cp, fun->numDefault);

    if (code) {
        mprAssert(code->codeLen > 0);
        ecEncodeNum(cp, code->numHandlers);
        ecEncodeNum(cp, code->codeLen);
        ecEncodeBlock(cp, code->byteCode, code->codeLen);
        if (code->numHandlers > 0) {
            createExceptionSection(cp, fun);
        }
        if (code->debug) {
            createDebugSection(cp, fun);
        }
    } else {
        ecEncodeNum(cp, 0);
        ecEncodeNum(cp, 0);
    }
    /*
        Recursively write args, locals and any nested functions and blocks.
     */
    attributes = 0;
    for (i = 0; i < numProp; i++) {
        createSection(cp, activation, i);
    }
    ecEncodeByte(cp, EJS_SECT_FUNCTION_END);
    mp->checksum += sumNum(fun->numArgs + numProp - fun->numArgs);
    if (code && code->numHandlers) {
        mp->checksum += sumNum(code->numHandlers);
    }
    if (ejsContainsMulti(ejs, qname.name, "--fun_")) {
        /* Don't sum the name for dynamic functions */
    } else {
        mp->checksum += sumString(qname.name);
    }
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static void createExceptionSection(EcCompiler *cp, EjsFunction *fun)
{
    Ejs         *ejs;
    EjsEx       *ex;
    EjsModule   *mp;
    EjsCode     *code;
    int         i;

    mprAssert(fun);

    mp = cp->state->currentModule;
    ejs = cp->ejs;
    code = fun->body.code;

    ecEncodeByte(cp, EJS_SECT_EXCEPTION);

    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        ecEncodeByte(cp, ex->flags);
        ecEncodeNum(cp, ex->tryStart);
        ecEncodeNum(cp, ex->tryEnd);
        ecEncodeNum(cp, ex->handlerStart);
        ecEncodeNum(cp, ex->handlerEnd);
        ecEncodeNum(cp, ex->numBlocks);
        ecEncodeNum(cp, ex->numStack);
        if (ex->catchType) {
            ecEncodeGlobal(cp, ex->catchType, ex->catchType->qname);
        } else {
            ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
        }
    }
}


static void createDebugSection(EcCompiler *cp, EjsFunction *fun)
{
    EcCodeGen   *code;
    EjsDebug    *debug;
    EjsLine     *line;
    int         i, patchSizeOffset, startDebug;

    mprAssert(fun);
    code = cp->state->code;
    debug = fun->body.code->debug;

    ecEncodeByte(cp, EJS_SECT_DEBUG);
    patchSizeOffset = ecGetCodeOffset(cp);
    ecEncodeInt32(cp, 0);

    startDebug = ecGetCodeOffset(cp);
    ecEncodeNum(cp, debug->numLines);
    for (i = 0; i < debug->numLines; i++) {
        line = &debug->lines[i];
        ecEncodeNum(cp, line->offset);
        ecEncodeWideAsMulti(cp, line->source);
    }
    ecEncodeInt32AtPos(cp, patchSizeOffset, ecGetCodeOffset(cp) - startDebug);
}


static void createBlockSection(EcCompiler *cp, EjsPot *parent, int slotNum, EjsBlock *block)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsName         qname;
    int             i;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    ecEncodeByte(cp, EJS_SECT_BLOCK);
    qname = ejsGetPropertyName(ejs, parent, slotNum);
    ecEncodeConst(cp, qname.name);
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum : -1);
    ecEncodeNum(cp, block->pot.numProp);

    /*
        Now emit all the properties
     */
    for (i = 0; i < block->pot.numProp; i++) {
        createSection(cp, (EjsPot*) block, i);
    }
    ecEncodeByte(cp, EJS_SECT_BLOCK_END);
}


static void createPropertySection(EcCompiler *cp, EjsPot *block, int slotNum, EjsObj *vp)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsModule   *mp;
    int         attributes;

    ejs = cp->ejs;
    mp = cp->state->currentModule;
    qname = ejsGetPropertyName(ejs, block, slotNum);
    
    createDocSection(cp, "var", block, slotNum);

    mprAssert(qname.name->value[0] != '\0');
    trait = ejsGetPropertyTraits(ejs, block, slotNum);
    attributes = trait->attributes;

    mprLog(7, "    global property section %@", qname.name);

    if (trait->type) {
        if (trait->type == ST(Namespace) || (!ejs->initialized && trait->type->qname.name == ST(Namespace)->qname.name)){
            attributes |= EJS_PROP_HAS_VALUE;
        }
    }
    ecEncodeByte(cp, EJS_SECT_PROPERTY);
    ecEncodeName(cp, qname);

    ecEncodeNum(cp, attributes);
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum : -1);
    if (trait->type) {
        ecEncodeGlobal(cp, trait->type, trait->type->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }

    if (attributes & EJS_PROP_HAS_VALUE) {
        if (vp && ejsIs(ejs, vp, Namespace)) {
            ecEncodeConst(cp, ((EjsNamespace*) vp)->value);
        } else {
            ecEncodeConst(cp, 0);
        }
    }
    mp->checksum += sumString(qname.name);
}


static void createDocSection(EcCompiler *cp, cchar *tag, EjsPot *block, int slotNum)
{
    Ejs         *ejs;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;
    mprAssert(slotNum >= 0);
    
    if (!(ejs->flags & EJS_FLAG_DOC)) {
        return;
    }
    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(EJS_DOC_HASH_SIZE, 0);
    }
    mprSprintf(key, sizeof(key), "%s %Lx %d", tag, PTOL(block), slotNum);
    if ((doc = mprLookupHash(ejs->doc, key)) == 0) {
        return;
    }
    ecEncodeByte(cp, EJS_SECT_DOC);
    ecEncodeConst(cp, doc->docString);
}


/*
    Add a constant to the constant pool. Grow if required and return the
    constant string offset into the pool.
 */
int ecAddStringConstant(EcCompiler *cp, EjsString *sp)
{
    int    offset;

    if (sp) {
        offset = ecAddModuleConstant(cp, cp->state->currentModule, ejsToMulti(cp->ejs, sp));
        if (offset < 0) {
            cp->fatalError = 1;
            mprAssert(offset > 0);
            return EJS_ERR;
        }
    } else {
        offset = 0;
    }
    return offset;
}


//  MOB -- remove
int ecAddCStringConstant(EcCompiler *cp, cchar *str)
{
    int    offset;

    if (str) {
        offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
        if (offset < 0) {
            cp->fatalError = 1;
            mprAssert(offset > 0);
            return EJS_ERR;
        }
    } else {
        offset = 0;
    }
    return offset;
}


int ecAddNameConstant(EcCompiler *cp, EjsName qname)
{
    if (ecAddStringConstant(cp, qname.name) < 0 || ecAddStringConstant(cp, qname.space) < 0) {
        return EJS_ERR;
    }
    return 0;
}


void ecAddFunctionConstants(EcCompiler *cp, EjsPot *obj, int slotNum)
{
    EjsFunction     *fun;

    fun = ejsGetProperty(cp->ejs, obj, slotNum);
    if (fun->resultType) {
        ecAddNameConstant(cp, fun->resultType->qname);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "fun", obj, slotNum);
    }
    ecAddConstants(cp, fun);
    if (fun->activation) {
        ecAddConstants(cp, fun->activation);
    }
}


void ecAddConstants(EcCompiler *cp, EjsAny *block)
{
    Ejs         *ejs;
    EjsName     qname;
    EjsTrait    *trait;
    EjsObj      *vp;
    int         i, numTraits;

    ejs = cp->ejs;
    
    if (VISITED(block)) {
        return;
    }
    SET_VISITED(block, 1);

    numTraits = ejsGetPropertyCount(ejs, block);
    for (i = 0; i < numTraits; i++) {
        qname = ejsGetPropertyName(ejs, block, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, block, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
        vp = ejsGetProperty(ejs, block, i);
        if (vp != block) {
            if (ejsIsFunction(ejs, vp)) {
                ecAddFunctionConstants(cp, block, i);
            } else if (ejsIsBlock(ejs, vp)) {
                ecAddConstants(cp, vp);
            }
        }
    }
    SET_VISITED(block, 0);
}


int ecAddDocConstant(EcCompiler *cp, cchar *tag, void *vp, int slotNum)
{
    Ejs         *ejs;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;

    mprAssert(ejs->doc);
    mprAssert(vp);
    mprAssert(slotNum >= 0);

    mprSprintf(key, sizeof(key), "%s %Lx %d", tag, PTOL(vp), slotNum);
    doc = (EjsDoc*) mprLookupHash(ejs->doc, key);
    if (doc && doc->docString) {
        if (ecAddStringConstant(cp, doc->docString) < 0) {
            mprAssert(0);
            return EJS_ERR;
        }
    }
    return 0;
}


/*
    Add a constant and encode the offset.
 */
int ecAddModuleConstant(EcCompiler *cp, EjsModule *mp, cchar *str)
{
    Ejs             *ejs;
    EjsConstants    *constants;
    MprHash         *hp;
    int             index;

    mprAssert(mp);
    ejs = cp->ejs;

    if (str == 0) {
        mprAssert(0);
        return 0;
    }
    constants = mp->constants;
    if (constants->table && (hp = mprLookupHashEntry(constants->table, str)) != 0) {
        return PTOI(hp->data);
    }
    index = ejsAddConstant(cp->ejs, constants, str);
    mprAddKey(constants->table, str, ITOP(index));
    return index;
}


/*
    Emit an encoded string ored with flags. The name index is shifted by 2.
    MOB -- should be full qname
 */
static void encodeTypeName(EcCompiler *cp, EjsString *name, int flags)
{
    int        offset;

    mprAssert(name);

    offset = ecAddModuleConstant(cp, cp->state->currentModule, ejsToMulti(cp->ejs, name));
    if (offset < 0) {
        cp->fatalError = 1;
        mprAssert(offset > 0);
    } else {
        ecEncodeNum(cp, offset << 2 | flags);
    }
}


/*
    Encode a global variable (usually a type). The encoding is untyped: 0, bound type: slot number, unbound or 
    unresolved type: name.
 */
void ecEncodeGlobal(EcCompiler *cp, EjsAny *obj, EjsName qname)
{
    Ejs         *ejs;
    int         slotNum;

    ejs = cp->ejs;
    slotNum = -1;

    if (obj == 0) {
        mprAssert(0);
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
        return;
    }
    /*
        If binding globals, we can encode the slot number of the type.
     */
    slotNum = ejsLookupProperty(ejs, ejs->global, qname);
    /* MOB - comment this out because ejs.tar was being compiled and bound */
    if (slotNum < ES_global_NUM_CLASS_PROP || cp->bind) {
        if (slotNum >= 0) {
            ecEncodeNum(cp, (slotNum << 2) | EJS_ENCODE_GLOBAL_SLOT);
            return;
        }
    }
    encodeTypeName(cp, qname.name, EJS_ENCODE_GLOBAL_NAME);
    ecEncodeConst(cp, qname.space);
}


/*
    Reserve a small amount of room sufficient for the next encoding
 */
static int reserveRoom(EcCompiler *cp, int room)
{
    EcCodeGen       *code;

    code = cp->state->code;
    mprAssert(code);

    if (mprGetBufSpace(code->buf) < room) {
        if (mprGrowBuf(code->buf, -1) < 0) {
            cp->fatalError = 1;
            mprAssert(0);
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


/*
    Encode an Ejscript instruction operation code
 */
void ecEncodeOpcode(EcCompiler *cp, int code)
{
    mprAssert(code < 240);
    mprAssert(cp);

    cp->lastOpcode = code;
    ecEncodeByte(cp, code);
}


/*
    Encode a <name><namespace> pair
 */
void ecEncodeName(EcCompiler *cp, EjsName qname)
{
    mprAssert(qname.name);

    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);
}


void ecEncodeConst(EcCompiler *cp, EjsString *sp)
{
    cchar   *str;
    int     offset;

    mprAssert(cp);

    if (sp) {
        str = ejsToMulti(cp->ejs, sp);
        offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
        if (offset < 0) {
            cp->error = 1;
            cp->fatalError = 1;
            return;
        }
    } else {
        offset = 0;
    }
    mprAssert(offset >= 0);
    ecEncodeNum(cp, offset);
}


void ecEncodeByte(EcCompiler *cp, int value)
{
    EcCodeGen   *code;
    uchar       *pc;

    mprAssert(cp);
    code = cp->state->code;

    if (reserveRoom(cp, sizeof(uchar)) < 0) {
        return;
    }
    pc = (uchar*) mprGetBufEnd(code->buf);
    *pc++ = value;
    mprAdjustBufEnd(code->buf, sizeof(uchar));
}


void ecEncodeMulti(EcCompiler *cp, cchar *str)
{
    int    len;

    mprAssert(cp);

    len = (int) strlen(str) + 1;
    mprAssert(len > 0);
    ecEncodeNum(cp, len);
    ecEncodeBlock(cp, (uchar*) str, len);
}


void ecEncodeWideAsMulti(EcCompiler *cp, MprChar *str)
{
    char    *mstr;
    ssize   len;

    mprAssert(cp);

    mstr = awtom(str, &len);
    len = strlen(mstr) + 1;
    mprAssert(len > 0);
    ecEncodeNum(cp, (int) len);
    ecEncodeBlock(cp, (uchar*) str, (int) len);
}


void ecEncodeNum(EcCompiler *cp, int64 number)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(int64) + 2) < 0) {
        return;
    }
    len = ejsEncodeNum(cp->ejs, (uchar*) mprGetBufEnd(buf), number);
    mprAdjustBufEnd(buf, len);
}


void ecEncodeDouble(EcCompiler *cp, double value)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(double) + 4) < 0) {
        return;
    }
    len = ejsEncodeDouble(cp->ejs, (uchar*) mprGetBufEnd(buf), value);
    mprAdjustBufEnd(buf, len);
}


/*
    Encode a 32-bit number. Always emit exactly 4 bytes.
 */
void ecEncodeInt32(EcCompiler *cp, int number)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;

    if (reserveRoom(cp, sizeof(int) / sizeof(char)) < 0) {
        return;
    }
    len = ejsEncodeInt32(cp->ejs, (uchar*) mprGetBufEnd(buf), number);
    mprAssert(len == 4);
    mprAdjustBufEnd(buf, len);
}


void ecEncodeByteAtPos(EcCompiler *cp, int offset, int value)
{
    ejsEncodeByteAtPos(cp->ejs, (uchar*) mprGetBufStart(cp->state->code->buf) + offset, value);
}


void ecEncodeInt32AtPos(EcCompiler *cp, int offset, int value)
{
    if (abs(value) > EJS_ENCODE_MAX_WORD) {
        mprError("Code generation error. Word %d exceeds maximum %d", value, EJS_ENCODE_MAX_WORD);
        cp->fatalError = 1;
        return;
    }
    ejsEncodeInt32AtPos(cp->ejs, (uchar*) mprGetBufStart(cp->state->code->buf) + offset, value);
}


void ecEncodeBlock(EcCompiler *cp, cuchar *buf, int len)
{
    EcCodeGen   *code;

    code = cp->state->code;

    if (reserveRoom(cp, len) < 0) {
        return;
    }
    if (mprPutBlockToBuf(code->buf, (char*) buf, len) != len) {
        cp->fatalError = 1;
    }
}


uint ecGetCodeOffset(EcCompiler *cp)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (uint) ((uchar*) mprGetBufEnd(code->buf) - (uchar*) mprGetBufStart(code->buf));
}


int ecGetCodeLen(EcCompiler *cp, uchar *mark)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (int) (((uchar*) mprGetBufEnd(code->buf)) - mark);
}


/*
    Copy the code at "pos" of length "size" the distance specified by "dist". Dist may be postitive or negative.
 */
void ecCopyCode(EcCompiler *cp, uchar *pos, int size, int dist)
{
    mprMemcpy((char*) &pos[dist], size, (char*) pos, size);
}


void ecAdjustCodeLength(EcCompiler *cp, int adj)
{
    EcCodeGen   *code;

    code = cp->state->code;
    mprAdjustBufEnd(code->buf, adj);
}


#if UNUSED && KEEP
static int swapWordField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}


static int swapShortField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}

static int swapCodePoint(EcCompiler *cp, int word)
{
#if BLD_CHAR_LEN == 4
    return swapWordField(cp, word);
#elif BLD_CHAR_LEN == 2
    return swapShortField(cp, word);
#else
    return word;
#endif 
}
#endif /* UNUSED */


/*
    Simple checksum of name and slots. Not meant to be rigorous.
 */
static int sumNum(int value)
{
    return value;
}


static int sumString(EjsString *name)
{
    MprChar *cp;
    int     checksum;

    checksum = 0;
    if (name) {
        for (cp = name->value; *cp; cp++) {
            checksum += *cp;
        }
    }
    return checksum;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecModuleWrite.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecParser.c"
 */
/************************************************************************/

/**
    ecParser. Parse ejscript source files.

    Parse source and create an internal abstract syntax tree of nodes representing the program.

    The Abstract Syntax Tree (AST) is comprised of a linked set of EcNodes. EjsNodes have a left and right pointer.
    Node with a list of children are represented by right hand links.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define peekToken(cp)   peekAheadToken(cp, 1)

/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)        if (ecEnterState(a) < 0) { return 0; } else

#undef LEAVE
#define LEAVE(cp, np)   ecLeaveStateWithResult(cp, np)


static void     addAscToLiteral(EcCompiler *cp, EcNode *np, cchar *str, ssize len);
static void     addCharsToLiteral(EcCompiler *cp, EcNode *np, MprChar *str, ssize len);
static void     addTokenToLiteral(EcCompiler *cp, EcNode *np);
static void     appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value);
static EcNode   *appendNode(EcNode *top, EcNode *np);
static void     applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributes, EjsString *namespaceName);
static void     copyDocString(EcCompiler *cp, EcNode *np, EcNode *from);
static EcNode   *compileInput(EcCompiler *cp, cchar *path);
static EcNode   *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createNameNode(EcCompiler *cp, EjsName name);
static EcNode   *createNamespaceNode(EcCompiler *cp, EjsString *name, bool isDefault, bool isLiteral);
static EcNode   *createNode(EcCompiler *cp, int kind, EjsString *name);
static void     dummy(int junk);
static EcNode   *expected(EcCompiler *cp, cchar *str);
static int      getToken(EcCompiler *cp);
static EjsString *tokenString(EcCompiler *cp);
static EcNode   *insertNode(EcNode *top, EcNode *np, int pos);
static EcNode   *linkNode(EcNode *np, EcNode *node);
static EcNode   *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseArgumentList(EcCompiler *cp);
static EcNode   *parseArguments(EcCompiler *cp);
static EcNode   *parseArrayComprehension(EcCompiler *cp, EcNode *literalElement);
static EcNode   *parseArrayPattern(EcCompiler *cp);
static EcNode   *parseArrayType(EcCompiler *cp);
static EcNode   *parseAssignmentExpression(EcCompiler *cp);
static EcNode   *parseAttribute(EcCompiler *cp);
static EcNode   *parseAttributeName(EcCompiler *cp);
static EcNode   *parseBlock(EcCompiler *cp);
static EcNode   *parseBlockStatement(EcCompiler *cp);
static EcNode   *parseBrackets(EcCompiler *cp);
static EcNode   *parseBreakStatement(EcCompiler *cp);
static EcNode   *parseCaseElements(EcCompiler *cp);
static EcNode   *parseCaseLabel(EcCompiler *cp);
static EcNode   *parseCatchClause(EcCompiler *cp);
static EcNode   *parseCatchClauses(EcCompiler *cp);
static EcNode   *parseClassBody(EcCompiler *cp);
static EcNode   *parseClassDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseClassInheritance(EcCompiler *cp);
static EcNode   *parseClassName(EcCompiler *cp);
static EcNode   *parseComprehensionExpression(EcCompiler *cp, EcNode *literalElement);
static EcNode   *parseConstructorSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseConstructorInitializer(EcCompiler *cp);
static EcNode   *parseContinueStatement(EcCompiler *cp);
static EcNode   *parseDirective(EcCompiler *cp);
static EcNode   *parseDirectives(EcCompiler *cp);
static EcNode   *parseDoStatement(EcCompiler *cp);
static EcNode   *parseDirectivesPrefix(EcCompiler *cp);
static EcNode   *parseElementList(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElementListPattern(EcCompiler *cp);
static EcNode   *parseElements(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElementTypeList(EcCompiler *cp);
static EcNode   *parseFieldList(EcCompiler *cp, EcNode *np);
static EcNode   *parseEmptyStatement(EcCompiler *cp);
static EcNode   *parseError(EcCompiler *cp, cchar *fmt, ...);
static EcNode   *parseExpressionStatement(EcCompiler *cp);
static EcNode   *parseFieldListPattern(EcCompiler *cp);
static EcNode   *parseFieldPattern(EcCompiler *cp, EcNode *np);
static EcNode   *parseFieldName(EcCompiler *cp);
static EcNode   *parseForStatement(EcCompiler *cp);
static EcNode   *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionBody(EcCompiler *cp, EcNode *fun);
static EcNode   *parseFunctionExpression(EcCompiler *cp);
static EcNode   *parseFunctionExpressionBody(EcCompiler *cp);
static EcNode   *parseFunctionName(EcCompiler *cp);
static EcNode   *parseFunctionSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseHashStatement(EcCompiler *cp);
static EcNode   *parseIdentifier(EcCompiler *cp);
static EcNode   *parseIfStatement(EcCompiler *cp);
static EcNode   *parseInterfaceBody(EcCompiler *cp);
static EcNode   *parseInterfaceInheritance(EcCompiler *cp);
static EcNode   *parseInitializerList(EcCompiler *cp, EcNode *np);
static EcNode   *parseInitializer(EcCompiler *cp);
static EcNode   *parseParameter(EcCompiler *cp, bool rest);
static EcNode   *parseParameterInit(EcCompiler *cp, EcNode *args);
static EcNode   *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseLabeledStatement(EcCompiler *cp);
static EcNode   *parseLeftHandSideExpression(EcCompiler *cp);
static EcNode   *parseLetBindingList(EcCompiler *cp);
static EcNode   *parseLetExpression(EcCompiler *cp);
static EcNode   *parseLetStatement(EcCompiler *cp);
static EcNode   *parseLiteralElement(EcCompiler *cp);
static EcNode   *parseLiteralField(EcCompiler *cp);
static EcNode   *parseListExpression(EcCompiler *cp);
static EcNode   *parseNamespaceAttribute(EcCompiler *cp);
static EcNode   *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode);
static EcNode   *parseNonemptyParameters(EcCompiler *cp, EcNode *list);
static EcNode   *parseNullableTypeExpression(EcCompiler *cp);
static EcNode   *parseObjectPattern(EcCompiler *cp);
static EcNode   *parseOptionalExpression(EcCompiler *cp);
static EcNode   *parseOverloadedOperator(EcCompiler *cp);
static EcNode   *parseParenListExpression(EcCompiler *cp);
static EcNode   *parseParameterisedTypeName(EcCompiler *cp);
static EcNode   *parseParameterKind(EcCompiler *cp);
static EcNode   *parseParameters(EcCompiler *cp, EcNode *args);
static EcNode   *parsePath(EcCompiler *cp, EcNode *lhs);
static EcNode   *parsePattern(EcCompiler *cp);
static EcNode   *parsePragmaItems(EcCompiler *cp, EcNode *np);
static EcNode   *parsePragmaItem(EcCompiler *cp);
static EcNode   *parsePragmas(EcCompiler *cp, EcNode *np);
static EcNode   *parsePrimaryExpression(EcCompiler *cp);
static EcNode   *parsePrimaryName(EcCompiler *cp);
static EcNode   *parseProgram(EcCompiler *cp, cchar *path);
static EcNode   *parsePropertyName(EcCompiler *cp);
static EcNode   *parsePropertyOperator(EcCompiler *cp);
static EcNode   *parseQualifiedNameIdentifier(EcCompiler *cp);
static EcNode   *parseRegularExpression(EcCompiler *cp);
static EcNode   *parseRequireItem(EcCompiler *cp);
static EcNode   *parseRequireItems(EcCompiler *cp, EcNode *np);
static EcNode   *parseReservedNamespace(EcCompiler *cp);
static EcNode   *parseRestArgument(EcCompiler *cp);
static EcNode   *parseRestParameter(EcCompiler *cp);
static EcNode   *parseResultType(EcCompiler *cp);
static EcNode   *parseReturnStatement(EcCompiler *cp);
static EcNode   *parseSimplePattern(EcCompiler *cp);
static EcNode   *parseSimpleQualifiedName(EcCompiler *cp);
static EcNode   *parseStatement(EcCompiler *cp);
static EcNode   *parseSubstatement(EcCompiler *cp);
static EcNode   *parseSuperInitializer(EcCompiler *cp);
static EcNode   *parseSwitchStatement(EcCompiler *cp);
static EcNode   *parseThrowStatement(EcCompiler *cp);
static EcNode   *parseTryStatement(EcCompiler *cp);
static EcNode   *parseTypeDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseTypeExpression(EcCompiler *cp);
static EcNode   *parseTypeIdentifierList(EcCompiler *cp);
static EcNode   *parseTypeInitialisation(EcCompiler *cp);
static EcNode   *parseModuleBody(EcCompiler *cp);
static EcNode   *parseModuleName(EcCompiler *cp);
static EcNode   *parseModuleDefinition(EcCompiler *cp);
static EcNode   *parseUsePragma(EcCompiler *cp, EcNode *np);
static EcNode   *parseVariableBinding(EcCompiler *cp, EcNode *np, EcNode *attributes);
static EcNode   *parseVariableBindingList(EcCompiler *cp, EcNode *list, EcNode *attributes);
static EcNode   *parseVariableDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableInitialisation(EcCompiler *cp);
static int       parseVersion(EcCompiler *cp, int parseMax);
static EcNode   *parseWhileStatement(EcCompiler *cp);
static EcNode   *parseWithStatement(EcCompiler *cp);
struct EcNode   *parseXMLAttribute(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLAttributes(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLElement(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLElementContent(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLTagContent(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLTagName(EcCompiler *cp, EcNode *np);
static EcNode   *parseYieldExpression(EcCompiler *cp);
static int      peekAheadToken(EcCompiler *cp, int ahead);
static EcToken  *peekAheadTokenStruct(EcCompiler *cp, int ahead);
static void     putSpecificToken(EcCompiler *cp, EcToken *token);
static void     putToken(EcCompiler *cp);
static EcNode   *removeNode(EcNode *np, EcNode *child);
static void     setNodeDoc(EcCompiler *cp, EcNode *np);
static EcNode   *unexpected(EcCompiler *cp);

#if BLD_DEBUG
static void     updateDebug(EcCompiler *cp);
#else
#define         updateDebug(cp)
#endif

#if BLD_DEBUG
/*
    Just for debugging. Generated via tokens.ksh
 */
char *tokenNames[] = {
    "",
    "assign",
    "at",
    "attribute",
    "bit_and",
    "bit_and_assign",
    "bit_or",
    "bit_or_assign",
    "bit_xor",
    "bit_xor_assign",
    "break",
    "call",
    "callee",
    "case",
    "cast",
    "catch",
    "cdata_end",
    "cdata_start",
    "class",
    "colon",
    "colon_colon",
    "comma",
    "const",
    "context_reserved_id",
    "continue",
    "debugger",
    "decrement",
    "default",
    "delete",
    "div",
    "div_assign",
    "do",
    "dot",
    "dot_dot",
    "dot_less",
    "double",
    "dynamic",
    "each",
    "elipsis",
    "else",
    "enumerable",
    "eof",
    "eq",
    "err",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "ge",
    "generator",
    "get",
    "goto",
    "gt",
    "has",
    "hash",
    "id",
    "if",
    "implements",
    "in",
    "include",
    "increment",
    "instanceof",
    "int",
    "interface",
    "internal",
    "intrinsic",
    "is",
    "lbrace",
    "lbracket",
    "le",
    "let",
    "logical_and",
    "logical_and_assign",
    "logical_not",
    "logical_or",
    "logical_or_assign",
    "logical_xor",
    "logical_xor_assign",
    "lparen",
    "lsh",
    "lsh_assign",
    "lt",
    "lt_slash",
    "minus",
    "minus_assign",
    "minus_minus",
    "mod",
    "module",
    "mod_assign",
    "mul",
    "mul_assign",
    "namespace",
    "native",
    "ne",
    "new",
    "nop",
    "null",
    "number",
    "number_word",
    "override",
    "plus",
    "plus_assign",
    "plus_plus",
    "private",
    "protected",
    "prototype",
    "public",
    "query",
    "rbrace",
    "rbracket",
    "regexp",
    "require",
    "reserved_namespace",
    "return",
    "rparen",
    "rsh",
    "rsh_assign",
    "rsh_zero",
    "rsh_zero_assign",
    "semicolon",
    "set",
    "slash_gt",
    "standard",
    "static",
    "strict",
    "strict_eq",
    "strict_ne",
    "string",
    "super",
    "switch",
    "this",
    "throw",
    "tilde",
    "to",
    "true",
    "try",
    "type",
    "typeof",
    "uint",
    "undefined",
    "use",
    "var",
    "void",
    "while",
    "with",
    "xml_comment_end",
    "xml_comment_start",
    "xml_pi_end",
    "xml_pi_start",
    "yield",
    0,
};


/*
    Just for debugging. Generated via tokens.ksh
 */
char *nodes[] = {
    "",
    "n_args",
    "n_assign_op",
    "n_attributes",
    "n_binary_op",
    "n_binary_type_op",
    "n_block",
    "n_break",
    "n_call",
    "n_case_elements",
    "n_case_label",
    "n_catch",
    "n_catch_arg",
    "n_catch_clauses",
    "n_class",
    "n_continue",
    "n_dassign",
    "n_directives",
    "n_do",
    "n_dot",
    "n_end_function",
    "n_expressions",
    "n_field",
    "n_for",
    "n_for_in",
    "n_function",
    "n_goto",
    "n_hash",
    "n_if",
    "n_literal",
    "n_module",
    "n_new",
    "n_nop",
    "n_object_literal",
    "n_parameter",
    "n_postfix_op",
    "n_pragma",
    "n_pragmas",
    "n_program",
    "n_qname",
    "n_ref",
    "n_return",
    "n_spread",
    "n_super",
    "n_switch",
    "n_this",
    "n_throw",
    "n_try",
    "n_type_identifiers",
    "n_unary_op",
    "n_use_module",
    "n_use_namespace",
    "n_value",
    "n_var",
    "n_var_definition",
    "n_void",
    "n_with",
    0,
};

#endif  /* BLD_DEBUG */

/*
    Compile the input stream and parse all directives into the given nodes reference.
 */
static EcNode *compileInput(EcCompiler *cp, cchar *path)
{
    EcNode      *np;

    mprAssert(cp);

    if (ecEnterState(cp) < 0) {
        return 0;
    }
    cp->fileState = cp->state;
    cp->fileState->strict = cp->strict;
    cp->blockState = cp->state;

    if (cp->shbang) {
        if (getToken(cp) == T_HASH && peekToken(cp) == T_LOGICAL_NOT) {
            while (cp->token->loc.lineNumber <= 1 && cp->token->tokenId != T_EOF && cp->token->tokenId != T_NOP) {
                getToken(cp);
            }
        }
        putToken(cp);
    }
    np = parseProgram(cp, path);
    mprAssert(np || cp->error);
    np = ecLeaveStateWithResult(cp, np);
    cp->fileState = 0;

    if (cp->errorCount > 0) {
        return 0;
    }
    return np;
}


/*
    Compile a source file and parse all directives into the given nodes reference.
    This may be called with the input stream already setup to parse a script.
 */
EcNode *ecParseFile(EcCompiler *cp, char *path)
{
    EcNode  *np;
    int     opened;

    mprAssert(path);

    opened = 0;
    path = mprGetNormalizedPath(path);
    if (cp->stream == 0) {
        if (ecOpenFileStream(cp, path) < 0) {
            parseError(cp, "Can't open %s", path);
            return 0;
        }
        opened = 1;
    }
    np = compileInput(cp, path);
    if (opened) {
        ecCloseStream(cp);
    }
    return np;
}


/*
    Lookup a module of the right version
    If max is <= 0, then accept any version from min upwards.
    This allows the caller to provide -1, -1 to match all versions.
    If both are equal, then only that version is acceptable.
 */
EjsModule *ecLookupModule(EcCompiler *cp, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0; ) {
        if (minVersion <= mp->version && mp->version <= maxVersion) {
            if (ejsCompareString(cp->ejs, mp->name, name) == 0) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


int ecAddModule(EcCompiler *cp, EjsModule *mp)
{
    mprAssert(cp->modules);
    return mprAddItem(cp->modules, mp);
}


int ecRemoveModule(EcCompiler *cp, EjsModule *mp)
{
    mprAssert(cp->modules);
    return mprRemoveItem(cp->modules, mp);
}


int ecResetModuleList(EcCompiler *cp)
{
    cp->modules = mprCreateList(-1, 0);
    if (cp->modules == 0) {
        return EJS_ERR;
    }
    return 0;
}


void ecResetParser(EcCompiler *cp)
{
    cp->token = 0;
}


/*
    XMLComment (ECMA-357)

    Input Sequences
        <!-- XMLCommentCharacters -->

    AST
 */
static EcNode *parseXMLComment(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_COMMENT_START) { }
    if (getToken(cp) != T_XML_COMMENT_END) {
        return expected(cp, "-->");
    }
    return LEAVE(cp, np);
}


/*
    XMLCdata (ECMA-357)

    Input Sequences
        <![CDATA[ XMLCDataCharacters ]]>

    AST
 */
static EcNode *parseXMLCdata(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_CDATA_START) { }
    if (getToken(cp) != T_CDATA_END) {
        return expected(cp, "]]>");
    }
    return LEAVE(cp, np);
}


/*
    XMLPI (ECMA-357)

    Input Sequences
        <? .... ?>

    AST
 */
static EcNode *parseXMLPI(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_PI_START) { }
    if (getToken(cp) != T_XML_PI_END) {
        return expected(cp, "?>");
    }
    return LEAVE(cp, np);
}


/*
    XMLMarkup (ECMA-357)
        XMLComment
        XMLCDATA
        XMLPI

    Input Sequences
        <!--
        [CDATA
        <?

    AST
 */
static EcNode *parseXMLMarkup(EcCompiler *cp, EcNode *np)
{
    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
        return parseXMLComment(cp);

    case T_CDATA_START:
        return parseXMLCdata(cp);

    case T_XML_PI_START:
        return parseXMLPI(cp);

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
}


/*
    XMLText (ECMA-357)

    Input Sequences
        SourceCharacters but no { or <

    AST
 */
static EcNode *parseXMLText(EcCompiler *cp, EcNode *np)
{
    MprChar *p;
    int     count;

    //  TODO This is discarding text white space. Need a low level getXmlToken routine
    //  or need lexer to preserved inter-token white space somewhere.
  
    peekToken(cp);
    for (count = 0; np; count++) {
        for (p = cp->peekToken->text; p && *p; p++) {
            if (*p == '{' || *p == '<') {
                if (cp->peekToken->text < p) {
                    addCharsToLiteral(cp, np, cp->token->text, (p - cp->token->text));
                    if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
                        return 0;
                    }
                }
                return np;
            }
        }
        if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
            return 0;
        }
        if (isalnum((int) cp->token->text[0]) && count > 0) {
            addAscToLiteral(cp, np, " ", 1);
        }
        addTokenToLiteral(cp, np);
        peekToken(cp);
    }
    return np;
}


/*
    XMLName (ECMA-357)
        XMLNameStart
        XMLName XMLNamePart

    Input Sequences
        UnicodeLetter
        _       underscore
        :       colon

    AST
 */
static EcNode *parseXMLName(EcCompiler *cp, EcNode *np)
{
    int         c;

    ENTER(cp);

    getToken(cp);
    if (cp->token == 0 || cp->token->text == 0) {
        return LEAVE(cp, unexpected(cp));
    }
    c = cp->token->text[0];
    if (isalpha(c) || c == '_' || c == ':') {
        addTokenToLiteral(cp, np);
    } else {
        np = parseError(cp, "Not an XML Name \"%@\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributeValue (ECMA-357)
        XMLDoubleStringCharacters
        XMLSingleStringCharacters

    Input Sequences
        "
        '
    AST
        Add data to literal.data buffer
 */
static EcNode *parseXMLAttributeValue(EcCompiler *cp, EcNode *np)
{
    //  TODO - should be preserving whether the input was ' or ""
    if (getToken(cp) != T_STRING) {
        return expected(cp, "quoted string");
    }
    addAscToLiteral(cp, np, "\"", 1);
    addTokenToLiteral(cp, np);
    addAscToLiteral(cp, np, "\"", 1);
    return np;
}


/*
    Identifier (1)
        ID |
        ContextuallyReservedIdentifier

    Input Sequences
        ID
        ContextuallyReservedIdentifier

    AST
        N_QNAME
            name
                id
 */
static EcNode *parseIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    tid = getToken(cp);
    if (cp->token->groupMask & G_CONREV) {
        tid = T_ID;
    }
    switch (tid) {
    case T_MUL:
    case T_ID:
        np = createNode(cp, N_QNAME, tokenString(cp));
        break;

    default:
        np = parseError(cp, "Not an identifier \"%s\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    Qualifier (3)
        *
        Identifier
        ReservedNamespace
        "StringLiteral"

    Input Sequences:
        *
        ID

    AST
        N_ATTRIBUTES
            namespace
 */

static EcNode *parseQualifier(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
        np = parseIdentifier(cp);
        break;

    case T_STRING:
        getToken(cp);
        np = createNode(cp, N_QNAME, NULL);
        np->qname.space = tokenString(cp);
        np->literalNamespace = 1;
        break;

    case T_MUL:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES, NULL);
        np->qname.space = tokenString(cp);
        break;

    case T_RESERVED_NAMESPACE:
        np = parseReservedNamespace(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ReservedNamespace (6)
        internal
        intrinsic
        private
        protected
        public

    Input
        internal
        intrinsic
        private
        protected
        public

    AST
        N_ATTRIBUTES
            namespace
            attributes
 */
static EcNode *parseReservedNamespace(EcCompiler *cp)
{
    EcNode      *np;
    int         attributes;

    ENTER(cp);

    if (getToken(cp) != T_RESERVED_NAMESPACE) {
        return LEAVE(cp, expected(cp, "reserved namespace"));
    }
    np = createNode(cp, N_ATTRIBUTES, NULL);

    attributes = 0;

    switch (cp->token->subId) {
    case T_INTRINSIC:
        break;

    case T_INTERNAL:
    case T_PRIVATE:
    case T_PROTECTED:
    case T_PUBLIC:
        np->specialNamespace = 1;
        break;

    default:
        return LEAVE(cp, parseError(cp, "Unknown reserved namespace %s", cp->token->text));
    }
    np->attributes = attributes;
    np->qname.space = tokenString(cp);
    return LEAVE(cp, np);
}


/*
    QualifiedNameIdentifier (11)
        Identifier
        ReservedIdentifier
        StringLiteral
        NumberLiteral
        Brackets
        OverloadedOperator

    Notes:
        Can be used to the right of a namespace qualifier. Eg. public::QualfiedNameIdentifier

    Input
        Identifier
        ReservedIdentifier
        Number
        "String"
        [
        Overloaded Operator

    AST
        N_QNAME
            name:
                namespace
                id
            left: N_EXPRESSIONS
 */
static EcNode *parseQualifiedNameIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    int         tid, reservedWord;

    ENTER(cp);

    tid = peekToken(cp);
    reservedWord = (cp->peekToken->groupMask & G_RESERVED);

    if (reservedWord) {
        np = createNode(cp, N_QNAME, tokenString(cp));

    } else switch (tid) {
        case T_ID:
        case T_TYPE:
            np = parseIdentifier(cp);
            break;

        case T_NUMBER:
            getToken(cp);
            np = createNode(cp, N_QNAME, NULL);
            vp = ejsParse(cp->ejs, cp->token->text, -1);
            //  MOB - cant set literal.var in a QNAME. clashes with "name" union structure. Not marked.
            mprAssert(0);
            np->literal.var = vp;
            break;

        case T_STRING:
            getToken(cp);
            np = createNode(cp, N_QNAME, NULL);
            vp = (EjsObj*) tokenString(cp);
            //  MOB - cant set literal.var in a QNAME. clashes with "name" union structure. Not marked.
            np->literal.var = vp;
            break;

        case T_LBRACKET:
            np = parseBrackets(cp);
            break;

        default:
            if (cp->token->groupMask == G_OPERATOR) {
                np = parseOverloadedOperator(cp);
            } else {
                getToken(cp);
                np = unexpected(cp);
            }
            break;
    }
    return LEAVE(cp, np);
}


/*
    SimpleQualifiedName (17)
        Identifier
        Qualifier :: QualifiedNameIdentifier

    Notes:
        Optionally namespace qualified name

    Input
        Identifier
        *

    AST
        N_QNAME
            name
                id
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseSimpleQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *name, *qualifier;

    ENTER(cp);

    if (peekToken(cp) == T_MUL || cp->peekToken->tokenId == T_STRING) {
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            qualifier = parseQualifier(cp);
            getToken(cp);
            np = parseQualifiedNameIdentifier(cp);
            if (np->kind == N_EXPRESSIONS) {
                name = np;
                np = createNode(cp, N_QNAME, NULL);
                np->name.nameExpr = linkNode(np, name);
            } else {
                np->literalNamespace = 1;
            }
            np->qname.space = qualifier->qname.space;

        } else {
            np = parseIdentifier(cp);
        }

    } else {
        np = parseIdentifier(cp);
        if (peekToken(cp) == T_COLON_COLON) {
            getToken(cp);
            qualifier = np;
            np = parseQualifiedNameIdentifier(cp);
            if (np) {
                if (np->kind == N_EXPRESSIONS) {
                    name = np;
                    np = createNode(cp, N_QNAME, NULL);
                    np->name.nameExpr = linkNode(np, name);
                }
                np->name.qualifierExpr = linkNode(np, qualifier);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ExpressionQualifiedName (15)
        ParenListExpression :: QualifiedNameIdentifier

    Input
        ( ListExpression ) :: *
        ( ListExpression ) :: Identifier
        ( ListExpression ) :: ReservedIdentifier
        ( ListExpression ) :: Number
        ( ListExpression ) :: String
        ( ListExpression ) :: [ ... ]
        ( ListExpression ) :: OverloadedOperator

    AST
        N_QNAME
            left: N_EXPRESSIONS
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseExpressionQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *qualifier;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    qualifier = parseListExpression(cp);
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    if (getToken(cp) == T_COLON_COLON) {
        np = parseQualifiedNameIdentifier(cp);
        np->name.qualifierExpr = linkNode(np, qualifier);
    } else {
        np = expected(cp, "\"::\"");
    }
    return LEAVE(cp, np);
}


/*
    PropertyName (20)
        SimpleQualifiedName         |
        ExpressionQualifiedName

    Input
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                namespace
                id
            left: N_EXPRESSIONS
            right: N_EXPRESSIONS
 */
static EcNode *parsePropertyName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_LPAREN) {
        np = parseExpressionQualifiedName(cp);
    } else {
        np = parseSimpleQualifiedName(cp);
    }
    return LEAVE(cp, np);
}


/*
    AttributeName (22)
        @ Brackets
        @ PropertyName

    Input
        @ [ ... ]
        @ PropertyName
            @ *
            @ ID
            @ Qualifier :: *
            @ Qualifier :: ID
            @ Qualifier :: ReservedIdentifier
            @ Qualifier :: Brackets
            @ ( ListExpression ) :: *
            @ ( ListExpression ) :: ID
            @ ( ListExpression ) :: ReservedIdentifier
            @ ( ListExpression ) :: [ ... ]

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: N_EXPRESSIONS
 */
static EcNode *parseAttributeName(EcCompiler *cp)
{
    EcNode      *np;
    char        *attribute;

    ENTER(cp);

    if (getToken(cp) != T_AT) {
        return LEAVE(cp, expected(cp, "@ prefix"));
    }
    if (peekToken(cp) == T_LBRACKET) {
        np = createNode(cp, N_QNAME, tokenString(cp));
        np = appendNode(np, parseBrackets(cp));
    } else {
        np = parsePropertyName(cp);
    }
    if (np && np->kind == N_QNAME) {
        //  MOB - OPT. Better to allow lexer to keep @ in the id name and return T_AT with the entire attribute name.
        np->name.isAttribute = 1;
        attribute = sjoin("@", np->qname.name->value, NULL);
        np->qname.name = ejsCreateStringFromAsc(cp->ejs, attribute);
    }
    return LEAVE(cp, np);
}


/*
    QualifiedName (24)
        AttributeName
        PropertyName

    Input
        @ ...
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: listExpression
            right: bracketExpression
 */
static EcNode *parseQualifiedName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_AT) {
        np = parseAttributeName(cp);
    } else {
        np = parsePropertyName(cp);
    }
    return LEAVE(cp, np);
}


/*
    PrimaryName (26)
        Path . PropertyName
        PropertyName

    Input
        *
        internal, intrinsic, private, protected, public
        Identifier
        (

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parsePrimaryName(EcCompiler *cp)
{
    EcNode      *np, *path;
    int         tid, id;

    ENTER(cp);

    np = 0;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }
    if (tid == T_ID && peekAheadToken(cp, 2) == T_DOT) {
        EcToken     *tok;
        tok = peekAheadTokenStruct(cp, 3);
        id = tok->tokenId;
        if (tok->groupMask & G_CONREV) {
            id = T_ID;
        }
        if (id == T_ID || id == T_MUL || id == T_RESERVED_NAMESPACE || id == T_LPAREN) {
            path = parsePath(cp, 0);
            np = createNode(cp, N_DOT, NULL);
            np = appendNode(np, path);
            getToken(cp);
        }
    }
    if (np) {
        np = appendNode(np, parsePropertyName(cp));
    } else {
        np = parsePropertyName(cp);
    }
    return LEAVE(cp, np);
}


/*
    Path (28)
        Identifier |
        Path . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
        N_DOT

    "dontConsumeLast" will be set if parsePath should not consume the last Identifier.
 */
static EcNode *parsePath(EcCompiler *cp, EcNode *lhs)
{
    EcNode      *np;
    EcToken     *tok;
    int         tid;

    ENTER(cp);

    if (lhs) {
        np = appendNode(createNode(cp, N_DOT, NULL), lhs);
        np = appendNode(np,  parseIdentifier(cp));
    } else {
        np = parseIdentifier(cp);
    }

    /*
        parsePath is called only from parsePrimaryName which requires that a ".PropertyName" be preserved.
        TODO - OPT. Perhaps hoist back into parsePrimaryName.
     */
    if (peekToken(cp) == T_DOT && peekAheadToken(cp, 2) == T_ID) {
        if (peekAheadToken(cp, 3) == T_DOT) {
            tok = peekAheadTokenStruct(cp, 4);
            tid = tok->tokenId;
            if (tok->groupMask & G_CONREV) {
                tid = T_ID;
            }
            if (tid == T_ID || tid == T_MUL || tid == T_RESERVED_NAMESPACE || tid == T_LPAREN) {
                getToken(cp);
                np = parsePath(cp, np);
            }
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ParenExpression (30)
        ( AssignmentExpression )
        ( )                                 # EJS FIX

    Input
        (

    AST
        N_EXPR
        N_NOP
 */
static EcNode *parseParenExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    if (peekToken(cp) != T_RPAREN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = createNode(cp, N_NOP, NULL);
    }
    if (getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}
#endif


/*
    ParenListExpression (31)
        ( ListExpression )

    Input
        (

    AST
        N_EXPRESSIONS
 */
static EcNode *parseParenListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseListExpression(cp);
    if (np && getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}


/*
    FunctionExpression (32)
        function Identifier FunctionSignature FunctionBody
        function FunctionSignature FunctionBody

    Input
        function id ( args ) { body }
        function ( args ) { body }

    AST
        N_FUNCTION
 */
static EcNode *parseFunctionExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *np, *funRef;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_FUNCTION, NULL);
    np->function.isExpression = 1;

    if (peekToken(cp) == T_ID) {
        getToken(cp);
        np->qname.name = tokenString(cp);
    }
    if (np->qname.name == 0) {
        np->qname.name = ejsSprintf(cp->ejs, "--fun_%d-%d--", np->seqno, (int) mprGetTime());
    }
    np->qname.space = state->inFunction ? S(empty): cp->fileState->nspace;

    np = parseFunctionSignature(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (STRICT_MODE(cp)) {
        if (np->function.resultType == 0) {
            return LEAVE(cp, parseError(cp,
                "Function has not defined a return type. Fuctions must be typed when declared in strict mode"));
        }
    }
    cp->state->currentFunctionNode = np;
    np->function.body = linkNode(np, parseFunctionExpressionBody(cp));

    if (np->function.body == 0) {
        return LEAVE(cp, 0);
    }
    /*
        The function must get linked into the top var block. It must not get processed inline at this point in the AST tree.
     */
    mprAssert(cp->state->topVarBlockNode);
    appendNode(cp->state->topVarBlockNode, np);

    /*
        Create a name node to reference the function. This is the value of this function expression.
        The funRef->name will be filled in by the AST processing for the function node.
     */
    funRef = createNode(cp, N_QNAME, NULL);
    funRef->qname = np->qname;
    return LEAVE(cp, funRef);
}


/*
    FunctionExpressionBody (34)
        Block
        AssignmentExpression

    Input
        {
    AST
 */
static EcNode *parseFunctionExpressionBody(EcCompiler *cp)
{
    EcNode      *np, *ret;

    ENTER(cp);

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }
    } else {
        np = createNode(cp, N_DIRECTIVES, NULL);
        ret = createNode(cp, N_RETURN, NULL);
        ret->ret.blockless = 1;
        ret = appendNode(ret, parseAssignmentExpression(cp));
        np = appendNode(np, ret);
    }
    if (np) {
        mprAssert(np->kind == N_DIRECTIVES);
    }
    np = appendNode(np, createNode(cp, N_END_FUNCTION, NULL));
    return LEAVE(cp, np);
}


/*
    ObjectLiteral (36)
        { FieldList }
        { FieldList } : NullableTypeExpression

    Input
        { LiteralField , ... }

    AST
        N_EXPRESSIONS
 */
static EcNode *parseObjectLiteral(EcCompiler *cp)
{
    Ejs     *ejs;
    EcNode  *typeNode, *np;

    ENTER(cp);

    ejs = cp->ejs;
    np = createNode(cp, N_OBJECT_LITERAL, NULL);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    if ((np = parseFieldList(cp, np)) == 0) {
        return LEAVE(cp, 0);
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
    } else {
        typeNode = createNode(cp, N_QNAME, ST(Object)->qname.name);
    }
    np->objectLiteral.typeNode = linkNode(np, typeNode);
    np->objectLiteral.isArray = 0;

    if (getToken(cp) != T_RBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    return LEAVE(cp, np);
}


/*
    FieldList (41)
        EMPTY
        LiteralField
        LiteralField , LiteralField

    Input
        LiteralField , ...

    AST
 */
static EcNode *parseFieldList(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    while (peekToken(cp) != T_RBRACE && !cp->error) {
        if (peekToken(cp) != T_COMMA) {
            np = appendNode(np, parseLiteralField(cp));
        } else {
            getToken(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    LiteralField (42)
        FieldKind FieldName : AssignmentExpression
        get Identifier FunctionSignature FunctionBody
        set Identifier FunctionSignature FunctionBody

    Input

    AST
 */
static EcNode *parseLiteralField(EcCompiler *cp)
{
    EcNode  *fp, *np, *id, *funRef, *fieldName;
    int     getterSetter;

    ENTER(cp);
    np = 0;
    getterSetter = 0;
    
    getToken(cp);
    if ((cp->token->tokenId == T_GET || cp->token->tokenId == T_SET) && peekToken(cp) != T_COLON) {
        /*
            get NAME() {}
         */
        fp = createNode(cp, N_FUNCTION, NULL);
        if (cp->token->tokenId == T_GET) {
            fp->function.getter = 1;
            fp->attributes |= EJS_TRAIT_GETTER;
        } else {
            fp->function.setter = 1;
            fp->attributes |= EJS_TRAIT_SETTER;
        }
        id = parseIdentifier(cp);
        if (id == 0) {
            return LEAVE(cp, 0);
        }
        cp->state->currentFunctionNode = fp;
        fp = parseFunctionSignature(cp, fp);
        fp->function.body = linkNode(fp, parseFunctionBody(cp, fp));
        if (fp->function.body == 0) {
            return LEAVE(cp, 0);
        }

        np = createNode(cp, N_FIELD, NULL);
        np->field.fieldKind = FIELD_KIND_FUNCTION;
        np->field.index = -1;
        np->attributes = fp->attributes;
        /*
            The function must get linked into the current var block. It must not get processed inline at
            this point in the AST tree because it must not use the block scope. Create a name based on the
            object literal seqno. This permits setters and getters to share the same name and thus when
            ejsDefineProperty is called -- they will get cross-linked.
         */
        fp->qname.name = ejsSprintf(cp->ejs, "--fun_%d-%d--", fp->seqno, (int) mprGetTime());
        fp->qname.space = cp->fileState->nspace;
        mprAssert(cp->state->topVarBlockNode);
        appendNode(cp->state->topVarBlockNode, fp);
        /*
            Must clear the getter|setter attributes so it can be loaded without invoking the accessor.
            The NEW_OBJECT opcode will call ejsDefineProperty which will restore the attributes.
         */
        fp->attributes &= ~(EJS_TRAIT_GETTER | EJS_TRAIT_SETTER);

        fieldName = createNode(cp, N_QNAME, id->qname.name);
        np->field.fieldName = linkNode(np, fieldName);

        funRef = createNode(cp, N_QNAME, fp->qname.name);
        np->field.expr = linkNode(np, funRef);

    } else {
        if (cp->token->tokenId == T_CONST) {
            np = createNode(cp, N_FIELD, NULL);
            np->field.varKind = KIND_CONST;
            np->attributes |= EJS_TRAIT_READONLY;
        } else {
            putToken(cp);
            np = createNode(cp, N_FIELD, NULL);
        }
        np->field.index = -1;
        np->field.fieldKind = FIELD_KIND_VALUE;
        if ((np->field.fieldName = linkNode(np, parseFieldName(cp))) == 0) {
            np = 0;
        } else {
            if (peekToken(cp) == T_COLON) {
                getToken(cp);
                np->field.expr = linkNode(np, parseAssignmentExpression(cp));
                
            } else if (np->field.fieldName->kind == N_QNAME) {
                np->field.expr = linkNode(np, createNode(cp, N_QNAME, NULL));
                np->field.expr->qname.name = np->field.fieldName->qname.name;

            } else if (np->field.fieldName->kind != N_LITERAL) {
                np = expected(cp, ": value");
            }
        }
    }
    return LEAVE(cp, np);
}


#if ROLLED_UP
/*
    FieldKind (45)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseFieldKind(EcCompiler *cp, EcNode *np)
{
    EcNode  *np;

    ENTER(cp);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
    }
    return LEAVE(cp, np);
}
#endif


/*
    FieldName (47)
        PropertyName
        StringLiteral
        NumberLiteral
        ReservedIdentifier

    Input

    AST
 */
static EcNode *parseFieldName(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
    case T_NUMBER:
    case T_STRING:
        np = parsePrimaryExpression(cp);
        break;

    default:
        np = parsePropertyName(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    ArrayLiteral (51)
        [ Elements ]

    ArrayLiteral (52)
        [ Elements ] : NullableTypeExpression

    Input sequence
        [

    AST
        N_EXPRESSIONS
            N_NEW
                N_QNAME
            N_EXPRESSIONS
                N_ASSIGN_OP
                    N_DOT
                        N_PARENT
                        N_LITERAL
                    ANY
 */
static EcNode *parseArrayLiteral(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np, *typeNode;

    ENTER(cp);

    ejs = cp->ejs;
    np = createNode(cp, N_OBJECT_LITERAL, NULL);
    np->objectLiteral.isArray = 1;

    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    } else {
        np = parseElements(cp, np);
        typeNode = 0;
        if (getToken(cp) != T_RBRACKET) {
            np = parseError(cp, "Expecting \"[\"");
        } else {
            if (peekToken(cp) == T_COLON) {
                typeNode = parseArrayType(cp);
                if (typeNode == 0) {
                    return LEAVE(cp, 0);
                }
            }
        }
        if (np) {
            if (typeNode == 0) {
                typeNode = createNode(cp, N_QNAME, ST(Array)->qname.name);
            }
            np->objectLiteral.typeNode = linkNode(np, typeNode);
        }
    }
    return LEAVE(cp, np);
}


/*
    Elements (54)
        ElementList
        ArrayComprehension

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElements(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_FOR || cp->peekToken->tokenId == T_LET || cp->peekToken->tokenId == T_IF) {
        np = parseArrayComprehension(cp, np);
    } else {
        np = parseElementList(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    ElementList (56)
        EMPTY
        LiteralElement
        , ElementList
        LiteralElement , ElementList

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElementList(EcCompiler *cp, EcNode *np)
{
    EcNode      *elt;
    int         index;

    ENTER(cp);

    for (index = 0; np; ) {
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
            index++;
        } else if (cp->peekToken->tokenId == T_RBRACKET) {
            break;
        } else {
            if ((elt = parseLiteralElement(cp)) != 0) {
                mprAssert(elt->kind == N_FIELD);
                elt->field.index = index;
                if (peekToken(cp) != T_COMMA && cp->peekToken->tokenId != T_RBRACKET) {
                    getToken(cp);
                    return LEAVE(cp, unexpected(cp));
                }
            }
            np = appendNode(np, elt);
        }
    }
    return LEAVE(cp, np);
}


/*
    LiteralElement (60)
        AssignmentExpression -noList, allowin-

    Input sequence

    AST
        N_ASSIGN_OP
            N_DOT
                N_REF
                N_LITERAL (empty - caller must set node->var)
            ANY
 */
static EcNode *parseLiteralElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = createNode(cp, N_FIELD, NULL);
    np->field.varKind = KIND_CONST;
    np->attributes |= EJS_TRAIT_READONLY;
    np->field.fieldKind = FIELD_KIND_VALUE;
    np->field.expr = linkNode(np, parseAssignmentExpression(cp));
    return LEAVE(cp, np);
}


/*
    ArrayComprehension (42)
        AssignmentExpression ComprehensionExpression
 */
static EcNode *parseArrayComprehension(EcCompiler *cp, EcNode *literalElement)
{
    EcNode      *np;

    ENTER(cp);

    np = parseAssignmentExpression(cp);
    np = parseComprehensionExpression(cp, np);
    return LEAVE(cp, np);
}


/*
    ComprehensionExpression (43)
        for (TypedPattern in CommaExpression) ComprehensionClause
        for each (TypedPattern in CommaExpression) ComprehensionClause
        let ParenExpression ComprehensionClause
        if ParenExpression ComprehensionClause
 */
static EcNode *parseComprehensionExpression(EcCompiler *cp, EcNode *literalElement)
{
    EcNode      *np;

    ENTER(cp);
    //  MOB
    np = 0;
    return LEAVE(cp, np);
}


#if UNUSED && MOB
/*
    ForInExpressionList (62)
        ForExpression
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ForInExpression (64)
        for ( ForInBinding in ListExpression -allowin- )
        for each ( ForInBinding in ListExpression -allowin- )
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalIfCondition (66)
        EMPTY
        if ParenListExpression

    Input
        this

    AST
 */


/*
    XMLInitializer (68)
        XMLMarkup
        XMLElement
        < > XMLElementContent </ >

    Input
        <!--
        [CDATA
        <?
        <

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLInitializer(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);
    ejs = cp->ejs;

    np = createNode(cp, N_LITERAL, NULL);
    np->literal.data = mprCreateBuf(0, 0);

    if (ST(XML) == 0) {
        return LEAVE(cp, parseError(cp, "No XML support configured"));
    }
    np->literal.var = (EjsObj*) ejsCreateObj(ejs, ST(XML), 0);

    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        return parseXMLMarkup(cp, np);

    case T_LT:
        if (peekAheadToken(cp, 2) == T_GT) {
            getToken(cp);
            getToken(cp);
            addAscToLiteral(cp, np, "<>", 2);
            np = parseXMLElementContent(cp, np);
            if (getToken(cp) != T_LT_SLASH) {
                return LEAVE(cp, expected(cp, "</"));
            }
            if (getToken(cp) != T_GT) {
                return LEAVE(cp, expected(cp, ">"));
            }
            addAscToLiteral(cp, np, "</>", 3);
        } else {
            return parseXMLElement(cp, np);
        }
        break;

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = 0;
    return LEAVE(cp, np);
}


/*
    XMLElementContent (71)
        { ListExpression } XMLElementContent
        XMLMarkup XMLElementContent
        XMLText XMLElementContent
        XMLElement XMLElementContent
        EMPTY
    Input
        {
        <!--
        [CDATA
        <?
        <
        Text
    AST
 */
struct EcNode *parseXMLElementContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    
    switch (peekToken(cp)) {
    case T_LBRACE:
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
        np = parseXMLElementContent(cp, np);
        break;

    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLMarkup(cp, np);
        break;

    case T_LT:
        np = parseXMLElement(cp, np);
        np = parseXMLElementContent(cp, np);
        break;

    case T_LT_SLASH:
        break;

    case T_EOF:
    case T_ERR:
    case T_NOP:
        return LEAVE(cp, 0);

    default:
        np = parseXMLText(cp, np);
        np = parseXMLElementContent(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLElement (76)
        < XMLTagContent XMLWhitespace />
        < XMLTagContent XMLWhitespace > XMLElementContent </ XMLTagName XMLWhitespace >

    Input
        <

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLElement(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (getToken(cp) != T_LT) {
        return LEAVE(cp, expected(cp, "<"));
    }
    addTokenToLiteral(cp, np);

    np = parseXMLTagContent(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (getToken(cp) == T_SLASH_GT) {
        addTokenToLiteral(cp, np);
        return LEAVE(cp, np);

    } else if (cp->token->tokenId != T_GT) {
        return LEAVE(cp, unexpected(cp));
    }

    addTokenToLiteral(cp, np);

    np = parseXMLElementContent(cp, np);
    if (getToken(cp) != T_LT_SLASH) {
        return LEAVE(cp, expected(cp, "</"));
    }
    addTokenToLiteral(cp, np);

    np = parseXMLTagName(cp, np);
    if (getToken(cp) != T_GT) {
        return LEAVE(cp, expected(cp, ">"));
    }
    addTokenToLiteral(cp, np);
    return LEAVE(cp, np);
}


/*
    XMLTagContent (79)
        XMLTagName XMLAttributes

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLTagContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    np = parseXMLTagName(cp, np);
    if (np) {
        np = parseXMLAttributes(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLTagName (80)
        { ListExpression }
        XMLName

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLTagName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (peekToken(cp) == T_LBRACE) {
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLName(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (82)
        XMLWhitespace { ListExpression }
        XMLAttribute XMLAttributes
        EMPTY
    Input

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLAttributes(EcCompiler *cp, EcNode *np)
{
    int         tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid == T_LBRACE) {
        parseListExpression(cp);
        if (peekToken(cp) == T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        while (tid != T_GT && tid != T_SLASH_GT) {
            if ((np = parseXMLAttribute(cp, np)) == 0) {
                break;
            }
            tid = peekToken(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (85)
        XMLWhitespace XMLName XMLWhitespace = XMLWhitepace { ListExpression (allowIn) }
        XMLWhitespace XMLName XMLWhitespace = XMLAttributeValue

    Input
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLAttribute(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    addAscToLiteral(cp, np, " ", 1);
    np = parseXMLName(cp, np);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    addAscToLiteral(cp, np, "=", 1);

    if (peekToken(cp) == T_LBRACE) {
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLAttributeValue(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    ThisExpression (87)
        this
        this callee
        this generator
        this function
    Input
        this

    AST
 */
static EcNode *parseThisExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THIS) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_THIS, NULL);
    peekToken(cp);
    
    if (cp->token->loc.lineNumber == cp->peekToken->loc.lineNumber) {
        switch (peekToken(cp)) {
        case T_TYPE:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_TYPE;
            break;

        case T_FUNCTION:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_FUNCTION;
            break;

        case T_CALLEE:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_CALLEE;
            break;

        case T_GENERATOR:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_GENERATOR;
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    PrimaryExpression (90)
        null
        true
        false
        NumberLiteral
        StringLiteral
        RegularExpression
        ThisExpression
        XMLInitializer
        ParenListExpression
        ArrayLiteral
        ObjectLiteral
        FunctionExpression
        AttributeName
        PrimaryName

    Input sequence
        null
        true
        false
        this
        function
        Identifier
        ContextuallyReservedIdentifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <

    AST
        N_FUNCTION
        N_NEW           (array / object literals)
        N_LITERAL
        N_QNAME
        N_THIS
 */
static EcNode *parsePrimaryExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np, *qualifier, *name;
    EjsObj      *vp;
    int         tid;

    ENTER(cp);

    ejs = cp->ejs;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }
    np = 0;
    switch (tid) {
    case T_STRING:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parsePrimaryName(cp);
        } else {
            getToken(cp);
            vp = (EjsObj*) tokenString(cp);
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = vp;
        }
        break;

    case T_ID:
        np = parsePrimaryName(cp);
        break;

    case T_AT:
        np = appendNode(np, parseAttributeName(cp));
        break;

    case T_NUMBER:
        getToken(cp);
        vp = ejsParse(cp->ejs, cp->token->text, -1);
        np = createNode(cp, N_LITERAL, tokenString(cp));
        np->literal.var = vp;
        break;

    case T_NULL:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = S(null);
        }
        break;

    case T_UNDEFINED:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = S(undefined);
        }
        break;

    case T_TRUE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 1);
            np->literal.var = vp;
        }
        break;

    case T_FALSE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 0);
            np->literal.var = vp;
        }
        break;

    case T_THIS:
        np = parseThisExpression(cp);
        break;

    case T_LPAREN:
        np = parseParenListExpression(cp);
        if (peekToken(cp) == T_COLON_COLON) {
            getToken(cp);
            qualifier = np;
            if ((np = parseQualifiedNameIdentifier(cp)) != 0) {
                if (np->kind == N_EXPRESSIONS) {
                    name = np;
                    np = createNode(cp, N_QNAME, tokenString(cp));
                    np->name.nameExpr = linkNode(np, name);
                }
                np->name.qualifierExpr = linkNode(np, qualifier);
            }
        }
        break;

    case T_LBRACKET:
        np = parseArrayLiteral(cp);
        break;

    case T_LBRACE:
        np = parseObjectLiteral(cp);
        break;

    case T_FUNCTION:
        np = parseFunctionExpression(cp);
        break;

    case T_VOID:
    case T_NAMESPACE:
    case T_TYPEOF:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = unexpected(cp);
        }
        break;

    case T_LT:
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLInitializer(cp);
        break;

    case T_DIV:
    case T_SLASH_GT:
        np = parseRegularExpression(cp);
        break;

    case T_ERR:
    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


static EcNode *parseRegularExpression(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    MprChar     *prefix;
    int         id;

    ENTER(cp);

    /* Flush peek ahead buffer */
    while (cp->putback) {
        getToken(cp);
    }
    prefix = wclone(cp->token->text);
    id = ecGetRegExpToken(cp, prefix);
    cp->peekToken = 0;
    updateDebug(cp);

    if (id != T_REGEXP) {
        return LEAVE(cp, parseError(cp, "Can't parse regular expression"));
    }
    if ((vp = (EjsObj*) ejsCreateRegExp(cp->ejs, tokenString(cp))) == NULL) {
        return LEAVE(cp, parseError(cp, "Can't compile regular expression"));
    }
    np = createNode(cp, N_LITERAL, NULL);
    np->literal.var = vp;
    return LEAVE(cp, np);
}


/*
    SuperExpression (104)
        super
        super ParenExpression

    Input
        super

    AST
        N_SUPER

    NOTES:
        Using Arguments instead of ParenExpression so we can have multiple args.
 */
static EcNode *parseSuperExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        np = unexpected(cp);

    } else {
        if (peekToken(cp) == T_LPAREN) {
            np = createNode(cp, N_SUPER, NULL);
            np = appendNode(np, parseArguments(cp));
        } else {
            np = createNode(cp, N_SUPER, NULL);
        }
    }
    return LEAVE(cp, np);
}


/*
    Arguments (106)
        ( )
        ( ArgumentList )

    Input
        (

    AST
        N_ARGS
 */
static EcNode *parseArguments(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        np = parseError(cp, "Expecting \"(\"");

    } else if (peekToken(cp) == T_RPAREN) {
        getToken(cp);
        np = createNode(cp, N_ARGS, NULL);

    } else {
        np = parseArgumentList(cp);
        if (np && getToken(cp) != T_RPAREN) {
            np = parseError(cp, "Expecting \")\"");
        }
    }
    return LEAVE(cp, np);
}


/*
    ArgumentList (118)
        AssignmentExpression
        ArgumentList , AssignmentExpression

    Input

    AST N_ARGS
        children: arguments
 */
static EcNode *parseArgumentList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_ARGS, NULL);

    if (np && peekToken(cp) == T_ELIPSIS) {
        np = appendNode(np, parseRestArgument(cp));
    } else {
        np = appendNode(np, parseAssignmentExpression(cp));
    }
    while (np && peekToken(cp) == T_COMMA) {
        getToken(cp);
        if (np && peekToken(cp) == T_ELIPSIS) {
            np = appendNode(np, parseRestArgument(cp));
        } else {
            np = appendNode(np, parseAssignmentExpression(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    RestArgument (NEW)
        ...
        ... Parameter

    Input

    AST
 */
static EcNode *parseRestArgument(EcCompiler *cp)
{
    EcNode      *np, *spreadArg;

    ENTER(cp);

    if (getToken(cp) == T_ELIPSIS) {
        spreadArg = createNode(cp, N_SPREAD, NULL);
        np = appendNode(spreadArg, parseAssignmentExpression(cp));
        if (peekToken(cp) == T_COMMA) {
            np = unexpected(cp);
        }
    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    PropertyOperator (110)
        . ReservedIdentifier
        . PropertyName
        . AttributeName
        .. QualifiedName
        . ParenListExpression
        . ParenListExpression :: QualifiedNameIdentifier
        Brackets
        TypeApplication

    Input
        .
        ..
        [

    AST
        N_DOT
 */
static EcNode *parsePropertyOperator(EcCompiler *cp)
{
    EcNode      *np, *qualifier, *name;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DOT:
        np = createNode(cp, N_DOT, NULL);
        getToken(cp);
        switch (peekToken(cp)) {
        case T_LPAREN:
            name = parseParenListExpression(cp);
            if (peekToken(cp) == T_COLON_COLON) {
                qualifier = name;
                getToken(cp);
                name = parseQualifiedNameIdentifier(cp);
                name->name.qualifierExpr = linkNode(name, qualifier);
            }
            np = appendNode(np, name);
            break;

        /* MOB TODO - should handle all contextually reserved identifiers here */
        case T_TYPE:
        case T_ID:
        case T_GET:
        case T_SET:
        case T_STRING:
        case T_REQUIRE:
        case T_RESERVED_NAMESPACE:
        case T_MUL:
            if (cp->token->groupMask & G_RESERVED) {
                np = appendNode(np, parseIdentifier(cp));
            } else {
                np = appendNode(np, parsePropertyName(cp));
            }
            break;

        case T_AT:
            np = appendNode(np, parseAttributeName(cp));
            break;

        case T_SUPER:
            getToken(cp);
            np = appendNode(np, createNode(cp, N_SUPER, NULL));
            break;

        default:
            if (cp->token->groupMask & G_RESERVED) {
                np = appendNode(np, parseIdentifier(cp));
            } else {
                np = appendNode(np, parsePropertyName(cp));
            }
#if UNUSED
            getToken(cp);
            np = unexpected(cp);
#endif
            break;
        }
        break;

    case T_LBRACKET:
        np = createNode(cp, N_DOT, NULL);
        np = appendNode(np, parseBrackets(cp));
        break;

    case T_DOT_DOT:
        getToken(cp);
        np = createNode(cp, N_DOT, NULL);
        name = parseQualifiedName(cp);
        if (name && name->kind == N_QNAME) {
            name->qname.name = ejsSprintf(cp->ejs, ".%@", name->qname.name);
        }
        np = appendNode(np, name);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Expecting property operator . .. or [");
        break;
    }
    return LEAVE(cp, np);
}


/*
    Brackets (125)
        [ ListExpression ]
        [ SliceExpression ]

    Input
        [

    AST
        N_EXPRESSIONS
 */
static EcNode *parseBrackets(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    //  TODO - not yet implementing SliceExpression
    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }

    if (peekToken(cp) == T_COLON) {
        /*
            Slice expression
         */
        /* First optional expression in a slice expression is empty */
        np = parseOptionalExpression(cp);
        if (getToken(cp) != T_COLON) {
            np = parseError(cp, "Expecting \":\"");
        }
        np = appendNode(np, parseOptionalExpression(cp));

    } else {

        np = parseListExpression(cp);

        if (peekToken(cp) == T_COLON) {
            /*
                Slice expression
             */
            np = appendNode(np, parseOptionalExpression(cp));
            if (peekToken(cp) != T_COLON) {
                getToken(cp);
                np = parseError(cp, "Expecting \":\"");
            }
            np = appendNode(np, parseOptionalExpression(cp));
        }
    }

    if (getToken(cp) != T_RBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }
    return LEAVE(cp, np);
}


/*
    TypeApplication (120)
        .< TypeExpressionList >

    Input
        .<

    AST
 */
#if FUTURE
/*
    SliceExpression (121)
        OptionalExpression : OptionalExpression
        OptionalExpression : OptionalExpression : OptionalExpression

    Input

    AST
 */
static EcNode *parseSliceExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalExpression (123)
        ListExpression -allowin-
        EMPTY

    Input

    AST
 */
static EcNode *parseOptionalExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseListExpression(cp);
    return LEAVE(cp, np);
}


/*
    MemberExpression (125) -a,b-
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseMemberExpression(EcCompiler *cp)
{
    EcNode      *np, *newNode;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_SUPER:
        np = parseSuperExpression(cp);
        if (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
                cp->peekToken->tokenId == T_LBRACKET) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        }
        break;

    case T_NEW:
        getToken(cp);
        newNode = createNode(cp, N_NEW, NULL);
        newNode = appendNode(newNode, parseMemberExpression(cp));
        np = createNode(cp, N_NEW, NULL);
        np = appendNode(np, newNode);
        np = appendNode(np, parseArguments(cp));
        break;

    default:
        np = parsePrimaryExpression(cp);
        break;
    }
    while (np && (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
            cp->peekToken->tokenId == T_LBRACKET)) {
#if 1
        if (np->loc.lineNumber == cp->peekToken->loc.lineNumber) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        } else {
            break;
        }
#else
        np = insertNode(parsePropertyOperator(cp), np, 0);
#endif
    }
    return LEAVE(cp, np);
}


/*
    CallExpression (129) -a,b-
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Input

    AST
        N_CALL

    "me" is to to an already parsed member expression
 */
static EcNode *parseCallExpression(EcCompiler *cp, EcNode *me)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;

    while (1) {
        peekToken(cp);
        if (me && me->loc.lineNumber != cp->peekToken->loc.lineNumber) {
            return LEAVE(cp, np);
        }
        switch (peekToken(cp)) {
        case T_LPAREN:
            np = createNode(cp, N_CALL, NULL);
            np = appendNode(np, me);
            np = appendNode(np, parseArguments(cp));
            if (np && cp->token) {
                np->loc.lineNumber = cp->token->loc.lineNumber;
            }
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            if (me == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            np = insertNode(parsePropertyOperator(cp), me, 0);
            if (np && cp->token) {
                np->loc.lineNumber = cp->token->loc.lineNumber;
            }
            break;

        default:
            if (np == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            return LEAVE(cp, np);
        }
        if (np == 0) {
            return LEAVE(cp, np);
        }
        me = np;
    }
    return LEAVE(cp, np);
}


/*
    NewExpression (132)
        MemberExpression
        new NewExpression

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseNewExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        getToken(cp);
        np = createNode(cp, N_NEW, NULL);
        np = appendNode(np, parseNewExpression(cp));

    } else {
        np = parseMemberExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    LeftHandSideExpression (134) -a,b-
        NewExpression
        CallExpression

    Where NewExpression is:
        MemberExpression
        new NewExpression

    Where CallExpression is:
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Where MemberExpression is:
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    So look ahead problem on MemberExpression. We don't know if it is a newExpression or a CallExpression. This requires
    large lookahead. So, refactored to be:

    LeftHandSideExpression (136) -a,b-
        new MemberExpression LeftHandSidePrime
        MemberExpression LeftHandSidePrime

    and where LeftHandSidePrime is:
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Also:
        new MemberExpression
        MemberExpression
        MemberExpression (
        MemberExpression .
        MemberExpression ..
        MemberExpression [

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSideExpression(EcCompiler *cp)
{
    EcNode      *np, *callNode;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        np = parseNewExpression(cp);
    } else {
        np = parseMemberExpression(cp);
    }
    if (np) {
        /*
            Refactored CallExpression processing
         */
        switch (peekToken(cp)) {
        case T_LPAREN:
        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            if (cp->token->loc.lineNumber == cp->peekToken->loc.lineNumber) {
                /*
                    May have multiline function expression: x = (function ..... multiple lines)() 
                 */
                np->loc.lineNumber = cp->token->loc.lineNumber;
                np = parseCallExpression(cp, np);
            }
            break;

        default:
            if (np->kind == N_NEW) {
                /*
                    Create a dummy call to the constructor
                 */
                callNode = createNode(cp, N_CALL, NULL);
                np = appendNode(callNode, np);
                np = appendNode(np, createNode(cp, N_ARGS, NULL));
            }
            break;
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    LeftHandSidePrime (psudo) -a,b-
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSidePrime(EcCompiler *cp, EcNode *np)
{
    EcNode      *callNode;

    ENTER(cp);

    do {
        switch (peekToken(cp)) {
        case T_LPAREN:
#if UNUSED
            callNode = createNode(cp, N_CALL, NULL);
            np = appendNode(callNode, np);
            np = appendNode(np, parseArguments(cp));
#endif
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            np = appendNode(np, parsePropertyOperator(cp));
            break;

        default:
            return LEAVE(cp, np);
        }

    } while (np);

    return LEAVE(cp, np);
}
#endif


/*
    UnaryTypeExpression (136)
        LeftHandSideExpression
        type NullableTypeExpression

    Input
        type

    AST
 */
static EcNode *parseUnaryTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (peekToken(cp) == T_TYPE) {
        getToken(cp);
        np = parseNullableTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    PostfixExpression (138)
        UnaryTypeExpression
        LeftHandSideExpression [no line break] ++
        LeftHandSideExpression [no line break] --

    Input

    AST
 */
static EcNode *parsePostfixExpression(EcCompiler *cp)
{
    EcNode      *parent, *np;

    ENTER(cp);

    if (peekToken(cp) == T_TYPE) {
        np = parseUnaryTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
        if (np) {
            if (peekToken(cp) == T_PLUS_PLUS || cp->peekToken->tokenId == T_MINUS_MINUS) {
                getToken(cp);
                parent = createNode(cp, N_POSTFIX_OP, NULL);
                np = appendNode(parent, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    UnaryExpression (141)
        PostfixExpression
        delete PostfixExpression
        void UnaryExpression
        typeof UnaryExpression
        ++ PostfixExpression
        -- PostfixExpression
        + UnaryExpression
        - UnaryExpression
        ~ UnaryExpression           (bitwise not)
        ! UnaryExpression

    Input

    AST
 */
static EcNode *parseUnaryExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DELETE:
    case T_LOGICAL_NOT:
    case T_PLUS:
    case T_PLUS_PLUS:
    case T_MINUS:
    case T_MINUS_MINUS:
    case T_TILDE:
    case T_TYPEOF:
    case T_VOID:
        getToken(cp);
        np = createNode(cp, N_UNARY_OP, NULL);
        np = appendNode(np, parseUnaryExpression(cp));
        break;

    default:
        np = parsePostfixExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    MultiplicativeExpression (152) -a,b-
        UnaryExpression
        MultiplicativeExpression * UnaryExpression
        MultiplicativeExpression / UnaryExpression
        MultiplicativeExpression % UnaryExpression

    Input

    AST
 */
static EcNode *parseMultiplicativeExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);
    
    np = parseUnaryExpression(cp);
    while (np) {
        switch (peekToken(cp)) {
        case T_MUL:
        case T_DIV:
        case T_MOD:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseUnaryExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    mprAssert(cp > 0);
    return LEAVE(cp, np);
}


/*
    AdditiveExpression (156)
        MultiplicativeExpression
        AdditiveExpression + MultiplicativeExpression
        AdditiveExpression - MultiplicativeExpression

    Input

    AST
 */
static EcNode *parseAdditiveExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    
    ENTER(cp);

    np = parseMultiplicativeExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_PLUS:
        case T_MINUS:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseMultiplicativeExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ShiftExpression (159) -a,b-
        AdditiveExpression
        ShiftExpression << AdditiveExpression
        ShiftExpression >> AdditiveExpression
        ShiftExpression >>> AdditiveExpression

    Input

    AST
 */
static EcNode *parseShiftExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseAdditiveExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LSH:
        case T_RSH:
        case T_RSH_ZERO:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseAdditiveExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    RelationalExpression (163) -allowin-
        ShiftExpression
        RelationalExpression < ShiftExpression
        RelationalExpression > ShiftExpression
        RelationalExpression <= ShiftExpression
        RelationalExpression >= ShiftExpression
        RelationalExpression [in] ShiftExpression
        RelationalExpression instanceOf ShiftExpression
        RelationalExpression cast ShiftExpression
        RelationalExpression to ShiftExpression
        RelationalExpression is ShiftExpression
        RelationalExpression like ShiftExpression

    Input

    AST
 */
static EcNode *parseRelationalExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseShiftExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_IN:
            if (cp->state->noin) {
                return LEAVE(cp, np);
            }
            /* Fall through */

        case T_LT:
        case T_LE:
        case T_GT:
        case T_GE:
        case T_INSTANCEOF:
        case T_IS:
        case T_CAST:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseShiftExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    EqualityExpression (182)
        RelationalExpression
        EqualityExpression == RelationalExpression
        EqualityExpression != RelationalExpression
        EqualityExpression === RelationalExpression
        EqualityExpression !== RelationalExpression

    Input

    AST
 */
static EcNode *parseEqualityExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseRelationalExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_EQ:
        case T_NE:
        case T_STRICT_EQ:
        case T_STRICT_NE:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseRelationalExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseAndExpression (187)
        EqualityExpression
        BitwiseAndExpression & EqualityExpression

    Input

    AST
 */
static EcNode *parseBitwiseAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseEqualityExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseEqualityExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseXorExpression (189)
        BitwiseAndExpression
        BitwiseXorExpression ^ BitwiseAndExpression

    Input

    AST
 */
static EcNode *parseBitwiseXorExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_XOR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseAndExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseOrExpression (191)
        BitwiseXorExpression
        BitwiseOrExpression | BitwiseXorExpression

    Input

    AST
 */
static EcNode *parseBitwiseOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseXorExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseXorExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalAndExpression (193)
        BitwiseOrExpression
        LogicalAndExpression && BitwiseOrExpression

    Input

    AST
 */
static EcNode *parseLogicalAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseOrExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalOrExpression (195)
        LogicalAndExpression
        LogicalOrExpression || LogicalOrExpression

    Input

    AST
 */
static EcNode *parseLogicalOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseLogicalAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseLogicalOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ConditionalExpression (197) -allowList,b-
        LetExpression -b-
        YieldExpression -b-
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    ConditionalExpression (197) -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input
        let
        yield
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        delete
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseConditionalExpression(EcCompiler *cp)
{
    EcNode      *np, *cond;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                cond = np;
                np = createNode(cp, N_IF, NULL);
                np->tenary.cond = linkNode(np, cond);
                np->tenary.thenBlock = linkNode(np, parseAssignmentExpression(cp));
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np->tenary.elseBlock = linkNode(np, parseAssignmentExpression(cp));
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    NonAssignmentExpression -allowList,b- (199)
        LetExpression
        YieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    NonAssignmentExpression -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input

    AST
 */
static EcNode *parseNonAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                np = parseAssignmentExpression(cp);
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np = parseAssignmentExpression(cp);
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    LetExpression (204)
        let ( LetBindingList ) ListExpression

    Input
        let

    AST
 */
static EcNode *parseLetExpression(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    
    if (getToken(cp) != T_LET) {
        return LEAVE(cp, expected(cp, "let"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseLetBindingList(cp);
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    return 0;
}


/*
    LetBindingList (205)
        EMPTY
        NonemptyLetBindingList -allowList-

    Input

    AST
 */
static EcNode *parseLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    NonemptyLetBindingList (207) -a-
        VariableBinding -a,allowin-
        VariableBinding -noList,allowin- , NonemptyLetBindingList -a-

    Input

    AST
 */
static EcNode *parseNonemptyLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    YieldExpression (209)
        yield
        yield [no line break] ListExpression

    Input

    AST
 */
static EcNode *parseYieldExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    Rewrite compound assignment. Eg. given x += 3  rewrite as
        x = x + 3;
 */
static EcNode *rewriteCompoundAssignment(EcCompiler *cp, int subId, EcNode *lhs, EcNode *rhs)
{
    EcNode      *np, *parent;

    ENTER(cp);

    /*
        Map the operator token to its non-assignment counterpart
     */
    np = createNode(cp, N_BINARY_OP, NULL);
    np->tokenId = subId - 1;

    np = appendNode(np, lhs);
    np = appendNode(np, rhs);
    parent = createNode(cp, N_ASSIGN_OP, NULL);
    np = createAssignNode(cp, lhs, np, parent);

    return LEAVE(cp, np);
}


static void fixDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *elt;
    int         next;
    
    for (next = 0; (elt = mprGetNextItem(np->children, &next)) != 0 && !cp->error; ) {
        fixDassign(cp, elt);
    }
    if (np->kind == N_OBJECT_LITERAL) {
        np->kind = N_DASSIGN;
        np->kindName = "n_dassign";
    } else if (np->kind == N_FIELD) {
        if (np->field.expr) {
            fixDassign(cp, np->field.expr);
        }
    }
}


/*
    AssignmentExpression (211)
        ConditionalExpression
        Pattern -a,b-allowin- = AssignmentExpression -a,b-
        SimplePattern -a,b-allowExpr- CompoundAssignmentOperator
                AssignmentExpression -a,b-

    Where
        SimplePattern is:
            LeftHandSideExpression -a,b-
            Identifier
        ConditionalExpression is:
            LetExpression -b-
            YieldExpression -b-
            LogicalOrExpression -a,b-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new
        let
        yield

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
        N_DELETE
 */

static EcNode *parseAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    EcState     *state;
    int         subId;

    ENTER(cp);
    state = cp->state;

    np = parseConditionalExpression(cp);
    if (np) {
        if (peekToken(cp) == T_ASSIGN) {
            getToken(cp);
            if (np->kind == N_OBJECT_LITERAL || np->kind == N_EXPRESSIONS) {
                fixDassign(cp, np );
            }
            subId = cp->token->subId;
            if (cp->token->groupMask & G_COMPOUND_ASSIGN) {
                np = rewriteCompoundAssignment(cp, subId, np, parseAssignmentExpression(cp));

            } else {
                parent = createNode(cp, N_ASSIGN_OP, NULL);
                np = createAssignNode(cp, np, parseAssignmentExpression(cp), parent);
            }
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TODO - refactored
    CompoundAssignmentOperator (227)
        *=
        /=
        %=
        +=
        -=
        <<=
        >>=
        >>>=
        &=
        ^=
        |=
        &&=
        ||=

    Input (see above)

    AST
 */
static EcNode *parseCompoundAssignmentOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ListExpression (227)
        AssignmentExpression -allowList,b-
        ListExpression -b- , AssignmentExpression -allowList,b-

    Input
        x = ...

    AST
        N_EXPRESSIONS
 */
static EcNode *parseListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_EXPRESSIONS, NULL);
    mprAssert(np);
    do {
        np = appendNode(np, parseAssignmentExpression(cp));
    } while (np && getToken(cp) == T_COMMA);
    if (np) {
        putToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    Pattern -a,b,g- (231)
        SimplePattern -a,b-g-
        ObjectPattern
        ArrayPattern

    Input
        Identifier
        {
        [

    AST
 */
static EcNode *parsePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LBRACKET:
        np = parseArrayPattern(cp);
        break;

    case T_LBRACE:
        np = parseObjectPattern(cp);
        break;

    default:
        np = parseSimplePattern(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    SimplePattern -a,b,noExpr- (232)
        Identifier

    SimplePattern -a,b,noExpr- (233)
        LeftHandSideExpression -a,b-

    Input

    AST
        N_QNAME
        N_LIST_EXPRESSION
 */
static EcNode *parseSimplePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseLeftHandSideExpression(cp);
    if (np == 0 && peekToken(cp) == T_ID) {
        np = parseIdentifier(cp);
    }
    return LEAVE(cp, np);
}


/*
    ObjectPattern -g- (234)
        { FieldListPattern }

    Input

    AST
 */
static EcNode *parseObjectPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, expected(cp, "{"));
    }
    np = parseFieldListPattern(cp);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, expected(cp, "}"));
    }
    return LEAVE(cp, np);
}


/*
    FieldListPattern -g- (248)
        EMPTY
        FieldPattern
        FieldPattern , FieldPattern

    Input

    AST
 */
static EcNode *parseFieldListPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DASSIGN, NULL);
    while (1) {
        np = appendNode(np, parseFieldPattern(cp, np));
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    FieldPattern -g- (251)
        FieldName
        FieldName : Pattern -noList,allowin,g-

    Input

    AST
 */
static EcNode *parseFieldPattern(EcCompiler *cp, EcNode *np)
{
    EcNode      *typeNode, *elt;

    ENTER(cp);
    elt = parseFieldName(cp);
    np = appendNode(np, elt);
    if (peekToken(cp) == ':') {
        getToken(cp);
        typeNode = parsePattern(cp);
        if (typeNode) {
            elt->typeNode = linkNode(np, typeNode);
        }
    }
    return LEAVE(cp, np);
}


/*
    ArrayPattern (240)
        [ ElementListPattern ]

    Input

    AST
 */
static EcNode *parseArrayPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (getToken(cp) != T_LBRACKET) {
        return LEAVE(cp, expected(cp, "["));
    }
    np = parseElementListPattern(cp);
    if (getToken(cp) != T_RBRACKET) {
        return LEAVE(cp, expected(cp, "]"));
    }
    return LEAVE(cp, np);
}


/*
    ElementListPattern -g- (253)
        EMPTY
        ElementPattern
        , ElementListPattern
        ElementPattern , ElementListPattern

    Input

    AST
 */
static EcNode *parseElementListPattern(EcCompiler *cp)
{
    EcNode      *np, *elt;
    int         index;

    ENTER(cp);
    
    np = createNode(cp, N_DASSIGN, NULL);
    np->objectLiteral.isArray = 1;
    
    for (index = 0; np; index++) {
        if (peekToken(cp) != T_COMMA) {
            elt = createNode(cp, N_FIELD, NULL);
            elt->attributes |= EJS_TRAIT_READONLY;
            elt->field.varKind = KIND_CONST;
            elt->field.fieldKind = FIELD_KIND_VALUE;
            elt->field.expr = linkNode(np, parsePattern(cp));
            elt->qname.name = elt->field.expr->qname.name;
            elt->field.index = index;
            np = appendNode(np, elt);
        }
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedIdentifier(EcCompiler *cp)
{
    EcNode      *np, *typeNode;

    ENTER(cp);

    np = parseSimplePattern(cp);

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
        if (typeNode) {
            np->typeNode = linkNode(np, typeNode);
            /* Accumulate EJS_TRAIT_MATCH | EJS_TRAIT_NULLABLE */
            np->attributes |= typeNode->attributes;
        } else {
            np = parseError(cp, "Expecting type");
        }
    }
    return LEAVE(cp, np);
}


/*
    TypedPattern (248)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
#if UNUSED
    case T_LBRACKET:
        np = parseArrayPattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseTypeExpression(cp));
        }
        break;

    case T_LBRACE:
        np = parseObjectPattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseTypeExpression(cp));
        }
        break;
#endif

    default:
        np = parseSimplePattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseNullableTypeExpression(cp));
        }
        break;
    }
    if (np && np->kind != N_QNAME) {
        return LEAVE(cp, unexpected(cp));
    }
    return LEAVE(cp, np);
}


/*
    NullableTypeExpression (266)
        null
        undefined
        TypeExpression
        TypeExpression ?            # Nullable
        MOB REMOVE TypeExpression ! # Non-Nullable

    Input

    AST
 */
static EcNode *parseNullableTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_NULL:
    case T_UNDEFINED:
        np = createNode(cp, N_QNAME, tokenString(cp));
        np->name.isType = 1;
        break;

    default:
        np = parseTypeExpression(cp);
        if (peekToken(cp) == T_QUERY) {
            getToken(cp);
        } else if (cp->peekToken->tokenId == T_LOGICAL_NOT) {
            getToken(cp);
            np->attributes |= EJS_TRAIT_THROW_NULLS;
        } else if (cp->peekToken->tokenId == T_TILDE) {
            getToken(cp);
            np->attributes |= EJS_TRAIT_CAST_NULLS;
        }
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeExpression (271)
        FunctionType
        UnionType
        RecordType
        ArrayType
        PrimaryName

    Input
        function
        (
        {
        [
        Identifier

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parseTypeExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);

    ejs = cp->ejs;

    switch (peekToken(cp)) {
#if UNUSED
    case T_FUNCTION:
        np = appendNode(np, parseFunctionType(cp));
        break;

    case T_LPAREN:
        np = appendNode(np, parseUnionType(cp));
        break;

    case T_LBRACE:
        np = appendNode(np, parseRecordType(cp));
        break;

    case T_LBRACKET:
        appendNode(np, parseFunctionType(cp));
        break;
#endif

    case T_MUL:
        getToken(cp);
        np = createNode(cp, N_QNAME, ST(Object)->qname.name);
        np->name.isType = 1;
        break;

    case T_STRING:
    case T_ID:
        np = parsePrimaryName(cp);
        if (np) {
            np->name.isType = 1;
        }
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    FunctionType (276)
        function FunctionSignatureType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FunctionSignatureType (277)
        TypeParameters ( ParametersType ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionSignatureType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ParametersType (280)
        EMPTY
        NonemptyParametersType

    Input

    AST
 */
static EcNode *parseParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyParametersType (282)
        ParameterInitType
        ParameterInitType , NonemptyParametersType
        RestParameterType

    Input

    AST
 */
static EcNode *parseNonemptyParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ParameterInitType (285)
        ParameterType
        ParameterType =

    Input

    AST
 */
static EcNode *parseParameterInitType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    RestParameterType (288)
        ...
        ... ParameterType

    Input
        ...

    AST
 */
static EcNode *parseRestParameterType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    UnionType (290)
        ( TypeExpressionList )

    Input
        (

    AST
 */
static EcNode *parseUnionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    RecordType (291)
        { FieldTypeList }

    Input
        {

    AST
 */
static EcNode *parseRecordType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FieldTypeList (292)
        EMPTY
        NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyFieldTypeList (294)
        FieldType
        FieldType , NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseNonemptyFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FieldType (296)
        FieldName : NullableTypeExpression

    Input

    AST
 */
static EcNode *parseFieldType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ArrayType (297)
        [ ElementTypeList ]

    Input

    AST
 */
static EcNode *parseArrayType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LBRACKET) {
        np = expected(cp, "[");
    } else {
        np = parseElementTypeList(cp);
        if (np) {
            if (getToken(cp) != T_LBRACKET) {
                np = expected(cp, "[");
            }
        }
    }

    return LEAVE(cp, np);
}


/*
    ElementTypeList (298)
        EMPTY
        NullableTypeExpression
        , ElementTypeList
        NullableTypeExpression , ElementTypeList

    Input

    AST
 */
static EcNode *parseElementTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


#if FUTURE
/*
    TypeExpressionList (302)
        NullableTypeExpression
        TypeExpressionList , NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Statement (289) -t,o-
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE

 */
static EcNode *parseStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         expectSemi, tid;

    ENTER(cp);

    expectSemi = 0;
    np = 0;

    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_DELETE:
    case T_DIV:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FUNCTION:
    case T_LBRACKET:
    case T_LOGICAL_NOT:
    case T_LPAREN:
    case T_MINUS_MINUS:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_PLUS_PLUS:
    case T_STRING:
    case T_SUPER:
    case T_THIS:
    case T_TRUE:
    case T_TYPEOF:
    case T_RESERVED_NAMESPACE:
    case T_REQUIRE:                             /* require used as an identifier */
        np = parseExpressionStatement(cp);
        expectSemi++;
        break;

    case T_BREAK:
        np = parseBreakStatement(cp);
        expectSemi++;
        break;

    case T_CONTINUE:
        np = parseContinueStatement(cp);
        expectSemi++;
        break;

    case T_DO:
        np = parseDoStatement(cp);
        expectSemi++;
        break;

    case T_FOR:
        np = parseForStatement(cp);
        break;

    case T_HASH:
        np = parseHashStatement(cp);
        break;

    case T_ID:
        if (tid == T_ID && peekAheadToken(cp, 2) == T_COLON) {
            np = parseLabeledStatement(cp);
        } else {
            np = parseExpressionStatement(cp);
            expectSemi++;
        }
        break;

    case T_IF:
        np = parseIfStatement(cp);
        break;

    case T_LBRACE:
        np = parseBlockStatement(cp);
        break;

    case T_LET:
        np = parseLetStatement(cp);
        break;

    case T_RETURN:
        np = parseReturnStatement(cp);
        expectSemi++;
        break;

    case T_SWITCH:
        np = parseSwitchStatement(cp);
        break;

    case T_THROW:
        np = parseThrowStatement(cp);
        expectSemi++;
        break;

    case T_TRY:
        np = parseTryStatement(cp);
        break;

    case T_WHILE:
        np = parseWhileStatement(cp);
        break;

    case T_WITH:
        np = parseWithStatement(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }

    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->loc.lineNumber < cp->token->loc.lineNumber || cp->token->tokenId == T_EOF || 
                    cp->token->tokenId == T_NOP || cp->token->tokenId == T_RBRACE) {
                putToken(cp);
            } else {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Substatement -o- (320)
        EmptyStatement
        Statement -o-

    Statement:
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_NOP
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */

static EcNode *parseSubstatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    np = 0;

    /*
        TODO: Missing: DefaultXML
     */
    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_BREAK:
    case T_CONTINUE:
    case T_DO:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FOR:
    case T_FUNCTION:
    case T_IF:
    case T_LBRACE:
    case T_LBRACKET:
    case T_LET:
    case T_LPAREN:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_RETURN:
    case T_STRING:
    case T_SUPER:
    case T_SWITCH:
    case T_THIS:
    case T_THROW:
    case T_TRUE:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (peekAheadToken(cp, 2) == T_COLON) {
            /* Labeled expression */
            np = parseStatement(cp);
        } else {
            np = parseStatement(cp);
        }
        break;

    default:
        np = createNode(cp, N_NOP, NULL);
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    Semicolon -abbrev- (322)
        ;
        VirtualSemicolon
        EMPTY

    Semicolon -noshortif- (325)
        ;
        VirtualSemicolon
        EMPTY

    Input

    AST
 */
static EcNode *parseSemicolon(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    EmptyStatement (33)
        ;

    Input
        EMPTY

    AST
        N_NOP
 */
static EcNode *parseEmptyStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = createNode(cp, N_NOP, NULL);
    return LEAVE(cp, np);
}


/*
    ExpressionStatement (331)
        [lookahead !function,{}] ListExpression -allowin-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        delete
        Identifier
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_DELETE
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_EXPRESSIONS
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseExpressionStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);
    tid = peekToken(cp);
    if (tid == T_FUNCTION || tid == T_LBRACE) {
        np = createNode(cp, 0, NULL);
    } else {
        np = parseListExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    BlockStatement (318)
        Block

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlockStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseBlock(cp);
    return LEAVE(cp, np);
}


/*
    LabeledStatement -o- (319)
        Identifier : Substatement

    Input

    AST
 */
static EcNode *parseLabeledStatement(EcCompiler *cp)
{
    getToken(cp);
    return parseError(cp, "Labeled statements are not yet implemented");
}


/*
    IfStatement -abbrev- (320)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -full- (322)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -noShortif- (324)
        if ParenListExpression Substatement else Substatement

    Input
        if ...

    AST
 */
static EcNode *parseIfStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_IF) {
        return LEAVE(cp, parseError(cp, "Expecting \"if\""));
    }
    if (peekToken(cp) != T_LPAREN) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np = createNode(cp, N_IF, NULL);
    if ((np->tenary.cond = linkNode(np, parseParenListExpression(cp))) == 0) {
        return LEAVE(cp, 0);
    }
    if ((np->tenary.thenBlock = linkNode(np, parseSubstatement(cp))) == 0) {
        return LEAVE(cp, 0);
    }
    if (peekToken(cp) == T_ELSE) {
        getToken(cp);
        np->tenary.elseBlock = linkNode(np, parseSubstatement(cp));
    }
    return LEAVE(cp, np);
}


/*
    SwitchStatement (328)
        switch ParenListExpression { CaseElements }
        switch type ( ListExpression -allowList,allowin- : TypeExpression )
                { TypeCaseElements }

    Input
        switch ...

    AST
        N_SWITCH
            N_EXPRESSIONS           ( ListExpression )
            N_CASE_ELEMENTS
 */
static EcNode *parseSwitchStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_SWITCH, NULL);

    if (getToken(cp) != T_SWITCH) {
        np = unexpected(cp);
    } else {
        if (peekToken(cp) != T_TYPE) {
            np = appendNode(np, parseParenListExpression(cp));
            if (getToken(cp) != T_LBRACE) {
                np = parseError(cp, "Expecting \"{\"");
            } else {
                np = appendNode(np, parseCaseElements(cp));
                if (getToken(cp) != T_RBRACE) {
                    np = parseError(cp, "Expecting \"{\"");
                }
            }

        } else {
#if FUTURE
            //  switch type
            getToken(cp);
            if (getToken(cp) != T_LPAREN) {
                np = parseError(cp, "Expecting \"(\"");
            } else {
                x = parseListExpression(cp);
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    x = parseTypeExpression(cp);
                    if (getToken(cp) != T_RPAREN) {
                        np = parseError(cp, "Expecting \")\"");
                    } else  if (getToken(cp) != T_LBRACE) {
                        np = parseError(cp, "Expecting \"{\"");
                    } else {
                        x = parseTypeCaseElements(cp);
                        if (getToken(cp) != T_RBRACE) {
                            np = parseError(cp, "Expecting \"}\"");
                        }
                    }
                }
                parseListExpression(cp);
            }
#endif
        }
    }
    return LEAVE(cp, np);
}


/*
    CaseElements (342)
        EMPTY
        CaseLabel
        CaseLabel CaseElementsPrefix CaseLabel
        CaseLabel CaseElementsPrefix Directive -abbrev-

    Refactored as:
        EMPTY
        CaseLable Directives
        CaseElements

    Input
        case
        default

    AST
        N_CASE_ELEMENTS
            N_CASE_LABEL: kind, expression
 */
static EcNode *parseCaseElements(EcCompiler *cp)
{
    EcNode      *np, *caseLabel, *directives;

    ENTER(cp);

    np = createNode(cp, N_CASE_ELEMENTS, NULL);

    while (np && (peekToken(cp) == T_CASE || cp->peekToken->tokenId == T_DEFAULT)) {
        caseLabel = parseCaseLabel(cp);
        directives = createNode(cp, N_DIRECTIVES, NULL);
        caseLabel = appendNode(caseLabel, directives);

        while (caseLabel && directives && peekToken(cp) != T_CASE && cp->peekToken->tokenId != T_DEFAULT) {
            if (cp->peekToken->tokenId == T_RBRACE) {
                break;
            }
            directives = appendNode(directives, parseDirective(cp));
        }
        np = appendNode(np, caseLabel);
    }
    return LEAVE(cp, np);
}


#if UNUSED && NOT_REQUIRED
/*
    CaseElementsPrefix (346)
        EMPTY
        CaseElementsPrefix CaseLabel
        CaseElementsPrefix Directive -full-

    Input

    AST
 */
static EcNode *parseCaseElementsPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    CaseLabel (349)
        case ListExpression -allowin- :
        default :

    Input
        case .. :
        default :

    AST
        N_CASE_LABEL  kind, expression
 */
static EcNode *parseCaseLabel(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;

    if (peekToken(cp) == T_CASE) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL, NULL);
        np->caseLabel.kind = EC_SWITCH_KIND_CASE;
        if ((np->caseLabel.expression = linkNode(np, parseListExpression(cp))) == 0) {
            return LEAVE(cp, np);
        }
    } else if (cp->peekToken->tokenId == T_DEFAULT) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL, NULL);
        np->caseLabel.kind = EC_SWITCH_KIND_DEFAULT;
    }
    if (getToken(cp) != T_COLON) {
        np = expected(cp, ":");
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeCaseElements (351)
        TypeCaseElement
        TypeCaseElement TypeCaseElement

    Input

    AST
 */
static EcNode *parseTypeCaseElements(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    TypeCaseElement (353)
        case ( TypedPattern -noList,noIn- ) Block -local-
        default Block -local-

    Input

    AST
 */
static EcNode *parseTypeCaseElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    DoStatement (355)
        do Substatement -abbrev- while ParenListExpresison

    Input
        do

    AST
        N_FOR
 */
static EcNode *parseDoStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DO, NULL);

    if (getToken(cp) != T_DO) {
        return LEAVE(cp, unexpected(cp));
    }
    np->forLoop.body = linkNode(np, parseSubstatement(cp));

    if (getToken(cp) != T_WHILE) {
        np = expected(cp, "while");
    } else {
        np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    }
    return LEAVE(cp, np);
}


/*
    WhileStatement (356)
        while ParenListExpresison Substatement -o-

    Input
        while

    AST
        N_FOR
 */
static EcNode *parseWhileStatement(EcCompiler *cp)
{
    EcNode      *np, *initializer;

    ENTER(cp);

    initializer = 0;

    if (getToken(cp) != T_WHILE) {
        return LEAVE(cp, parseError(cp, "Expecting \"while\""));
    }
    /*
        Convert into a "for" AST
     */
    np = createNode(cp, N_FOR, NULL);
    np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    np->forLoop.body = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ForStatement -o- (357)
        for ( ForInitializer ; OptionalExpression ; OptionalExpression )
                Substatement
        for ( ForInBinding in ListExpression -allowin- ) Substatement
        for each ( ForInBinding in ListExpression -allowin- ) Substatement

    Where:

    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    VariableDefinition -b- (429)
        VariableDefinitionKind VariableBindingList -allowList,b-

    VariableDefinitionKind (430)
        const
        let
        let const
        var

    MemberExpression Input tokens
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Input
        for ( 'const|let|let const|var' '[|{'

    AST
        N_FOR
        N_FOR_IN
 */
static EcNode *parseForStatement(EcCompiler *cp)
{
    EcNode      *np, *initializer, *body, *iterGet, *block, *callGet, *dot;
    Ejs         *ejs;
    int         each, forIn;

    ENTER(cp);

    ejs = cp->ejs;
    initializer = 0;
    np = 0;
    forIn = 0;
    each = 0;

    if (getToken(cp) != T_FOR) {
        return LEAVE(cp, parseError(cp, "Expecting \"for\""));
    }
    if (peekToken(cp) == T_EACH) {
        each++;
        getToken(cp);
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    if (peekToken(cp) == T_ID && peekAheadToken(cp, 2) == T_IN) {
        /*
            For in forces the variable to be a let scoped var
         */
        initializer = createNode(cp, N_VAR_DEFINITION, NULL);
        if (initializer) {
            initializer->def.varKind = KIND_LET;
            initializer = parseVariableBindingList(cp, initializer, 0);
        }

    } else if (peekToken(cp) == T_CONST || cp->peekToken->tokenId == T_LET || cp->peekToken->tokenId == T_VAR) {
        initializer = parseVariableDefinition(cp, 0);

    } else if (cp->peekToken->tokenId != T_SEMICOLON) {
        cp->state->noin = 1;
        initializer = parseListExpression(cp);
    }
    if (initializer == 0 && cp->error) {
        return LEAVE(cp, 0);
    }
    if (initializer && mprGetListLength(initializer->children) > 2) {
        return LEAVE(cp, parseError(cp, "Too many iteration variables"));
    }
    if (getToken(cp) == T_SEMICOLON) {
        forIn = 0;
        np = createNode(cp, N_FOR, NULL);
        np->forLoop.initializer = linkNode(np, initializer);
        if (peekToken(cp) != T_SEMICOLON) {
            np->forLoop.cond = linkNode(np, parseOptionalExpression(cp));
        }
        if (getToken(cp) != T_SEMICOLON) {
            np = parseError(cp, "Expecting \";\"");
        } else if (peekToken(cp) != T_RPAREN) {
            np->forLoop.perLoop = linkNode(np, parseOptionalExpression(cp));
        }

    } else if (cp->token->tokenId == T_IN) {
        forIn = 1;
        np = createNode(cp, N_FOR_IN, NULL);
        np->forInLoop.iterVar = linkNode(np, initializer);

        /*
            Create a "listExpression.get/values" node
         */
        dot = createNode(cp, N_DOT, NULL);
        iterGet = appendNode(dot, parseListExpression(cp));
        iterGet = appendNode(iterGet, createNameNode(cp, N(EJS_ITERATOR_NAMESPACE, (each) ? "getValues" : "get")));

        /*
            Create a call node for "get"
         */
        callGet = createNode(cp, N_CALL, NULL);
        callGet = appendNode(callGet, iterGet);
        callGet = appendNode(callGet, createNode(cp, N_ARGS, NULL));
        np->forInLoop.iterGet = linkNode(np, callGet);

        np->forInLoop.iterNext = linkNode(np, createNode(cp, N_NOP, NULL));

        if (np->forInLoop.iterVar == 0 || np->forInLoop.iterGet == 0) {
            return LEAVE(cp, 0);
        }

    } else {
        return LEAVE(cp, unexpected(cp));
    }
    if (getToken(cp) != T_RPAREN) {
        np = parseError(cp, "Expecting \")\"");
    }
    body = linkNode(np, parseSubstatement(cp));
    if (body == 0) {
        return LEAVE(cp, body);
    }

    /*
        Fixup the body block and move it outside the entire for loop.
     */
    if (body->kind == N_BLOCK) {
        block = body;
        body = removeNode(block, block->left);
    } else {
        block = createNode(cp, N_BLOCK, NULL);
    }
    if (forIn) {
        np->forInLoop.body = linkNode(np, body);
        np->forInLoop.each = each;
    } else {
        if (each) {
            return LEAVE(cp, parseError(cp, "\"for each\" can only be used with \"for .. in\""));
        }
        mprAssert(np != body);
        np->forLoop.body = linkNode(np, body);
    }

    /*
        Now make the for loop node a child of the outer block. Block will initially be a child of np, so must re-parent first
     */
    mprAssert(block != np);
    np = appendNode(block, np);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    Input

    AST
 */
static EcNode *parseForInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    Input

    AST
 */
static EcNode *parseForInBinding(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    HashStatement (EJS)
        # ListExpression

    Input
        # expression directive

    AST
        N_HASH
 */
static EcNode *parseHashStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_HASH) {
        return LEAVE(cp, parseError(cp, "Expecting \"#\""));
    }
    np = createNode(cp, N_HASH, NULL);
    np->hash.expr = linkNode(np, parseListExpression(cp));
    np->hash.body = linkNode(np, parseDirective(cp));
    return LEAVE(cp, np);
}


/*
    LetStatement (367)
        let ( LetBindingList ) Substatement -o-

    Input

    AST
 */
static EcNode *parseLetStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    WithStatement -o- (368)
        with ( ListExpression -allowin- ) Substatement -o-
        with ( ListExpression -allowin- : TypeExpression ) Substatement -o-

    Input

    AST
 */
static EcNode *parseWithStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_WITH) {
        return LEAVE(cp, expected(cp, "with"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = createNode(cp, N_WITH, NULL);
    np->with.object = linkNode(np, parseListExpression(cp));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    np->with.statement = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ContinueStatement (370)
        continue
        continue [no line break] Identifier

    Input
        continue

    AST
        N_CONTINUE
 */
static EcNode *parseContinueStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_CONTINUE) {
        np = expected(cp, "continue");
    } else {
        np = createNode(cp, N_CONTINUE, NULL);
        lineNumber = cp->token->loc.lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->loc.lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    BreakStatement (372)
        break
        break [no line break] Identifier

    Input
        break

    AST
        N_BREAK
 */
static EcNode *parseBreakStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_BREAK) {
        np = expected(cp, "break");
    } else {
        np = createNode(cp, N_BREAK, NULL);
        lineNumber = cp->token->loc.lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->loc.lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    ReturnStatement (374)
        return
        return [no line break] ListExpression -allowin-

    Input
        return ...

    AST
        N_RETURN
 */
static EcNode *parseReturnStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_RETURN) {
        np = unexpected(cp);
    } else {
        if (cp->state->currentFunctionNode == 0) {
            np = parseError(cp, "Return statement outside function");
        } else {
            np = createNode(cp, N_RETURN, NULL);
            if (peekToken(cp) != T_SEMICOLON && np->loc.lineNumber == cp->peekToken->loc.lineNumber) {
                np = appendNode(np, parseListExpression(cp));
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ThrowStatement (376)
        throw ListExpression -allowin-

    Input
        throw ...

    AST
 */
static EcNode *parseThrowStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THROW) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_THROW, NULL);
    np = appendNode(np, parseListExpression(cp));
    return LEAVE(cp, np);
}


/*
    TryStatement (377)
        try Block -local- CatchClauses
        try Block -local- CatchClauses finally Block -local-
        try Block -local- finally Block -local-

    Input
        try ...

    AST
 */
static EcNode *parseTryStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    /*
        Just ignore try / catch for now
     */
    if (getToken(cp) != T_TRY) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_TRY, NULL);
    if (np) {
        np->exception.tryBlock = linkNode(np, parseBlock(cp));
        if (peekToken(cp) == T_CATCH) {
            np->exception.catchClauses = linkNode(np, parseCatchClauses(cp));
        }
        if (peekToken(cp) == T_FINALLY) {
            getToken(cp);
            np->exception.finallyBlock = linkNode(np, parseBlock(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    CatchClauses (380)
        CatchClause
        CatchClauses CatchClause

    Input
        catch
 */
static EcNode *parseCatchClauses(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_CATCH) {
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_CATCH_CLAUSES, NULL);
    do {
        np = appendNode(np, parseCatchClause(cp));
    } while (peekToken(cp) == T_CATCH);
    return LEAVE(cp, np);
}


/*
    CatchClause (382)
        catch ( Parameter ) Block -local-

    Input
        catch

    AST
        T_CATCH
 */
static EcNode *parseCatchClause(EcCompiler *cp)
{
    EcNode      *np, *block, *arg, *varDef, *assign, *name;

    ENTER(cp);


    if (getToken(cp) != T_CATCH) {
        return LEAVE(cp, unexpected(cp));
    }

    np = createNode(cp, N_CATCH, NULL);

    /*
        EJS enhancement: allow no (Parameter)
     */
    varDef = 0;
    arg = 0;
    if (peekToken(cp) == T_LPAREN) {
        getToken(cp);
        varDef = parseParameter(cp, 0);
        if (getToken(cp) != T_RPAREN) {
            return LEAVE(cp, unexpected(cp));
        }
        if (varDef) {
            mprAssert(varDef->kind == N_VAR_DEFINITION);
            varDef->def.varKind = KIND_LET;
            arg = varDef->left;
            removeNode(varDef, arg);
            mprAssert(arg->kind == N_QNAME);
            arg->kind = N_VAR;
            arg->name.varKind = KIND_LET;
            arg->kindName = "n_var";
            arg->qname.space = cp->state->nspace;

            /* Create assignment node */
            name = createNode(cp, N_QNAME, arg->qname.name);
            assign = appendNode(createNode(cp, N_ASSIGN_OP, NULL), name);
            assign = appendNode(assign, createNode(cp, N_CATCH_ARG, NULL));
            arg = appendNode(arg, assign);
            varDef = appendNode(varDef, arg);
#if UNUSED
            parent = createNode(cp, N_ASSIGN_OP, NULL);
            arg = createAssignNode(cp, arg, createNode(cp, N_CATCH_ARG, NULL), parent);
            varDef = appendNode(varDef, arg);
#endif
        }
    }
    np->catchBlock.arg = varDef;

    block = parseBlock(cp);
    if (block) {
        if (varDef) {
            block = insertNode(block, varDef, 0);
        }
    }
    np = appendNode(np, block);
    return LEAVE(cp, np);
}


/* -t- == global, class, interface, local */

/*
    Directives -t- (367)
        EMPTY
        DirectivesPrefix Directive -t,abbrev-

    Input
        #
        import
        use
        {
        (
        break
        continue
        ?? DefaultXML
        do
        ?? ExpressionS
        for
        if
        label :
        let
        new
        return
        switch
        throw
        try
        while
        with
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module

    AST
        N_DIRECTIVES
 */
static EcNode *parseDirectives(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *saveState;
    EcState     *state;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES, NULL);
    state = cp->state;
    state->topVarBlockNode = np;

    saveState = cp->directiveState;
    cp->directiveState = state;
    state->blockNestCount++;

    do {
        switch (peekToken(cp)) {
        case T_ERR:
            cp->directiveState = saveState;
            getToken(cp);
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_REQUIRE:
            if (peekAheadToken(cp, 2) != T_ID && peekAheadToken(cp, 2) != T_STRING) {
                np = appendNode(np, parseDirective(cp));
            } else {
                np = appendNode(np, parseDirectivesPrefix(cp));
            }
            break;

        case T_USE:
            np = appendNode(np, parseDirectivesPrefix(cp));
            break;

        case T_RBRACE:
            if (state->blockNestCount == 1) {
                getToken(cp);
            }
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_SEMICOLON:
            getToken(cp);
            break;

        case T_ATTRIBUTE:
        case T_BREAK:
        case T_CLASS:
        case T_CONST:
        case T_CONTINUE:
        case T_DELETE:
        case T_DIV:
        case T_DO:
        case T_DOT:
        case T_FALSE:
        case T_FOR:
        case T_FINAL:
        case T_FUNCTION:
        case T_HASH:
        case T_ID:
        case T_IF:
        case T_INTERFACE:
        case T_MINUS_MINUS:
        case T_LBRACKET:
        case T_LBRACE:
        case T_LPAREN:
        case T_LET:
        case T_NAMESPACE:
        case T_NATIVE:
        case T_NEW:
        case T_LOGICAL_NOT:
        case T_NUMBER:
        case T_RESERVED_NAMESPACE:
        case T_RETURN:
        case T_PLUS_PLUS:
        case T_STRING:
        case T_SUPER:
        case T_SWITCH:
        case T_THIS:
        case T_THROW:
        case T_TRUE:
        case T_TRY:
        case T_TYPEOF:
        case T_VAR:
        case T_WHILE:
        case T_MODULE:
        case T_WITH:
            np = appendNode(np, parseDirective(cp));
            break;

        case T_NOP:
            if (state->blockNestCount == 1) {
                getToken(cp);
                break;
            } else {
                /*
                    NOP tokens are injected when reading from the console. If nested, eat all input and continue.
                 */
                ecResetInput(cp);
            }
            break;

        default:
            getToken(cp);
            np = unexpected(cp);
            cp->directiveState = saveState;
            return LEAVE(cp, np);
        }

        if (cp->error && !cp->fatalError) {
            np = ecResetError(cp, np, 1);
        }
    } while (np && (!cp->interactive || state->blockNestCount > 1));

    cp->directiveState = saveState;
    return LEAVE(cp, np);
}


/*
    DirectivesPrefix -t- (369)
        EMPTY
        Pragmas
        DirectivesPrefix Directive -t,full-

    Rewritten as:
        DirectivesPrefix

    Input
        use
        import

    AST
        N_PRAGMAS
 */
static EcNode *parseDirectivesPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_PRAGMAS, NULL);
    do {
        switch (peekToken(cp)) {
        case T_ERR:
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            return LEAVE(cp, np);

        case T_USE:
        case T_REQUIRE:
            np = parsePragmas(cp, np);
            break;

        default:
            return LEAVE(cp, np);
        }
        if (!(peekToken(cp) == T_REQUIRE && (peekAheadToken(cp, 2) == T_ID || peekAheadToken(cp, 2) == T_STRING))) {
            break;
        }
    } while (np);
    return LEAVE(cp, np);
}


/*
    Scan ahead and see if this is an annotatable directive
 */
static int isAttribute(EcCompiler *cp)
{
    int     i, tid;

    /*
        Assume we have just seen an ID. Handle the following patterns:
            nspace var
            nspace function
            nspace class
            nspace interface
            nspace let
            nspace const
            nspace type
            nspace namespace
            a.nspace namespace
            a.b.c.nspace::nspace namespace
     */
    for (i = 2; i < EC_MAX_LOOK_AHEAD + 2; i++) {
        peekAheadToken(cp, i);
        tid = cp->peekToken->tokenId;
        switch (tid) {
        case T_ATTRIBUTE:
        case T_CLASS:
        case T_CONST:
        case T_FUNCTION:
        case T_INTERFACE:
        case T_LET:
        case T_MUL:
        case T_NAMESPACE:
        case T_RESERVED_NAMESPACE:
        case T_TYPE:
        case T_VAR:
            return 1;

        case T_COLON_COLON:
        case T_DOT:
            break;

        default:
            return 0;
        }

        /*
            Just saw a "." or "::".  Make sure this is part of a PropertyName
         */
        tid = peekAheadToken(cp, ++i);
        if (tid != T_ID && tid != T_RESERVED_NAMESPACE && tid == T_MUL && tid != T_STRING && tid != T_NUMBER &&
                tid != T_LBRACKET && !(cp->peekToken->groupMask & G_RESERVED)) {
            return 0;
        }
    }
    return 0;
}


/*
    Directive -t,o- (372)
        EmptyStatement
        Statement
        AnnotatableDirective -t,o-

    Input
        #
        {
        break
        continue
        ?? DefaultXML
        do
        ?? Expressions
        for
        if
        label :
        let
        return
        switch
        throw
        try
        while
        with
        *
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */
static EcNode *parseDirective(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_EOF:
        getToken(cp);
        return LEAVE(cp, 0);

    case T_ERR:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));

    /* EmptyStatement */
    case T_SEMICOLON:
        getToken(cp);
        np = parseEmptyStatement(cp);
        break;

    /* Statement */
    /*
        TBD -- missing:
            - DefaultXMLNamespaceStatement
            - ExpressionStatement
            - LabeledStatement
     */
    case T_LBRACE:
    case T_BREAK:
    case T_CONTINUE:
    case T_DELETE:
    case T_DO:
    case T_FOR:
    case T_HASH:
    case T_IF:
    case T_RETURN:
    case T_SUPER:
    case T_SWITCH:
    case T_THROW:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (isAttribute(cp)) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

    case T_RESERVED_NAMESPACE:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parseStatement(cp);
            break;
        }
        /* Fall through */
                
    /* AnnotatableDirective */
    case T_ATTRIBUTE:
    case T_CLASS:
    case T_CONST:
    case T_FUNCTION:
    case T_INTERFACE:
    case T_LET:
    case T_MUL:
    case T_NAMESPACE:
    case T_TYPE:
    case T_MODULE:
    case T_VAR:
        np = parseAnnotatableDirective(cp, 0);
        break;

    case T_STRING:
        //  TDOO - should we test let ...?
        if (peekAheadToken(cp, 2) == T_VAR || peekAheadToken(cp, 2) == T_CLASS || peekAheadToken(cp, 2) == T_FUNCTION) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

#if FUTURE
    /* IncludeDirective */
    case T_INCLUDE:
        np = parseIncludeStatement(cp);
        break;
#endif

    default:
        np = parseStatement(cp);
    }
    return LEAVE(cp, np);
}


/*
    AnnotatableDirective -global,o- (375)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDefinition -global-
        ClassDefinition
        InterfaceDefintion
        NamespaceDefinition Semicolon -o-
        TypeDefinition Semicolon
        PackageDefinition
        ModuleDefinition

    AnnotatableDirective -interface,o- (384)
        Attributes [no line break] AnnotatableDirective -t,o-
        FunctionDeclaration Semicolon -o-
        TypeDefinition Semicolon -o-

    AnnotatableDirective -t,o- (387)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDeclaration -t-
        NamespaceDefintion Semicolon -o-
        TypeDefinition Semicolon -o-

    Input
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module
        package

    AST
        N_CLASS
        N_FUNCTION
        N_QNAME
        N_NAMESPACE
        N_VAR_DEFINITION
        N_MODULE??
 */
static EcNode *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes)
{
    EcState     *state;
    EcNode      *nextAttribute, *np;
    int         expectSemi;

    ENTER(cp);

    np = 0;
    expectSemi = 0;
    state = cp->state;

    switch (peekToken(cp)) {

    /* Attributes AnnotatableDirective */
    case T_STRING:
    case T_ATTRIBUTE:
    case T_RESERVED_NAMESPACE:
    case T_ID:
        nextAttribute = parseAttribute(cp);
        if (nextAttribute) {
            getToken(cp);
            if (nextAttribute->loc.lineNumber < cp->token->loc.lineNumber) {
                /* Must be no line break after the attribute */
                return LEAVE(cp, unexpected(cp));
            }
            putToken(cp);
            /*
                Aggregate the attributes and pass in. Must do this to allow "private static var a, b, c"
             */
            if (attributes) {
                nextAttribute->attributes |= attributes->attributes;
                if (attributes->qname.space && nextAttribute->qname.space) {
                    return LEAVE(cp, parseError(cp, "Can't define multiple namespaces for directive"));
                }
                if (attributes->qname.space) {
                    nextAttribute->qname.space = attributes->qname.space;
                }
            }
            np = parseAnnotatableDirective(cp, nextAttribute);
        }
        break;

    case T_CONST:
    case T_LET:
    case T_VAR:
        np = parseVariableDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_FUNCTION:
        if (state->inInterface) {
            np = parseFunctionDeclaration(cp, attributes);
        } else {
            np = parseFunctionDefinition(cp, attributes);
        }
        break;

    case T_CLASS:
#if OLD && UNUSED
        if (state->inClass == 0) {
            /* Nested classes are not supported */
            np = parseClassDefinition(cp, attributes);
        } else {
            getToken(cp);
            np = unexpected(cp);
        }
#else
            np = parseClassDefinition(cp, attributes);
#endif
        break;

    case T_INTERFACE:
        if (state->inClass == 0) {
            np = parseInterfaceDefinition(cp, attributes);
        } else {
            np = unexpected(cp);
        }
        break;

    case T_NAMESPACE:
        np = parseNamespaceDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_TYPE:
        np = parseTypeDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_MODULE:
        np = parseModuleDefinition(cp);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Unknown directive \"%s\"", cp->token->text);
    }
    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->loc.lineNumber < cp->token->loc.lineNumber || cp->token->tokenId == T_EOF) {
                putToken(cp);
            } else if (cp->token->tokenId != T_NOP) {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Attribute -global- (391)
        NamespaceAttribute
        dynamic
        final
        native
        [ AssignmentExpression allowList,allowIn]

    Attribute -class- (396)
        NamespaceAttribute
        final
        native
        override
        prototype
        static
        [ AssignmentExpression allowList,allowIn]

    Attribute -interface- (419)
        NamespaceAttribute

    Attribute -local- (420)
        NamespaceAttribute

    Input -common-
        NamespaceAttribute
            Path . Identifier
            Identifier
            public
            internal
        final
        native
        [

    Input -global-
        NamespaceAttribute -global-
            intrinsic
        dynamic

    Input -class-
        NamespaceAttribute -class-
            intrinsic
            private
            protected
        override
        prototype
        static

    AST
        N_ATTRIBUTES
            attribute
                flags
            attributes
 */
static EcNode *parseAttribute(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state;
    int         inClass, inInterface, subId;

    ENTER(cp);

    state = cp->state;
    inClass =state->inClass ? 1 : 0;
    inInterface = state->inInterface ? 1 : 0;
    np = 0;

    if (state->inFunction) {
        np = parseNamespaceAttribute(cp);
        return LEAVE(cp, np);
    }

    peekToken(cp);
    subId = cp->peekToken->subId;
    switch (cp->peekToken->tokenId) {
    case T_ID:
    case T_RESERVED_NAMESPACE:
    case T_STRING:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            getToken(cp);
            return LEAVE(cp, parseError(cp, "Can't use private or protected in this context"));
        }
        np = parseNamespaceAttribute(cp);
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES, NULL);
        switch (cp->token->subId) {
        case T_DYNAMIC:
            if (inClass || inInterface) {
                np = unexpected(cp);
            } else {
                np->attributes |= EJS_TYPE_DYNAMIC_INSTANCE;
            }
            break;

        case T_FINAL:
            np->attributes |= EJS_TYPE_FINAL;
            break;

        case T_NATIVE:
            np->attributes |= EJS_PROP_NATIVE;
            break;

#if UNUSED
        case T_ORPHAN:
            if (inClass || inInterface) {
                np = unexpected(cp);
            } else {
                np->attributes |= EJS_TYPE_ORPHAN;
            }
            break;
#endif
        case T_OVERRIDE:
            if (inClass || inInterface) {
                np->attributes |= EJS_FUN_OVERRIDE;
            } else {
                np = unexpected(cp);
            }
            break;

#if UNUSED
        case T_SHARED:
            np->attributes |= EJS_PROP_SHARED;
            break;
#endif

        case T_STATIC:
            if (inClass || inInterface) {
                np->attributes |= EJS_PROP_STATIC;
            } else {
                np = unexpected(cp);
            }
            break;

        case T_ENUMERABLE:
            np->attributes |= EJS_PROP_ENUMERABLE;
            break;

        default:
            np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        }
        break;

    case T_LBRACKET:
        np = appendNode(np, parseAssignmentExpression(cp));
        break;

    default:
        np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        break;
    }
    return LEAVE(cp, np);
}


/*
    NamespaceAttribute -global- (405)
        public
        internal
        intrinsic
        PrimaryName

    NamespaceAttribute -class- (409)
        ReservedNamespace
        PrimaryName

    Input -common-
        Identifier
        internal
        public

    Input -global-
        intrinsic

    Input -class-
        intrinsic
        private
        protected

    AST
        N_ATTRIBUTES
            attribute
                flags
            left: N_QNAME | N_DOT
 */
static EcNode *parseNamespaceAttribute(EcCompiler *cp)
{
    EcNode      *np, *qualifier;
    int         inClass, subId;

    ENTER(cp);

    inClass = (cp->state->inClass) ? 1 : 0;
    peekToken(cp);
    subId = cp->peekToken->subId;

    np = createNode(cp, N_ATTRIBUTES, NULL);
    np->loc.lineNumber = cp->peekToken->loc.lineNumber;

    switch (cp->peekToken->tokenId) {
    case T_RESERVED_NAMESPACE:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            getToken(cp);
            return LEAVE(cp, unexpected(cp));
        }
        qualifier = parseReservedNamespace(cp);
        np->attributes = qualifier->attributes;
        np->specialNamespace = qualifier->specialNamespace;
        np->qname.space = qualifier->qname.space;
        break;

    case T_ID:
        qualifier = parsePrimaryName(cp);
        if (qualifier->kind == N_QNAME) {
            np->attributes = qualifier->attributes;
            np->qname.space = qualifier->qname.name;
        } else {
            /*
                This is a N_DOT expression compile-time constant expression.
             */
            mprAssert(0);
#if UNUSED
            np->qualifierNode = linkNode(np, qualifier);
#endif
        }
        break;

    case T_STRING:
        getToken(cp);
        np->qname.space = tokenString(cp);
        np->literalNamespace = 1;
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = parseError(cp, "Attribute \"%s\" not supported on local variables", cp->token->text);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableDefinition -b- (411)
        VariableDefinitionKind VariableBindingList -allowList,b-

    Input
        const
        let
        let const
        var

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinition(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);
    np = parseVariableDefinitionKind(cp, attributes);
    np = parseVariableBindingList(cp, np, attributes);
    return LEAVE(cp, np);
}


/*
    VariableDefinitionKind (412)
        const
        let
        let const
        var

    Input

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION, NULL);
    setNodeDoc(cp, np);

    switch (getToken(cp)) {
    case T_CONST:
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
        break;

    case T_LET:
        if (attributes && attributes->attributes & EJS_PROP_STATIC) {
            np = parseError(cp, "Static and let are not a valid combination. Use var instead.");

        } else {
            np->def.varKind = KIND_LET;
            if (peekToken(cp) == T_CONST) {
                np->def.varKind |= KIND_CONST;
                np->attributes |= EJS_TRAIT_READONLY;
            }
        }
        break;

    case T_VAR:
        np->def.varKind = KIND_VAR;
        break;

    default:
        np = parseError(cp, "Bad variable definition kind");
    }
    return LEAVE(cp, np);
}


/*
    VariableBindingList -a,b- (416)
        VariableBinding
        VariableBindingList -noList,b- , VariableBinding -a,b-

    Input

    AST
 */
static EcNode *parseVariableBindingList(EcCompiler *cp, EcNode *varList, EcNode *attributes)
{
    ENTER(cp);

    varList = parseVariableBinding(cp, varList, attributes);
    while (varList && peekToken(cp) == T_COMMA) {
        getToken(cp);
        varList = parseVariableBinding(cp, varList, attributes);
    }
    return LEAVE(cp, varList);
}


/*
    VariableBinding -a,b- (418)
        TypedIdentifier (258)
        TypedPattern (260) -noList,noIn- VariableInitialisation -a,b-

    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    TypedPattern (260)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
        N_QNAME variableId
        N_ASSIGN
            left: N_QNAME variableId
            right: N_LITERAL

 */
static EcNode *parseVariableBinding(EcCompiler *cp, EcNode *np, EcNode *attributes)
{
    EcNode      *var, *assign, *elt, *initialize, *name;
    int         next;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LBRACKET:
    case T_LBRACE:
        initialize = parsePattern(cp);
        for (next = 0; (elt = mprGetNextItem(initialize->children, &next)) != 0 && !cp->error; ) {
            mprAssert(elt->kind == N_FIELD);
            if (elt->field.expr->kind != N_QNAME) {
                return LEAVE(cp, parseError(cp, "Bad destructuring variable declaration"));
            }
            var = createNode(cp, N_VAR, NULL);
            var->qname = elt->field.expr->qname;
            var->name.varKind = np->def.varKind;
            var->attributes |= np->attributes;
            applyAttributes(cp, var, attributes, 0); 
            copyDocString(cp, var, np);
            np = appendNode(np, var);
        }
        if (peekToken(cp) == T_ASSIGN) {
            getToken(cp);
            assign = createNode(cp, N_ASSIGN_OP, NULL);
            assign = createAssignNode(cp, initialize, parseAssignmentExpression(cp), assign);
            np = appendNode(np, assign);
        }
        break;

    default:
        var = parseTypedIdentifier(cp);
        if (var == 0) {
            return LEAVE(cp, var);
        }
        mprAssert(var->qname.name);
        if (var->kind != N_QNAME) {
            return LEAVE(cp, parseError(cp, "Bad variable name"));
        }
        if (STRICT_MODE(cp)) {
            if (var->typeNode == 0) {
                parseError(cp, "Variable untyped. Variables must be typed when declared in strict mode");
                var = ecResetError(cp, var, 0);
                /* Keep parsing */
            }
        }
        var->kind = N_VAR;
        var->kindName = "n_var";
        var->name.varKind = np->def.varKind;
        var->attributes |= np->attributes;
        applyAttributes(cp, var, attributes, 0);
        copyDocString(cp, var, np);

        if (peekToken(cp) == T_ASSIGN) {
            name = createNode(cp, N_QNAME, tokenString(cp));
            name->qname = var->qname;
            assign = appendNode(createNode(cp, N_ASSIGN_OP, NULL), name);
            assign = appendNode(assign, parseVariableInitialisation(cp));
            var = appendNode(var, assign);
        }
        np = appendNode(np, var);
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableInitialisation -a,b- (426)
        = AssignmentExpression -a,b-

    Input
        =

    AST
        N_EXPRESSIONS
 */
static EcNode *parseVariableInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) == T_ASSIGN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    FunctionDeclaration (421)                                   # For interfaces
        function FunctionName FunctionSignature

    Notes:
        This is for function declarations in interfaces only.

    Input
        function

    AST
        N_FUNCTION
            function: name, getter, setter, block,
                children: parameters
 */
static EcNode *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    cp->state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }
    tid = peekToken(cp);
    if (tid != T_ID && tid != T_GET && tid != T_SET) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }
    np = parseFunctionName(cp);
    if (np) {
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributes, 0);
        np = parseFunctionSignature(cp, np);
        if (np) {
            np->function.isMethod = 1;
            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    np = parseError(cp, 
                        "Function has not defined a return type. Fuctions must be typed when declared in strict mode");
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    FunctionDefinition -class- (424)
        function ClassName ConstructorSignature FunctionBody -allowin-
        function FunctionName FunctionSignature FunctionBody -allowin-

    FunctionDeclaration -t- (442)
        function FunctionName FunctionSignature FunctionBody -allowin-
        let function FunctionName FunctionSignature FunctionBody -allowin-
        const function FunctionName FunctionSignature FunctionBody -allowin-

    Input
        function
        let
        const

    AST N_FUNCTION
        function: name, getter, setter, block,
            children: parameters
 */
static EcNode *parseFunctionDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np, *className;
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }
    if (getToken(cp) != T_ID && !(cp->token->groupMask & (G_CONREV | G_OPERATOR))) {
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }
    if (cp->state->currentClassName.name && 
            ejsCompareWide(cp->ejs, cp->state->currentClassName.name, cp->token->text, cp->token->length) == 0) {
        /*
            Constructor
         */
        np = createNode(cp, N_FUNCTION, NULL);
        putToken(cp);
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributeNode, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));
        className = parseClassName(cp);

        if (className) {
            np->qname.name = className->qname.name;
            np->function.isConstructor = 1;
            cp->state->currentClassNode->klass.constructor = np;
        }
        if (np) {
            np = parseConstructorSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (!(np->attributes & EJS_PROP_NATIVE)) {
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                np->function.isMethod = 1;
            }
        }

    } else {
        putToken(cp);
        np = parseFunctionName(cp);
        if (np) {
            setNodeDoc(cp, np);
            applyAttributes(cp, np, attributeNode, 0);
            np = parseFunctionSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (attributeNode && (attributeNode->attributes & EJS_PROP_NATIVE)) {
                    if (peekToken(cp) == T_LBRACE) {
                        return LEAVE(cp, parseError(cp, "Native functions declarations must not have bodies"));
                    }

                } else {
#if UNUSED
                    if (peekToken(cp) != T_LBRACE) {
                        np->function.noBlock = 1;
                    }
#endif
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                if (state->inClass && !state->inFunction && state->classState->blockNestCount == (state->blockNestCount - 1)) {
                    np->function.isMethod = 1;
                }
            }

            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    parseError(cp, "Function has not defined a return type. Functions must be typed in strict mode");
                    np = ecResetError(cp, np, 0);
                    /* Keep parsing */
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    FunctionName (427)
        Identifier
        OverloadedOperator
        get Identifier
        set Identifier

    Input
        Identifier
        get
        set
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    AST N_FUNCTION
        function: name, getter, setter
 */
static EcNode *parseFunctionName(EcCompiler *cp)
{
    EcNode      *name, *np;
    int         accessorId, tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid != T_GET && tid != T_SET) {
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
    }

    switch (tid) {
    case T_GET:
    case T_SET:
    case T_DELETE:
        getToken(cp);
        accessorId = cp->token->tokenId;

        tid = peekToken(cp);
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
        if (tid == T_LPAREN) {
            /*
                Function is called get() or set(). So put back the name and fall through to T_ID
             */
            putToken(cp);

        } else {
            if (tid != T_ID) {
                getToken(cp);
                return LEAVE(cp, parseError(cp, "Expecting identifier"));
            }
            name = parseIdentifier(cp);
            np = createNode(cp, N_FUNCTION, NULL);
            if (accessorId == T_GET) {
                np->function.getter = 1;
                np->attributes |= EJS_TRAIT_GETTER;
            } else {
                np->function.setter = 1;
                np->attributes |= EJS_TRAIT_SETTER;
            }
            np->qname.name = name->qname.name;
            break;
        }
        /* Fall through */

    case T_ID:
        name = parseIdentifier(cp);
        np = createNode(cp, N_FUNCTION, NULL);
        np->qname.name = name->qname.name;
        break;

    default:
        getToken(cp);
        if (cp->token->groupMask == G_OPERATOR) {
            putToken(cp);
            np = parseOverloadedOperator(cp);
        } else {
            np = unexpected(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    OverloadedOperator (431)
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    Input
        + - ~ * / % < > <= >= == << >> >>> & | === != !==
        [ . (  =        EJS exceptions

    AST
        N_QNAME
 */
static EcNode *parseOverloadedOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (getToken(cp)) {
    /*
        EJS extensions
     */
    case T_LBRACKET:
    case T_LPAREN:
    case T_DOT:
    case T_ASSIGN:
        /* Fall through */

    case T_PLUS:
    case T_MINUS:
    case T_TILDE:
    case T_MUL:
    case T_DIV:
    case T_MOD:
    case T_LT:
    case T_GT:
    case T_LE:
    case T_GE:
    case T_EQ:
    case T_LSH:
    case T_RSH:
    case T_RSH_ZERO:
    case T_BIT_AND:
    case T_BIT_OR:
    case T_STRICT_EQ:
    case T_NE:
    case T_STRICT_NE:
        /* Node holds the token */
        np = createNode(cp, N_FUNCTION, NULL);
        np->qname.name = tokenString(cp);
        break;

    default:
        np = unexpected(cp);
        break;
    }

    return LEAVE(cp, np);
}


/*
    FunctionSignature (450) (See also FunctionSignatureType)
        TypeParameters ( Parameters ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input
        .< TypeParameterList >

    AST
 */
static EcNode *parseFunctionSignature(EcCompiler *cp, EcNode *np)
{
    EcNode      *parameters;

    if (np == 0) {
        return np;
    }
    ENTER(cp);
    mprAssert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np->function.parameters = linkNode(np, createNode(cp, N_ARGS, NULL));

    //  TODO - should accep
    if (peekToken(cp) == T_ID || cp->peekToken->tokenId == T_ELIPSIS || cp->peekToken->groupMask & G_CONREV) {
        if (mcmp(cp->peekToken->text, "this") == 0) {
            ;
        } else {
            parameters = parseParameters(cp, np->function.parameters);
            if (parameters == 0) {
                while (getToken(cp) != T_RPAREN && cp->token->tokenId != T_EOF);
                return LEAVE(cp, 0);
            }
            np->function.parameters = linkNode(np, parameters);
        }
    }
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }
    if (np) {
        if (peekToken(cp) == T_COLON) {
            np->function.resultType = linkNode(np, parseResultType(cp));
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeParameters (453)
        EMPTY
        .< TypeParameterList >
    Input

    AST
 */
static EcNode *parseTypeParameters(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    TypeParametersList (455)
        Identifier
        Identifier , TypeParameterList

    Input

    AST
 */
static EcNode *parseTypeParameterList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Parameters (457)
        EMPTY
        NonemptyParameters

    Input

    AST
 */
static EcNode *parseParameters(EcCompiler *cp, EcNode *args)
{
    ENTER(cp);

    if (peekToken(cp) != T_RPAREN) {
        args = parseNonemptyParameters(cp, args);
    }
    return LEAVE(cp, args);
}


/*
    NonemptyParameters (459)
        ParameterInit
        ParameterInit , NonemptyParameters
        RestParameter

    Input
        Identifier
        ...

    AST
        N_ARGS
            N_VAR_DEFN
                N_QNAME
                N_ASSIGN_OP
                    N_QNAME, N_LITERAL

 */
static EcNode *parseNonemptyParameters(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_ELIPSIS) {
        np = appendNode(np, parseRestParameter(cp));

    } else {
        np = appendNode(np, parseParameterInit(cp, np));
        if (np) {
            if (peekToken(cp) == T_COMMA) {
                getToken(cp);
                np = parseNonemptyParameters(cp, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterInit (462)
        Parameter
        Parameter = NonAssignmentExpression -noList,allowIn-

    Input

    AST
 */
static EcNode *parseParameterInit(EcCompiler *cp, EcNode *args)
{
    EcNode      *np, *assignOp, *lastArg;

    ENTER(cp);

    np = parseParameter(cp, 0);

    if (peekToken(cp) == T_ASSIGN) {
        getToken(cp);
        /*
            Insert a N_ASSIGN_OP node under the VAR_DEFN
         */
        assignOp = createNode(cp, N_ASSIGN_OP, NULL);
        assignOp = appendNode(assignOp, np->left);
        mprAssert(mprGetListLength(np->children) == 1);

        mprRemoveItemAtPos(np->children, 0);
        assignOp = appendNode(assignOp, parseNonAssignmentExpression(cp));
        np = appendNode(np, assignOp);

        if (assignOp) {
            appendDocString(cp, args->parent, assignOp->left, assignOp->right);
        }

    } else if (args->children) {
        lastArg = (EcNode*) mprGetLastItem(args->children);
        if (lastArg && lastArg->left->kind == N_ASSIGN_OP) {
            np = parseError(cp, "Cannot have required parameters after parameters with initializers");
        }
    }
    return LEAVE(cp, np);
}


/*
    Parameter (464)
        ParameterKind TypedPattern -noList,noIn-

    Input

    AST
 */
static EcNode *parseParameter(EcCompiler *cp, bool rest)
{
    Ejs         *ejs;
    EcNode      *np, *parameter;

    ENTER(cp);

    ejs = cp->ejs;
    np = parseParameterKind(cp);
    parameter = parseTypedPattern(cp);
    if (parameter) {
        parameter->qname.space = S(empty);
    }
    np = appendNode(np, parameter);
    if (parameter) {
        if (STRICT_MODE(cp)) {
            if (parameter->typeNode == 0 && !rest) {
                parseError(cp, "Parameter untyped. Parameters must be typed when declared in strict mode.");
                np = ecResetError(cp, np, 0);
                /* Keep parsing */
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterKind (465)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseParameterKind(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION, NULL);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
    }
    return LEAVE(cp, np);
}


/*
    RestParameter (467)
        ...
        ... Parameter

    Input

    AST
 */
static EcNode *parseRestParameter(EcCompiler *cp)
{
    EcNode      *np, *varNode;

    ENTER(cp);

    if (getToken(cp) == T_ELIPSIS) {
        np = parseParameter(cp, 1);
        if (np && np->left) {
            if (np->left->kind == N_QNAME) {
                varNode = np->left;
            } else if (np->left->kind == N_ASSIGN_OP) {
                varNode = np->left->left;
            } else {
                varNode = 0;
                mprAssert(0);
            }
            if (varNode) {
                mprAssert(varNode->kind == N_QNAME);
                varNode->name.isRest = 1;
            }
        }

    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ResultType (469)
        EMPTY
        : void
        : NullableTypeExpression

    Input

    AST
        N_DOT
        N_QNAME
        N_VOID

    NOTE: we do not handle EMPTY here. Caller must handle.
 */
static EcNode *parseResultType(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);

    ejs = cp->ejs;

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if (peekToken(cp) == T_VOID) {
            getToken(cp);
            np = createNode(cp, N_QNAME, ST(Void)->qname.name);
            np->name.isType = 1;

        } else {
            np = parseNullableTypeExpression(cp);
        }

    } else {
        /*  Don't handle EMPTY here */
        getToken(cp);
        np = unexpected(cp);;
    }
    return LEAVE(cp, np);
}


/*
    ConstructorSignature (472)
        TypeParameters ( Parameters )
        TypeParameters ( Parameters ) : ConstructorInitializer

    Input

    AST
 */
static EcNode *parseConstructorSignature(EcCompiler *cp, EcNode *np)
{
    if (np == 0) {
        return np;
    }
    ENTER(cp);

    mprAssert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np->function.parameters = linkNode(np, createNode(cp, N_ARGS, NULL));
    np->function.parameters = linkNode(np, parseParameters(cp, np->function.parameters));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }
    if (np) {
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->function.constructorSettings = linkNode(np, parseConstructorInitializer(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    ConstructorInitializer (462)
        InitializerList
        InitializerList SuperInitializer
        SuperInitializer

    Input
        TDB
        super

    AST
        N_DIRECTIVES
 */
static EcNode *parseConstructorInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES, NULL);

    if (peekToken(cp) != T_SUPER) {
        np = parseInitializerList(cp, np);
    }
    if (peekToken(cp) == T_SUPER) {
        np = appendNode(np, parseSuperInitializer(cp));
    }
    return LEAVE(cp, np);
}


/*
    InitializerList (465)
        Initializer
        InitializerList , Initializer

    Input
        TBD

    AST
        N_DIRECTIVES
 */
static EcNode *parseInitializerList(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np && np->kind == N_DIRECTIVES);

    while (1) {
        np = appendNode(np, parseInitializer(cp));
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    Initializer (467)
        Pattern -noList,noIn,noExpr- VariableInitialisation -nolist,allowIn-

    Input
        TBD

    AST
        N_ASSIGN
 */
static EcNode *parseInitializer(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parsePattern(cp);

    if (peekToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    parent = createNode(cp, N_ASSIGN_OP, NULL);
    np = createAssignNode(cp, np, parseVariableInitialisation(cp), parent);
    return LEAVE(cp, np);
}


/*
    SuperInitializer (481)
        super Arguments

    Input
        super

    AST
        N_SUPER
 */
static EcNode *parseSuperInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        return LEAVE(cp, expected(cp, "super"));
    }
    np = createNode(cp, N_SUPER, NULL);
    np = appendNode(np, parseArguments(cp));
    return LEAVE(cp, np);
}


/*
    FunctionBody -b- (469)
        Block -local-
        AssignmentExpression -b-

    Input
        {
        (

    AST
 */
static EcNode *parseFunctionBody(EcCompiler *cp, EcNode *fun)
{
    Ejs         *ejs;
    EcNode      *np, *end, *ret;

    ENTER(cp);

    ejs = cp->ejs;
    cp->state->inFunction = 1;
    cp->state->nspace = S(empty);

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }

    } else {
        /*
            Create a return for block-less functions
         */
        np = createNode(cp, N_DIRECTIVES, NULL);
        ret = createNode(cp, N_RETURN, NULL);
        ret->ret.blockless = 1;
        ret = appendNode(ret, parseAssignmentExpression(cp));
        np = appendNode(np, ret);
    }
    if (np) {
        end = createNode(cp, N_END_FUNCTION, NULL);
        np = appendNode(np, end);
    }
    return LEAVE(cp, np);
}


/*
    ClassDefinition (484)
        class ClassName ClassInheritance ClassBody

    Input
        class id ...

    AST
        N_CLASS
            name
                id
            extends: id

 */
static EcNode *parseClassDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance, *constructor;
    int         tid;

    ENTER(cp);

    state = cp->state;

    if (getToken(cp) != T_CLASS) {
        return LEAVE(cp, expected(cp, "class"));
    }
    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }
    np = createNode(cp, N_CLASS, NULL);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    state->classState = state;
    state->defaultNamespace = NULL;

    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }
    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);

    np->qname.name = classNameNode->qname.name;
    state->currentClassName = np->qname;
    state->inClass = 1;

    tid = peekToken(cp);
    if (tid == T_EXTENDS || tid == T_IMPLEMENTS) {
        inheritance = parseClassInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = inheritance->klass.extends;
        }
        if (inheritance->klass.implements) {
            np->klass.implements = inheritance->klass.implements;
        }
    }
    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseClassBody(cp));

    if (np && np->klass.constructor == 0) {
        /*
            Create a default constructor because the user did not supply a constructor. We always
            create a constructor node even if one is not required (or generated). This makes binding easier later.
         */
        constructor = createNode(cp, N_FUNCTION, NULL);
        np->klass.constructor = linkNode(np, constructor);
        constructor->qname.name = np->qname.name;
        applyAttributes(cp, constructor, 0, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));
        constructor->function.isMethod = 1;
        constructor->function.isConstructor = 1;
        constructor->function.isDefault = 1;
    }
    return LEAVE(cp, np);
}


/*
    ClassName (485)
        ParameterisedTypeName
        ParameterisedTypeName !
    Input

    AST
 */
static EcNode *parseClassName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = parseParameterisedTypeName(cp);
    if (peekToken(cp) == T_LOGICAL_NOT) {
        getToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    ParameterisedTypeName (487)
        Identifier
        Identifier TypeParameters

    Input

    AST
 */
static EcNode *parseParameterisedTypeName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }
    np = parseIdentifier(cp);

#if FUTURE
    if (peekToken(cp) == T_DOT_LESS) {
        np = parseTypeParameters(cp);
    }
#endif
    return LEAVE(cp, np);
}


/*
    ClassInheritance (489)
        EMPTY
        extends PrimaryName
        implements TypeIdentifierList
        extends PrimaryName implements TypeIdentifierList

    Input

    AST N_CLASS
        extends: id
        left: implements list if ids
 */
static EcNode *parseClassInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS, NULL);

    switch (getToken(cp)) {
    case T_EXTENDS:
        id = parsePrimaryName(cp);
        if (id) {
            np->klass.extends = id->qname.name;
        }
        if (peekToken(cp) == T_IMPLEMENTS) {
            getToken(cp);
            np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
        }
        break;

    case T_IMPLEMENTS:
        np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
        break;

    default:
        putToken(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeIdentifierList (493)
        PrimaryName
        PrimaryName , TypeIdentifierList

    Input

    AST
 */
static EcNode *parseTypeIdentifierList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_TYPE_IDENTIFIERS, NULL);
    while (peekToken(cp) == T_ID) {
        np = appendNode(np, parsePrimaryName(cp));
        if (peekToken(cp) != T_COMMA) {
            break;
        }
        getToken(cp);
    }

    /*
        Discard the first NOP node
     */
    return LEAVE(cp, np);
}


/*
    ClassBody (495)
        Block -class-

    Input

    AST
 */
static EcNode *parseClassBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    cp->state->inFunction = 0;

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "class body { }"));
    }
    np = parseBlock(cp);
    if (np) {
        np = np->left;
        mprAssert(np->kind == N_DIRECTIVES);
    }
    return LEAVE(cp, np);
}


/*
    InterfaceDefinition (496)
        interface ClassName InterfaceInheritance InterfaceBody

    Input

    AST
 */
static EcNode *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance;

    ENTER(cp);
    
    state = cp->state;

    np = 0;
    if (getToken(cp) != T_INTERFACE) {
        return LEAVE(cp, expected(cp, "interface"));
    }
    
    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }

    np = createNode(cp, N_CLASS, NULL);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    state->classState = state;
    state->defaultNamespace = NULL;
    
    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }

    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);
    
    np->qname.name = classNameNode->qname.name;
    np->klass.isInterface = 1;
    state->currentClassName.name = np->qname.name;
    state->inInterface = 1;
    
    if (peekToken(cp) == T_EXTENDS) {
        inheritance = parseInterfaceInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = inheritance->klass.extends;
        }
    }

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseInterfaceBody(cp));

    return LEAVE(cp, np);
}


/*
    InterfaceInheritance (497)
        EMPTY
        extends TypeIdentifierList

    Input

    AST
 */
static EcNode *parseInterfaceInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS, NULL);

    if (peekToken(cp) == T_EXTENDS) {
        id = parseTypeIdentifierList(cp);
        if (id) {
            np->klass.extends = id->qname.name;
        }
    }
    return LEAVE(cp, np);
}


/*
    InterfaceBody (499)
        Block -interface-

    Input

    AST
 */
static EcNode *parseInterfaceBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "interface body { }"));
    }

    np = parseBlock(cp);
    if (np) {
        np = np->left;
        mprAssert(np->kind == N_DIRECTIVES);
    }

    return LEAVE(cp, np);
}


/*
    NamespaceDefinition (500)
        namespace Identifier NamespaceInitialisation

    Input
        namespace

    AST
        N_NAMESPACE
 */
static EcNode *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *varDefNode, *assignNode, *varNode, *typeNode, *namespaceNode, *nameNode;
    EjsObj      *vp;

    ENTER(cp);
    state = cp->state;
    if (state->inClass || state->inFunction) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Namespace definitions are not permitted inside classes or functions"));
    }
    if (getToken(cp) != T_NAMESPACE) {
        return LEAVE(cp, unexpected(cp));
    }

    /*
        Handle namespace definitions like:
            let NAME : Namespace = NAMESPACE_LITERAL
     */
    if ((varNode = parseIdentifier(cp)) == 0) {
        return LEAVE(cp, varNode);
    }
    mprAssert(varNode->kind == N_QNAME);
    varNode->kind = N_VAR;
    varNode->kindName = "n_var";
    varNode->name.varKind = KIND_VAR;
    varNode->name.isNamespace = 1;
    setNodeDoc(cp, varNode);

    /*
        Hand-craft a "Namespace" type node
     */
    typeNode = createNode(cp, N_QNAME, tokenString(cp));
    typeNode->qname.name = ejsCreateStringFromAsc(cp->ejs, "Namespace");
    varNode->typeNode = linkNode(varNode, typeNode);
    applyAttributes(cp, varNode, attributeNode, 0);

    if (peekToken(cp) == T_ASSIGN) {
        namespaceNode = parseNamespaceInitialisation(cp, varNode);
    } else {
        /*
            Create a namespace literal node from which to assign.
         */
        namespaceNode = createNode(cp, N_LITERAL, NULL);
        vp = (EjsObj*) ejsCreateNamespace(cp->ejs, varNode->qname.name);
        namespaceNode->literal.var = vp;
        varNode->name.nsvalue = vp;
    }
    /*
        Create an assignment node
     */
    nameNode = createNode(cp, N_QNAME, tokenString(cp));
    nameNode->qname = varNode->qname;
    assignNode = appendNode(createNode(cp, N_ASSIGN_OP, NULL), nameNode);
    assignNode = appendNode(assignNode, namespaceNode);
    varNode = appendNode(varNode, assignNode);

    varDefNode = createNode(cp, N_VAR_DEFINITION, NULL);
    varDefNode->def.varKind = KIND_VAR;
    varDefNode = appendNode(varDefNode, varNode);

    return LEAVE(cp, varDefNode);
}


/*
    NamespaceInitialisation (501)
        EMPTY
        = StringLiteral
        = MOB -- not supported SimpleQualifiedName

    AST
        N_LITERAL
        N_QNAME
        N_DOT
 */
static EcNode *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode)
{
    EcNode      *np;
    EjsObj      *vp;

    ENTER(cp);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, unexpected(cp));
    }
    if (peekToken(cp) != T_STRING) {
        return LEAVE(cp, expected(cp, "Namespace initializers must be literal strings"));
    }
    getToken(cp);
    np = createNode(cp, N_LITERAL, tokenString(cp));
    vp = (EjsObj*) ejsCreateNamespace(cp->ejs, nameNode->qname.name);
    np->literal.var = vp;

    if (peekToken(cp) != T_SEMICOLON && cp->peekToken->tokenId != T_EOF && 
            cp->peekToken->loc.lineNumber == cp->token->loc.lineNumber) {
        return LEAVE(cp, expected(cp, "Namespace initializers must be simple literal strings"));
    }
#if UNUSED
    } else {
        np = parsePrimaryName(cp);
    }
#endif
    return LEAVE(cp, np);
}


/*
    TypeDefinition (504)
        type ParameterisedTypeName TypeInitialisation

    Input

    AST
 */
static EcNode *parseTypeDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np;

    ENTER(cp);
    np = parseTypeInitialisation(cp);
    return LEAVE(cp, np);
}


/*
    TypeInitialisation (505)
        = NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ModuleDefinition (493)
        module ModuleBody
        module ModuleName ModuleBody

    Input
        module ...

    AST
        N_MODULE
 */
static EcNode *parseModuleDefinition(EcCompiler *cp)
{
    EcNode      *np, *moduleName, *body;
    EjsString   *nspace;
    cchar       *name;
    int         next, isDefault, pos, version;

    ENTER(cp);
    version = 0;

    if (getToken(cp) != T_MODULE) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_MODULE, NULL);

    if (peekToken(cp) == T_ID) {
        isDefault = 0;
        moduleName = parseModuleName(cp);
        if (moduleName == 0) {
            return LEAVE(cp, 0);
        }
        version = 0;
        if (peekToken(cp) == T_STRING || cp->peekToken->tokenId == T_NUMBER) {
            if ((version = parseVersion(cp, 0)) < 0) {
                expected(cp, "A version number NUM[.NUM[.NUM]]");
                return 0;
            }
        }
        np->module.name = moduleName->qname.name;
        if (version) {
            nspace = ejsSprintf(cp->ejs, "%@-%d", moduleName->qname.name, version);
        } else if (cp->modver) { 
            nspace = ejsSprintf(cp->ejs, "%@-%d", moduleName->qname.name, cp->modver);
            version = cp->modver;
        } else {
            nspace = moduleName->qname.name;
        }
    } else {
        isDefault = 1;
        nspace = cp->fileState->nspace;
    }
    mprAssert(nspace);
    
    if (isDefault) {
        /*
            No module name. Set the namespace to the unique internal namespace name.
         */
        np->module.name = ejsCreateStringFromAsc(cp->ejs, EJS_DEFAULT_MODULE);
    }
    np->qname.name = np->module.name;
    np->module.version = version;
    cp->state->currentModule = ejsCreateModule(cp->ejs, np->qname.name, np->module.version, NULL);
    cp->state->defaultNamespace = nspace;

    body = parseModuleBody(cp);
    if (body == 0) {
        return LEAVE(cp, 0);
    }
    /* 
        Append the module namespace and also modules provided via ec/ejs --require switch
     */
    pos = 0;
    if (!isDefault) {
        body = insertNode(body, createNamespaceNode(cp, cp->fileState->nspace, 0, 1), pos++);
    }
    body = insertNode(body, createNamespaceNode(cp, nspace, 1, 1), pos++);
    for (next = 0; (name = mprGetNextItem(cp->require, &next)) != 0; ) {
        body = insertNode(body, createNamespaceNode(cp, ejsCreateStringFromAsc(cp->ejs, name), 0, 1), pos++);
    }
    mprAssert(body->kind == N_BLOCK);
    np = appendNode(np, body);
    return LEAVE(cp, np);
}


/*
    ModuleName (494)
        Identifier
        ModuleName . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
            name: name
 */
static EcNode *parseModuleName(EcCompiler *cp)
{
    EcNode      *np, *idp;
    Ejs         *ejs;
    EjsObj      *lastPackage;
    EjsString   *name;

    ENTER(cp);

    np = parseIdentifier(cp);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    name = np->qname.name;

    ejs = cp->ejs;
    lastPackage = 0;

    while (np && getToken(cp) == T_DOT) {
        /*
            Stop if not "identifier"
         */
        if (peekAheadToken(cp, 1) != T_ID) {
            break;
        }
        idp = parseIdentifier(cp);
        if (idp == 0) {
            return LEAVE(cp, idp);
        }
        np = appendNode(np, idp);
        name = ejsSprintf(cp->ejs, "%@.%@", name, idp->qname.name);
    }
    putToken(cp);
    np->qname.name = name;
    return LEAVE(cp, np);
}


/*
    ModuleBody (496)
        Block -global-

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseModuleBody(EcCompiler *cp)
{
    return parseBlock(cp);
}


/*
    Pragma (505)
        UsePragma Semicolon |
        ImportPragma Semicolon

    Input
        use ...
        import ...

    AST
        N_IMPORT
        N_PRAGMAS
 */
static EcNode *parsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    switch (peekToken(cp)) {
    case T_USE:
    case T_REQUIRE:
        np = parseUsePragma(cp, np);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    Pragmas (497)
        Pragma
        Pragmas Pragma

    Input
        use ...
        require
        import

    AST
        N_PRAGMAS
            N_IMPORT
            N_PRAGMA
 */
static EcNode *parsePragmas(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

#if OLD
    while (peekToken(cp) == T_USE || cp->peekToken->tokenId == T_REQUIRE) {
        np = parsePragma(cp, np);
        if (np == 0) {
            break;
        }
    }
    return LEAVE(cp, np);
#else
    return LEAVE(cp, parsePragma(cp, np));
#endif
}


/*
    UsePragma (501)
        use PragmaItems
        require

    Input
        use ...

    AST
        N_PRAGMAS
 */
static EcNode *parseUsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_REQUIRE) {
        getToken(cp);
        np = parseRequireItems(cp, np);
    } else if (peekToken(cp) == T_USE) {
        getToken(cp);
        np = parsePragmaItems(cp, np);
    } else{
        getToken(cp);
        np = parseError(cp, "Expecting \"use\" or \"require\"");
    }
    return LEAVE(cp, np);
}


static EcNode *parseRequireItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    do {
        np = appendNode(np, parseRequireItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


//  TODO - should return an EcNode
/*
    Parse "NUM[.NUM[.NUM]]" and return a version number. Return < 0 on parse errors.
 */
static int parseVersion(EcCompiler *cp, int parseMax)
{
    MprChar     *str, *p, *next;
    int         major, minor, patch;

    if (parseMax) {
        major = minor = patch = EJS_VERSION_FACTOR - 1;
    } else {
        major = minor = patch = 0;
    }
    if (getToken(cp) != T_STRING && cp->token->tokenId != T_NUMBER) {
        return MPR_ERR_BAD_VALUE;
    }
    str = wclone(cp->token->text);
    if ((p = mtok(str, ".", &next)) != 0) {
        major = (int) wtoi(p, 10, NULL);
    }
    if ((p = mtok(next, ".", &next)) != 0) {
        minor = (int) wtoi(p, 10, NULL);
    }
    if ((p = mtok(next, ".", &next)) != 0) {
        patch = (int) wtoi(p, 10, NULL);
    }
    return EJS_MAKE_VERSION(major, minor, patch);
}


//  TODO - should return an EcNode
/*
    Parse [version:version]. Valid forms include:
        [version]
        [:version]
        [version:version]
 */
static int parseVersions(EcCompiler *cp, int *minVersion, int *maxVersion)
{
    *minVersion = 0;
    *maxVersion = EJS_MAX_VERSION;

    getToken(cp);
    if (peekToken(cp) != T_COLON) {
        if ((*minVersion= parseVersion(cp, 0)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if ((*maxVersion = parseVersion(cp, 1)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (getToken(cp) != T_RBRACKET) {
        expected(cp, "]");
    }
    return 0;
}


static EcNode *parseRequireItem(EcCompiler *cp)
{
    EcNode      *np, *ns, *moduleName;
    int         minVersion, maxVersion;

    ENTER(cp);
    
    np = createNode(cp, N_USE_MODULE, NULL);
    ns = createNode(cp, N_USE_NAMESPACE, NULL);
    np->useModule.minVersion = 0;
    np->useModule.maxVersion = EJS_MAX_VERSION;

    if ((moduleName = parseModuleName(cp)) != 0) {
        np->qname.name = moduleName->qname.name;
    }
    /*
        Optional [version:version]
     */
    if (peekToken(cp) == T_LBRACKET) {
        if (parseVersions(cp, &minVersion, &maxVersion) < 0) {
            return 0;
        }
        np->useModule.minVersion = minVersion;
        np->useModule.maxVersion = maxVersion;
    }

    ns->qname.name = np->qname.name;
    ns->name.isLiteral = 1;
    np = appendNode(np, ns);
    return LEAVE(cp, np);
}


/*
    PragmaItems (502)
        PragmaItem
        PragmaItems , PragmaItem

    Input
        decimal
        default
        namespace
        standard
        strict
        module

    AST
        N_PRAGMAS
        N_MODULE
 */
static EcNode *parsePragmaItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    do {
        np = appendNode(np, parsePragmaItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


/*
    PragmaItem (504)
        decimal LeftHandSideExpression
        default namespace PrimaryName
        // default number [decimal | default | double | int | long | uint | ulong]
        namespace PrimaryName
        standard
        strict
        module ModuleName OptionalStringLiteral

    Input
        See above

    AST
        N_PRAGMA
        N_MODULE
 */
static EcNode *parsePragmaItem(EcCompiler *cp)
{
    EcNode      *np, *ns;
    EcState     *upper;
    EjsModule   *module;
    int         attributes;

    ENTER(cp);

    attributes = 0;

    np = createNode(cp, N_PRAGMA, NULL);
    np->pragma.strict = cp->fileState->strict;
    module = 0;

    /*
        PragmaIdentifiers (737)
     */
    switch (getToken(cp)) {
#if UNUSED
    case T_DECIMAL:
        np->pragma.decimalContext = linkNode(np, parseLeftHandSideExpression(cp));
        break;
#endif
    case T_MODULE:
        /* TODO DEPRECATE */
        np = parseRequireItem(cp);
        break;

    case T_DEFAULT:
        getToken(cp);
        if (cp->token->tokenId == T_NAMESPACE) {
            if (peekToken(cp) == T_MODULE) {
                getToken(cp);
                module = cp->state->currentModule;
                if (module == 0) {
                    np = parseError(cp, "No open module");
                    break;
                }
                np = createNode(cp, N_USE_NAMESPACE, NULL);
                if (module->version) {
                    np->qname.name = ejsSprintf(cp->ejs, "%@-%d", module->name, module->version);
                    np->name.isLiteral = 1;
                } else {
                    np->qname.name = module->name;
                    np->name.isLiteral = 1;
                }
                np->name.isLiteral = 1;

            } else if (peekToken(cp) == T_STRING) {
                getToken(cp);
                np = createNode(cp, N_USE_NAMESPACE, tokenString(cp));
                np->name.isLiteral = 1;

            } else {
                ns = parsePrimaryName(cp);
                if (ns) {
                    mprAssert(ns->qname.name);
                    np = createNode(cp, N_USE_NAMESPACE, ns->qname.name);
                }
            }
            if (np) {
                /*
                    Must apply this default namespace upwards to all blocks below the blockState. It will define the
                    new namespace value. Note that functions and classes null this so it does not propagate into classes or
                    functions.
                 */
                for (upper = cp->state->next; upper; upper = upper->next) {
                    upper->defaultNamespace = np->qname.name;
                    if (upper == cp->blockState) {
                        break;
                    }
                }
                cp->blockState->nspace = np->qname.name;
                np->name.isDefault = 1;
            }
        }
        break;

    case T_STANDARD:
        cp->fileState->strict = np->pragma.strict = 0;
        break;

    case T_STRICT:
        cp->fileState->strict = np->pragma.strict = 1;
        break;

    case T_NAMESPACE:
        if (peekToken(cp) == T_STRING) {
            getToken(cp);
            np = createNode(cp, N_USE_NAMESPACE, tokenString(cp));
            np->name.isLiteral = 1;

        } else {
            np = createNode(cp, N_USE_NAMESPACE, NULL);
            ns = parsePrimaryName(cp);
            if (ns) {
                np = appendNode(np, ns);
                if (ns->kind == N_DOT) {
                    np->qname.name = ns->right->qname.name;
                } else {
                    np->qname.name = ns->qname.name;
                }
            }
        }
        break;

    default:
        np = parseError(cp, "Unknown pragma identifier");
    }
    return LEAVE(cp, np);
}


/*
    Block -t- (514)
        { Directives }

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlock(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state, *saveState;

    ENTER(cp);

    state = cp->state;
    saveState = cp->blockState;
    cp->blockState = state;

    if (getToken(cp) != T_LBRACE) {
        // putToken(cp);
        np = parseError(cp, "Expecting \"{\"");

    } else {
        np = createNode(cp, N_BLOCK, NULL);
        np = appendNode(np, parseDirectives(cp));
        if (np) {
            if (getToken(cp) != T_RBRACE) {
                // putToken(cp);
                np = parseError(cp, "Expecting \"}\"");
            }
        }
    }
    cp->blockState = saveState;
    return LEAVE(cp, np);
}


/*
    Program (515)
        Directives -global-

    Input
        AnyDirective

    AST N_PROGRAM
        N_DIRECTIVES ...

 */
static EcNode *parseProgram(EcCompiler *cp, cchar *path)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *np, *module, *block, *require, *namespace;
    EjsString   *name;
    cchar       *requireName;
    char        *md5, *apath;
    int         next;

    ENTER(cp);
    
    ejs = cp->ejs;
    state = cp->state;
    state->strict = cp->strict;

    //  MOB  public should be a standard string
    np = createNode(cp, N_PROGRAM, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));

#if UNUSED && KEEP
    if (cp->fileState->lang == EJS_SPEC_ECMA) {
        np->qname.name = EJS_PUBLIC_NAMESPACE;
    } else {
#endif
    if (cp->visibleGlobals && ejs->state->internal) {
        np->qname.name = ejs->state->internal->value;
    } else if (path) {
        apath = mprGetAbsPath(path);
        md5 = mprGetMD5Hash(apath, (int) strlen(apath), NULL);
        np->qname.name = ejsSprintf(cp->ejs, "%s-%s-%d", EJS_INTERNAL_NAMESPACE, md5, cp->uid++);
    } else {
        np->qname.name = ejsCreateStringFromAsc(cp->ejs, EJS_INTERNAL_NAMESPACE);
    }
    state->nspace = np->qname.name;
    mprAssert(state->nspace);
        
    cp->fileState->nspace = state->nspace;

    /*
        Create the default module node
     */
    module = createNode(cp, N_MODULE, NULL);
    module->qname.name = ejsCreateStringFromAsc(cp->ejs, EJS_DEFAULT_MODULE);

    /*
        Create a block to hold the namespaces. Add a require node for the default module and add modules specified 
        via --require switch
     */
    block = createNode(cp, N_BLOCK, NULL);
    namespace = createNamespaceNode(cp, cp->fileState->nspace, 0, 1);
    namespace->name.isInternal = 1;
    block = appendNode(block, namespace);
    for (next = 0; (requireName = mprGetNextItem(cp->require, &next)) != 0; ) {
        name = ejsCreateStringFromAsc(cp->ejs, requireName);
        require = createNode(cp, N_USE_MODULE, NULL);
        require->qname.name = name;
        require->useModule.minVersion = 0;
        require->useModule.maxVersion = EJS_MAX_VERSION;
        require = appendNode(require, createNamespaceNode(cp, name, 0, 1));
        block = appendNode(block, require);
    }
    block = appendNode(block, parseDirectives(cp));
    module = appendNode(module, block);
    np = appendNode(np, module);

    if (!cp->interactive && peekToken(cp) != T_EOF) {
        if (np) {
            np = unexpected(cp);
        }
        return LEAVE(cp, np);
    }

    /*
        Reset the line number to prevent debug source lines preceeding these elements
     */
    if (np) {
        np->loc.lineNumber = 0;
    }
    if (module) {
        module->loc.lineNumber = 0;
    }
    if (block) {
        block->loc.lineNumber = 0;
    }
    return LEAVE(cp, np);
}


#if UNUSED
static EcNode *parseBreak(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseContinue(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseDo(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFor(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseIf(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseLet(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseReturn(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseSwitch(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseThrow(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    return LEAVE(cp, np);
}


static EcNode *parseTry(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWhile(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWith(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseVarDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFunctionDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseInclude(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


#if NOT_USED_IN_GRAMMAR
static EcNode *parseSuper(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Recover from a parse error to allow parsing to continue.
 */
EcNode *ecResetError(EcCompiler *cp, EcNode *np, bool eatInput)
{
    int     tid;

    mprAssert(cp->error);

    if (cp->error) {
        if (!cp->fatalError && cp->errorCount < EC_MAX_ERRORS) {
            cp->error = 0;
            np = createNode(cp, N_DIRECTIVES, NULL);
        }
    }

    /*
        Try to resync by eating input up to the next statement / directive
     */
    while (!cp->interactive) {
        tid = peekToken(cp);
        if (tid == T_SEMICOLON || tid == T_RBRACE || tid == T_RBRACKET || tid == T_RPAREN || tid == T_ERR || tid == T_EOF)  {
            break;
        }
        if (np && np->loc.lineNumber < cp->peekToken->loc.lineNumber) {
            /* Virtual semicolon */
            break;
        }
        getToken(cp);
    }
    return np;
}


#if FUTURE
/*
    Returns an allocated buffer. Caller must free.
 */
static char *detab(EcCompiler *cp, char *src)
{
    char    *p, *dest;
    int     tabCount;

    tabCount = 0;

    for (p = src; *p; p++) {
        if (*p == '\t') {
            tabCount++;
        }
    }

    dest = ejsAlloc(cp->ejs, strlen(src) + 1 + (tabCount * cp->tabWidth));
    if (dest == 0) {
        mprAssert(dest);
        return src;
    }
    for (p = dest; *src; src++) {
        if (*src== '\t') {
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
        } else {
            *p++ = *src;
        }
    }
    *p = '\0';

    return dest;
}
#endif


#if BLD_DEBUG
static void updateDebug(EcCompiler *cp)
{
    mprAssert(cp);

    if (cp->token) {
        cp->token->name = tokenNames[cp->token->tokenId];
    }
    if (cp->peekToken) {
        cp->peekToken->name = tokenNames[cp->peekToken->tokenId];
    }
}
#endif


/*
    Get the next input token. May have been previous obtained and putback.
 */
static int getToken(EcCompiler *cp)
{
    int         id;

    if (cp->fatalError) {
        return T_ERR;
    }
    id = ecGetToken(cp);
    cp->peekToken = 0;
    return id;
}


/*
    Peek ahead (K) tokens and return the token id
 */
static int peekAheadToken(EcCompiler *cp, int ahead)
{
    EcToken     *token;

    token = peekAheadTokenStruct(cp, ahead);
    if (token == 0) {
        return EJS_ERR;
    }
    return token->tokenId;
}


int ecPeekToken(EcCompiler *cp)
{
    return peekAheadToken(cp, 1);
}


/*
    Peek ahead (K) tokens and return the token.
 */
static EcToken *peekAheadTokenStruct(EcCompiler *cp, int ahead)
{
    EcToken     *token, *currentToken, *tokens[EC_MAX_LOOK_AHEAD];
    int         i;

    mprAssert(ahead > 0 && ahead <= EC_MAX_LOOK_AHEAD);
    if (ahead == 1) {
        /* Fast look ahead of one token.  */
        if (cp->putback) {
            cp->peekToken = cp->putback;
            return cp->putback;
        }
    }
    /*
        takeToken will take the current token and remove it from the input
        We must preserve the current token throughout.
     */
    currentToken = ecTakeToken(cp);
    for (i = 0; i < ahead; i++) {
        if (ecGetToken(cp) < 0) {
            mprAssert(0);
            return 0;
        }
        tokens[i] = ecTakeToken(cp);
    }
    /*
        Peek at the token of interest
     */
    token = tokens[i - 1];
    for (i = ahead - 1; i >= 0; i--) {
        putSpecificToken(cp, tokens[i]);
    }
    if (currentToken) {
        ecPutSpecificToken(cp, currentToken);
        ecGetToken(cp);
    }
    cp->peekToken = token;
    updateDebug(cp);
    return token;
}


static void putToken(EcCompiler *cp)
{
    ecPutToken(cp);
    updateDebug(cp);
}


static void putSpecificToken(EcCompiler *cp, EcToken *token)
{
    ecPutSpecificToken(cp, token);
}


static void setNodeDoc(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && cp->doc) {
        np->doc = ejsCreateStringFromAsc(ejs, cp->docToken);
        cp->docToken = 0;
    }
}


static void appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value)
{
    EjsString   *defaultValue;
    Ejs         *ejs;
    char        arg[MPR_MAX_STRING];
    int         found;
    
    ejs = cp->ejs;

    if (!(ejs->flags & EJS_FLAG_DOC)) {
        return;
    }
    if (np == 0 || parameter == 0 || parameter->kind != N_QNAME || value == 0) {
        return;
    }
    defaultValue = 0;
    if (value->kind == N_QNAME) {
        defaultValue = value->qname.name;
    } else if (value->kind == N_UNARY_OP) {
        if (value->left->kind == N_LITERAL) {
            if (value->tokenId == T_MINUS) {
                defaultValue = ejsSprintf(ejs, "-%@", ejsToString(ejs, value->left->literal.var));
            }
        }
    } else if (value->kind == N_LITERAL) {
        defaultValue = ejsToString(ejs, value->literal.var);
    }
    if (defaultValue == 0) {
        defaultValue = ejsCreateStringFromAsc(ejs, "expression");
    }
    if (np->doc) {
        found = 0;
        mprSprintf(arg, sizeof(arg), "@param %@ ", parameter->qname.name);
        if (ejsContainsMulti(ejs, np->doc, arg) != 0 || ejsContainsMulti(ejs, np->doc, "@duplicate") != 0) {
            found++;
        } else {
            mprSprintf(arg, sizeof(arg), "@params %@ ", parameter->qname.name);
            if (ejsContainsMulti(ejs, np->doc, arg) != 0) {
                found++;
            }
        }
        if (found) {
            np->doc = ejsSprintf(ejs, "%@\n@default %@ %@", np->doc, parameter->qname.name, defaultValue);
        } else {
            np->doc = ejsSprintf(ejs, "%@\n@param %@\n@default %@ %@", np->doc, parameter->qname.name,
                parameter->qname.name, defaultValue);
        }
    }
}


static void copyDocString(EcCompiler *cp, EcNode *np, EcNode *from)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && from->doc) {
        np->doc = from->doc;
        from->doc = 0;
    }
}


/*
    This is used outside the parser. It must reset the line number as the
    node will not correspond to any actual source code line;
 */
EcNode *ecCreateNode(EcCompiler *cp, int kind)
{
    EcNode  *node;

    node = createNode(cp, kind, NULL);
    if (node) {
        node->loc.lineNumber = -1;
        node->loc.source = 0;
    }
    return node;
}


static EcNode *createNameNode(EcCompiler *cp, EjsName qname)
{
    EcNode      *np;

    if ((np = createNode(cp, N_QNAME, NULL)) != NULL) {
        np->qname = qname;
    }
    return np;
}


static EcNode *createNamespaceNode(EcCompiler *cp, EjsString *name, bool isDefault, bool isLiteral)
{
    EcNode      *np;
    
    np = createNode(cp, N_USE_NAMESPACE, name);
    np->name.isDefault = isDefault;
    np->name.isLiteral = isLiteral;
    return np;
}


/*
    This is used outside the parser.
 */
EcNode *ecLinkNode(EcNode *np, EcNode *child)
{
    return linkNode(np, child);
}


/*
    Create a binary tree node.
 */
static EcNode *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    mprAssert(cp);
    mprAssert(lhs);
    mprAssert(parent);

    /*
        appendNode will return the parent if no error
     */
    parent = appendNode(parent, lhs);
    parent = appendNode(parent, rhs);

    return parent;
}


static EcNode *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    mprAssert(cp);
    mprAssert(lhs);
    mprAssert(parent);

    return appendNode(appendNode(parent, lhs), rhs);
}


/*
    Add a child node. If an allocation error, return 0, otherwise return the
    parent node.
 */
//  MOB -- should have an appendNodes( ....)
static EcNode *appendNode(EcNode *np, EcNode *child)
{
    EcCompiler      *cp;
    MprList         *list;
    int             index;

    if (child == 0 || np == 0) {
        return 0;
    }
    mprAssert(np != child);
    
    list = np->children;
    cp = np->cp;

    if ((index = mprAddItem(np->children, child)) < 0) {
        return 0;
    }
    if (index == 0) {
        np->left = list->items[index];
    } else if (index == 1) {
        np->right = list->items[index];
    }
    child->parent = np;
    return np;
}


EcNode *ecAppendNode(EcNode *np, EcNode *child)
{
    return appendNode(np, child);
}


EcNode *ecChangeNode(EcCompiler *cp, EcNode *np, EcNode *oldNode, EcNode *newNode)
{
    EcNode      *child;
    int         next;

    for (next = 0; (child = mprGetNextItem(np->children, &next)) != 0; ) {
        if (child == oldNode) {
            mprSetItem(np->children, next - 1, newNode);
            if (next == 1) {
                np->left = mprGetItem(np->children, next - 1);
            } else if (next == 2) {
                np->right = mprGetItem(np->children, next - 1);
            }
            newNode->parent = np;
            return np;
        }
    }
    mprAssert(0);
    return 0;
}


/*
    Link a node. This only steals the node.
 */
static EcNode *linkNode(EcNode *np, EcNode *node)
{
    if (node == 0 || np == 0) {
        return 0;
    }
    node->parent = np;
    return node;
}


/*
    Insert a child node. If an allocation error, return 0, otherwise return the parent node.
 */
static EcNode *insertNode(EcNode *np, EcNode *child, int pos)
{
    EcCompiler      *cp;
    MprList         *list;
    int             index, len;

    if (child == 0 || np == 0) {
        return 0;
    }
    list = np->children;
    cp = np->cp;

    index = mprInsertItemAtPos(list, pos, child);
    if (index < 0) {
        return 0;
    }
    len = mprGetListLength(list);
    if (len > 0) {
        np->left = (EcNode*) list->items[0];
    }
    if (len > 1) {
        np->right = (EcNode*) list->items[1];
    }
    child->parent = np;
    return np;
}


/*
    Remove a child node and return it.
 */
static EcNode *removeNode(EcNode *np, EcNode *child)
{
    EcCompiler      *cp;
    int             index;

    if (child == 0 || np == 0) {
        return 0;
    }
    cp = np->cp;

    index = mprRemoveItem(np->children, child);
    mprAssert(index >= 0);

    if (index == 0) {
        np->left = np->right;
    } else if (index == 1) {
        np->right = 0;
    }
    child->parent = 0;
    return child;
}


static EcNode *unexpected(EcCompiler *cp)
{
    int     junk = 0;

    /*
        This is just to avoid a Vxworks 5.4 linker bug. The link crashes when this function has no local vars.
     */
    dummy(junk);
    return parseError(cp, "Unexpected input \"%s\"", cp->token->text);
}


static EcNode *expected(EcCompiler *cp, cchar *str)
{
    return parseError(cp, "Expected input \"%s\"", str);
}


static void applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributeNode, EjsString *overrideNamespace)
{
    EcState     *state;
    EjsString   *nspace;
    int         attributes;

    state = cp->state;

    attributes = 0;
    nspace = 0;

    if (attributeNode) {
        /*
            Attribute node passed in.
         */
        attributes = attributeNode->attributes;
        if (attributeNode->qname.space) {
            nspace = attributeNode->qname.space;
        }
        if (attributeNode->literalNamespace) {
            np->literalNamespace = 1;
        }
    } else {
        /*
            "space"::var
         */
        if (np->qname.space) {
            nspace = np->qname.space;
        }
    }
    if (nspace == 0) {
        if (overrideNamespace) {
            nspace = overrideNamespace;
        } else if (cp->blockState->defaultNamespace) {
            nspace = cp->blockState->defaultNamespace;
        } else {
            nspace = cp->blockState->nspace;
        }
    }
    mprAssert(nspace);

    if (state->inFunction) {
        ;
    } else if (state->inClass) {
        if (ejsCompareMulti(cp->ejs, nspace, EJS_INTERNAL_NAMESPACE) == 0) {
            nspace = cp->fileState->nspace;
        } else if (ejsCompareMulti(cp->ejs, nspace, EJS_PRIVATE_NAMESPACE) == 0 || 
                   ejsCompareMulti(cp->ejs, nspace, EJS_PROTECTED_NAMESPACE) == 0) {
            nspace = ejsFormatReservedNamespace(cp->ejs, &state->currentClassName, nspace);
        }
    } else {
        if (cp->visibleGlobals && !(attributeNode && attributeNode->qname.space)) {
            nspace = ejsCreateStringFromAsc(cp->ejs, EJS_EMPTY_NAMESPACE);
        } else if (ejsCompareMulti(cp->ejs, nspace, EJS_INTERNAL_NAMESPACE) == 0) {
            nspace = cp->fileState->nspace;
        }
    }
    mprAssert(nspace);
    np->qname.space = nspace;

    mprLog(7, "Parser apply attributes namespace = \"%@\", current line %w", nspace, np->loc.source);
    mprAssert(np->qname.space);
    np->attributes |= attributes;
}


static void addTokenToLiteral(EcCompiler *cp, EcNode *np)
{
    MprBuf      *buf;

    if (np) {
        buf = np->literal.data;
        mprPutBlockToBuf(buf, (char*) cp->token->text, cp->token->length * sizeof(MprChar));
        mprAddNullToBuf(buf);
    }
}


static void addCharsToLiteral(EcCompiler *cp, EcNode *np, MprChar *str, ssize count)
{
    MprBuf      *buf;

    if (np) {
        buf = np->literal.data;
        mprPutBlockToBuf(buf, (char*) str, count * sizeof(MprChar));
        mprAddNullToBuf(buf);
    }
}


static void addAscToLiteral(EcCompiler *cp, EcNode *np, cchar *str, ssize count)
{
    MprBuf      *buf;
    MprChar     c;
    int         i;

    if (np) {
        buf = np->literal.data;
        for (i = 0; i < count; i++) {
            c = (uchar) str[i];
            mprPutBlockToBuf(buf, (char*) &c, sizeof(MprChar));
        }
        mprAddNullToBuf(buf);
    }
}


/*
    Reset the input. Eat all tokens, clear errors, exceptions and the result value. Used by ejs for console input.
 */
void ecResetInput(EcCompiler *cp)
{
    Ejs         *ejs;
    EcToken     *tp;

    ejs = cp->ejs;
    cp->stream->flags &= ~EC_STREAM_EOL;
    cp->error = 0;
    cp->ejs->exception = 0;
    cp->ejs->result = S(undefined);
    while ((tp = cp->putback) != 0 && (tp->tokenId == T_EOF || tp->tokenId == T_NOP)) {
        ecGetToken(cp);
    }
}


void ecSetOptimizeLevel(EcCompiler *cp, int level)
{
    cp->optimizeLevel = level;
}


void ecSetWarnLevel(EcCompiler *cp, int level)
{
    cp->warnLevel = level;
}


void ecSetStrictMode(EcCompiler *cp, int enabled)
{
    cp->strict = enabled;
}


void ecSetTabWidth(EcCompiler *cp, int width)
{
    cp->tabWidth = width;
}


void ecSetOutputFile(EcCompiler *cp, cchar *outputFile)
{
    if (outputFile) {
        //  MOB UNICODE
        cp->outputFile = sclone(outputFile);
    }
}


void ecSetCertFile(EcCompiler *cp, cchar *certFile)
{
    //  MOB UNICODE
    cp->certFile = sclone(certFile);
}


static EjsString *tokenString(EcCompiler *cp)
{
    Ejs     *ejs;

    ejs = cp->ejs;
    if (cp->token) {
        return ejsCreateString(cp->ejs, cp->token->text, cp->token->length);
    }
    return S(empty);
}


void ecMarkLocation(EcLocation *loc)
{
    mprMark(loc->source);
    mprMark(loc->filename);
}


static void manageNode(EcNode *node, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ejsMarkName(&node->qname);
        ecMarkLocation(&node->loc);
        mprMark(node->blockRef);
        mprMark(node->namespaceRef);
        mprMark(node->typeNode);
        mprMark(node->children);
        mprMark(node->namespaces);
        mprMark(node->code);
        mprMark(node->doc);

        switch (node->kind) {
        case N_ARGS:
            break;

        case N_ASSIGN_OP:
            break;

        case N_BINARY_OP:
            break;

        case N_BLOCK:
            break;

        case N_BREAK:
            break;

        case N_CALL:
            break;

        case N_CLASS:
            mprMark(node->klass.implements);
            mprMark(node->klass.constructor);
            mprMark(node->klass.staticProperties);
            mprMark(node->klass.instanceProperties);
            mprMark(node->klass.classMethods);
            mprMark(node->klass.methods);
            mprMark(node->klass.ref);
            mprMark(node->klass.initializer);
            mprMark(node->klass.publicSpace);
            mprMark(node->klass.internalSpace);
            mprMark(node->klass.extends);
            break;

        case N_CASE_LABEL:
            mprMark(node->caseLabel.expression);
            //  MOB - surely these can be local?
            mprMark(node->caseLabel.expressionCode);
            break;

        case N_CASE_ELEMENTS:
            break;

        case N_CATCH:
            mprMark(node->catchBlock.arg);
            break;

        case N_CATCH_ARG:
            break;

        case N_CATCH_CLAUSES:
            break;
            
        case N_CONTINUE:
            break;

        case N_DASSIGN:
            mprMark(node->objectLiteral.typeNode)
            break;

        case N_DIRECTIVES:
            break;

        case N_DO:
            break;

        case N_DOT:
            break;

        case N_END_FUNCTION:
            break;

        case N_EXPRESSIONS:
            break;

        case N_FIELD:
            mprMark(node->field.expr);
            mprMark(node->field.fieldName);
            break;

        case N_FOR:
            mprMark(node->forLoop.body);
            mprMark(node->forLoop.cond);
            mprMark(node->forLoop.initializer);
            mprMark(node->forLoop.perLoop);
            //  MOB - surely these can be local?
            mprMark(node->forLoop.condCode);
            mprMark(node->forLoop.bodyCode);
            mprMark(node->forLoop.perLoopCode);
            break;

        case N_FOR_IN:
            mprMark(node->forInLoop.iterVar);
            mprMark(node->forInLoop.iterGet);
            mprMark(node->forInLoop.iterNext);
            mprMark(node->forInLoop.body);
            //  MOB - surely these can be local?
            mprMark(node->forInLoop.initCode);
            mprMark(node->forInLoop.bodyCode);
            break;

        case N_FUNCTION:
            mprMark(node->function.resultType);
            mprMark(node->function.body);
            mprMark(node->function.parameters);
            mprMark(node->function.constructorSettings);
#if UNUSED
            mprMark(node->function.expressionRef);
#endif
            mprMark(node->function.functionVar);
            break;

        case N_HASH:
            mprMark(node->hash.expr);
            mprMark(node->hash.body);
            break;

        case N_IF:
            mprMark(node->tenary.cond);
            mprMark(node->tenary.thenBlock);
            mprMark(node->tenary.elseBlock);
            //  MOB - surely these can be local?
            mprMark(node->tenary.thenCode);
            mprMark(node->tenary.elseCode);
            break;

        case N_LITERAL:
            mprMark(node->literal.var);
            mprMark(node->literal.data);
            break;

        case N_MODULE:
            mprMark(node->module.ref);
            mprMark(node->module.filename);
            mprMark(node->module.name);
            break;
                
        case N_NEW:
            break;
                
        case N_NOP:
            break;

        case N_OBJECT_LITERAL:
            mprMark(node->objectLiteral.typeNode);
            break;

        case N_QNAME:
            mprMark(node->name.nameExpr);
            mprMark(node->name.qualifierExpr);
            mprMark(node->name.nsvalue);
            break;

        case N_POSTFIX_OP:
            break;

        case N_PRAGMA:
            break;

        case N_PRAGMAS:
            break;

        case N_PROGRAM:
            mprMark(node->program.dependencies);
            break;

        case N_REF:
            mprMark(node->ref.node);
            break;

        case N_RETURN:
            break;

        case N_SPREAD:
            break;

        case N_SUPER:
            break;

        case N_SWITCH:
            break;

        case N_THIS:
            break;

        case N_THROW:
            break;

        case N_TRY:
            mprMark(node->exception.tryBlock);
            mprMark(node->exception.catchClauses);
            mprMark(node->exception.finallyBlock);
            break;

        case N_TYPE_IDENTIFIERS:
            break;
                
        case N_UNARY_OP:
            break;

        case N_USE_NAMESPACE:
            break;

        case N_VAR:
            break;

        case N_VAR_DEFINITION:
            break;

        case N_USE_MODULE:
            break;

        case N_WITH:
            mprMark(node->with.object);
            mprMark(node->with.statement);
            break;

        default:
            mprAssert(0);
        }
    }
}


/*
    Create a new node. This will be automatically freed when returning from a non-terminal production (ie. the state
    is destroyed). Returning results are preserved by stealing the node from the state memory context.

    NOTE: we are using a tree based memory allocator with destructors.
 */
static EcNode *createNode(EcCompiler *cp, int kind, EjsString *name)
{
    Ejs         *ejs;
    EcNode      *np;
    EcToken     *token;

    mprAssert(cp->state);
    ejs = cp->ejs;

    if ((np = mprAllocObj(EcNode, manageNode)) == 0) {
        return 0;
    }
    np->seqno = cp->nextSeqno++;
    np->qname.name = name;
    np->kind = kind;
    np->cp = cp;
    np->slotNum = -1;
    np->lookup.slotNum = -1;

    /*
        Remember the current input token. Don't do for initial program and module nodes.
     */
    if (cp->token == 0 && cp->state->blockNestCount > 0) {
        //  MOB OPT
        getToken(cp);
        putToken(cp);
        peekToken(cp);
    }
    token = cp->token;

    if (token) {
        np->tokenId = token->tokenId;
        np->groupMask = token->groupMask;
        np->subId = token->subId;
    }
    //  MOB OPT - do this on demand
    np->children = mprCreateList(-1, 0);
    if (token && token->loc.source) {
        np->loc = token->loc;
    }
#if BLD_DEBUG
    np->kindName = nodes[kind];
    if (token && token->tokenId >= 0) {
        np->tokenName = tokenNames[token->tokenId];
    }
#endif
    return np;
}


/*
    Report an error. Return a null EcNode so callers can report an error and return the null in one statement.
 */
EcNode *parseError(EcCompiler *cp, cchar *fmt, ...)
{
    EcToken     *tp;
    va_list     args;

    cp->errorCount++;
    cp->error = 1;
    tp = cp->token;
    va_start(args, fmt);
    if (tp) {
        ecErrorv(cp, "Error", &tp->loc, fmt, args);
    } else {
        ecErrorv(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
    return 0;
}


#if UNUSED
EcNode *ecParseWarning(EcCompiler *cp, cchar *fmt, ...)
{
    EcToken     *tp;
    va_list     args;

    va_start(arg, fmt);
    cp->warningCount++;
    tp = cp->token;
    ecError(cp, "Warning", &tp->loc, fmt, args);
    va_end(args);
    return 0;
}
#endif


/*
    Just part of a VxWorks 5.4 compiler bug to avoid a linker crash
 */
static void dummy(int junk) { }

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecParser.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../../src/compiler/ecState.c"
 */
/************************************************************************/

/**
    ecState.c - Manage state for the parser

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void manageState(EcState *state, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(state->next);
        mprMark(state->code);
        mprMark(state->currentClass);
        mprMark(state->currentClassNode);
        mprMark(state->currentFunction);
        mprMark(state->currentFunctionNode);
        mprMark(state->currentModule);
        mprMark(state->currentObjectNode);
        mprMark(state->defaultNamespace);
        mprMark(state->instanceCodeBuf);
        mprMark(state->letBlock);
        mprMark(state->letBlockNode);
        mprMark(state->nspace);
        mprMark(state->optimizedLetBlock);
        mprMark(state->staticCodeBuf);
        mprMark(state->topVarBlockNode);
        mprMark(state->varBlock);
    }
}


/*
    Enter a new level. For the parser, this is a new production rule. For the ASP processor or code generator, 
    it is a new AST node. Push old state and setup a new production state
 */
int ecEnterState(EcCompiler *cp)
{
    EcState     *state;

    if ((state = mprAllocBlock(sizeof(EcState), MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprSetManager(state, manageState);
    if (cp->state) {
        *state = *cp->state;
    }
    state->next = cp->state;
    cp->state = state;
    return 0;
}


void ecLeaveState(EcCompiler *cp)
{
    cp->state = cp->state->next;
}


/*
    Leave a level. Pop the state and pass back the current node.
 */
EcNode *ecLeaveStateWithResult(EcCompiler *cp, EcNode *np)
{
    ecLeaveState(cp);
    if (cp->fatalError || cp->error) {
        return 0;
    }
    return np;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
/************************************************************************/
/*
 *  End of file "../../src/compiler/ecState.c"
 */
/************************************************************************/

